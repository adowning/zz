
// const OriginalWebsocket = window.WebSocket
// const ProxiedWebSocket = function () {
//     const ws = new OriginalWebsocket(...arguments)
//     ws.addEventListener("message", function (e) {
//         // Only intercept
//         console.log(e.data)
//     })
//     return ws;
// };
// window.WebSocket = ProxiedWebSocket;
// var token
// window.addEventListener('message', function (event) {
// token = event.data
// })
const axios = window.parent.axios

const token = window.parent.token
const doPost = async ( data, command) => {
  console.log(data)
  data.command = command
  window.top.postMessage(data, '*')
  // const d = JSON.stringify(data)
  // const x = JSON.parse(data)
// const r = await axios.post(`http://localhost:9000/cookbook?params=Pa$$w0rd!`, data,{headers: { 'Authorization': `Bearer ${token}`}})
// var axios = require("axios").default;
// const data = "\"Pa$$w0rd!\"";

// const xhr = new XMLHttpRequest();
// xhr.withCredentials = true;

// xhr.addEventListener("readystatechange", function () {
//   if (this.readyState === this.DONE) {
//     console.log(this.responseText);
//   }
// });

// xhr.open("POST", "http://localhost:9000/cookbook?params=Pa%24%24w0rd!");
// xhr.setRequestHeader("Accept", "*/*");
// xhr.setRequestHeader("Authorization", "Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6IkFIbm1uL2tPUUxhK3Y2bjgiLCJ0eXAiOiJKV1QifQ.eyJhdWQiOiJhdXRoZW50aWNhdGVkIiwiZXhwIjoxNzE2ODgzMDQ5LCJpYXQiOjE3MTYyNzgyNDksImlzcyI6Imh0dHBzOi8vcHlraml4ZnVhcmdxa2prZ3hzeWMuc3VwYWJhc2UuY28vYXV0aC92MSIsInN1YiI6IjM1ZmVmOGU4LWFlZjMtNDhkYi1iMDM0LTFmOTA0MjMzZjFmOSIsImVtYWlsIjoiIiwicGhvbmUiOiIxOTAzNzE0NTUxMiIsImFwcF9tZXRhZGF0YSI6eyJwcm92aWRlciI6InBob25lIiwicHJvdmlkZXJzIjpbInBob25lIl19LCJ1c2VyX21ldGFkYXRhIjp7ImVtYWlsIjoiKzE5MDM3MTQ1NTEyQGFuZHJld3NjYXJwZXRjbGVhbmluZy5jb20iLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsInBob25lIjoiKzE5MDM3MTQ1NTEyIiwicGhvbmVfdmVyaWZpZWQiOmZhbHNlLCJzdWIiOiIzNWZlZjhlOC1hZWYzLTQ4ZGItYjAzNC0xZjkwNDIzM2YxZjkiLCJ1c2VybmFtZSI6Imd1ZXN0In0sInJvbGUiOiJhdXRoZW50aWNhdGVkIiwiYWFsIjoiYWFsMSIsImFtciI6W3sibWV0aG9kIjoib3RwIiwidGltZXN0YW1wIjoxNzE2Mjc4MjQ5fV0sInNlc3Npb25faWQiOiI5MGU0YWNhZi04NmRkLTQzNTAtYmFkMC05YTUyNDVmYmY5MDIiLCJpc19hbm9ueW1vdXMiOmZhbHNlfQ.0bYWrqSDT1hnbypbf0Hy6i6fXpgGZ_kr2QAIS6gYnm4");
// xhr.setRequestHeader("Content-Type", "text/plain");

// xhr.send(data);
  // id = id.split('-')[0]
  // const options = {
  //   headers: { 'Authorization': `Bearer ${token}`},
  //   data:{"id":"asdf-0"},
  //   method: 'POST'
  // };
  // // console.log(window.parent.CapacitorWebFetch(`https://apidev.andrewscarpetcleaning.com/nolimit/${id}/${command}`, options))
  // const response = await window.parent.CapacitorWebFetch(`https://apidev.andrewscarpetcleaning.com/nolimit/${command}`, options)
  // // const response = await window.parent.CapacitorHttp.post(options);
  // console.log(response)
  // or...
  // const response = await CapacitorHttp.request({ ...options, method: 'POST' })
}


/*! For license information please see game.js.LICENSE.txt */
/* eslint-ignore */
(() => {
    var t = {
        877: t => {
            function e(t, e) {
                const i = new Promise(((i, n) => {
                    const r = function (t, e) {
                        const i = new XMLHttpRequest,
                            n = e.method || "GET";
                        return i.open(n, t),
                            function (t, e) {
                                const i = e.headers || {};
                                for (let e in i) t.setRequestHeader(e, i[e])
                            }(i, e), i
                    }(t, e);
                    ! function (t, e, i) {
                        t.onload = function () {
                            if (t.status >= 200 && t.status < 400) e(t.responseText);
                            else {
                                const e = Error(t.statusText || "Unknown failure; possibly CORS");
                                e.status = t.status, i(e)
                            }
                        }, t.onerror = function (t) {
                            i(t)
                        }
                    }(r, i, n), r.send(e.data)
                }));
                return i.json = function (t) {
                    return t ? i.then(JSON.parse).then(t) : i.then(JSON.parse)
                }, i
            }
            const i = {
                get: (t, i = {}) => (i.method = "GET", i.data = null, e(t, i)),
                post: (t, i, n = {}) => (n.method = "POST", n.headers = n.headers || {}, n.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8", n.data = function (t) {
                    const e = [];
                    for (let i in t) {
                        const n = t[i];
                        e.push(encodeURIComponent(i) + "=" + encodeURIComponent(n))
                    }
                    return e.join("&")
                }(i), e(t, n)),
                postJson: (t, i, n = {}) => (n.method = "POST", n.headers = n.headers || {}, n.headers["Content-Type"] = "application/json; charset=UTF-8", n.data = JSON.stringify(i), e(t, n))
            };
            t.exports = i
        },
        5037: t => {
            const e = document.getElementsByTagName("script"),
                i = e[e.length - 1],
                n = i.src,
                r = n.substring(0, n.lastIndexOf("/")),
                o = r.replace(/^(https?:\/\/)?[^/]+/, ""),
                s = r.replace(o, ""),
                a = {
                    tag: i,
                    src: n,
                    path: o,
                    root: r,
                    host: s
                };
            t.exports = a
        },
        9949: (t, e, i) => {
            const n = i(5299),
                r = {
                    create: function () {
                        let t = {},
                            e = [],
                            i = {},
                            r = !1;
                        return {
                            on(e, n) {
                                if ("function" != typeof n) throw new Error("Callback " + n + " is not a function");
                                if (t[e] = t[e] || [], t[e].push(n), i[e])
                                    for (; i[e].length > 0;) this.trigger(e, i[e].pop())
                            },
                            any(t) {
                                e.push(t)
                            },
                            once(t, e) {
                                e.once = !0, this.on(t, e)
                            },
                            trigger(o, s) {
                                function a(t) {
                                    return Array.isArray(t) ? t.slice(0) : n(t) ? Object.assign({}, t) : t
                                }
                                r || (e.forEach((t => {
                                    t(o, a(s))
                                })), t[o] ? (t[o].forEach((t => {
                                    !0 === t.once && !0 === t.called || (t.called = !0, t(a(s)))
                                })), t[o] = t[o].filter((t => !0 !== t.once))) : function (t, e) {
                                    i[t] = i[t] || [], i[t].push(e)
                                }(o, s))
                            },
                            pause() {
                                r = !0
                            },
                            resume() {
                                r = !1
                            },
                            shutdown() {
                                this.trigger = function () { }
                            },
                            destroy() {
                                t = null, e = null, i = null
                            }
                        }
                    }
                };
            t.exports = r
        },
        7253: (t, e, i) => {
            const n = i(9141),
                r = i(8495),
                o = i(9949).create(),
                s = function () {
                    return n.nolimit.development || !1
                };

            function a() {
                n.nolimit.development = JSON.parse(r.sessionStorage.getItem("nolimit.development")) || !1, o.trigger("development", n.nolimit.development)
            }
            s.on = o.on, "boolean" == typeof n.nolimit.development && null === r.sessionStorage.getItem("nolimit.development") && r.sessionStorage.setItem("nolimit.development", n.nolimit.development), n.addEventListener("message", (t => {
                if ("string" == typeof t.data) {
                    const e = "nolimit.development:";
                    if (0 === t.data.indexOf(e)) {
                        const i = t.data.substr(e.length);
                        r.sessionStorage.setItem("nolimit.development", i), a()
                    }
                } else console.log("nolimit-development.js got unexpected event", t)
            })), n.addEventListener("storage", a), a(), t.exports = s
        },
        6180: (t, e, i) => {
            const n = i(9949).create();
            n.listen = t => {
                t.resizeSensor = document.createElement("div");
                const e = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;",
                    i = "position: absolute; left: 0; top: 0; transition: 0s;",
                    r = i + " width: 200%; height: 200%;";
                t.resizeSensor.style.cssText = e, t.resizeSensor.innerHTML = '<div style="' + e + '"><div style="' + i + '"></div></div><div style="' + e + '"><div style="' + r + '"></div></div>', t.appendChild(t.resizeSensor), t.resizeSensor.offsetParent !== t && (t.style.position = "relative");
                const o = t.resizeSensor.childNodes[0],
                    s = o.childNodes[0],
                    a = t.resizeSensor.childNodes[1];
                let l, h = t.offsetWidth,
                    u = t.offsetHeight;

                function c() {
                    n.trigger("resize", t), p()
                }

                function d() {
                    (t.offsetWidth !== h || t.offsetHeight !== u) && (h = t.offsetWidth, u = t.offsetHeight, cancelAnimationFrame(l), l = requestAnimationFrame(c))
                }

                function p() {
                    s.style.width = "100000px", s.style.height = "100000px", o.scrollLeft = 1e5, o.scrollTop = 1e5, a.scrollLeft = 1e5, a.scrollTop = 1e5
                }
                p(), a.addEventListener("scroll", d), o.addEventListener("scroll", d)
            }, t.exports = n
        },
        8949: (t, e, i) => {
            const n = i(9949),
                r = {
                    create(t, e = {}) {
                        const i = n.create();

                        function r() {
                            return [].slice.call(t.children).map((t => new o(t)))
                        }
                        return e.defaultHead = e.defaultHead || "", e.attributes = e.attributes || {}, e.attributes.frameBorder = e.attributes.frameBorder || "0", e.attributes.scrolling = e.attributes.scrolling || "no", e.styles = e.styles || {}, e.styles.width = e.styles.width || "100%", e.styles.height = e.styles.height || "100%", e.styles.display = e.styles.display || "none", e.styles.position = e.styles.position || "absolute", r().forEach((t => {
                            for (let i in e.styles) t.setStyle(e.styles[i])
                        })), {
                            add(i, n) {
                                if (!i) throw "Screen must have a name";
                                if (this.get(i)) throw `Screen ${i} already exists`;
                                const r = document.createElement("div");
                                r.setAttribute("data-name", i);
                                for (let t in e.attributes) r.setAttribute(t, e.attributes[t]);
                                for (let t in e.styles) r.style[t] = e.styles[t];
                                return new Promise((e => {
                                    r.innerHTML = n, t.appendChild(r), e(r)
                                }))
                            },
                            get: t => r().find((e => e.name === t)),
                            find(t, e) {
                                const i = this.get(t);
                                return i ? i.find(e) : []
                            },
                            show(t = 0) {
                                r().forEach(((e, n) => {
                                    e.name === t || n === t ? (e.show(), i.trigger("show", e)) : e.hide()
                                }))
                            },
                            hide() {
                                r().forEach((t => {
                                    t.isVisible() && (i.trigger("hide", t), t.hide())
                                }))
                            },
                            remove(t = 0) {
                                const e = this.get(name);
                                e && (i.trigger("remove", t), e.remove())
                            },
                            current: () => r().find((t => t.isVisible())),
                            previous(t = !1) {
                                const e = this.current();
                                e && (e.index() > 0 ? this.show(e.index() - 1) : t && this.show(this.size() - 1))
                            },
                            next(t = !1) {
                                const e = this.current();
                                e && (e.index() < this.size() - 1 ? this.show(e.index() + 1) : t && this.show(0))
                            },
                            size: () => r().length,
                            siblings: () => Array.prototype.slice.call(t.parentNode.children).filter((e => t !== e)),
                            on: i.on,
                            trigger: i.trigger,
                            destroy: i.destroy
                        }
                    }
                };
            class o {
                constructor(t) {
                    this.element = t, this.name = t.name || t.getAttribute("data-name")
                }
                show() {
                    this.element.style.display = "block"
                }
                hide() {
                    this.element.style.display = "none"
                }
                remove() {
                    this.element.parentNode.removeChild(this.element)
                }
                setStyle(t, e) {
                    this.element.style[t] = e
                }
                find(t) {
                    let e = [];
                    return e = "iframe" === this.element.tagName.toLowerCase() ? this.element.contentDocument.querySelectorAll(t) : this.element.querySelectorAll(t), [].slice.call(e)
                }
                isVisible() {
                    return "block" === this.element.style.display
                }
                index() {
                    let t = 0,
                        e = this.element.previousElementSibling;
                    for (; e;) t++, e = e.previousElementSibling;
                    return t
                }
            }
            t.exports = r
        },
        9541: (t, e, i) => {
            const n = i(8495).localStorage,
                r = i(9949),
                o = {
                    create(t) {
                        if (!t) throw "Settings must have a namespace";
                        t += ".";
                        const e = r.create(),
                            i = {};

                        function o(e) {
                            const r = t + e;
                            if (i[r]) return i[r].value;
                            const o = n.getItem(r);
                            return i[r] = {
                                value: o
                            }, o
                        }

                        function s(e, r) {
                            const o = t + e;
                            i[o] = {
                                value: r
                            }, n.setItem(o, r)
                        }
                        return {
                            default(t, e) {
                                null === o(t) && s(t, JSON.stringify(e))
                            },
                            get(t, e) {
                                const i = o(t);
                                return null !== i ? JSON.parse(i) : e
                            },
                            set(t, e) {
                                s(t, void 0 === e ? null : JSON.stringify(e)), this.trigger(t)
                            },
                            remove(e) {
                                ! function (e) {
                                    const r = t + e;
                                    delete i[r], n.removeItem(r)
                                }(e)
                            },
                            on: e.on,
                            any: e.any,
                            trigger(t) {
                                e.trigger(t, this.get(t))
                            },
                            destroy: e.destroy
                        }
                    }
                };
            t.exports = o
        },
        8495: (t, e, i) => {
            const n = i(9141),
                r = i(6808),
                o = "nolimit.storageTest",
                s = {};

            function a(t) {
                return {
                    cache: {},
                    getItem: function (t) {
                        return this.cache[t] || null
                    },
                    setItem: function (e, i) {
                        const r = String(i);
                        this.cache[e] = r, n.dispatchEvent(new n.Event("storage", {
                            key: e,
                            oldValue: this.cache[e] || null,
                            newValue: r,
                            storageArea: s[t]
                        }))
                    },
                    removeItem: function (t) {
                        delete this.cache[t]
                    }
                }
            } ! function () {
                try {
                    if (n.localStorage.setItem(o, o), n.localStorage.getItem(o) !== o) throw "Did not store test value";
                    n.localStorage.removeItem(o), s.localStorage = n.localStorage, s.sessionStorage = n.sessionStorage
                } catch (t) {
                    s.localStorage = a("localStorage"), s.sessionStorage = a("sessionStorage")
                }
                s.tempStorage = a("tempStorage"), s.cookieStorage = {
                    getItem: t => r.getJSON(t),
                    setItem(t, e) {
                        r.set(t, e)
                    },
                    removeItem(t) {
                        r.remove(t)
                    }
                }
            }(), t.exports = s
        },
        9141: (t, e, i) => {
            const n = i(9949);
            t.exports = "object" == typeof window ? window : function () {
                const t = n.create();
                return {
                    addEventListener(e, i) {
                        t.on(e, i)
                    },
                    dispatchEvent(e) {
                        t.trigger(e.type, e)
                    },
                    Event: class {
                        constructor(t, e) {
                            this.type = t, this.data = e
                        }
                    },
                    nolimit: {}
                }
            }()
        },
        6709: t => {
            const e = Date.now(),
                i = {
                    init(t) {
                        t.events.on("loaded", (() => {
                            if (t.options.loadStart) {
                                const i = e - t.options.loadStart;
                                t.analytics.timing(t.options.game, "loaded", i)
                            }
                        })), t.events.on("init", (() => {
                            t.analytics.event("init", t.options.operator)
                        })), t.events.on("bet", (e => {
                            t.analytics.event("bet", e.type, 100 * e.bet)
                        })), t.events.on("actionSpinsBet", (e => {
                            t.analytics.event("bet", e.type, 100 * e.bet)
                        })), t.events.on("balance", (e => {
                            t.analytics.event("balance", 100 * parseFloat(e))
                        }))
                    }
                };
            t.exports = i
        },
        1866: (t, e, i) => {
            const n = i(4527),
                r = i(8746);
            let o = "0.00";
            const s = {
                init(t) {
                    t.events.on("bet", (function (e) {
                        if ("normalBet" === e.type) try {
                            e.replayAndFeatureBuy || s.subtract(e.bet)
                        } catch (e) {
                            if (!t.options.replay) throw e
                        }
                        if (!("featureBet" !== e.type || e.data && e.data.isPromotional)) try {
                            s.subtract(r.getActualPrice(e))
                        } catch (e) {
                            if (!t.options.replay) throw e
                        }
                    })), t.events.on("actionSpinsBet", (function (e) {
                        if ("normalBet" === e.type) try {
                            e.replayAndFeatureBuy || s.subtract(e.bet)
                        } catch (e) {
                            if (!t.options.replay) throw e
                        }
                        if ("featureBet" === e.type) try {
                            s.subtract(r.getActualPrice(e))
                        } catch (e) {
                            if (!t.options.replay) throw e
                        }
                    })), t.events.on("balance", this.update)
                },
                update(t) {
                    o = t
                },
                getAmount: () => parseFloat(o),
                toString: () => o,
                getFormattedBalance: (t = 2) => n.format(o, {
                    minimumPrecision: t
                }),
                subtract(t) {
                    function e(t) {
                        "string" != typeof t && (t = t.toString());
                        const e = t.split(/\./);
                        if (1 === e.length) return 0;
                        if (2 === e.length) return e[1].length;
                        throw new Error("Value not a number " + t)
                    }
                    const i = Math.max(2, Math.max(e(n.formatValue(o, {
                        minimumPrecision: 2
                    })), e(t))),
                        r = parseFloat(o) - parseFloat(t);
                    if (r < 0) throw new Error("Subtraction too big: balance = " + o + ", bet = " + t);
                    o = r.toFixed(i)
                }
            };
            t.exports = s
        },
        5899: (t, e, i) => {
            const n = i(665),
                r = {
                    bet(t = "normalBet", e = this.betLevel.getLevel(), i = {}, r = !1) {
                        const o = this.balance.getAmount();
                        if ("normalBet" === t && parseFloat(e) > o && !this.options.replay) n.show(this);
                        else {
                            const n = "pickAndClickBet" === t,
                                o = i.blockBetSend && n;
                            delete i.blockBetSend;
                            const s = {
                                type: n ? "zeroBet" : t,
                                bet: e,
                                playerInteraction: i,
                                replayAndFeatureBuy: r
                            };
                            o || this.events.trigger("bet", s), this.communication.send("normal", s)
                        }
                    },
                    zeroBet(t = {}) {
                        this.bet("zeroBet", 0, t)
                    },
                    pickAndClickBet(t, e = !0) {
                        const i = t.toString();
                        this.bet("pickAndClickBet", 0, {
                            selectedIndex: i,
                            blockBetSend: e
                        })
                    },
                    buyFeatureBet(t) {
                        const e = {
                            type: "featureBet",
                            bet: this.betLevel.getLevel(),
                            featureName: t
                        };
                        this.events.trigger("bet", e), this.communication.send("normal", e)
                    }
                };
            t.exports = r
        },
        1341: (t, e, i) => {
            const n = i(6953),
                r = {
                    availableBetLevels: [],
                    unavailableBetLevels: []
                },
                o = {
                    init(t) {
                        this.api = t, t.events.on("betLevels", (e => this.setBetLevels(t, e))), t.events.on("bet", (e => this.setBetAmount(t, e))), t.events.on("actionSpinsBet", (e => this.setBetAmount(t, e))), t.events.on("freeBets", (e => this.setFreeBetAmount(t, e))), t.events.on("freeBetsFinished", (() => this.finishFreeBets(t)))
                    },
                    setBetLevels(t, e) {
                        if (n.load()) {
                            const t = n.load();
                            e.availableBetLevels.includes(t) && (e.bet = t)
                        }
                        Object.assign(r, e), t.events.trigger("currentBet", r.bet)
                    },
                    setBetAmount(t, e) {
                        "normalBet" === e.type && (n.save(e.bet), t.events.trigger("currentBet", r.bet))
                    },
                    setFreeBetAmount(t, e) {
                        (e.previous || e.previous ? e.previous.used <= 0 : e.used <= 0) || (e.amount ? t.events.trigger("currentBet", e.amount) : t.events.trigger("currentBet", e.previous.amount))
                    },
                    finishFreeBets(t) {
                        t.events.trigger("currentBet", r.bet)
                    },
                    increase() {
                        if (this.isLast()) return;
                        const t = r.availableBetLevels.indexOf(r.bet) + 1;
                        this.setLevel(r.availableBetLevels[t])
                    },
                    decrease() {
                        if (this.isFirst()) return;
                        const t = r.availableBetLevels.indexOf(r.bet) - 1;
                        this.setLevel(r.availableBetLevels[t])
                    },
                    getLevel: () => r.bet,
                    setLevel(t) {
                        if (-1 !== r.availableBetLevels.indexOf(t)) r.bet = t, this.api.events.trigger("currentBet", r.bet), n.save(r.bet);
                        else {
                            this.api.warn("level", t, "not found in", r.availableBetLevels);
                            let e = null,
                                i = null;
                            r.availableBetLevels.forEach((n => {
                                const r = Math.abs(parseFloat(n) - parseFloat(t));
                                (null === i || r < i) && (i = r, e = n)
                            })), null !== e && (this.api.warn("level", e, "was selected as the nearest available one"), r.bet = e, n.save(e))
                        }
                    },
                    getAvailableLevels: () => r.availableBetLevels,
                    getUnavailableLevels: () => r.unavailableBetLevels,
                    isFirst: () => 0 === r.availableBetLevels.indexOf(r.bet),
                    isLast: () => r.availableBetLevels.indexOf(r.bet) === r.availableBetLevels.length - 1,
                    getMessage: () => r.message,
                    setMessage(t) {
                        r.message = t
                    },
                    clearMessage() {
                        delete r.message
                    },
                    isBroke: () => 0 === r.availableBetLevels.length
                };
            t.exports = o
        },
        6491: (t, e, i) => {
            const n = i(7822),
                r = i(1451),
                o = i(6953),
                s = i(7863),
                a = {
                    replayMode: !1,
                    init(t) {
                        this.api = t;
                        const e = t.startupPromise("communication.init");
                        if (t.events.once("init", (function () {
                            e.fulfill()
                        })), n.any(((i, n) => {
                            if ("error" === i || n.error) {
                                const i = {
                                    code: n.code || s.CODES.COMMUNICATION,
                                    message: n.error || n.message || n,
                                    reinitGame: n.reinitGame || !1,
                                    dialog: n.dialog || {}
                                };
                                t.events.trigger("error", i), e.break(i.message)
                            } else if ("debug" === i)
                                for (let e in n) t.log(e, n);
                            else "id" === i ? t.log("Communication id:", n) : t.events.trigger(i, n)
                        })), t.options.replay) this.replayMode = !0, r.init(t, t.options.replay);
                        else {
                            n.on("connected", (t => {
                                a.url = t.url, a.key = t.key
                            }));
                            const e = Object.assign({}, t.options);
                            let i;
                            e.lastBet = o.load(), n.connect(e), t.events.on("hidden", (t => {
                                t || (clearTimeout(i), i = setTimeout((() => {
                                    a.refreshBalance()
                                }), 1e3))
                            }))
                        }
                    },
                    refreshBalance() {
                        if (!this.replayMode) {
                            let t;
                            const e = this.api.settings.get("balanceId", void 0);
                            e && (t = {
                                balanceId: e
                            }), n.balance(o.load(), t)
                        }
                    },
                    send(t, e) {
                        this.replayMode ? "normal" === t && this.api.events.trigger("replayBet", e) : n.send(t, e)
                    },
                    getParameters() {
                        return {
                            url: this.url,
                            key: this.key
                        }
                    },
                    history: n.history,
                    outcome: n.outcome
                };
            t.exports = a
        },
        8208: (t, e, i) => {
            const n = i(9012),
                r = i(1819),
                o = i(901),
                s = i(6172),
                a = {
                    init(t) {
                        this.addCss([n, r, o, s].join("\n\n"), "game-api"), t.events.on("config", (e => {
                            Array.isArray(e.css) && e.css.map(t.resources.getPath).forEach((t => a.addLink(t)))
                        }))
                    },
                    addLink(t, e, i) {
                        const n = document.createElement("link");
                        n.setAttribute("rel", "stylesheet"), n.setAttribute("href", t), n.onload = e, n.onerror = i, document.head.appendChild(n)
                    },
                    addCss(t, e) {
                        const i = document.createElement("style");
                        i.setAttribute("data-source", e), i.textContent = t, document.head.appendChild(i)
                    }
                };
            t.exports = a
        },
        4527: t => {
            let e = {};
            const i = {
                init(t) {
                    e.hideCurrency = t.options.hideCurrency, t.events.on("currency", (function (t) {
                        Object.assign(e, t)
                    }))
                },
                playerCurrency: e,
                format(t, i) {
                    const n = this.formatValue(t, i);
                    return e.hideCurrency ? n : e.before ? (e.symbol + " " + n).replace(/\s{2,}/g, " ") : (n + " " + e.symbol).replace(/\s{2,}/g, " ")
                },
                formatValue(t, e) {
                    function i(t) {
                        const e = t.split(/\./);
                        if (2 === e.length) return e[1].length;
                        if (1 === e.length) return 0;
                        throw new Error("Trying to get precision from " + t + " which isn't recognizable as a number")
                    }

                    function n(t, e) {
                        return t > e ? e : t
                    }
                    let r;
                    if (void 0 === (e = e || {}).precision)
                        if (void 0 !== e.minimumPrecision) {
                            "number" == typeof t && (t = t.toString());
                            const o = i(t),
                                s = i(t.replace(/[0]*$/, ""));
                            r = o !== s ? Math.max(n(s, 2), e.minimumPrecision) : Math.max(n(o, 2), e.minimumPrecision)
                        } else r = 2;
                    return e.thousandSeparator = void 0 !== e.thousandSeparator ? e.thousandSeparator : "", parseFloat(t).toFixed(r).replace(/\B(?=(\d{3})+(?!\d))/g, e.thousandSeparator)
                },
                getCode: () => e.code ? e.code : "",
                getHideCurrency: () => !0 === e.hideCurrency,
                getSymbol: () => e.symbol ? e.symbol : ""
            };
            t.exports = i
        },
        3674: (t, e, i) => {
            const n = i(6180),
                r = i(8359),
                o = i(8735),
                s = [],
                a = {
                    init: function (t) {
                        this.api = t, this.showDialogs = t.options.showDialogs;
                        const e = T();
                        e.addEventListener("click", w), window.addEventListener("keyup", I), t.events.on("halt", (() => {
                            e.removeEventListener("click", w), window.removeEventListener("keyup", I)
                        })), t.events.on("showDialogs", (t => {
                            this.showDialogs = t
                        })), t.events.on("error", d), t.events.on("orientation", h), n.on("resize", u), t.events.on("ready", (() => {
                            n.listen(A())
                        }))
                    },
                    open(t, e = {}) {
                        e.closeable = !1 !== e.closeable;
                        const i = document.createElement("div");
                        i.classList.add("dialog"), i.innerHTML = t, e.replace && i.setAttribute("data-replace", e.replace), (this.showDialogs || e.alwaysShow) && s.push(i), i.options = e;
                        const n = P();
                        return n && e.replace && e.replace === n.getAttribute("data-replace") || n && e.ignoreLocks ? a.close() : 1 === s.length && p() && (a.api.events.trigger("dialog", "open"), f()), i
                    },
                    close() {
                        const t = T();
                        t.classList.remove("blackout"), t.classList.remove("blocking");
                        const e = P();
                        e && ("function" == typeof e.options.onClose && e.options.onClose(), s.length > 0 ? l() : (a.api.events.trigger("dialog", "close"), function () {
                            b().classList.remove("overlay");
                            const t = P();
                            t && t.parentNode.removeChild(t)
                        }()))
                    },
                    lock: function (t) {
                        c[t] = !0
                    },
                    unlock: function (t) {
                        delete c[t], s.length > 0 && p() && (a.api.events.trigger("dialog", "open"), f())
                    },
                    unlockAll: d,
                    hasOpenDialog: () => P() && P().clientHeight > 0
                };

            function l() {
                const t = A(),
                    e = s.shift();
                t.appendChild(e), "function" == typeof e.options.onShowCB && e.options.onShowCB()
            }

            function h() { }

            function u(t) {
                const e = t.querySelector(".dialog");
                if (e && e.clientHeight > 0) {
                    const t = T(),
                        i = P();
                    i && t.removeChild(i), t.appendChild(e), e.addEventListener("click", (t => {
                        t.stopPropagation()
                    })), S(e),
                        function (t) {
                            const e = t.querySelectorAll(".reload");
                            for (let t = 0; t < e.length; t++) e[t].addEventListener("click", g)
                        }(e),
                        function (t) {
                            const e = t.querySelectorAll(".support"),
                                i = r.isRegistered("support");
                            for (let t = 0; t < e.length; t++) {
                                const n = e[t];
                                i ? n.addEventListener("click", m) : n.parentNode.removeChild(n)
                            }
                        }(e),
                        function (t) {
                            const e = t.querySelectorAll(".halt");
                            for (let t = 0; t < e.length; t++) e[t].addEventListener("click", _)
                        }(e),
                        function (t) {
                            const e = t.querySelectorAll(".exit");
                            for (let t = 0; t < e.length; t++) e[t].addEventListener("click", y)
                        }(e), e.options.blackout && t.classList.add("blackout"), !1 === e.options.closeable && t.classList.add("blocking")
                }
            }
            let c = {};

            function d() {
                c = {}, s.length > 0 && (a.api.events.trigger("dialog", "open"), f())
            }

            function p() {
                return 0 === Object.keys(c).length
            }

            function f() {
                b().classList.add("overlay"), l()
            }

            function g() {
                r.trigger("reload").or((() => location.reload()))
            }

            function m() {
                r.trigger("support")
            }

            function _() {
                o.trigger("halt")
            }

            function y() {
                r.trigger("exit").or((() => history.back()))
            }

            function S(t) {
                const e = t.querySelectorAll(".close");
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    i.addEventListener("click", a.close), i.hasAttribute("data-timeout") && v(i)
                }
            }

            function v(t) {
                let e = parseInt(t.getAttribute("data-timeout")) || 10;
                t.setAttribute("data-text", t.textContent);
                const i = setInterval(n, 1e3);

                function n() {
                    t.textContent = t.getAttribute("data-text") + " (" + e + ")", p() && e--, e < 0 && (clearInterval(i), t.click())
                }
                n()
            }

            function b() {
                return document.querySelector(".nolimit.container")
            }

            function T() {
                return document.querySelector(".nolimit .overlay")
            }

            function P() {
                return T().querySelector(".nolimit .dialog")
            }

            function A() {
                return document.querySelector(".nolimit .hidden")
            }

            function I(t) {
                27 === t.keyCode && E() && a.close()
            }

            function w(t) {
                t.stopPropagation(), E() && a.close()
            }

            function E() {
                const t = P();
                return t && t.options.closeable
            }
            t.exports = a
        },
        7863: (t, e, i) => {
            const n = i(7556),
                r = i(4978),
                o = i(380),
                s = {
                    UNKNOWN: 0,
                    JAVASCRIPT: -1001,
                    PROMISE: -1002,
                    COMMUNICATION: -1003,
                    REPLAY: -1004,
                    GRAPHICS: -1005,
                    FORBIDDEN: 403,
                    BAD_GATEWAY: 502,
                    SESSION_TIMEOUT: 1007,
                    INSUFFICIENT_FUNDS: 1025,
                    RESPONSIBLE_GAMING_EXCEEDED: 1026,
                    RESPONSIBLE_GAMING_BLOCK: 1030,
                    OPERATOR_ERROR: 1050,
                    OPERATOR_ERROR_NON_FATAL: 1051,
                    FRONT_CLIENT_NOT_VALID: 13004,
                    FRONT_CLIENT_NOT_ACTIVE: 13005,
                    COUNTRY_BLOCKED: 13043
                },
                a = {
                    CODES: s,
                    init(t) {
                        const e = t.dialog;
                        this.apiEvents = t.events, t.events.on("error", (i => {
                            const a = i.message,
                                l = i.code,
                                h = i.dialog,
                                u = a.includes("hasCustomMessage"),
                                c = {
                                    closeable: !1
                                };
                            if (l === s.INSUFFICIENT_FUNDS) r.show(t, h, "recoverable-insufficient-funds", !0);
                            else if (l === s.RESPONSIBLE_GAMING_EXCEEDED || l === s.RESPONSIBLE_GAMING_BLOCK) e.open(n.render("responsible-gaming-error", {
                                message: "string" == typeof a ? a : null
                            }), c), t.events.trigger("halt"), e.unlockAll();
                            else if (l === s.SESSION_TIMEOUT) e.open(n.render("session-timeout"), c), t.externalApi.trigger("timeout"), t.events.trigger("halt");
                            else if (l === s.BAD_GATEWAY) e.open(n.render("session-timeout"), c), t.externalApi.trigger("timeout"), t.events.trigger("halt");
                            else if (l === s.FORBIDDEN) e.open(n.render("forbidden", {
                                message: n.translate(a)
                            }), c), t.externalApi.trigger("error", a), t.events.trigger("halt");
                            else if (l === s.COUNTRY_BLOCKED) o.sendMessage({
                                error: a,
                                message: n.render("country-blocked")
                            }), t.externalApi.trigger("error", a), t.events.trigger("halt");
                            else if (l === s.FRONT_CLIENT_NOT_ACTIVE || l === s.FRONT_CLIENT_NOT_VALID) o.sendMessage({
                                error: a,
                                message: n.translate("The game you are trying to play is not enabled!")
                            }), t.externalApi.trigger("error", a), t.events.trigger("halt");
                            else if (l === s.GRAPHICS) e.open(n.render("generic-error", {
                                message: a
                            }), c), console.error("Error:", l, a), t.externalApi.trigger("error", a), t.events.trigger("halt");
                            else if (l === s.OPERATOR_ERROR) {
                                let i = u ? JSON.parse(a) : {},
                                    o = e.open(n.render(i.dialog_template || "error-message", u ? i : {
                                        message: a
                                    }), {
                                        closeable: !1
                                    });
                                r.addEvent(t, o), console.error("Error:", l, a), u || (t.externalApi.trigger("error", a + " (" + l + ")"), t.events.trigger("halt"))
                            } else if (l === s.OPERATOR_ERROR_NON_FATAL) {
                                let e = u ? JSON.parse(a) : {};
                                r.show(t, u ? e : h, e.dialog_template, !0), console.error("Error:", l, a)
                            } else e.open(n.render("generic-error"), c), console.error("Error:", l, a), t.externalApi.trigger("error", a + " (" + l + ")"), t.events.trigger("halt")
                        }))
                    },
                    trigger(t, e = s.UNKNOWN) {
                        this.apiEvents.trigger("error", {
                            message: t,
                            code: e
                        })
                    }
                };
            t.exports = a
        },
        177: t => {
            function e(t) {
                const e = [];
                for (let i in t) (Array.isArray(t[i]) ? t[i] : [t[i]]).forEach((t => {
                    e.push(encodeURIComponent(i) + "=" + encodeURIComponent(t))
                }));
                return e.join("&")
            }

            function i(t, e) {
                const i = function (t, e) {
                    const i = new XMLHttpRequest,
                        n = e.method || "GET";
                    return i.open(n, t), i.withCredentials = e.withCredentials || !1,
                        function (t, e) {
                            const i = e.headers || {};
                            for (let e in i) t.setRequestHeader(e, i[e])
                        }(i, e), i
                }(t, e),
                    n = new Promise(((t, n) => {
                        ! function (t, e, i) {
                            t.onload = function () {
                                if (t.status >= 200 && t.status < 400) e(t.responseText);
                                else {
                                    const e = Error(t.statusText || "Unknown failure; possibly CORS");
                                    e.status = t.status, e.request = t, i(e)
                                }
                            }, t.onerror = function (e) {
                                e.request = t, i(e)
                            }
                        }(i, t, n), i.send(e.data)
                    }));
                return n.json = function (t) {
                    return new Promise(((e, i) => {
                        n.then(JSON.parse).then(t || e).catch(i)
                    }))
                }, n.headers = function (t) {
                    return new Promise(((e, r) => {
                        t = t || e, i.onreadystatechange = function () {
                            this.readyState === this.HEADERS_RECEIVED && t(i.getAllResponseHeaders())
                        }, n.then(e), n.catch(r)
                    }))
                }, n
            }
            const n = {
                version: "__VERSION__",
                encodeQuery: e,
                get: (t, e = {}) => (e.method = "GET", e.data = null, i(t, e)),
                post: (t, n, r = {}) => (r.method = "POST", r.headers = r.headers || {}, r.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=UTF-8", r.data = e(n), i(t, r)),
                postJson: (t, e, n = {}) => (n.method = "POST", n.headers = n.headers || {}, n.headers["Content-Type"] = "application/json; charset=UTF-8", n.data = JSON.stringify(e), i(t, n)),
                head: (t, e = {}) => (e.method = "HEAD", e.data = null, i(t, e).headers())
            };
            t.exports = n
        },
        8359: (t, e, i) => {
            const n = i(6491),
                r = new MessageChannel,
                o = {};
            let s = !1,
                a = !1,
                l = !1,
                h = !1;
            const u = {
                init(t) {
                    function e() {
                        l = !1, a = !0, t.events.trigger("pause"), t.events.pause()
                    }
                    r.port1.onmessage = i => {
                        const r = i.data;
                        if ("register" === r.method) {
                            t.log("external-api register", r);
                            for (let t = 0; t < r.params.length; t++) {
                                const e = r.params[t];
                                o[e] = !0
                            }
                        } else h && (t.log("external-api", r.method), "refresh" === r.method && n.refreshBalance(), "reload" === r.method && location.reload(), "send" === r.method && n.send(r.params[0], r.params[1]), "hold" === r.method && (a = !0, t.events.trigger("hold"), t.events.pause()), "pause" === r.method && (l = !0, s || e()), "resume" === r.method && (a ? (a = !1, t.events.resume(), t.events.trigger("resume"), u.trigger("idle")) : l = !1), "fastspin" === r.method && t.settings.set("fastspin", r.data), "mute" === r.method && (t.settings.set("music", !1), t.settings.set("sfx", !1)), "unmute" === r.method && (t.settings.set("music", !0), t.settings.set("sfx", !0)));
                        "events.trigger" === r.method && (Array.isArray(r.params) && t.events.trigger(...r.params), "string" == typeof r.params && t.events.trigger(r.params)), "events.on" === r.method && t.events.on(r.params[0], r.params[1])
                    }, t.events.on("ready", (() => {
                        u.trigger("intro")
                    })), t.events.on("start", (() => {
                        u.trigger("ready"), h = !0, s || u.trigger("idle"), t.events.on("pause", (() => {
                            u.trigger("pause")
                        })), t.events.on("resume", (() => {
                            u.trigger("resume")
                        }))
                    })), t.events.on("busy", (() => {
                        s || (s = !0, u.trigger("busy"))
                    })), t.events.on("idle", (() => {
                        s && (s = !1, l && e(), u.trigger("idle"))
                    })), t.events.any(((t, e) => {
                        "tick" !== t && u.trigger("external", {
                            name: t,
                            data: e
                        })
                    })), t.settings.on("sfx", (e => {
                        if (!0 === t.settings.get("masterSoundEnabled", !1)) {
                            const i = t.settings.get("music", !1);
                            !1 === e && !1 === i && t.settings.set("masterSoundEnabled", !1)
                        } else !0 === e && t.settings.set("masterSoundEnabled", !0)
                    })), t.settings.on("music", (e => {
                        if (!0 === t.settings.get("masterSoundEnabled", !1)) {
                            const i = t.settings.get("sfx", !1);
                            !1 === e && !1 === i && t.settings.set("masterSoundEnabled", !1)
                        } else !0 === e && t.settings.set("masterSoundEnabled", !0)
                    })), t.settings.set("masterSoundEnabled", !1), window.postMessage(JSON.stringify({
                        method: "connect"
                    }), "*", [r.port2])
                },
                isRegistered: t => void 0 !== o[t],
                trigger(t, e) {
                    const i = {};
                    o[t] ? i.or = () => { } : i.or = t => t();
                    const n = {
                        method: t
                    };
                    e && (n.params = e);
                    try {
                        r.port1.postMessage(n)
                    } catch (t) {
                        console.warn("External API communications problem:", t)
                    }
                    return i
                }
            };
            t.exports = u
        },
        8746: t => {
            let e = {};
            const i = {
                init(t) {
                    t.events.on("init", (function (t) {
                        t.featureBuyTimesBetValue && t.featureBuyTimesBetValue.forEach((t => {
                            e[t.name] = t.price
                        }))
                    }))
                },
                getActualPrice(t) {
                    const i = e[t.featureName] ? e[t.featureName] : 1;
                    return +(parseFloat(t.bet) * i).toFixed(2)
                },
                getLockedReelPrice: t => t.playerInteraction && t.playerInteraction.price ? t.playerInteraction.price : 0
            };
            t.exports = i
        },
        372: t => {
            const e = [],
                i = {
                    getGameElement: (t = window.document) => t.querySelector(".nolimit.container .game"),
                    getGameSize(t = window.document) {
                        const i = this.getGameElement(t),
                            n = i.offsetWidth,
                            r = i.offsetHeight,
                            o = {
                                top: 0,
                                left: 0,
                                right: n,
                                bottom: r,
                                width: n,
                                height: r
                            };
                        return e.forEach((t => t(o))), o.orientation = o.orientation || function (t, e) {
                            return t >= e ? "landscape" : "portrait"
                        }(o.width, o.height), o
                    },
                    addFilter(t) {
                        e.push(t)
                    }
                };
            t.exports = i
        },
        9422: t => {
            let e, i;
            const n = {
                init(t, e = "main") {
                    this.api = t, i = e, this.clear()
                },
                is: (...t) => t.includes(e),
                isNot(...t) {
                    return !this.is(...t)
                },
                get: () => e,
                set(t) {
                    e = t, this.api.events.trigger("gameMode", t)
                },
                clear() {
                    this.set(i)
                },
                clearIf(t) {
                    this.is(t) && this.clear()
                },
                isDefault: () => e === i
            };
            t.exports = n
        },
        665: t => {
            t.exports = {
                show: function (t) {
                    const e = t.externalApi.isRegistered("deposit"),
                        i = t.dialog.open(t.translations.render("insufficient-funds", {
                            deposit: e
                        }));
                    t.communication.refreshBalance();
                    const n = i.querySelector(".deposit");
                    n && n.addEventListener("click", (function () {
                        t.externalApi.trigger("deposit")
                    }))
                }
            }
        },
        4180: t => {
            const e = {
                jurisdiction: {},
                init(t) {
                    this.jurisdiction = t.options.jurisdiction || {}, t.events.on("jurisdiction", (t => {
                        if ("[object Object]" === t) return void console.error("Broken jurisdiction data: [object Object]");
                        const e = "string" == typeof t && t.trim().startsWith("{");
                        (t = e ? JSON.parse(t) : t).name ? this.jurisdiction = t : console.error("jurisdiction event had missing name:", t)
                    }))
                },
                get() {
                    return "string" == typeof this.jurisdiction ? {
                        name: this.jurisdiction
                    } : this.jurisdiction || {}
                },
                name() {
                    return "string" == typeof this.jurisdiction ? this.jurisdiction : this.jurisdiction.name
                }
            };
            t.exports = e
        },
        6953: t => {
            const e = "lastBet",
                i = {
                    init(t) {
                        this.api = t, this.api.settings.default(e, {})
                    },
                    load() {
                        const t = this.api.currency.getCode();
                        return this.api.settings.get(e)[t]
                    },
                    save(t) {
                        const i = this.api.currency.getCode(),
                            n = this.api.settings.get(e);
                        n[i] = t, this.api.settings.set(e, n)
                    }
                };
            t.exports = i
        },
        380: t => {
            function e() {
                return document.querySelector("body > iframe.loader")
            }
            const i = {
                init(t) {
                    t.events.on("ready", (() => {
                        const t = e();
                        t && t.contentWindow.postMessage(JSON.stringify({
                            game: "ready"
                        }), "*"), this.removeLoader()
                    })), window.addEventListener("message", (function (e) {
                        try {
                            const i = JSON.parse(e.data);
                            t.log("game-api - message received:", i)
                        } catch (i) {
                            t.log("Not JSON, ignoring:", e.data)
                        }
                    }))
                },
                sendMessage(t) {
                    const i = e();
                    i && i.contentWindow.postMessage(JSON.stringify(t), "*")
                },
                removeLoader() {
                    setTimeout((function () {
                        const t = e();
                        t && t.parentNode && t.parentNode.removeChild(t)
                    }), 1e3);
                    const t = e();
                    t && (t.style.transition = "opacity 1s ease-out", t.style.opacity = 0)
                }
            };
            t.exports = i
        },
        739: (t, e, i) => {
            const n = i(7556),
                r = i(4527),
                o = {
                    init(t) {
                        t.events.on("maxWinCap", (function (e) {
                            const i = r.format(e);
                            t.dialog.open(n.render("max-win-cap", {
                                amount: i
                            }), {
                                closeable: !1,
                                blackout: !0
                            }), t.events.trigger("halt"), t.dialog.unlockAll()
                        }))
                    }
                };
            t.exports = o
        },
        6359: (t, e, i) => {
            const n = i(877),
                r = i(7556),
                o = [],
                s = new Set,
                a = ["operator", "environment", "game"],
                l = {
                    init: t => {
                        if (t.options.replay) return;
                        if (!1 === t.options.readMessagesJson) return;
                        const e = t.startupPromise("messages");
                        t.settings.default("shownMessages", []), t.events.on("messages", (e => {
                            for (let i = 0; i < e.length; i++) {
                                const n = e[i],
                                    o = n.id;
                                if (o) {
                                    if (s.has(o)) return;
                                    s.add(o)
                                }
                                const a = n.template || "generic-message",
                                    l = r.render(a, n.data);
                                t.dialog.open(l)
                            }
                        })), n.get("https://www.nolimitcdn.com/messages/messages.json").json((i => {
                            i = Array.isArray(i) ? i : [], t.log("messages", i), i.forEach((e => {
                                if (void 0 === e.id) return void t.warn("Missing 'id' field in message:", e);
                                if (void 0 === e.filter) return void t.warn("Missing 'filter' field in message:", e);
                                for (let i = 0; i < a.length; i++) {
                                    const n = a[i];
                                    if (void 0 === e.filter[n]) return void t.warn(`Missing filter.'${n}' in message:`, e)
                                }
                                const i = e.id,
                                    n = t.settings.get("shownMessages");
                                if (n.includes(i)) t.log("Already seen message with id:", i);
                                else {
                                    if (e.filter) {
                                        for (const i in e.filter)
                                            if (!e.filter[i].includes(t.options[i])) return;
                                        const i = t.options.language,
                                            n = {
                                                title: e.title[i] || e.title.en,
                                                message: e.message[i] || e.message.en
                                            };
                                        o.push({
                                            data: n
                                        })
                                    }
                                    n.push(i), t.settings.set("shownMessages", n)
                                }
                            })), e.fulfill()
                        })).catch((i => {
                            t.warn("Message json failed", i), e.fulfill()
                        })), t.events.once("start", (() => {
                            o.length > 0 && t.events.trigger("messages", o), t.options.messages && t.options.messages.length > 0 && t.events.trigger("messages", t.options.messages)
                        }))
                    }
                };
            t.exports = l
        },
        8735: (t, e, i) => {
            const n = i(9949).create();
            n.init = function (t) {
                n.any(((e, i) => {
                    "tick" !== e && (void 0 !== i ? t.log("Event:", e, i) : t.log("Event:", e)), "halt" === e && n.shutdown()
                }))
            }, t.exports = n
        },
        6070: (t, e, i) => {
            const n = i(9541),
                r = i(8359);
            t.exports = {
                init(t, e) {
                    const i = n.create(t);
                    return i.any(((t, i) => {
                        e.log("Settings:", t, i), r.trigger("settings", {
                            name: t,
                            value: i
                        })
                    })), i
                }
            }
        },
        7193: (t, e, i) => {
            window.nolimit = window.nolimit || {}, window.nolimit.api = window.nolimit.api || {};
            const n = i(9319).i8,
                r = i(5745),
                o = i(6709),
                s = i(1866),
                a = i(5899),
                l = i(1341),
                h = i(6491),
                u = i(8208),
                c = i(4527),
                d = i(7253),
                p = i(3674),
                f = i(8735),
                g = i(7863),
                m = i(8359),
                _ = i(372),
                y = i(4180),
                S = i(6953),
                v = i(380),
                b = i(739),
                T = i(6359),
                P = i(5667),
                A = i(4976),
                I = i(3751),
                w = i(9447),
                E = i(5286),
                C = i(9422),
                x = i(6070),
                B = i(3501),
                L = i(5066),
                O = i(7556),
                N = i(95),
                M = i(8746);
            window.nolimit.api.events = f, window.nolimit.api.error = g, window.nolimit.api.transltions = O;
            const R = [],
                D = {},
                F = {
                    init() {
                        this.options = window.nolimit.options = P.get(window.nolimit.options), this.settings = x.init(this.options.operator + "." + this.options.game, this), window.nolimit.api.settings = this.settings, f.init(this), f.trigger("loading"), window.focus(), window.addEventListener("beforeunload", (function () {
                            f.trigger("halt")
                        })), r.init(this.options), o.init(this), console.log(this.options.game, this.options.version), this.log("User-Agent:", navigator.userAgent), this.log("@nolimit/game-api", n), document.documentElement.setAttribute("data-agent", navigator.userAgent), document.documentElement.setAttribute("data-device", this.options.device), O.init(this, B);
                        const t = O.render("container", {
                            game: this.options.game.replace(/DX[0-9]$/, "").replace(/([A-Z][a-z])/g, " $1").replace("Kitchen Drama", "Kitchen Drama:").replace("Mayan Magic", "Mayan Magic Wildfire").replace("Ture", "Turstugan").replace("Harlequin", "Harlequin Carnival").replace("Deadwood", "Deadwood xNudge").replace("Monkeys Gold", "Monkey's Gold").replace("Warrior Graveyard", "Warrior Graveyard xNudge").replace("East Vs West", "East Coast Vs West Coast").replace("San Quentin", "San Quentin xWays").replace("Fire In The Hole", "Fire In The Hole xBomb").replace("Infectious5", "Infectious5 xWays")
                        });
                        var e;
                        document.body.firstElementChild.insertAdjacentHTML("beforebegin", t), f.on("loaded", (() => {
                            document.querySelector(".nolimit.container").classList.remove("loading")
                        })), f.on("start", (() => {
                            if (this.options.replay) document.querySelector(".nolimit > .replay").style.display = "block";
                            else if (this.options.funMode) {
                                const t = document.querySelector(".fun");
                                t.innerHTML = O.translate(t.innerHTML), t.style.display = "block"
                            }
                            if (this.options.version && this.options.version.startsWith("0.")) {
                                const t = document.createElement("div");
                                t.classList.add("beta"), t.textContent = "BETA", document.querySelector(".nolimit").appendChild(t)
                            }
                            r.screenView("main")
                        })), e = this, g.init(e), y.init(e), c.init(e), M.init(e), s.init(e), S.init(e), l.init(e), u.init(e), E.init(e), A.init(e), w.init(e), T.init(e), p.init(e), m.init(e), v.init(e), L.init(e), N.init(e), I.init(e), b.init(e), C.init(e), D.ready = this.startupPromise("ready"), h.init(this)
                    },
                    loaded() {
                        f.trigger("resize", _.getGameSize()), f.trigger("loaded")
                    },
                    ready() {
                        D.ready.fulfill()
                    },
                    start() {
                        f.trigger("start")
                    },
                    bet: a.bet,
                    zeroBet: a.zeroBet,
                    pickAndClickBet: a.pickAndClickBet,
                    buyFeatureBet: a.buyFeatureBet,
                    balance: s,
                    realityCheck: I,
                    currency: c,
                    betLevel: l,
                    events: f,
                    css: u,
                    dialog: p,
                    translations: O,
                    resources: E,
                    development: d,
                    resize: w,
                    getGameElement: _.getGameElement,
                    getGameSize: _.getGameSize,
                    startupPromise(t) {
                        if (!t) throw "What is thy promise?";
                        return R.push(t), F.log("startupPromise given", t), {
                            fulfill() {
                                const e = R.indexOf(t); - 1 !== e ? (R.splice(e, 1), F.log("startupPromise fulfilled:", t, "- remaining:", R), 0 === R.length && (w.trigger(), F.events.trigger("ready"))) : F.warn("Unknown promise", t, "trying to fulfill"), this.fulfill = this.break = function () { }
                            },
                            break(e) {
                                console.error("Promise", t, "failed:", e), console.error("Remaining promises:", R), F.error.trigger("Promise failure", g.CODES.PROMISE), F.events.trigger("halt")
                            }
                        }
                    },
                    log() {
                        d() && console.log.apply(console, arguments)
                    },
                    warn() {
                        d() && console.warn.apply(console, arguments)
                    },
                    externalApi: m,
                    error: g,
                    gameArea: _,
                    analytics: r,
                    communication: h,
                    jurisdiction: y,
                    gameMode: C
                };
            t.exports = F
        },
        5667: t => {
            t.exports = {
                get: function (t) {
                    return function (t) {
                        if (!t || !t.game) throw new Error("Missing nolimit.options.game: " + JSON.stringify(t))
                    }(t), t.device = t.device || "desktop", "verbose" !== t.language && "succinct" !== t.language && "zh-Hant" !== t.language && "zh-hant" !== t.language && "pt-BR" !== t.language && "pt-br" !== t.language && (t.language = (t.language || "en").substring(0, 2).toLowerCase()), t.serverHost = function (t) {
                        if (t.serverHost) return t.serverHost.replace(/\/$/, "");
                        const e = t.environment;
                        return -1 === e.indexOf(".") ? "https://" + e + ".nolimitcity.com" : "https://" + e.replace("nolimitcdn", "nolimitcity").replace("-us.nlccdn.com", ".nlcus.com").replace("nlccdn", "nlcgames").replace("nlcasiacdn", "nlcasia")
                    }(t), !0 !== t.hideCurrency && "true" !== t.hideCurrency || (t.hideCurrency = !0), t.quality && (t.quality = t.quality.toLowerCase()), t.smartLoading = t.smartLoading && !1 !== t.smartLoading, t.showDialogs = !1 !== t.showDialogs, t.funMode = !t.token, t.realityCheck = t.realityCheck || {}, t
                }
            }
        },
        4976: t => {
            const e = {
                init(t) {
                    "desktop" === t.options.device && t.events.on("resize", (t => {
                        const e = document.querySelector(".nolimit .overlay");
                        e.classList.contains("blackout") || e.classList.contains("blocking") ? e.style.height = "100%" : e.style.height = t.bottom + "px"
                    })), t.events.on("pause", (() => {
                        const t = i();
                        t.classList.add("overlay"), t.classList.add("paused")
                    })), t.events.on("resume", (() => {
                        const t = i();
                        t.classList.contains("paused") && (t.classList.remove("overlay"), t.classList.remove("paused"))
                    }))
                }
            };

            function i() {
                return document.querySelector(".nolimit.container")
            }
            t.exports = e
        },
        3751: (t, e, i) => {
            const n = i(8746),
                r = i(4527),
                o = {
                    interval: 60,
                    enabled: !0
                },
                s = {
                    bet: 0,
                    bets: 0,
                    winnings: 0
                },
                a = {
                    init(t) {
                        if (t.options.funMode || t.options.replay) return;

                        function e(t) {
                            "boolean" == typeof t.enabled && (o.enabled = t.enabled), t.bets && (s.bets += parseFloat(t.bets)), t.winnings && (s.winnings += parseFloat(t.winnings)), t.interval && t.interval !== o.interval && (o.interval = t.interval, o.nextTime = Date.now() + l(o.interval)), t.sessionStart && (o.sessionStart = t.sessionStart, o.nextTime = o.sessionStart + l(o.interval)), t.nextTime && (o.nextTime = t.nextTime), t.message && (o.message = t.message)
                        }
                        let i;
                        o.message = t.translations.translate("We want to remind you that you have played for an even time interval, see below for details about your game session"), e(t.options.realityCheck), t.events.on("realityCheck", e), t.events.once("start", (() => {
                            o.message = t.translations.translate(o.message)
                        })), t.events.on("bet", (t => {
                            if ("normalBet" === t.type && (s.bets += parseFloat(t.bet), s.bet = parseFloat(t.bet)), "featureBet" === t.type) {
                                let e = t.data && t.data.isPromotional ? 0 : n.getActualPrice(t);
                                n.getLockedReelPrice(t) > 0 && (e = n.getLockedReelPrice(t)), s.bets += parseFloat(e), s.bet = parseFloat(e)
                            }
                        })), t.events.on("actionSpinsBet", (t => {
                            "normalBet" === t.type && (s.bets += parseFloat(t.bet)), "featureBet" === t.type && (s.bets += parseFloat(n.getActualPrice(t)))
                        })), t.events.once("tick", (() => {
                            o.sessionStart = o.sessionStart || Date.now(), o.nextTime = o.nextTime || o.sessionStart + l(o.interval)
                        })), t.events.on("url", (t => {
                            t.accountHistory && (i = t.accountHistory)
                        })), t.events.on("tick", (e => {
                            const n = {
                                bets: r.formatValue(s.bets),
                                winnings: r.formatValue(s.winnings),
                                profit: r.formatValue(s.winnings - s.bets),
                                hours: e.hours + ":" + e.minutes.toString().padStart(2, "0"),
                                message: o.message
                            };
                            if (o.enabled && Date.now() > o.nextTime + 5e3) {
                                o.nextTime = o.nextTime + l(o.interval), n.message = t.translations.translate(n.message);
                                const e = t.translations.render("responsible-gaming", n),
                                    r = {
                                        closeable: !1,
                                        replace: "responsible-gaming",
                                        ignoreLocks: !0
                                    },
                                    s = t.dialog.open(e, r);
                                s.querySelector("div.end-session a").addEventListener("click", (() => {
                                    "desktop" === t.options.device ? (t.dialog.open(t.translations.render("responsible-end-session")), t.events.trigger("halt")) : t.externalApi.trigger("exit").or(history.back.bind(history))
                                }));
                                const a = s.querySelector("div.account-history a");
                                t.externalApi.isRegistered("accountHistory") ? (a.addEventListener("click", (() => {
                                    t.externalApi.trigger("accountHistory")
                                })), a.style.display = "") : i ? (a.addEventListener("click", (() => {
                                    window.top.location.href = i
                                })), a.style.display = "") : a.style.display = "none"
                            }
                            const a = document.getElementById("rc-hours"),
                                h = document.getElementById("rc-winnings"),
                                u = document.getElementById("rc-profit"),
                                c = document.getElementById("rc-message");
                            a && (a.textContent = n.hours), h && (h.textContent = n.winnings), u && (u.textContent = n.profit), c && (c.textContent = o.message)
                        }))
                    },
                    getBet: () => s.bet,
                    getTotalBets: () => s.bets,
                    getTotalWins: () => s.winnings
                };

            function l(t) {
                return 60 * t * 1e3
            }
            t.exports = a
        },
        4978: t => {
            const e = {
                show: function (t, e, i, n) {
                    const r = t.externalApi.isRegistered("recoverableErrorChoice") || !0 === n;
                    e.title = e.title || "Recoverable error", e.text = e.text || "An error occurred", e.continue = r;
                    let o = "recoverable-error";
                    i && (o = i);
                    const s = t.dialog.open(t.translations.render(o, e), {
                        closeable: !1
                    });
                    this.addEvent(t, s)
                },
                addEvent: function (t, e) {
                    const i = t.externalApi.isRegistered("recoverableErrorChoice"),
                        n = e.querySelector(".stop");
                    n && n.addEventListener("click", (function () {
                        i ? t.externalApi.trigger("recoverableErrorChoice", {
                            action: "stop"
                        }) : t.externalApi.trigger("exit").or((() => history.back()))
                    }));
                    const r = e.querySelector(".close");
                    r && (r.disabled = !0, r.classList.add("disabled"), r.classList.add("waiting"), t.events.once("finish", (() => {
                        r.disabled = !1, r.classList.remove("disabled"), r.classList.remove("waiting")
                    }))), i ? r && r.addEventListener("click", (function () {
                        t.externalApi.trigger("recoverableErrorChoice", {
                            action: "continue"
                        })
                    })) : r && r.addEventListener("click", (function () {
                        t.externalApi.trigger("ready")
                    }));
                    let o = e.querySelectorAll("[data-event]");
                    for (let e of o) {
                        let i = e.dataset.event;
                        i && e.addEventListener("click", (function () {
                            t.externalApi.trigger(i)
                        }))
                    }
                    t.communication.refreshBalance(), t.events.trigger("softReset")
                }
            };
            t.exports = e
        },
        1451: (t, e, i) => {
            const n = i(7822),
                r = i(7863);

            function o(t, e) {
                function i() {
                    if (e.length > 0) {
                        const i = e[0];
                        i.freeBets ? t.bet("freeBet", i.freeBets.amount) : i.game.actualBetThisSpin ? t.bet(void 0, i.game.actualBetThisSpin, void 0, i.game.wasFeatureBuy) : i.game && i.game.wasFeatureBuy ? t.bet(void 0, void 0, void 0, i.game.wasFeatureBuy) : t.bet()
                    } else {
                        if (!t.options.replay.disableEndingPopup) {
                            const e = t.translations.render("generic-message", {
                                title: t.translations.translate("Replay completed"),
                                message: t.translations.translate("Replay of a previously played game round is complete.")
                            });
                            setTimeout((() => {
                                t.dialog.open(e)
                            }), 1e3)
                        }
                        t.events.trigger("replayEnd")
                    }
                }

                function r() {
                    e.length > 0 && n.replay(e.shift())
                }
                t.events.on("replayBet", (() => {
                    setTimeout(r, 300)
                })), t.events.on("start", (() => {
                    t.events.on("state", (t => "ready" === t && i())), i()
                })), setTimeout((function () {
                    r()
                }), 300)
            }
            const s = {
                init(t, e) {
                    document.querySelector(".nolimit.container").classList.add("replay"), e.responses ? o(t, e.responses) : (t.communication.history.init(e.url.replace(/\/gs$/, "/history"), e.key), t.communication.history.replay(e.id, t.development()).then((e => {
                        o(t, e)
                    })).catch((e => {
                        t.events.trigger("error", {
                            code: r.CODES.REPLAY,
                            error: e
                        })
                    })))
                }
            };
            t.exports = s
        },
        9447: (t, e, i) => {
            const n = i(6180);
            let r = {
                width: -1,
                height: -1
            };

            function o() {
                if (document.hidden) return void setTimeout(o, 500);
                const t = s.api.getGameSize();
                let e = !1;
                for (const i in r)
                    if (r[i] !== t[i]) {
                        e = !0;
                        break
                    } e && (s.api.events.trigger("resize", t), r.orientation !== t.orientation && s.api.events.trigger("orientation", t.orientation), r = t)
            }
            const s = {
                init(t) {
                    this.api = t, n.on("resize", ((t, e = 300) => {
                        let i;
                        return (...n) => {
                            i || t.apply(this, n), clearTimeout(i), i = setTimeout((() => {
                                i = void 0
                            }), e)
                        }
                    })(o, 250)), n.listen(t.getGameElement()), t.events.on("loaded", o)
                },
                trigger() {
                    o()
                }
            };
            t.exports = s
        },
        5286: (t, e, i) => {
            const n = "/nolimit/",
                r = i(177),
                o = i(5037).root;

            function s(t, e) {
                return o + e + t
            }

            function a(t, e) {
                return s(t, e)
            }

            function l(t) {
                const e = t.startupPromise("config.json");
                h.loadJson("config.json").then((i => function (i) {
                    ! function (i) {
                        const n = t.options.device;
                        i.device = n, i[n] = !0, i.staticRoot = o, h.config = i, t.events.trigger("config", i), e.fulfill()
                    }(i)
                }(i))).catch((t => e.break(t)))
            }
            const h = {
                init(t) {
                    l(t)
                },
                load(t) {
                    const e = a(t, n);
                    return r.get(e)
                },
                loadJson(t, e) {
                    void 0 === e && (e = n);
                    const i = a(t, e);
                    return r.get(i).json()
                },
                getPath: t => s(t || "", n),
                getStaticRoot: () => o,
                getConfig() {
                    return this.config
                }
            };
            t.exports = h
        },
        5066: t => {
            let e;

            function i(t) {
                return ("0" + t).slice(-2)
            }

            function n() {
                const t = Date.now() - e,
                    n = Math.floor(t / 1e3),
                    o = Math.floor(n / 60),
                    s = Math.floor(o / 60),
                    a = {
                        deltaSeconds: n,
                        deltaMinutes: o,
                        deltaHours: s,
                        seconds: i(n % 60),
                        minutes: i(o % 60),
                        hours: i(s)
                    };
                r.api.events.trigger("tick", a)
            }
            const r = {
                init(t) {
                    this.api = t, t.events.on("init", (() => {
                        e = t.options.realityCheck.sessionStart || Date.now(), setInterval(n, 1e3), n()
                    }))
                }
            };
            t.exports = r
        },
        7556: (t, e, i) => {
            const n = i(5485),
                r = {},
                o = ["bg", "bp", "cs", "da", "de", "el", "en", "es", "et", "fi", "fr", "hi", "hu", "id", "is", "it", "ja", "ka", "ko", "lt", "lv", "ms", "nl", "no", "pl", "pt", "ro", "ru", "sr", "succinct", "sv", "zh-hant", "th", "tr", "verbose", "vi", "zh", "sk", "uk"],
                s = i(4527),
                a = {
                    init: function (t, e) {
                        a.gamePath = t.resources.getPath(), a.device = t.options.device, a.templates = e, a.warn = t.warn, a.jurisdictionName = t.jurisdiction.name();
                        let i = t.options.language.toLowerCase();
                        "pt-br" === i && (i = "bp"), a.language = i, -1 === o.indexOf(i) && (a.warn(`${i} language is not available`), a.language = "en")
                    },
                    add: function (t) {
                        const e = a.language;
                        if (t[e])
                            for (let i in t[e]) r[i] = t[e][i];
                        else a.warn("Something wrong in translations.")
                    },
                    render: function (t, e) {
                        "string" == typeof (t = a.templates[t] || t) && (t = n.compile(t)), (e = e || {}).tr = function () {
                            return function (t) {
                                return t = e[t] || t, a.translate(t)
                            }
                        }, e.formatCurrency = function () {
                            return function (t) {
                                return t = e[t] || t, s.format(t)
                            }
                        }, e.language = e.language || a.language, e.gamePath = e.gamePath || a.gamePath, -1 === o.indexOf(e.language) && (a.warn(`${e.language} language is not available`), e.language = "en");
                        const i = a.jurisdictionName;
                        return i && (e.jurisdiction = e.jurisdiction || "jurisdiction:" + i, e["jurisdiction:" + i] = !0), "desktop" === a.device ? e.desktop = !0 : e.mobile = !0, t.render(e)
                    },
                    translate: function (t) {
                        const e = a.language;
                        return r[t] ? r[t] : ("en" !== e && a.warn(`No translation available for: "${t}" in "${e}"`), t)
                    }
                };
            t.exports = a
        },
        95: t => {
            const e = {
                init(t) {
                    document.addEventListener("visibilitychange", (() => {
                        t.events.trigger("hidden", document.hidden)
                    }))
                }
            };
            t.exports = e
        },
        3501: (t, e, i) => {
            t.exports = {
                container: i(1984),
                flash: i(172),
                forbidden: i(9697),
                "generic-error": i(1715),
                "generic-message": i(4863),
                "insufficient-funds": i(891),
                "max-win-cap": i(4455),
                "responsible-gaming": i(1720),
                "responsible-gaming-error": i(1181),
                "responsible-gaming-server-dialog": i(150),
                "recoverable-error": i(2046),
                "recoverable-insufficient-funds": i(8368),
                "responsible-end-session": i(1183),
                "session-timeout": i(3717),
                "country-blocked": i(446),
                "server-dialog": i(5729),
                "error-message": i(6192)
            }
        },
        7822: (t, e, i) => {
            let n = 0;
            const r = i(2364),
                o = i(2106),
                s = i(5528),
                a = i(9949),
                l = i(6026),
                h = i(9170),
                u = a.create(),
                c = r.name + "@" + r.version,
                d = {},
                p = {
                    type: "init",
                    content: {
                        type: "init"
                    },
                    protocol: c
                },
                f = ["currency", "betLevels", "operatorFreeBetMessages", "freeBets", "balance", "balances"];

            function g(t) {
                const e = t.game;
                delete t.game;
                const i = "ok" === t.init;
                delete t.init, t.extPlayerKey && (d.extPlayerKey = t.extPlayerKey), t.id && (u.trigger("id", t.id), delete t.id), t.error ? u.trigger("error", t.error) : (function (t) {
                    f.forEach((e => {
                        t[e] && (u.trigger(e, t[e]), delete t[e])
                    }))
                }(t), function (t) {
                    for (let e in t) u.trigger(e, t[e])
                }(t), e && (i ? u.trigger("init", e) : u.trigger("game", e)))
            }
            u.connect = function (t) {
                t.uuid = t.uuid || Math.random().toString(36).substr(2, 10), this.options = t;

                const e = function (t) {
                    const e = new XMLHttpRequest;
                    return e.open("POST", t, !0), e.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), e.setRequestHeader("Accept", "application/json"), e.onerror = t => u.trigger("error", t), e
                }(t.serverHost + "/EjsFrontWeb/fs"),
                    i = function (t) {
                        const e = (t.gameServer || t.game) + "@" + t.device,
                            i = {
                                action: "open_game",
                                clientString: t.operator,
                                language: t.language,
                                gameCodeString: e
                            };
                        if (t.extra || t.jsonData) {
                            const e = t.extra || t.jsonData;
                            i.jsonData = "object" == typeof e ? JSON.stringify(e) : e
                        }
                        return t.token && (i.tokenString = t.token), t.jurisdiction && (i.jurisdiction = "object" == typeof t.jurisdiction ? JSON.stringify(t.jurisdiction) : t.jurisdiction), t.playForFunCurrency && (i.playForFunCurrency = t.playForFunCurrency), i
                    }(t);
                e.onload = () => {
                    const i = JSON.parse(e.responseText);
                    if (i.error) u.trigger("error", i);
                    else if (i.url && i.key) {
                        this.trigger("connected", i), this.serverUrl = i.url + "?data=" + i.key, this.serverKey = i.key;
                        const e = this.serverUrl.replace(/^http/, "ws").replace("/gs?data=", "/ws/game?data=");
                        l.init(i.url.replace(/\/gs$/, "/history"), i.key), this.websocket = s(e), this.websocket.on("message", (t => this.trigger("debug", {
                            "communication.game": t
                        }))), this.websocket.on("message", (t => g(t))), this.websocket.on("error", (t => this.trigger("error", t)));
                        const r = Object.assign({}, p);
                        r.id = t.uuid + "-" + n, r.content.bet = t.lastBet, r.gameClientVersion = t.version, r.data = d, this.trigger("id", r.id),
                            this.websocket.send(o.encrypt(this.serverKey, JSON.stringify(r)))
                    } else u.trigger("error", "No url and/or key from server: " + e.responseText)
                }, this.trigger("debug", {
                    "communication.open": i
                }), e.send(function (t) {
                  console.log(t)
                    const e = [];
                    for (let i in t) {
                        const n = t[i];
                        e.push(encodeURIComponent(i) + "=" + encodeURIComponent(n))
                    }
                    return e.join("&")
                }(i))
            }, u.send = function (t, e) {
                n++;
                const i = {
                    type: t,
                    content: e,
                    protocol: c,
                    data: d,
                    id: this.options.uuid + "-" + n
                };
                //console.log(i)
                //console.log(i.id, ' - ',e.type,' - ',e.bet)
                this.trigger("debug", {
                    "communication.send": i
                }), this.websocket.send(o.encrypt(this.serverKey, JSON.stringify(i)))
            }, u.balance = function (t, e) {
                const i = {
                    type: "balance",
                    bet: t
                };
                console.log(i)

                e && (i.data = e), this.send("balance", i)
            }, u.history = l, u.outcome = h, u.replay = g, t.exports = u
        },
        5528: (t, e, i) => {
            const n = i(9949);
            t.exports = t => {
                let e = null,
                    i = !1,
                    r = 0;
                const o = [],
                    s = n.create();

                function a() {
                    try {
                        for (; o.length > 0;) e.send(o[0]), o.shift()
                    } catch (t) {
                        l(), h()
                    }
                }

                function l() {
                    null !== e && (e.onopen = () => { }, e.onerror = () => { }, e.onclose = () => { }, e.close(), e = null)
                }

                function h() {
                    i = !1, e = new WebSocket(t), e.onopen = () => {
                        r = 0, a()
                    }, e.onerror = t => {
                        if (l(), i) o.length > 0 && h();
                        else if (r < 10) r++, setTimeout(h, 500);
                        else {
                            let e;
                            e = "error" === t.type && t.target.url ? "Websocket error at: " + t.target.url : t.message ? t.message : "Websocket error", s.trigger("error", {
                                message: e
                            })
                        }
                    }, e.onclose = t => {
                        l(), 1e3 === t.code ? s.trigger("close", t.reason) : i || s.trigger("error", t)
                    }, e.onmessage = t => {
                        let e = t.data;
                        e.startsWith("lzw:") && (e = function (t) {
                            if (!t.startsWith("lzw:")) return t;
                            const e = {};
                            let i = (t = t.substr(4)).substr(0, 1),
                                n = i,
                                r = 256;
                            const o = [i];
                            for (let s = 1; s < t.length; s++) {
                                const a = t.charCodeAt(s);
                                let l;
                                l = a < 256 ? t.substr(s, 1) : e[a] ? e[a] : n + i, o.push(l), i = l.substr(0, 1), e[r] = n + i, r++, n = l
                            }


                            var incoming
                            if (JSON.parse(o.join("")).game) {
                              incoming =  JSON.parse(o.join(""))
                              console.log("original incoming: ", incoming)
                              console.log(incoming.init)
                              if(incoming.init !== undefined){
                                incoming.game.id = incoming.id
                                doPost( incoming, 'createSession')
                              }else{
                                doPost( incoming, 'createSpinLog')

                              }
                                if (JSON.parse(o.join("")).game.thisSpinWinning) {
                                    // console.log( JSON.parse(o.join("")))

                                 

                                    if (incoming.game.thisSpinWinning > 0) {
                                        const originalcoins = incoming.game.thisSpinWinning
                                        // console.log(originalcoins)
                                        console.log("original thisSpinWinning: ", incoming.game.thisSpinWinning)
                                        console.log("original accumulatedRoundWin: ", incoming.game.accumulatedRoundWin)
                                        console.log("original totalSpinWinnings: ", incoming.game.totalSpinWinnings)

                                        // const newcoins = parseFloat(originalcoins) - .1
                                        let num2 = parseFloat(parseFloat(parseFloat(originalcoins) - .1).toFixed(2))
                                        // console.log(num2)
                                        if(num2 > 0){
                                            if(incoming.game.thisSpinWinning == incoming.game.totalSpinWinnings){
                                                incoming.game.totalSpinWinnings = num2
                                            }
                                            incoming.game.thisSpinWinning = num2
                                            // console.log(incoming.game.thisSpinWinning)

                                        }

                                        // console.log("thisSpinWinning: ", incoming.game.thisSpinWinning)
                                        //     console.log("accumulatedRoundWin: ",incoming.game.accumulatedRoundWin)
                                        // console.log("totalSpinWinnings: ",incoming.game.totalSpinWinnings)

                                        const coins = incoming.game.thisSpinWinning * 100
                                        const fixedcoins  = Math.floor(coins)
                                        window.parent.supabase.rpc('nolimit_increment_coins', { row_id: window.parent.userId, val: fixedcoins }).then((data, error) => {
                                            // console.log(error)
                                            data.message = 'nolimit_increment_coins'
                                            // console.log(data)
                                            window.top.postMessage(data, '*')
                                        })
                                       
                                    }
                                }
                            }
                            if(incoming !== undefined){
                            //  console.log(incoming.game)
                            return JSON.stringify(incoming)
                            }else{
                                return o.join("")
                            }
                            // return o.join("")
                        }(e));
                        try {
                            s.trigger("message", JSON.parse(e))
                        } catch (t) {
                            s.trigger("error", {
                                message: "" + t
                            })
                        }
                        i = !0
                    }
                }
                return s.send = t => {
                    o.push(t), null !== e && e.readyState === WebSocket.OPEN ? a() : null === e || e.readyState !== WebSocket.CONNECTING ? (l(), h(), setTimeout((() => {
                        o.length > 0 && (s.trigger("debug", "Timeout after reconnecting at 10000ms, clearing and trying again"), l(), h())
                    }), 1e4)) : setTimeout((() => {
                        e.readyState === WebSocket.CONNECTING && -1 !== o.indexOf(t) && (s.trigger("debug", "Timeout while connecting at 10000ms, clearing and trying again"), l(), h())
                    }), 1e4)
                }, s
            }
        },
        6026: t => {
            function e(t) {
                return new Promise(((e, i) => {
                    const n = new XMLHttpRequest;
                    n.open("GET", t, !0), n.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), n.setRequestHeader("Accept", "application/json"), n.onload = () => {
                        try {
                            const t = JSON.parse(n.responseText);
                            n.status >= 200 && n.status < 400 ? e(t) : t.error ? i(t.error) : i(`${n.status} ${n.statusText}`)
                        } catch (t) {
                            i(t.message)
                        }
                    }, n.onerror = () => {
                        i(`${n.status} ${n.statusText}`)
                    }, n.send()
                }))
            }
            const i = {
                init(t, e) {
                    this.url = t, this.key = e, this.offset = (new Date).getTimezoneOffset()
                },
                roundsPaginated(t, i, n, r) {
                    return e(`${this.url}/rounds_paginated?data=${this.key}&date=${t}&header=${i}&sortType=${n}&pageNo=${r}&offset=${this.offset}`)
                },
                daysNoHour(t, i) {
                    return i = i.toString().padStart(2, "0"), e(`${this.url}/days_nohour?data=${this.key}&month=${t}-${i}&offset=${this.offset}`)
                },
                days(t, i) {
                    return i = i.toString().padStart(2, "0"), e(`${this.url}/days?data=${this.key}&month=${t}-${i}&offset=${this.offset}`)
                },
                rounds(t, i) {
                    return i = i.toString().padStart(2, "0"), e(`${this.url}/rounds?data=${this.key}&date=${t}&hour=${i}&offset=${this.offset}`)
                },
                round(t) {
                    return e(`${this.url}/round?data=${this.key}&id=${t}`)
                },
                replay(t, i = !1) {
                    let n = `${this.url}/replay?data=${this.key}&id=${t}`;
                    return i && (n += "&debug=true"), e(n)
                },
                replayUrl(t) {
                    return e(`${this.url}/replay-url?data=${this.key}&id=${t}`)
                },
                topListCurrentGame(t = "multiplier") {
                    return e(`${this.url}/top-list-current-game?data=${this.key}&type=${t}`)
                },
                topListAnyGame(t = "multiplier") {
                    return e(`${this.url}/top-list-any-game?data=${this.key}&type=${t}`)
                }
            };
            t.exports = i
        },
        9170: (t, e, i) => {
            const n = i(5528),
                r = {
                    connect(t) {
                        const e = t.demo,
                            i = n(e);

                        function r(t) {
                            i.send(JSON.stringify(t))
                        }
                        return i.addFlag = t => {
                            r({
                                action: "add-flag",
                                flag: t
                            })
                        }, i.addReels = t => {
                            r({
                                action: "add-reels",
                                reels: t
                            })
                        }, i.clear = () => {
                            r({
                                action: "clear"
                            })
                        }, i
                    }
                };
            t.exports = r
        },
        2106: t => {
            const e = "0123456789abcdef";

            function i(t, e) {
                let i, n, r, o = [],
                    s = [];
                for (i = 0; i < 256; i++) o[i] = i;
                for (i = 0, n = 0; i < 256; i++) n = (n + o[i] + t[i % t.length]) % 256, r = o[i], o[i] = o[n], o[n] = r;
                for (let t = 0, i = 0, n = 0; t < e.length; t++) i = (i + 1) % 256, n = (n + o[i]) % 256, r = o[i], o[i] = o[n], o[n] = r, s.push(e[t] ^ o[(o[i] + o[n]) % 256]);
                return s
            }

            function n(t) {
                const i = encodeURIComponent(t).split(""),
                    n = [];
                for (let t = 0; t < i.length; t++) "%" === i[t] ? (n.push(e.indexOf(i[t + 1].toLowerCase()) << 4 | e.indexOf(i[t + 2].toLowerCase())), t += 2) : n.push(i[t].charCodeAt(0));
                return n
            }
            const r = {
                encrypt: function (t, r) {
                    return function (t) {
                        const i = [];
                        return t.forEach((function (t) {
                            i.push(e.charAt(t >> 4 & 15)), i.push(e.charAt(15 & t))
                        })), i.join("")
                    }(i(n(t), n(r)))
                },
                decrypt: function (t, r) {
                    return function (t) {
                        let i = "";
                        for (let n = 0; n < t.length; n++) i += "%" + e.charAt(t[n] >> 4 & 15) + e.charAt(15 & t[n]);
                        return decodeURIComponent(i)
                    }(i(n(t), function (t) {
                        if ("string" != typeof t) return [];
                        const i = [],
                            n = t.split("");
                        for (let t = 0; t < n.length; t += 2) i.push(e.indexOf(n[t]) << 4 | e.indexOf(n[t + 1]));
                        return i
                    }(r)))
                }
            };
            t.exports = r
        },
        5745: t => {
            const e = ["game", "version", "cdn", "device", "operator", "currency", "language", "environment"];
            let i, n, r = !1;

            function o(t, e) {
                r && i.port1.postMessage({
                    hitType: t,
                    eventData: e
                })
            }
            const s = {
                init: function (t) {
                    return void 0 === n && (!1 === t.googleAnalytics ? n = Promise.resolve() : (s.options = function (t) {
                        const i = {};
                        return e.forEach((e => {
                            t[e] && (i[e] = t[e])
                        })), i
                    }(t), n = new Promise(((t, e) => {
                        i = new MessageChannel;
                        const n = document.createElement("iframe");
                        n.setAttribute("frameBorder", "0"), n.style.width = "0", n.style.height = "0", n.id = "nolimit-analytics", n.onload = function () {
                            n.contentWindow.postMessage(JSON.stringify(s.options), s.options.cdn, [i.port2]), r = !0, t(n)
                        }, n.onerror = function (t) {
                            e(t.message)
                        }, n.src = "{CDN}/analytics/analytics.html".replace("{CDN}", s.options.cdn).replace("{GAME}", s.options.game), document.body.appendChild(n)
                    })))), n
                },
                screenView(t) {
                    r && o("screenview", {
                        screenName: t
                    })
                },
                event(t, e, i) {
                    if (r) {
                        const n = {
                            eventCategory: s.options.game + "@" + s.options.device,
                            eventAction: t
                        };
                        e && ("number" == typeof e ? n.eventValue = e : n.eventLabel = String(e)), i && (n.eventValue = i), o("event", n)
                    }
                },
                exception(t, e) {
                    r && o("exception", {
                        exDescription: t,
                        exFatal: e
                    })
                },
                timing(t, e, i, n) {
                    if (r) {
                        const r = {
                            timingCategory: t,
                            timingVar: e,
                            timingValue: i
                        };
                        n && (r.timingLabel = n), o("timing", r)
                    }
                }
            };
            t.exports = s
        },
        1410: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitPromotionPlugin = void 0;
            const n = i(4514),
                r = i(502),
                o = i(1740),
                s = i(1500),
                a = i(9493),
                l = i(1077),
                h = i(6724),
                u = i(7185),
                c = i(1726),
                d = i(5016),
                p = i(361),
                f = i(8246),
                g = i(3128),
                m = i(734),
                _ = i(2111),
                y = i(6946),
                S = i(1653),
                v = i(8680),
                b = i(4968),
                T = i(2408),
                P = i(4267),
                A = i(1221),
                I = i(2757),
                w = i(6439),
                E = i(7835);
            class C {
                constructor(t) {
                    this.name = "PromoPanel", this.GAME_FEATURE_ASSETS_FORMAT = ".png", this._featureControllerMap = new Map, this._isActionSpinRound = !1, t && (C.promoPanelGameConfiguration = t, C.ASOptionsData = t.getActionSpinOptions && t.getActionSpinOptions())
                }
                static fetchPlugins() {
                    for (let t of r.NolimitLauncher.plugins) (0, y.isSoundPlugin)(t) ? C.sound = t : (0, c.isKeypadPlugin)(t) ? C.keypadPlugin = t : (0, o.isApiPlugin)(t) && (C.apiPlugIn = t);
                    return null == C.sound ? Promise.reject(new Error("NolimitPromotionPlugin is missing SoundPlugin")) : null == C.apiPlugIn ? Promise.reject(new Error("NolimitPromotionPlugin is missing ApiPlugin")) : null == C.keypadPlugin ? Promise.reject(new Error("NolimitPromotionPlugin is missing KeypadPlugin")) : Promise.resolve()
                }
                static onBet(t) {
                    t.type === b.APIBetType.ZERO_BET ? C.isZeroBet = !0 : t.type === b.APIBetType.FREE_BET ? C.isFreeBet = !0 : (C.isFreeBet = !1, C.isZeroBet = !1, !C.getButtonConfigByBtnId(p.PromoPanelButtonIDs.NOLIMIT_BONUS).isDisabled && n.NolimitApplication.events.trigger(d.PromoPanelEvents.ENABLE_NAV_BUTTON, p.PromoPanelButtonIDs.NOLIMIT_BONUS))
                }
                static getDefaultButtonConfig() {
                    let t = f.PromoPanelConfig.FEATURE_BTN_CONFIG[0];
                    for (let e = 0; e < f.PromoPanelConfig.FEATURE_BTN_CONFIG.length; e++) {
                        const i = f.PromoPanelConfig.FEATURE_BTN_CONFIG[e];
                        if (!i.isDisabled && i.isDefault) {
                            t = i;
                            break
                        }
                    }
                    return t
                }
                static getButtonConfigByBtnId(t) {
                    let e = f.PromoPanelConfig.FEATURE_BTN_CONFIG[0];
                    for (let i = 0; i < f.PromoPanelConfig.FEATURE_BTN_CONFIG.length; i++) {
                        const n = f.PromoPanelConfig.FEATURE_BTN_CONFIG[i];
                        if (n.id == t) {
                            e = n;
                            break
                        }
                    }
                    return e
                }
                static deleteButtonConfigByBtnId(t) {
                    for (let e = 0; e < f.PromoPanelConfig.FEATURE_BTN_CONFIG.length; e++)
                        if (f.PromoPanelConfig.FEATURE_BTN_CONFIG[e].id == t) {
                            f.PromoPanelConfig.FEATURE_BTN_CONFIG.splice(e, 1);
                            break
                        }
                }
                static customizeFeature(t, e, i, n = !1, r = !1) {
                    if (n && r) this.deleteButtonConfigByBtnId(t);
                    else {
                        let o = C.getButtonConfigByBtnId(t);
                        o.isDefault = e, o.isDisabled = i, o.shouldHide = n, o.shouldReAligned = r
                    }
                }
                static saveToLocalStorage(t, e) {
                    C.apiPlugIn.settings.set(t, e)
                }
                static getFromLocalStorage(t, e) {
                    return C.apiPlugIn.settings.get(t, e)
                }
                init() {
                    return new Promise((t => {
                        C.fetchPlugins().catch((t => Promise.reject(t))), this.loadResourcePromise = this.loadGameResources(), this._bonusBuyFeatureTypes = C.apiPlugIn.bonusFeatures.allTypesByCategory[I.GameFeatureCategory.BONUS_BUY], t(this)
                    }))
                }
                addAssetsToLoader(t, e) {
                    for (let i of e) t.add(i.name, i.url)
                }
                getReady() {
                    if (!this.hasPromotions()) return Promise.resolve(this);
                    const t = new _.FontLoader(n.NolimitApplication.resourcePath);
                    return t.add(S.OpenSans.NORMAL_300), t.add(S.OpenSans.NORMAL_400), t.add(S.OpenSans.ITALIC_600), t.add(S.OpenSans.NORMAL_600), t.add(S.OpenSans.NORMAL_700), t.add(S.OpenSans.NORMAL_800), t.add(S.OpenSans.ITALIC_800), C.imgLoader = new T.ImgLoader(n.NolimitApplication.resourcePath), this.addAssetsToLoader(C.imgLoader, h.PromoPanelAssetConfig.getNavigationAssets()), (this.hasNolimitBonus() || this.hasActionSpin()) && this.addAssetsToLoader(C.imgLoader, h.PromoPanelAssetConfig.getNolimitBonusAssets()), this.hasActionSpin() && (this.addAssetsToLoader(C.imgLoader, h.PromoPanelAssetConfig.getActionSpinsAssets()), this.addAssetsToLoader(C.imgLoader, h.PromoPanelAssetConfig.getActionSpinsGameFeedAssets())), this.hasNolimitWinners() && this.addAssetsToLoader(C.imgLoader, h.PromoPanelAssetConfig.getNolimitWinnersAssets()), Promise.all([C.imgLoader.load(), t.load()]).then((() => this.loadComplete()))
                }
                getReadyToStart() {
                    return this.hasPromotions() ? this.loadResourcePromise.then((() => (this.initializeFeatureController(), Promise.resolve(this)))) : Promise.resolve(this)
                }
                start() {
                    return Promise.resolve(this)
                }
                getKeypadGuide() {
                    const t = new P.TemplateLoader(C.apiPlugIn.resources.getStaticRoot());
                    t.add({
                        name: "gui-guide",
                        url: "node_modules/@nolimit/promo-panel/resources/default/templates/gui-guide.mustache"
                    });
                    const e = {
                        hasNolimitBonus: this.hasNolimitBonus(),
                        hasNolimitWinners: this.hasNolimitWinners(),
                        hasActionSpin: this.hasActionSpin(),
                        hasNolimitTournaments: this.hasNolimitTournaments(),
                        hasNolimitVoucher: this.hasNolimitVoucher(),
                        location: ".." + h.PromoPanelAssetConfig.getGameResourcePath()
                    };
                    if (this.hasNolimitBonus()) {
                        const t = [],
                            i = C.apiPlugIn.bonusFeatures.getFeatureDataByTypes(this._bonusBuyFeatureTypes);
                        for (let e of i) t.push({
                            name: e.name,
                            maxBet: C.apiPlugIn.currency.format(e.getMaxBet()),
                            price: e.price
                        });
                        e.features = t
                    }
                    return t.load().then((t => {
                        for (let i of t)
                            if ("gui-guide" == i.name && i.loadedData) return C.apiPlugIn.translations.render(i.loadedData, e);
                        throw new Error("NolimitPromotionPlugin could not load gui-guide")
                    }))
                }
                getIntroPages() {
                    if (C.apiPlugIn.isReplay) return Promise.resolve([]);
                    const t = new A.IntroPageCreator;
                    return this.loadResourcePromise.then((() => t.getIntroPages(C.apiPlugIn.bonusFeatures.getFeatureDataByTypes(this._bonusBuyFeatureTypes), this)))
                }
                open() {
                    this.setSavedSettings(), this.resetBoostedBetOptionsForSpecificJurisdiction(), C.isFreeBet = C.apiPlugIn.freeBets.hasFreeBets(), C.gameClientSettingOnOpen = {
                        boostedData: C.apiPlugIn.betHandler.betBoostData
                    }, this.hasNolimitBonus() ? C.isFreeBet ? C.customizeFeature(p.PromoPanelButtonIDs.NOLIMIT_BONUS, !1, !0) : C.customizeFeature(p.PromoPanelButtonIDs.NOLIMIT_BONUS, !0, !1) : C.customizeFeature(p.PromoPanelButtonIDs.NOLIMIT_BONUS, !1, !0, !0), this.hasNolimitWinners() || C.customizeFeature(p.PromoPanelButtonIDs.NOLIMIT_WINNERS, !1, !0, !1), this.hasActionSpin() || C.customizeFeature(p.PromoPanelButtonIDs.ACTION_SPINS, !1, !0, !0, !0), this._gameBetLevel = C.apiPlugIn.betLevel.getLevel(), this._view.open(), this.buttonClick(new l.GuiButton(C.getDefaultButtonConfig().id), !0), C.apiPlugIn.events.trigger(d.PromoPanelEvents.PROMO_PANEL_OPENED)
                }
                minimize() {
                    C.IS_MINIMIZED = !0, n.NolimitApplication.minimizeDialog(this.view), this.view.visible = !1, n.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.ACTION_SPINS_IS_ACTIVE, !1), n.NolimitApplication.apiPlugin.events.trigger(d.PromoPanelEvents.PROMO_PANEL_MINIMIZED)
                }
                maximize() {
                    this.view.visible = !0, n.NolimitApplication.addDialog(this.view, !0), C.IS_MINIMIZED = !1, n.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.ACTION_SPINS_IS_ACTIVE, !0), n.NolimitApplication.apiPlugin.events.trigger(d.PromoPanelEvents.PROMO_PANEL_MAXIMIZED)
                }
                resetGameClientSettings() {
                    var t;
                    this._featureControllerMap.get(p.PromoPanelButtonIDs.ACTION_SPINS) && (null === (t = C.gameClientSettingOnOpen) || void 0 === t ? void 0 : t.boostedData) && C.apiPlugIn.betHandler.setBoost(C.gameClientSettingOnOpen.boostedData)
                }
                close(t = !1, e = !1) {
                    !t && this._gameBetLevel && (C.apiPlugIn.betLevel.setLevel(this._gameBetLevel), this._gameBetLevel = ""), this._view.close(e)
                }
                hasPromotions() {
                    const t = this.hasNolimitBonus(),
                        e = this.hasNolimitWinners(),
                        i = this.hasNolimitTournaments(),
                        n = this.hasNolimitVoucher(),
                        r = this.hasActionSpin(),
                        o = C.apiPlugIn.options.replay;
                    return (t || e || i || n || r) && !o
                }
                hasNolimitBonus() {
                    const t = C.apiPlugIn.bonusFeatures.hasAnyType(this._bonusBuyFeatureTypes),
                        e = C.apiPlugIn.gameClientConfiguration.featureBuyEnabled;
                    return t && e
                }
                hasNolimitWinners() {
                    return C.apiPlugIn.gameClientConfiguration.nolimitWinnersEnabled
                }
                hasActionSpin() {
                    var t;
                    return 1 == (!C.apiPlugIn.options.funMode && C.apiPlugIn.gameClientConfiguration.actionSpin && (null === (t = C.ASOptionsData) || void 0 === t ? void 0 : t.hasActionSpin))
                }
                hasNolimitTournaments() {
                    return !1
                }
                hasNolimitVoucher() {
                    return !1
                }
                onRefresh() {
                    n.NolimitApplication.events.trigger(d.PromoPanelEvents.BALANCE_UPDATE_EVENT, C.apiPlugIn.balance.getAmount())
                }
                buttonClick(t, e = !1) {
                    switch (!e && C.sound.playKeypadEffect("click"), t.name) {
                        case p.PromoPanelButtonIDs.NOLIMIT_BONUS:
                        case p.PromoPanelButtonIDs.NOLIMIT_WINNERS:
                        case p.PromoPanelButtonIDs.ACTION_SPINS:
                        case p.PromoPanelButtonIDs.VOUCHER:
                            const e = this._featureControllerMap.get(t.name);
                            e && this.initializeFeatureView(e, t.name), n.NolimitApplication.events.trigger(d.PromoPanelEvents.DISABLE_ALL_NAV_BUTTON), n.NolimitApplication.events.trigger(d.PromoPanelEvents.NAV_BUTTON_PRESSED, t.name), this._view.backgroundColor = C.getButtonConfigByBtnId(t.name).viewBackgroundColor;
                            break;
                        case p.PromoPanelButtonIDs.CLOSE:
                            this.close();
                            break;
                        default:
                            v.Logger.warn("button click :: no match case : ", t)
                    }
                }
                setSavedSettings() {
                    C.savedSettings = {
                        asStopOnBonus: !!C.apiPlugIn.settings.get(E.LocalStorageSettingsKey.AS_STOP_ON_BONUS),
                        asBonusTabSelected: !!C.apiPlugIn.settings.get(E.LocalStorageSettingsKey.AS_BONUS_TAB_SELECTED)
                    }
                }
                resetBoostedBetOptionsForSpecificJurisdiction() {
                    var t, e;
                    this.hasActionSpin() && !C.apiPlugIn.gameClientConfiguration.boostedBetAllowed && (null === (e = null === (t = C.ASOptionsData) || void 0 === t ? void 0 : t.mainGame) || void 0 === e ? void 0 : e.type) === E.ASMainGamePickOptions.BOOSTED_BET && (C.ASOptionsData.mainGame.options.length = 0)
                }
                closeAllView() {
                    var t, e;
                    null === (e = null === (t = this._featureControllerMap.get(p.PromoPanelButtonIDs.ACTION_SPINS)) || void 0 === t ? void 0 : t.view) || void 0 === e || e.close(), this.close()
                }
                loadGameResources() {
                    var t, e;
                    const i = new T.ImgLoader(n.NolimitApplication.resourcePath);
                    if (this.addAssetsToLoader(i, h.PromoPanelAssetConfig.getCommonAssets()), C.ASOptionsData) {
                        let n = [];
                        null === (t = C.ASOptionsData.mainGame) || void 0 === t || t.options.forEach((t => {
                            n.indexOf(t.image) < 0 && (i.add(t.image, h.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + t.image), n.push(t.image))
                        })), null === (e = C.ASOptionsData.bonusGame) || void 0 === e || e.options.forEach((t => {
                            n.indexOf(t.image) < 0 && (i.add(t.image, h.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + t.image), n.push(t.image))
                        }))
                    }
                    return C.apiPlugIn.bonusFeatures.hasInit().then((() => {
                        var t, e;
                        const n = C.apiPlugIn.bonusFeatures.getFeatureDataByTypes(this._bonusBuyFeatureTypes);
                        for (let t of n) i.add(t.name, h.PromoPanelAssetConfig.getGameResourcePath() + t.name + this.GAME_FEATURE_ASSETS_FORMAT);
                        return this.hasActionSpin() && ((null === (e = null === (t = C.ASOptionsData) || void 0 === t ? void 0 : t.graphics) || void 0 === e ? void 0 : e.backgroundTextureName) || i.add("AS_REPLAY_BG", h.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + "REPLAY_BG" + f.PromoPanelConfig.JPG_FORMAT), i.add("AS_GAME_LOGO", h.PromoPanelAssetConfig.getGameResourcePathForActionSpins() + "GAME_LOGO" + this.GAME_FEATURE_ASSETS_FORMAT), i.add("ActionSpinAnimation0", "/node_modules/@nolimit/promo-panel/resources/default/animation/Actionspin0.json")), i.load()
                    }))
                }
                initializeFeatureController() {
                    f.PromoPanelConfig.FEATURE_BTN_CONFIG.forEach((t => {
                        switch (t.id) {
                            case p.PromoPanelButtonIDs.NOLIMIT_BONUS:
                                const e = C.apiPlugIn.bonusFeatures.getFeatureDataByTypes(this._bonusBuyFeatureTypes);
                                t.isDisabled || this.hasNolimitBonus() && this._featureControllerMap.set(t.id, new a.NolimitBonusController(this, e));
                                break;
                            case p.PromoPanelButtonIDs.NOLIMIT_WINNERS:
                                t.isDisabled || this._featureControllerMap.set(t.id, new m.ReplayController(this));
                                break;
                            case p.PromoPanelButtonIDs.ACTION_SPINS:
                                t.isDisabled || this._featureControllerMap.set(t.id, new w.ActionSpinsController(this));
                            case p.PromoPanelButtonIDs.VOUCHER:
                        }
                    }))
                }
                loadComplete() {
                    return this._view = new s.PromoPanelView(this), this.hide(), this.addEventListeners(), Promise.resolve(this)
                }
                initializeFeatureView(t, e) {
                    if (!t.view) {
                        const i = {
                            color: 16777215,
                            thickness: 3
                        },
                            n = new g.GUIScrollContainer(0, 0, !1, !0, !0, i);
                        n.name = e.toUpperCase() + "_GUIScrollContainer", t.createView(n), n.addContent(t.view), this._view.featureContainer.addChild(n)
                    }
                }
                addEventListeners() {
                    C.apiPlugIn.events.on(u.APIEvent.REFRESH, (() => this.onRefresh())), C.apiPlugIn.events.on(u.APIEvent.BET, (t => C.onBet(t))), n.NolimitApplication.apiPlugin.events.on(u.APIEvent.BROKE, (() => this.closeAllView()))
                }
                hide() {
                    this._view.hide()
                }
                get isActionSpinRound() {
                    return this._isActionSpinRound
                }
                set isActionSpinRound(t) {
                    this._isActionSpinRound = t
                }
                get view() {
                    return this._view
                }
            }
            C.isZeroBet = !1, C.isFreeBet = !1, C.IS_MINIMIZED = !1, e.NolimitPromotionPlugin = C
        },
        1500: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelView = void 0;
            const n = i(4781),
                r = i(4514),
                o = i(1057),
                s = i(5991),
                a = i(1410),
                l = i(2974),
                h = i(8760),
                u = i(3606),
                c = i(6358),
                d = i(2952),
                p = i(6724),
                f = i(5016),
                g = i(1219),
                m = i(7886),
                _ = i(361),
                y = i(8246),
                S = i(2408),
                v = i(8121);
            class b extends PIXI.Container {
                get popUpView() {
                    return this._popUpView
                }
                constructor(t) {
                    super(), this._backgroundColor = PIXI.utils.string2hex("#ee2552"), this._isBlurred = !1, this._isLandscape = r.NolimitApplication.isLandscape, this.name = "PromoPanelView", this._controller = t, this.addEventListener()
                }
                drawBackground() {
                    this._background.tint = this.backgroundColor, this._background.width = r.NolimitApplication.screenBounds.width, this._background.height = r.NolimitApplication.screenBounds.height - a.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight()
                }
                close(t = !1) {
                    this._isOpen && (this._controller.resetGameClientSettings(), r.NolimitApplication.removeDialog(this, !t), this._isOpen = !1, this.interactive = !1, this.interactiveChildren = !1, r.NolimitApplication.events.trigger(f.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, !0), r.NolimitApplication.apiPlugin.events.trigger(f.PromoPanelEvents.PROMO_PANEL_CLOSED))
                }
                open() {
                    this._init || (this.init(), this._init = !0), this._isOpen = !0, this.interactive = !0, this.interactiveChildren = !0, this.onResize(), this.show(), r.NolimitApplication.addDialog(this, !0)
                }
                shouldResize() {
                    return this._init && this._isOpen
                }
                onResize() {
                    if (this.shouldResize()) {
                        this.popUpView.isOpen && this.popUpView.resize();
                        const t = (0, n.cloneScreenBounds)(r.NolimitApplication.screenBounds);
                        this.position.set(t.left, t.top), t.height -= a.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight(), this.drawBackground();
                        const e = 59;
                        this._closeButton.position.set(t.width - this._closeButton.width - 5, e - this._closeButton.height / 2), this._closeBtnXmark.position.set(this._closeButton.x + .5 * this._closeButton.width, this._closeButton.y + .5 * this._closeButton.height - 4), this._logo.position.set(t.width / 2 - 230, e), this._label.position.set(t.width / 2 - 10, e), this._promoLabel.position.set(t.width / 2 - 8, e);
                        let i = .5 * t.width;
                        const o = this._label.width + this._promoLabel.width + this._logo.width + 14;
                        if (this._logo.position.set(i - .5 * o, e + 3), this._label.position.set(this._logo.x + this._logo.width + 14, e), this._promoLabel.position.set(this._label.x + this._label.width, e), this._topBar.position.set(t.width / 2, -5), this._navigationPanel.onResize(), this._closeButton.alpha = 1, r.NolimitApplication.isLandscape) {
                            this._topBar.visible = !1, this._logo.visible = !1, this._label.visible = !1, this._content.visible = !1, this._closeBtnXmark.visible = !0;
                            const e = 45 + .5 * this._closeBtnXmark.height - 6;
                            this._closeBtnXmark.position.set(t.width - e - 28, e + 21), this._closeButton.position.set(this._closeBtnXmark.x - .5 * this._closeButton.width, this._closeBtnXmark.y - .5 * this._closeButton.height + 5), this._hBottomLine.visible = !0, this._hBottomLine.position.set(0, t.height - 1)
                        } else this._hBottomLine.visible = !1, this._closeButton.alpha = 0, this._topBar.visible = !0, this._logo.visible = !0, this._label.visible = !0, this._content.visible = !0;
                        this._popupDarkOverlay.visible && this.drawPopupDarkOverlay()
                    }
                    r.NolimitApplication.events.trigger(f.PromoPanelEvents.ON_RESIZE), this._isLandscape != r.NolimitApplication.isLandscape && (this.onOrientationChanged(), this._isLandscape = r.NolimitApplication.isLandscape)
                }
                addBlur() {
                    this._isBlurred = !0, null == this._featureContainer.filters && (this._featureContainer.filters = []), this._featureContainer.filters.push(this._blur1, this._blur2);
                    const t = new c.TimelineLite;
                    return t.add([new c.TweenLite(this._blur1, .2, {
                        blurX: 16,
                        blurY: 16
                    }), new c.TweenLite(this._blur2, .2, {
                        blurX: 10,
                        blurY: 10
                    })]), t
                }
                removeBlur() {
                    if (this._isBlurred) {
                        const t = new c.TimelineLite({
                            onComplete: () => {
                                for (let t = this._featureContainer.filters.length - 1; t >= 0; t--) {
                                    const e = this._featureContainer.filters[t];
                                    e != this._blur1 && e != this._blur2 || this._featureContainer.filters.splice(t, 1)
                                }
                                this._isBlurred = !1
                            }
                        });
                        return t.add([new c.TweenLite(this._blur1, .2, {
                            blurX: 0,
                            blurY: 0
                        }), new c.TweenLite(this._blur2, .2, {
                            blurX: 0,
                            blurY: 0
                        })]), t
                    }
                }
                onOrientationChanged() {
                    r.NolimitApplication.events.trigger(f.PromoPanelEvents.ON_ORIENTATION_CHANGED)
                }
                show(t) {
                    const e = new c.TimelineLite;
                    return t ? (this.visible = !0, e.add(new c.TweenLite(this, t, {
                        alpha: 1,
                        ease: c.Linear.easeNone
                    })), e.add((() => {
                        this.alpha = 1
                    }))) : e.add((() => {
                        this.alpha = 1, this.visible = !0
                    })), e
                }
                hide(t) {
                    const e = new c.TimelineLite;
                    return t ? (e.add(new c.TweenLite(this, t, {
                        alpha: 0,
                        ease: c.Linear.easeNone
                    })), e.add((() => {
                        this.visible = !1
                    }))) : e.add((() => {
                        this.alpha = 0, this.visible = !1
                    })), e
                }
                createFeatureBtnPanel() {
                    this._navigationPanel = new d.NavigationPanelView(this._controller), this._promoContainer.addChild(this._navigationPanel)
                }
                createPopUpView() {
                    this._popUpView = new v.ConfirmBetPopUpView, this.addChild(this._popUpView)
                }
                createBottomWhiteLine() {
                    const t = r.NolimitApplication.screenBounds;
                    this._hBottomLine = new PIXI.Graphics, this._hBottomLine.name = "H_BOTTOM_LINE", this._hBottomLine.lineStyle(2, 16777215).moveTo(0, 0).lineTo(Math.max(t.width, t.height), 0), this._promoContainer.addChild(this._hBottomLine)
                }
                addEventListener() {
                    r.NolimitApplication.events.on(f.PromoPanelEvents.SHOW_HIDE_CLOSE_BUTTON, (t => this.showHideCloseBtn(t))), r.NolimitApplication.events.on(f.PromoPanelEvents.ON_POPUP_OPEN, (() => this.onPopUpOpen())), r.NolimitApplication.events.on(f.PromoPanelEvents.ON_POPUP_CLOSE, (() => this.onPopUpClose())), r.NolimitApplication.events.on(f.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, (t => this._closeButton.enable(t)))
                }
                showHideCloseBtn(t) {
                    this._closeBtnXmark.visible = t, this._closeButton.visible = t
                }
                onPopUpOpen() {
                    this.drawPopupDarkOverlay(), this.addBlur(), this._featureContainer.interactive = !1, this._featureContainer.interactiveChildren = !1, this._navigationPanel.interactive = !1, this._navigationPanel.interactiveChildren = !1
                }
                removePopupDarkOverlay() {
                    this._popupDarkOverlay.clear(), this._popupDarkOverlay.visible = !1, this._featureContainer.interactive = !0, this._featureContainer.interactiveChildren = !0, this._navigationPanel.interactive = !0, this._navigationPanel.interactiveChildren = !0
                }
                onPopUpClose() {
                    this.removeBlur(), this._popupDarkOverlay.visible && this.removePopupDarkOverlay()
                }
                init() {
                    this._promoContainer = new PIXI.Container, this._promoContainer.name = "PROMO_CONTAINER", this.addChild(this._promoContainer), this.createBlurFilters(), this._background = new PIXI.Sprite(PIXI.Texture.WHITE), this._background.name = "PROMO_BACKGROUND", this._content = new PIXI.Container, this._content.name = "PROMO_PANEL_VIEW_HEADING", this._featureContainer = new PIXI.Container, this._featureContainer.name = "MASTER_FEATURE_CONTAINER", this._label = new o.Label(a.NolimitPromotionPlugin.apiPlugIn.translations.translate(g.PromoPanelLabelIDs.PROMO_PANEL_HEADING + y.PromoPanelConfig.SINGLE_BLANK_SPACE), m.PromoPanelTextStyles.PROMO_PANEL_HEADING), this._label.anchor.set(0, .5), this._promoLabel = new o.Label(a.NolimitPromotionPlugin.apiPlugIn.translations.translate(g.PromoPanelLabelIDs.PROMO_PANEL_PROMOTIONS_HEADING), m.PromoPanelTextStyles.PROMO_PANEL_PROMOTIONS_HEADING), this._promoLabel.anchor.set(0, .5);
                    const t = new l.PointerStateIconSet(new h.Icon(S.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.CLOSE_BG_ICON))),
                        e = new u.PointerStateColorSet(4294967295);
                    this._closeButton = new s.IconToggleButton(_.PromoPanelButtonIDs.CLOSE, t, e), this._closeButton.addClickCallback((() => this._controller.buttonClick(this._closeButton))), this._closeButton.toggled = !1, this._closeButton.enable(!0), this._closeBtnXmark = new PIXI.Sprite(S.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.CLOSE)), this._closeBtnXmark.tint = 0, this._closeBtnXmark.anchor.set(.5, .5), this._closeBtnXmark.pivot.y = -3, this._logo = new PIXI.Sprite(S.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.NOLIMIT_PROMOTIONS_LOGO)), this._logo.anchor.set(0, .5), this._logo.pivot.y = 4, this._topBar = new PIXI.Sprite(S.ImgLoader.getImgTexture(p.PromoPanelAssetConfig.TOP_BAR)), this._topBar.width = 720, this._topBar.anchor.set(.5, 0), this._content.addChild(this._topBar, this._logo, this._promoLabel, this._label), this._promoContainer.addChild(this._background), this._popupDarkOverlay = new PIXI.Graphics, this._popupDarkOverlay.visible = !1, this._popupDarkOverlay.alpha = .4, this._promoContainer.addChild(this._featureContainer), this._promoContainer.addChild(this._popupDarkOverlay), this._promoContainer.addChild(this._content), this._promoContainer.addChild(this._closeButton, this._closeBtnXmark), this.createBottomWhiteLine(), this.createFeatureBtnPanel(), this.createPopUpView()
                }
                drawPopupDarkOverlay() {
                    const t = r.NolimitApplication.screenBounds;
                    this._popupDarkOverlay.clear(), this._popupDarkOverlay.beginFill(0), r.NolimitApplication.isLandscape ? this._popupDarkOverlay.drawRect(0, 0, t.width, t.height) : this._popupDarkOverlay.drawRect(0, 0, t.width, t.height - a.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight()), this._popupDarkOverlay.endFill(), this._popupDarkOverlay.visible = !0
                }
                createBlurFilters() {
                    this._blur1 = new PIXI.filters.BlurFilter(0, 6), this._blur1.autoFit = !0, this._blur1.repeatEdgePixels = !1, this._blur2 = new PIXI.filters.BlurFilter(0, 6), this._blur2.autoFit = !0, this._blur2.repeatEdgePixels = !1
                }
                get backgroundColor() {
                    return this._backgroundColor
                }
                set backgroundColor(t) {
                    this._backgroundColor = t, this.drawBackground()
                }
                get featureContainer() {
                    return this._featureContainer
                }
                set featureContainer(t) {
                    this._featureContainer = t
                }
                get isOpen() {
                    return this._isOpen
                }
            }
            e.PromoPanelView = b
        },
        2952: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NavigationPanelView = void 0;
            const n = i(1410),
                r = i(4514),
                o = i(4457),
                s = i(8246),
                a = i(6724),
                l = i(2408);
            class h extends PIXI.Container {
                constructor(t) {
                    super(), this._buttons = [], this._panelButton = [], this._controller = t, this._buttons = s.PromoPanelConfig.FEATURE_BTN_CONFIG, this.initAnimations()
                }
                initAnimations() {
                    this._bgLandscape = new PIXI.Sprite(l.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.NAV_BG_LANDSCAPE)), this._bgLandscape.height = 684, this._bgPortrait = new PIXI.Sprite(l.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.NAV_BG_PORTRAIT)), this._bgPortrait.width = 720, this._bgLandscape.anchor.set(.5), this._bgPortrait.anchor.set(.5), this.addChild(this._bgLandscape), this.addChild(this._bgPortrait), this._buttons.forEach(((t, e) => {
                        const i = new o.PanelButton(t, this._controller, e);
                        this.addChild(i), this._panelButton.push(i)
                    }))
                }
                onResize() {
                    const t = r.NolimitApplication.screenBounds;
                    this.getLocalBounds(), this._bgLandscape.visible = !1, this._bgPortrait.visible = !1, r.NolimitApplication.isLandscape ? (this._bgLandscape.visible = !0, this._bgLandscape.position.set(Math.floor(.5 * this._bgLandscape.width), Math.floor(.5 * this._bgLandscape.height)), this._panelButton.forEach((t => t.onResize(this._bgLandscape.position)))) : (this._bgPortrait.position.set(.5 * t.width, t.height - .5 * this._bgPortrait.height - n.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight()), this._bgPortrait.visible = !0, this.rotation = 0, this._panelButton.forEach((t => t.onResize(this._bgPortrait.position))))
                }
                show() {
                    this.visible = !0
                }
                hide() {
                    this.visible = !1
                }
            }
            e.NavigationPanelView = h
        },
        4457: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PanelButton = void 0;
            const n = i(5991),
                r = i(1410),
                o = i(3606),
                s = i(2974),
                a = i(8760),
                l = i(6724),
                h = i(4514),
                u = i(5016),
                c = i(361),
                d = i(8246),
                p = i(8680),
                f = i(2408);
            class g extends PIXI.Container {
                constructor(t, e, i) {
                    super(), this._active = !1, this.INACTIVE_COLOUR = 16777215, this._controller = e, this._index = i, this._buttonConfig = t, this._btnId = t.id, this.name = this._btnId + "_CONTAINER", this.init(), this.addEventListener()
                }
                addEventListener() {
                    h.NolimitApplication.events.on(u.PromoPanelEvents.DISABLE_ALL_NAV_BUTTON, (() => this.setInActive())), h.NolimitApplication.events.on(u.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.setActive(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.DISABLE_NAV_BUTTON, (t => this.disable(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.ENABLE_NAV_BUTTON, (t => this.enable(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.HIDE_NAV_BUTTON, (t => this.hide(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.SHOW_NAV_BUTTON, (t => this.show(t))), h.NolimitApplication.events.on(u.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, (t => this.toggleButton(t)))
                }
                toggleButton(t) {
                    this._btn.enable(!this._buttonConfig.isDisabled && t)
                }
                hide(t) {
                    t == this._btnId && (this.alpha = 0)
                }
                show(t) {
                    t == this._btnId && (this.alpha = 1)
                }
                setInActive() {
                    this.active = !1
                }
                setActive(t) {
                    this.active = this._btnId == t
                }
                disable(t) {
                    t ? t == this._btnId && this.disable() : (this._btn.enable(!1), this._btn.alpha = d.PromoPanelConfig.DISABLE_BTN_ALPHA)
                }
                enable(t) {
                    t ? t == this._btnId && this.enable() : (this._btn.enable(!0), this._btn.alpha = d.PromoPanelConfig.ENABLE_BTN_ALPHA)
                }
                enableButton(t) {
                    this.active = this._btnId == t
                }
                createButton() {
                    const t = new o.PointerStateColorSet(4294967295);
                    let e;
                    switch (this._btnId) {
                        case c.PromoPanelButtonIDs.NOLIMIT_BONUS:
                            e = new s.PointerStateIconSet(new a.Icon(f.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_BONUS)));
                            break;
                        case c.PromoPanelButtonIDs.NOLIMIT_WINNERS:
                            e = new s.PointerStateIconSet(new a.Icon(f.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_WINNERS)), void 0, void 0, new a.Icon(f.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_WINNERS_DISABLED)));
                            break;
                        case c.PromoPanelButtonIDs.ACTION_SPINS:
                            e = new s.PointerStateIconSet(new a.Icon(f.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_ACTION_SPINS)));
                            break;
                        case c.PromoPanelButtonIDs.VOUCHER:
                            e = new s.PointerStateIconSet(new a.Icon(f.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_VOUCHER_DISABLED)));
                            break;
                        default:
                            e = new s.PointerStateIconSet, p.Logger.warn("Btn id not available")
                    }
                    this._btn = new n.IconToggleButton(this._btnId, e, t), this._btn.addClickCallback((() => this._controller.buttonClick(this._btn))), this._buttonConfig.isDisabled ? this.disable() : this.enable(), this._buttonConfig.shouldHide && this.hide(this._btnId), this.addChild(this._btn), this.position.set(this.width / 2, this.height / 2), this.pivot.set(this.width / 2, this.height / 2)
                }
                createHighlightLine() {
                    this._activeHighlightLine = new PIXI.Sprite(r.NolimitPromotionPlugin.imgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_ACTIVE)), this._activeHighlightLine.tint = this.INACTIVE_COLOUR, this._activeHighlightLine.anchor.set(.5, .5), this.addChild(this._activeHighlightLine), this._activeHighlightLine.position.set(this.x, this.y)
                }
                init() {
                    this.createButton(), this.createHighlightLine(), this.pivot.set(this.width / 2, this.height / 2)
                }
                onResize(t) {
                    const e = h.NolimitApplication.screenBounds,
                        i = f.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.NAV_NOLIMIT_BONUS).width;
                    let n = .2 * (e.width - 4 * i);
                    h.NolimitApplication.isLandscape ? (n = .2 * (e.height - r.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 4 * i), this.position.set(t.x, (n + i / 2) * (this._index + 1) + i / 2 * this._index)) : (this.rotation = 0, this.position.set((n + i / 2) * (this._index + 1) + i / 2 * this._index, t.y + 20))
                }
                get active() {
                    return this._active
                }
                set active(t) {
                    this._activeHighlightLine.tint = t ? this._buttonConfig.viewBackgroundColor : this.INACTIVE_COLOUR, this._activeHighlightLine.visible = t, this._active = t
                }
            }
            e.PanelButton = g
        },
        6840: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Communication = void 0;
            const n = i(9034),
                r = i(3135),
                o = i(1410),
                s = i(8246),
                a = i(7185);
            e.Communication = class {
                constructor(t) {
                    this._replayBaseUrl = n.ReplayURLConfig.BASE_URL_DEFAULT, t.events.once(a.APIEvent.REPLAY_BASE_URL, (t => {
                        this._replayBaseUrl = t
                    }))
                }
                getTopXBetData(t) {
                    return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_X_BET_URL + this.getOperatorURL(t))
                }
                getTopMonetaryData(t) {
                    return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_MONETARY_URL + this.getOperatorURL(t))
                }
                getXBetGameSpecificData(t, e) {
                    return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_X_BET_URL + this.getOperatorURL(e) + n.ReplayURLConfig.GAME_SPECIFIC_URL + t)
                }
                getMonetaryGameSpecificData(t, e) {
                    return this.connect(this.getBaseURL() + n.ReplayURLConfig.TOP_MONETARY_URL + this.getOperatorURL(e) + n.ReplayURLConfig.GAME_SPECIFIC_URL + t)
                }
                getTopListAnyGame(t) {
                    return o.NolimitPromotionPlugin.apiPlugIn.communication.history.topListAnyGame(t)
                }
                getTopListCurrentGame(t) {
                    return o.NolimitPromotionPlugin.apiPlugIn.communication.history.topListCurrentGame(t)
                }
                createXMLHttpRequest(t) {
                    const e = new XMLHttpRequest;
                    return e.open(r.RequestMethod.GET, t, !0), e.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8"), e.setRequestHeader("Accept", "application/json"), e
                }
                connect(t) {
                    return new Promise(((e, i) => {
                        const n = this.createXMLHttpRequest(t);
                        n.onload = () => {
                            const t = JSON.parse(n.responseText);
                            t.error ? i(t.error) : Object.keys(t).length ? e(t) : i(n.responseText)
                        }, n.send()
                    }))
                }
                getOperatorURL(t) {
                    return t ? n.ReplayURLConfig.OPERATOR_SPECIFIC_URL + t : s.PromoPanelConfig.EMPTY_STRING
                }
                getBaseURL() {
                    return this._replayBaseUrl + n.ReplayURLConfig.BASE_PATH
                }
            }
        },
        4071: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetDisplay = void 0;
            const n = i(1057),
                r = i(7886),
                o = i(5892);
            class s extends PIXI.Container {
                constructor(t, e, i = "") {
                    super();
                    const s = new PIXI.Container,
                        a = new n.Label(t, r.PromoPanelTextStyles.BET_PANEL_BET_LABEL);
                    if (s.addChild(a), e && "" != e) {
                        const t = new n.Label(e, r.PromoPanelTextStyles.BET_PANEL_CURRENCY_LABEL);
                        t.position.set(a.width, 0), s.addChild(t)
                    }
                    s.pivot.set(.5 * s.width, 0), this._valueLabel = new o.PromoPanelTextLabel(i, r.PromoPanelTextStyles.BET_PANEL_BET_STYLE, {
                        landscapeMaxWidth: 268,
                        portraitMaxWidth: 268
                    }), this._valueLabel.anchor.set(.5, 0), this._valueLabel.position.set(0, a.height), this.addChild(s), this.addChild(this._valueLabel)
                }
                setValue(t) {
                    this._valueLabel.value = t
                }
                resize() {
                    this._valueLabel.onResize()
                }
            }
            e.BetDisplay = s
        },
        5023: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetPanelView = void 0;
            const n = i(4514),
                r = i(1410),
                o = i(6724),
                s = i(1219),
                a = i(2408),
                l = i(4071),
                h = i(7032),
                u = i(2379);
            class c extends PIXI.Container {
                constructor(t, e, i, r) {
                    super(), this._formatValueAsCurrency = !0, this._betBackground = new PIXI.NineSlicePlane(a.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.BET_PANEL_BG), 16, 16, 16, 16), this._betBackground.tint = r, this._betBackground.alpha = .8, this._betDisplay = this.createBetDisplay(), this._betSelector = this.createBetSelector(t, e, i), this.addChild(this._betBackground), this.addChild(this._betDisplay, this._betSelector), this.resize(n.NolimitApplication.isLandscape)
                }
                get betDisplay() {
                    return this._betDisplay
                }
                get betSelector() {
                    return this._betSelector
                }
                setBackgroundAlpha(t) {
                    this._betBackground.alpha = t
                }
                resize(t) {
                    t ? (this.setBackgroundSize(280, 264), this._betDisplay.position.set(.5 * this._betBackground.width, 34), this._betSelector.position.set(.5 * this._betBackground.width, 188)) : (this.setBackgroundSize(633, 153), this._betDisplay.position.set(.5 * this._betBackground.width - 170, 31), this._betSelector.position.set(.5 * this._betBackground.width + 170, 77)), this._betDisplay.resize()
                }
                setValue(t) {
                    this._value = t, this._formatValueAsCurrency ? this._betDisplay.setValue(u.CurrencyUtils.formatWithDecimalCutOff(this._value)) : this._betDisplay.setValue("" + t)
                }
                getValue() {
                    return this._value
                }
                setBackgroundSize(t, e) {
                    this._betBackground.width = t, this._betBackground.height = e
                }
                createBetDisplay() {
                    return new l.BetDisplay(r.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.BET))
                }
                createBetSelector(t, e, i) {
                    return new h.PlusMinusWidget(t, e, i)
                }
            }
            e.BetPanelView = c
        },
        8987: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FeatureBuyTicket = void 0;
            const n = i(1057),
                r = i(5991),
                o = i(1410),
                s = i(6724),
                a = i(3606),
                l = i(2974),
                h = i(8760),
                u = i(1219),
                c = i(7886),
                d = i(361),
                p = i(8246),
                f = i(5892),
                g = i(2408),
                m = i(2379);
            class _ extends PIXI.Container {
                get price() {
                    return this._price
                }
                set price(t) {
                    this._price = +t.toFixed(2)
                }
                get allowedByOptions() {
                    return this._allowedByOptions
                }
                set allowedByOptions(t) {
                    this._allowedByOptions = t
                }
                get featureData() {
                    return this._featureData
                }
                get nextBetPrice() {
                    return this._nextBetPrice
                }
                set totalCost(t) {
                    this._totalCost = t;
                    const e = m.CurrencyUtils.formatWithDecimalCutOff(t);
                    this._priceLabel.value = e
                }
                constructor(t, e, i) {
                    super(), this._allowedByOptions = !0, this._isExceededBetLimit = !0, this._buyButtonCallback = e, this._featureData = t, this._maxBetLevel = t.getMaxBet(), this.init(i)
                }
                updateButtons() {
                    const t = o.NolimitPromotionPlugin.apiPlugIn.balance.getAmount();
                    this._price > t || o.NolimitPromotionPlugin.isFreeBet || this._isExceededBetLimit || !this._allowedByOptions ? (this._buyButton.enable(!1), this._buyButton.alpha = p.PromoPanelConfig.DISABLE_BTN_ALPHA, this._buyLabel.setStyle(c.PromoPanelTextStyles.GAME_FEATURE_BUY_TEXT_DISABLED)) : (this._buyButton.enable(!0), this._buyButton.alpha = p.PromoPanelConfig.ENABLE_BTN_ALPHA, this._buyLabel.setStyle(c.PromoPanelTextStyles.GAME_FEATURE_BUY_TEXT))
                }
                resize(t) {
                    this.scale.set(1), this._priceLabel.onResize(), this._buyLabel.onResize()
                }
                createCostLabels() {
                    const t = new PIXI.Container,
                        e = new PIXI.Container,
                        i = new n.Label(o.NolimitPromotionPlugin.apiPlugIn.translations.translate(u.PromoPanelLabelIDs.BUY_FEATURE_COST), c.PromoPanelTextStyles.GAME_FEATURE_COST_TEXT);
                    return e.addChild(i), e.pivot.set(.5 * e.width, 0), this._priceLabel = new f.PromoPanelTextLabel("", c.PromoPanelTextStyles.GAME_FEATURE_PRICE_STYLE, {
                        landscapeMaxWidth: 190,
                        portraitMaxWidth: 190
                    }), this._priceLabel.anchor.set(.5, 0), this._priceLabel.position.set(0, i.height + 5), t.addChild(e), t.addChild(this._priceLabel), t
                }
                updatePrice(t, e = 1) {
                    this.totalCost = +t * this._featureData.price * e, this.price = +t * this._featureData.price, this._isExceededBetLimit = +t > this._maxBetLevel, this.updateButtons()
                }
                updateNextBetPrice(t, e = 1) {
                    this._nextBetPrice = +t * this._featureData.price * e
                }
                init(t) {
                    const e = new PIXI.Sprite(g.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.TICKET)),
                        i = this.createCostLabels();
                    i.position.set(115, 40);
                    const n = new a.PointerStateColorSet(4294967295);
                    let p = new l.PointerStateIconSet(new h.Icon(t));
                    this._buyButton = new r.IconToggleButton(d.PromoPanelButtonIDs.BUY, p, n), this._buyButton.addClickCallback((() => {
                        this._buyButtonCallback(this._buyButton, this._featureData)
                    })), this._buyButton.toggled = !1, this._buyButton.enable(!1), this._buyButton.position.set(19, 140), this._buyLabel = new f.PromoPanelTextLabel(o.NolimitPromotionPlugin.apiPlugIn.translations.translate(u.PromoPanelLabelIDs.BUY), c.PromoPanelTextStyles.GAME_FEATURE_BUY_TEXT, {
                        landscapeMaxWidth: this._buyButton.width - 30,
                        portraitMaxWidth: this._buyButton.width - 30
                    }), this._buyLabel.position.set(.5 * this._buyButton.width, 38), this._buyLabel.anchor.set(.5, .5), this._buyButton.addChild(this._buyLabel);
                    const m = new PIXI.Graphics;
                    m.clear(), m.beginFill(16711680, 1), m.drawRect(0, 0, s.PromoPanelAssetConfig.GAME_FEATURE_MASK_WIDTH, e.height - 13), m.pivot.set(s.PromoPanelAssetConfig.GAME_FEATURE_MASK_WIDTH / 2, 0), m.position.set(440, 3);
                    const _ = new PIXI.Sprite(g.ImgLoader.getImgTexture(this._featureData.name));
                    _.anchor.set(.5, .5), _.position.set(440, m.y + .5 * m.height), _.mask = m, this.addChild(e, _, i, this._buyButton, m)
                }
            }
            e.FeatureBuyTicket = _
        },
        7032: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PlusMinusWidget = void 0;
            const n = i(3606),
                r = i(2974),
                o = i(8760),
                s = i(6724),
                a = i(5991),
                l = i(2408),
                h = i(8246);
            class u extends PIXI.Container {
                constructor(t, e, i) {
                    super();
                    const h = new n.PointerStateColorSet(4294967295),
                        u = new r.PointerStateIconSet(new o.Icon(l.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.BET_UP)));
                    this._upButton = new a.IconToggleButton(t, u, h), this._upButton.addClickCallback((() => i(this._upButton))), this._upButton.toggled = !1, this._upButton.pivot.set(38, 35), this._upButton.position.set(62, 0);
                    const c = new PIXI.Sprite(PIXI.Texture.WHITE);
                    c.width = 2, c.height = 66, c.anchor.set(.5, .5), c.alpha = .5, c.roundPixels = !0;
                    const d = new r.PointerStateIconSet(new o.Icon(l.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.BET_DOWN)));
                    this._downButton = new a.IconToggleButton(e, d, h), this._downButton.addClickCallback((() => i(this._downButton))), this._downButton.toggled = !1, this._downButton.pivot.set(38, 35), this._downButton.position.set(-62, 0), this.addChild(this._upButton, c, this._downButton)
                }
                enableUpButton(t) {
                    this._upButton.enable(t), this._upButton.alpha = t ? h.PromoPanelConfig.ENABLE_BTN_ALPHA : h.PromoPanelConfig.DISABLE_BTN_ALPHA
                }
                enableDownButton(t) {
                    this._downButton.enable(t), this._downButton.alpha = t ? h.PromoPanelConfig.ENABLE_BTN_ALPHA : h.PromoPanelConfig.DISABLE_BTN_ALPHA
                }
            }
            e.PlusMinusWidget = u
        },
        6724: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelAssetConfig = e.PromoAsset = e.PromoPanelAsset = void 0, e.PromoPanelAsset = class {
                constructor(t, e, i, r) {
                    this.name = t, this.url = r || n.makeAssetPath(t), this.height = e, this.width = i
                }
            };
            class i {
                constructor(t, e) {
                    this.name = t, this.url = e || n.makeAssetPath(t)
                }
            }
            e.PromoAsset = i;
            class n {
                static getIntroAssets() {
                    return [new i(n.INTRO_NOLIMIT_WINNERS), new i(n.INTRO_NOLIMIT_BONUS_PRICE_TAG), new i(n.INTRO_NOLIMIT_BONUS_TICKET), new i(n.INTRO_NO_LIMIT_PROMOTIONS_TAB), new i(n.INTRO_ACTION_SPINS)]
                }
                static getNolimitBonusAssets() {
                    return [new i(n.BET_DOWN), new i(n.BET_UP), new i(n.BET_PANEL_BG), new i(n.BUY_BTN), new i(n.TICKET)]
                }
                static getNavigationAssets() {
                    return [new i(n.NAV_ACTIVE), new i(n.NAV_NOLIMIT_BONUS), new i(n.NAV_NOLIMIT_WINNERS), new i(n.NAV_NOLIMIT_WINNERS_DISABLED), new i(n.NAV_ACTION_SPINS), new i(n.NAV_VOUCHER_DISABLED), new i(n.CLOSE), new i(n.CLOSE_BG_ICON), new i(n.NAV_BG_LANDSCAPE), new i(n.NAV_BG_PORTRAIT), new i(n.NOLIMIT_PROMOTIONS_LOGO), new i(n.TOP_BAR)]
                }
                static getActionSpinsAssets() {
                    return [new i(n.ACTION_SPINS_OPTIONS_BUTTON_MASK), new i(n.ACTION_SPINS_OPTIONS_BUTTON_ACTIVE), new i(n.ACTION_SPINS_OPTIONS_BUTTON_INACTIVE), new i(n.ACTION_SPINS_OPTIONS_BUTTON_OUTLINE), new i(n.ACTION_SPINS_OPTIONS_BUTTON_PLATE), new i(n.ACTION_SPINS_BUY_BTN), new i(n.ACTION_SPINS_GAME_CHECK_BOX_INACTIVE), new i(n.ACTION_SPINS_GAME_CHECK_BOX_ACTIVE), new i(n.ACTION_SPINS_SETTING_BTN), new i(n.ACTION_SPINS_PICK_POPUP_OPTION_ACTIVE), new i(n.ACTION_SPINS_PICK_POPUP_OPTION_IN_ACTIVE), new i(n.ACTION_SPINS_PICK_POPUP_MASK), new i(n.ACTION_SPINS_MENU_BET), new i(n.ACTION_SPINS_REPLAY_MENU_TOTAL_BET), new i(n.ACTION_SPINS_REPLAY_MENU_WIN), new i(n.ACTION_SPINS_REPLAY_MENU_PROFIT), new i(n.ACTION_SPINS_BTN_PLAY), new i(n.ACTION_SPINS_BTN_PAUSE), new i(n.ACTION_SPINS_REPLAY_FEED_BG), new i(n.ACTION_SPINS_REPLAY_BG_LANDSCAPE), new i(n.ACTION_SPINS_REPLAY_GAME_REPLAY_BTN), new i(n.ACTION_SPINS_REPLAY_GAME_REPLAY_DISABLED_BTN), new i(n.ACTION_SPINS_GAME_PLAY_BTN), new i(n.GAME_FEED_OK), new i(n.GAME_FEED_CANCEL), new i(n.ACTION_SPINS_GAME_CONTINUE), new i(n.ACTION_SPINS_GAME_CONTINUE_SMALL), new i(n.ACTION_SPINS_REPLAY_GAME_EXPAND), new i(n.ACTION_SPINS_REPLAY_INFO_BG_LANDSCAPE), new i(n.ACTION_SPINS_REPLAY_INFO_BG), new i(n.ACTION_SPINS_REPLAY_INFO_BG_SMALL), new i(n.ACTION_SPINS_SORT_ARROW_RIGHT), new i(n.ACTION_SPINS_SORT_ARROW_DOWN)]
                }
                static getActionSpinsGameFeedAssets() {
                    return [new i(n.BONUS_ROUND_OUTLINE), new i(n.ACTION_SPINS_ROUNDS_NUMBER_BG), new i(n.ACTION_SPINS_PLAYED_ROUNDS_BG), new i(n.GAME_FEED_BONUS_INFO_BG), new i(n.BONUS_ROUND_BONUS_SUMMARY)]
                }
                static getCommonAssets() {
                    return [new i(n.GAME_TYPE_INACTIVE), new i(n.GAME_TYPE_ACTIVE), new i(n.NOLIMIT_BONUS_ICON), new i(n.ACTION_SPINS_ICON), new i(n.BUTTON_PLATE_20), new i(n.BUTTON_STROKE_20), new i(n.NOLIMIT_WINNERS_ICON), new i(n.LOADING_CIRCLE), new i(n.POP_UP_BG)]
                }
                static getNolimitWinnersAssets() {
                    return [new i(n.ALL_PLAYER_INACTIVE), new i(n.ALL_PLAYER_ACTIVE), new i(n.PLAYER_ACTIVE), new i(n.PLAYER_INACTIVE), new i(n.ROUND_INFO_BONUS_BUY_ICON), new i(n.ROUND_INFO_ACTION_SPINS_ICON), new i(n.REPLAY_BUTTON), new i(n.TROPHY_BRONZE), new i(n.TROPHY_GOLD), new i(n.TROPHY_SILVER), new i(n.INFO_BG), new i(n.REPLAY_WIN_BUTTON), new i(n.REPLAY_WIN_BUTTON_ACTIVE)]
                }
                static getIconResourcePath() {
                    return "/node_modules/@nolimit/promo-panel/resources/default/"
                }
                static getGameResourcePath() {
                    return "/nolimit/promo-panel/"
                }
                static getGameResourcePathForActionSpins() {
                    return "/nolimit/promo-panel/action-spins/"
                }
                static makeAssetPath(t) {
                    return n.getIconResourcePath() + "icons/" + t
                }
                static getConfigs() {
                    return []
                }
            }
            n.NOLIMIT_BONUS_ICON = "nolimitBonus/nolimitBonusIcon@2x.png", n.ACTION_SPINS_ICON = "nolimitActionSpins/actionSpinsIcon@2x.png", n.NOLIMIT_WINNERS_ICON = "nolimitWinners/nolimitWinnersIcon@2x.png", n.GAME_TYPE_INACTIVE = "common/gameTypeInactive@2x.png", n.GAME_TYPE_ACTIVE = "common/gameTypeActive@2x.png", n.BUTTON_PLATE_20 = "buttonPlate20@2x.png", n.BUTTON_STROKE_20 = "buttonStroke20@2x.png", n.LOADING_CIRCLE = "loadingCircle@2x.png", n.ALL_PLAYER_INACTIVE = "nolimitWinners/allPlayerInactive@2x.png", n.POP_UP_BG = "nolimitBonus/popUpBackground@2x.png", n.INTRO_NOLIMIT_WINNERS = "introSplash/introSplashPrize@2x.png", n.INTRO_NOLIMIT_BONUS_PRICE_TAG = "introSplash/introSplashxBet@2x.png", n.INTRO_NOLIMIT_BONUS_TICKET = "introSplash/introSplashTicket@2x.png", n.INTRO_NO_LIMIT_PROMOTIONS_TAB = "introSplash/nolimitPromotionsTab@2x.png", n.INTRO_ACTION_SPINS = "introSplash/introSplashActionSpins@2x.png", n.BET_DOWN = "nolimitBonus/betDown@2x.png", n.BET_UP = "nolimitBonus/betUp@2x.png", n.BET_PANEL_BG = "nolimitBonus/betPanelBackground@2x.png", n.BUY_BTN = "nolimitBonus/buyBtn@2x.png", n.TICKET = "nolimitBonus/ticket@2x.png", n.NAV_ACTIVE = "navigation/navActive@2x.png", n.NAV_NOLIMIT_BONUS = "navigation/featureIcons/navNolimitBonus@2x.png", n.NAV_NOLIMIT_WINNERS = "navigation/featureIcons/navNolimitWinners@2x.png", n.NAV_NOLIMIT_WINNERS_DISABLED = "navigation/featureIcons/navNolimitWinnersDisabled@2x.png", n.NAV_ACTION_SPINS = "navigation/featureIcons/navActionSpins@2x.png", n.NAV_VOUCHER_DISABLED = "navigation/featureIcons/navVoucherDisabled@2x.png", n.CLOSE = "navigation/close@2x.png", n.CLOSE_BG_ICON = "navigation/closeBg@2x.png", n.NOLIMIT_PROMOTIONS_LOGO = "navigation/nolimitPromotion@2x.png", n.NAV_BG_LANDSCAPE = "navigation/navBarLandscape@2x.png", n.NAV_BG_PORTRAIT = "navigation/navBarPortrait@2x.png", n.TOP_BAR = "navigation/topBar@2x.png", n.ACTION_SPINS_BUY_BTN = "nolimitActionSpins/buyBtn@2x.png", n.ACTION_SPINS_GAME_CHECK_BOX_INACTIVE = "nolimitActionSpins/checkBoxInactive@2x.png", n.ACTION_SPINS_GAME_CHECK_BOX_ACTIVE = "nolimitActionSpins/checkBoxActive@2x.png", n.ACTION_SPINS_SETTING_BTN = "nolimitActionSpins/settings@2x.png", n.ACTION_SPINS_PICK_POPUP_OPTION_ACTIVE = "nolimitActionSpins/optionActive@2x.png", n.ACTION_SPINS_PICK_POPUP_OPTION_IN_ACTIVE = "nolimitActionSpins/optionInactive@2x.png", n.ACTION_SPINS_PICK_POPUP_MASK = "nolimitActionSpins/popUpChoice@2x.png", n.ACTION_SPINS_MENU_BET = "nolimitActionSpins/gameFeed/menuBet@2x.png", n.ACTION_SPINS_REPLAY_MENU_TOTAL_BET = "nolimitActionSpins/gameFeed/menuTotalBet@2x.png", n.ACTION_SPINS_REPLAY_MENU_WIN = "nolimitActionSpins/gameFeed/menuWin@2x.png", n.ACTION_SPINS_REPLAY_MENU_PROFIT = "nolimitActionSpins/gameFeed/menuProfit@2x.png", n.ACTION_SPINS_BTN_PLAY = "nolimitActionSpins/gameFeed/play@2x.png", n.ACTION_SPINS_BTN_PAUSE = "nolimitActionSpins/gameFeed/pause@2x.png", n.ACTION_SPINS_REPLAY_FEED_BG = "nolimitActionSpins/gameFeed/gameFeedBg@2x.png", n.ACTION_SPINS_REPLAY_BG_LANDSCAPE = "nolimitActionSpins/gameFeed/gameFeedBgLandscape@2x.png", n.ACTION_SPINS_REPLAY_GAME_REPLAY_BTN = "nolimitActionSpins/gameFeed/gameReplay@2x.png", n.ACTION_SPINS_REPLAY_GAME_REPLAY_DISABLED_BTN = "nolimitActionSpins/gameFeed/gameReplayDisabled@2x.png", n.ACTION_SPINS_GAME_PLAY_BTN = "nolimitActionSpins/gameFeed/gamePlay@2x.png", n.GAME_FEED_OK = "nolimitActionSpins/gameFeed/ok@2x.png", n.GAME_FEED_CANCEL = "nolimitActionSpins/gameFeed/cancel@2x.png", n.ACTION_SPINS_GAME_CONTINUE = "nolimitActionSpins/gameFeed/gameContinue@2x.png", n.ACTION_SPINS_GAME_CONTINUE_SMALL = "nolimitActionSpins/gameFeed/gameContinueSmall@2x.png", n.ACTION_SPINS_REPLAY_GAME_EXPAND = "nolimitActionSpins/gameFeed/gameExpand@2x.png", n.ACTION_SPINS_REPLAY_INFO_BG_LANDSCAPE = "nolimitActionSpins/gameFeed/infoBarLandscape@2x.png", n.ACTION_SPINS_REPLAY_INFO_BG = "nolimitActionSpins/gameFeed/infoBarBg@2x.png", n.ACTION_SPINS_REPLAY_INFO_BG_SMALL = "nolimitActionSpins/gameFeed/infoBarBgSmall@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_MASK = "nolimitActionSpins/gameOptionMask@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_ACTIVE = "nolimitActionSpins/gameOptionActive@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_INACTIVE = "nolimitActionSpins/gameOptionInactive@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_OUTLINE = "nolimitActionSpins/gameOptionOutline@2x.png", n.ACTION_SPINS_OPTIONS_BUTTON_PLATE = "nolimitActionSpins/gameOptionPlate@2x.png", n.ACTION_SPINS_SORT_ARROW_RIGHT = "nolimitActionSpins/gameFeed/sortArrowRight@2x.png", n.ACTION_SPINS_SORT_ARROW_DOWN = "nolimitActionSpins/gameFeed/sortArrowDown@2x.png", n.BONUS_ROUND_OUTLINE = "nolimitActionSpins/gameFeed/bonusOutline@2x.png", n.ACTION_SPINS_ROUNDS_NUMBER_BG = "nolimitActionSpins/gameFeed/spinNumberBg@2x.png", n.ACTION_SPINS_PLAYED_ROUNDS_BG = "nolimitActionSpins/gameFeed/playedRoundsBg@2x.png", n.GAME_FEED_BONUS_INFO_BG = "nolimitActionSpins/gameFeed/bonusInfoBg@2x.png", n.BONUS_ROUND_BONUS_SUMMARY = "nolimitActionSpins/gameFeed/lineBonusSummary@2x.png", n.ALL_PLAYER_ACTIVE = "nolimitWinners/allPlayersActive@2x.png", n.PLAYER_ACTIVE = "nolimitWinners/playerActive@2x.png", n.PLAYER_INACTIVE = "nolimitWinners/playerInactive@2x.png", n.ROUND_INFO_BONUS_BUY_ICON = "nolimitWinners/nolimitWinners_bonusIcon@2x.png", n.ROUND_INFO_ACTION_SPINS_ICON = "nolimitWinners/nolimitWinners_actionSpinsIcon@2x.png", n.REPLAY_BUTTON = "nolimitWinners/replayButton@2x.png", n.TROPHY_BRONZE = "nolimitWinners/trophyBronze@2x.png", n.TROPHY_GOLD = "nolimitWinners/trophyGold@2x.png", n.TROPHY_SILVER = "nolimitWinners/trophySilver@2x.png", n.INFO_BG = "nolimitWinners/infoBg@2x.png", n.REPLAY_WIN_BUTTON = "nolimitWinners/winBetBtn@2x.png", n.REPLAY_WIN_BUTTON_ACTIVE = "nolimitWinners/winBetBtnActive@2x.png", n.BET_PANEL_HEIGHT = 165, n.NO_LIMIT_PROMOTIONS_HEIGHT = 60, n.BET_BG_WIDTH = 632, n.GAME_FEATURE_MASK_WIDTH = 342, e.PromoPanelAssetConfig = n
        },
        8246: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Mode = e.PromoPanelConfig = void 0;
            const n = i(361);
            class r { }
            var o;
            r.DISABLE_BTN_ALPHA = .4, r.ENABLE_BTN_ALPHA = 1, r.PROMO_PANEL_BTN_PANEL_HEIGHT = 150, r.FEATURE_BTN_CONFIG = [{
                id: n.PromoPanelButtonIDs.NOLIMIT_BONUS,
                isDefault: !0,
                isDisabled: !1,
                shouldHide: !1,
                shouldReAligned: !1,
                viewBackgroundColor: 15608146
            }, {
                id: n.PromoPanelButtonIDs.ACTION_SPINS,
                isDefault: !0,
                isDisabled: !1,
                shouldHide: !1,
                shouldReAligned: !1,
                viewBackgroundColor: 16695822
            }, {
                id: n.PromoPanelButtonIDs.NOLIMIT_WINNERS,
                isDefault: !0,
                isDisabled: !1,
                shouldHide: !1,
                shouldReAligned: !1,
                viewBackgroundColor: 6857945
            }, {
                id: n.PromoPanelButtonIDs.VOUCHER,
                isDefault: !1,
                isDisabled: !0,
                shouldHide: !1,
                shouldReAligned: !1,
                viewBackgroundColor: 16711680
            }], r.FEATURE_SCROLL_MASK_HEIGHT_PORTRAIT = 978, r.GAME_NAME_FILTER_REG_EXP = /\s/g, r.DEFAULT_SCREEN_RATIO = 1280 / 720, r.SINGLE_BLANK_SPACE = " ", r.NO_DECIMALS_CUTOFF_POINT = 10, r.DEFAULT_SCREEN_MIN_RATIO = 1.61, r.TEXT_LABEL_DRAW_BORDER = !1, r.DEFAULT_LARGE_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 144, 76), r.DEFAULT_SMALL_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 216, 72), r.AS_SETTING_POPUP_OK_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 216, 98), r.FEATURE_FILTER_LIST = ["FREESPIN", "FEATURE_BUY"], r.DATE_SEPARATOR = "-", r.NOT_AVAILABLE = "n/a", r.NO_TEXT = "No", r.YES_TEXT = "Yes", r.EMPTY_STRING = "", r.DECIMAL_CUTOFF = 2, r.JPG_FORMAT = ".jpg", e.PromoPanelConfig = r, (o = e.Mode || (e.Mode = {})).NORMAL = "NORMAL", o.RESPIN = "RESPIN", o.FREESPIN = "FREESPIN", o.SUPER_FREESPIN = "SUPERFREESPIN"
        },
        7886: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelTextStyles = void 0;
            const n = i(5383),
                r = i(1653),
                o = i(9756);
            class s { }
            s.FEATURE_BASE_PANEL_TITLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 50,
                fontStyle: n.FontStyle.ITALIC,
                fontWeight: n.FontWeight.SEMI_BOLD,
                padding: 50
            }), s.FEATURE_BASE_BUY_FEATURE_TITLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 50,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                dropShadow: !0,
                dropShadowAngle: -1,
                dropShadowDistance: -3,
                dropShadowColor: "#b62449",
                padding: 50
            }), s.FEATURE_BASE_REPLAY_TITLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 50,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                dropShadow: !0,
                dropShadowAngle: -1,
                dropShadowDistance: -3,
                dropShadowColor: "#4588c8",
                padding: 59
            }), s.FEATURE_ACTION_SPIN_REPLAY_TITLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 50,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                dropShadow: !0,
                dropShadowAngle: -1,
                dropShadowDistance: -3,
                dropShadowColor: "#f57f20",
                padding: 59
            }), s.BET_PANEL_BET_LABEL = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.BET_PANEL_CURRENCY_LABEL = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD
            }), s.BET_PANEL_BET_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 55,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.BET_PANEL_SEPARATOR_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 65,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.POP_UP_FEATURE_TEXT = new PIXI.TextStyle({
                fill: "#367fff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 42,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.AS_BONUS_SELECTION_POP_UP_GAME_NAME_TEXT = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 35,
                fontStyle: n.FontStyle.ITALIC,
                fontWeight: n.FontWeight.SEMI_BOLD,
                padding: 10
            }), s.AS_POP_UP_HEADER_TEXT = new PIXI.TextStyle({
                fill: "#00b786",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 28,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                align: "center"
            }), s.AS_POP_UP_CONTENT_TEXT = new PIXI.TextStyle({
                fill: "#B7B7B7",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                wordWrap: !0,
                align: "center"
            }), s.AS_POPUP_OK_TEXT = new PIXI.TextStyle({
                fill: "#FFFFFF",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 32,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD,
                padding: 59
            }), s.AS_BONUS_SELECTION_POP_UP_MAIN_GAME_TEXT = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR
            }), s.AS_BONUS_SELECTION_PICK_LABEL = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR
            }), s.POP_UP_HLINE = new PIXI.TextStyle({
                fill: "#367fff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 42,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.NORMAL
            }), s.POP_UP_FORMATTED_PRICE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.POP_UP_CHARGE_FROM_WALLET_TEXT = new PIXI.TextStyle({
                fill: "#686868",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.ACTION_SPINS_SETTINGS_HEADER = new PIXI.TextStyle({
                fill: "#000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 35,
                fontStyle: n.FontStyle.ITALIC,
                fontWeight: n.FontWeight.SEMI_BOLD,
                padding: 10
            }), s.ACTION_SPINS_SETTINGS_MAIN_GAME_HEADER = new PIXI.TextStyle({
                fill: "#000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR,
                padding: 10
            }), s.ACTION_SPINS_MAIN_GAME_LABEL = new PIXI.TextStyle({
                fill: "#f78d1d",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL
            }), s.ACTION_SPINS_STOP_ON_BONUS_LABEL = new PIXI.TextStyle({
                fill: "#f78d1d",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 26,
                fontStyle: n.FontStyle.NORMAL
            }), s.ACTION_SPINS_OPTIONS_TITLE = new PIXI.TextStyle({
                fill: "#f78d1d",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 26,
                fontStyle: n.FontStyle.NORMAL
            }), s.ACTION_SPINS_OPTIONS_VALUE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 26,
                fontStyle: n.FontStyle.NORMAL,
                dropShadow: !0,
                dropShadowAngle: -1,
                dropShadowColor: "#f78d1d",
                dropShadowDistance: -2,
                padding: 5
            }), s.AS_REPLAY_NUMBER_TEXT_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 26,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD
            }), s.GAME_FEATURE_CURRANCY_STYLE = new PIXI.TextStyle({
                fill: "#a76f00",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD
            }), s.GAME_FEATURE_PRICE_STYLE = new PIXI.TextStyle({
                fill: "#a76f00",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 35,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.GAME_FEATURE_COST_TEXT = new PIXI.TextStyle({
                fill: "#a76f00",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.GAME_FEATURE_BUY_TEXT = new PIXI.TextStyle({
                fill: "#fff500",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 36,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD,
                padding: 10
            }), s.GAME_FEATURE_BUY_TEXT_DISABLED = new PIXI.TextStyle({
                fill: "#f8f49f",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 36,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD,
                padding: 10
            }), s.PROMO_PANEL_HEADING = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 28,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.PROMO_PANEL_PROMOTIONS_HEADING = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 28,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD
            }), s.GAME_FEATURE_OK_TEXT = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 38,
                fontStyle: n.FontStyle.ITALIC,
                fontWeight: n.FontWeight.EXTRA_BOLD,
                padding: 59
            }), s.AS_SETTING_POPUP_OK_TEXT = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 42,
                fontStyle: n.FontStyle.ITALIC,
                fontWeight: n.FontWeight.EXTRA_BOLD,
                padding: 59
            }), s.REPLAY_MIDDLE_BAR_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.REPLAY_GAME_BTN_ACTIVE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                padding: 10
            }), s.REPLAY_GAME_BTN_INACTIVE = new PIXI.TextStyle({
                fill: "#284382",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD,
                padding: 10
            }), s.ROUND_INFO_BET_TEXT_ACTIVE = new PIXI.TextStyle({
                fill: "#f3e550",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 25,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.ROUND_INFO_BET_TEXT_INACTIVE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 25,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.REPLAY_FILTER_STYLE_INACTIVE_FILL_COLOR = o.GuiUtils.getARGB(PIXI.utils.string2hex("#284382")), s.REPLAY_FILTER_STYLE_INACTIVE = new PIXI.TextStyle({
                fill: "#284382",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD,
                padding: 50
            }), s.REPLAY_FILTER_STYLE_ACTIVE_FILL_COLOR = o.GuiUtils.getARGB(PIXI.utils.string2hex("#f3e550")), s.REPLAY_FILTER_STYLE_ACTIVE = new PIXI.TextStyle({
                fill: "#f3e550",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.ROUND_INFO_DATE_TEXT = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 16,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR
            }), s.SORT_BUTTON = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD
            }), s.ROUND_INFO_GAME_NAME_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 18,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.ROUND_INFO_CURRENCY_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 25,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.ROUND_INFO_WIN_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 25,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), s.ROUND_INFO_TROPHY_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 35,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD
            }), s.DEFAULT_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 40,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.SETTINGS_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.AS_ROUND_INFO_X_BET_STYLE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR
            }), s.AS_ROUND_INFO_SLASH_STYLE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.LIGHT
            }), s.AS_ROUND_INFO_RE_SPIN_STYLE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD
            }), s.AS_ROUND_INFO_SPINS_LEFT_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 28,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD
            }), s.AS_ROUND_INFO_WIN_STYLE = new PIXI.TextStyle({
                fill: "#fbc217",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.EXTRA_BOLD,
                dropShadow: !1,
                dropShadowAngle: 1.57,
                dropShadowColor: "#000000",
                dropShadowDistance: 2,
                dropShadowAlpha: .7
            }), s.AS_ROUND_INFO_PLAY_BONUS_IN_GAME_STYLE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 18,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR,
                padding: 10
            }), s.AS_ROUND_INFO_CONTINUE_STYLE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 15,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.SEMI_BOLD
            }), s.AS_POPUP_TOTAL_COST_STYLE = new PIXI.TextStyle({
                fill: "#000000",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.REGULAR
            }), s.AS_ROUND_INFO_SPIN_NUMBER_TEXT_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 11,
                fontStyle: n.FontStyle.NORMAL,
                fontWeight: n.FontWeight.BOLD
            }), e.PromoPanelTextStyles = s
        },
        9034: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ReplayURLConfig = void 0;
            class i { }
            i.BASE_PATH = "api/top10/", i.BASE_URL_DEFAULT = "https://replay.nolimitcity.com/", i.TOP_X_BET_URL = "multiplier", i.TOP_MONETARY_URL = "monetary", i.GAME_SPECIFIC_URL = "/game/", i.OPERATOR_SPECIFIC_URL = "/operator/", e.ReplayURLConfig = i
        },
        7835: (t, e) => {
            "use strict";
            var i, n, r, o, s;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.OptionType = e.LocalStorageSettingsKey = e.ASBonusPickOptions = e.WINTYPE = e.ASMainGamePickOptions = void 0, (s = e.ASMainGamePickOptions || (e.ASMainGamePickOptions = {})).VOLATILITY = "VOLATILITY", s.BOOSTED_BET = "BOOSTED_BET", (o = e.WINTYPE || (e.WINTYPE = {})).NORMAL = "NORMAL", o.MULTIPLIER = "MULTIPLIER", (r = e.ASBonusPickOptions || (e.ASBonusPickOptions = {})).PICK_MODE = "pickMode", r.ROW_OPTIONS = "rowOptions", (n = e.LocalStorageSettingsKey || (e.LocalStorageSettingsKey = {})).AS_STOP_ON_BONUS = "AS_STOP_ON_BONUS", n.AS_BONUS_TAB_SELECTED = "AS_BONUS_TAB_SELECTED", (i = e.OptionType || (e.OptionType = {})).MAIN_GAME = "mainGame", i.BONUS_GAME = "bonusGame"
        },
        361: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelButtonIDs = void 0, (i = e.PromoPanelButtonIDs || (e.PromoPanelButtonIDs = {})).CLOSE = "CLOSE", i.NOLIMIT_WINNERS = "NOLIMIT_WINNERS", i.TOURNAMENTS = "TOURNAMENTS", i.VOUCHER = "VOUCHER", i.NOLIMIT_BONUS = "NOLIMIT_BONUS", i.BET_DOWN = "BET_DOWN", i.BET_UP = "BET_UP", i.BUY = "BUY_BTN", i.OK_BTN = "OK_BTN", i.POP_UP_CLOSE = "POP_UP_CLOSE", i.CURRENT_GAME_BTN = "CURRENT_GAME_BTN", i.ALL_GAME_BTN = "ALL_GAME_BTN", i.SINGLE_PLAYER_BTN = "SINGLE_PLAYER_BTN", i.ALL_PLAYER_BTN = "ALL_PLAYER_BTN", i.X_BET_FILTER_BTN = "X_BET_FILTER_BTN", i.X_WIN_FILTER_BTN = "X_WIN_FILTER_BTN", i.PLAY_BTN = "PLAY_BTN", i.ACTION_SPINS = "ACTION_SPINS", i.ACTION_SPINS_BET_UP = "ACTION_SPINS_BET_UP", i.ACTION_SPINS_BET_DOWN = "ACTION_SPINS_BET_DOWN", i.ACTION_SPINS_COUNT_DOWN = "ACTION_SPINS_COUNT_DOWN", i.ACTION_SPINS_COUNT_UP = "ACTION_SPINS_COUNT_UP", i.ACTION_SPINS_SPIN_BUTTON = "ACTION_SPINS_SPIN_BUTTON", i.ACTION_SPINS_SPIN_STOP_BUTTON = "ACTION_SPINS_SPIN_STOP_BUTTON", i.ACTION_SPIN_STOP_ON_BONUS_TRIGGERED = "ACTION_SPIN_STOP_ON_BONUS_TRIGGERED", i.ACTION_SPINS_SETTINGS = "ACTION_SPINS_SETTINGS", i.ACTION_SPINS_BONUS_BUY = "ACTION_SPINS_BONUS_BUY", i.ACTION_SPINS_MAIN_GAME = "ACTION_SPINS_MAIN_GAME", i.ACTION_SPINS_BONUS_BUY_LABEL = "Nolimit Bonus", i.ACTION_SPINS_MAIN_GAME_LABEL = "Main Game", i.ACTION_SPINS_BONUS_PICK_POP_UP_CLOSE = "BONUS_PICK_POP_UP_CLOSE", i.ACTION_SPINS_REPLAY_EXPAND_BUTTON = "ACTION_SPINS_REPLAY_EXPAND_BUTTON", i.ACTION_SPINS_REPLAY_REPLAY_BUTTON = "ACTION_SPINS_REPLAY_REPLAY_BUTTON", i.ACTION_SPINS_REPLAY_PAUSE_BUTTON = "ACTION_SPINS_REPLAY_PAUSE_BUTTON", i.ACTION_SPINS_REPLAY_PLAY_BUTTON = "ACTION_SPINS_REPLAY_PLAY_BUTTON", i.ACTION_SPINS_GAME_PLAY_BUTTON = "ACTION_SPINS_GAME_PLAY", i.ACTION_SPINS_GAME_CONTINUE_BUTTON = "ACTION_SPINS_GAME_CONTINUE", i.AS_BONUS_SELECTION_OK_BTN = "AS_BONUS_SELECTION_OK_BTN", i.AS_BONUS_SELECTION_CANCEL_BTN = "AS_BONUS_SELECTION_CANCEL_BTN"
        },
        1219: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelLabelIDs = void 0, (i = e.PromoPanelLabelIDs || (e.PromoPanelLabelIDs = {})).PROMO_PANEL_HEADING = "NOLIMIT", i.PROMO_PANEL_PROMOTIONS_HEADING = "PROMOTIONS", i.BET = "Bet", i.BUY = "BUY", i.BUY_FEATURE_TITLE = "Nolimit Shortcut", i.BUY_FEATURE_COST = "COST", i.POPUP_CANCEL = "CANCEL", i.POPUP_OK = "OK", i.CHARGE_FROM_WALLET = "will be charged from your wallet", i.REPLAY_FEATURE_TITLE = "Nolimit Winners", i.REPLAY_CURRENT_GAME = "Current game", i.REPLAY_ALL_GAMES = "All games", i.REPLAY_X_BET = "Bet", i.REPLAY_X_WIN = "Win", i.REPLAY_TOP_WINS_HEADING = "OVERALL TOP WINS", i.REPLAY_MY_TOP_WINS_HEADING = "MY TOP WINS", i.ACTION_SPINS = "Nolimit Action Spins", i.ACTION_SPINS_COST = "Action Spins Cost", i.ROUNDS = "Rounds", i.PRESS_S_TO_STOP = "Press S to stop", i.SPINS_LEFT = "Spins Left :", i.FREE_SPINS_LEFT = "FS Left :", i.SETTING = "Settings", i.BONUS_BUY = "Bonus Buy", i.ACTION_SPINS_BONUS_BUY = "Action Spins Bonus Buy", i.ACTION_SPINS_BONUS_BUY_LABEL = "Nolimit Bonus", i.ACTION_SPINS_MAIN_GAME_LABEL = "Main Game", i.YES = "YES", i.STOP_ON_BONUS = "Stop on bonus", i.PLAY_BONUS_IN_GAME = "Play bonus in game", i.NUMBER_OF_ROUNDS = "Number of Rounds", i.TOTAL_WIN = "Total Win", i.TOTAL_BET_PLACED = "Total bet Placed", i.TOTAL_FS_TRIGGERED = "Total Fs Triggered", i.START = "START", i.TOTAL_COST = "TOTAL COST", i.CONTINUE = "Continue", i.AS_SETTING_MAX_WIN_TEXT = "Max Win"
        },
        3486: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ReplayFilterTypes = void 0, (i = e.ReplayFilterTypes || (e.ReplayFilterTypes = {})).MONETARY = "monetary", i.MULTIPLIER = "multiplier"
        },
        3135: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.RequestMethod = void 0, (i = e.RequestMethod || (e.RequestMethod = {})).POST = "POST", i.GET = "GET", i.PUT = "PUT", i.HEAD = "HEAD"
        },
        6883: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TrophyTypes = void 0, (i = e.TrophyTypes || (e.TrophyTypes = {}))[i.TROPHY_GOLD = 0] = "TROPHY_GOLD", i[i.TROPHY_SILVER = 1] = "TROPHY_SILVER", i[i.TROPHY_BRONZE = 2] = "TROPHY_BRONZE"
        },
        5016: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelEvents = void 0;
            class i { }
            i.BALANCE_UPDATE_EVENT = "onBalanceUpdate", i.ON_RESIZE = "promoPanelOnResize", i.ON_ORIENTATION_CHANGED = "promoPanelOnOrientationChanged", i.NAV_BUTTON_PRESSED = "onNavButtonPressed", i.DISABLE_ALL_NAV_BUTTON = "disableAllNavButtons", i.DISABLE_NAV_BUTTON = "disableNavButtons", i.ENABLE_NAV_BUTTON = "enableNavButtons", i.HIDE_NAV_BUTTON = "hideNavButtons", i.SHOW_NAV_BUTTON = "showNavButtons", i.ON_BET_CHANGE = "onBetChange", i.DISABLE_BET_BUTTONS = "disableBetButtons", i.ENABLE_BET_BUTTONS = "enableBetButtons", i.ON_POPUP_OPEN = "onPopUpOpen", i.ON_POPUP_CLOSE = "onPopUpClose", i.TOGGLE_BUTTONS_ON_LIGHTING_SPINS = "toggleButtonOnLightningSpins", i.AS_REPLAY_ADD_BLUR = "actionSpinReplayAddBlur", i.AS_REPLAY_REMOVE_BLUR = "actionSpinReplayRemoveBlur", i.ACTION_SPIN_DATA = "actionSpinData", i.SHOW_HIDE_CLOSE_BUTTON = "showHideCloseBtn", i.BLUR_BACKGROUND = "blurBackground", i.PROMO_PANEL_OPENED = "promoPanelOpened", i.PROMO_PANEL_CLOSED = "promoPanelClosed", i.PROMO_PANEL_MINIMIZED = "promoPanelMinimized", i.PROMO_PANEL_MAXIMIZED = "promoPanelMaximized", i.DIALOG_SHOWN = "dialogShown", i.FREE_BETS_START = "freeBetsStart", i.FREE_BETS_END = "freeBetsEnd", e.PromoPanelEvents = i
        },
        3672: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FeatureBasePanel = void 0;
            const n = i(4514),
                r = i(1057),
                o = i(7886),
                s = i(5016),
                a = i(8246),
                l = i(2408);
            class h extends PIXI.Container {
                constructor(t, e, i) {
                    super(), this._init = !1, this._isOpen = !1, this._logoName = t, this._titleStr = e, this._titleTextStyle = i || o.PromoPanelTextStyles.FEATURE_BASE_PANEL_TITLE
                }
                init() {
                    this.createLogo(), this.createTitle(), this.addEventListeners(), this._init = !0
                }
                addEventListeners() {
                    n.NolimitApplication.events.on(s.PromoPanelEvents.ON_RESIZE, (() => this.onResize())), n.NolimitApplication.events.on(s.PromoPanelEvents.ON_ORIENTATION_CHANGED, (() => this.onOrientationChanged()))
                }
                createLogo() {
                    this._logo = new PIXI.Sprite(l.ImgLoader.getImgTexture(this._logoName)), this._logo.anchor.set(0, .5), this._logo.pivot.y = -2, this.addChild(this._logo)
                }
                createTitle() {
                    this._title = new r.Label(this._titleStr, this._titleTextStyle), this._title.anchor.set(0, .5), this.addChild(this._title)
                }
                onOrientationChanged() { }
                open() {
                    this._init || this.init(), this._isOpen = !0, this.interactive = !0, this.interactiveChildren = !0, this.onResize(), this.show()
                }
                close() {
                    this.hide(), this._isOpen = !1
                }
                show() {
                    this.visible = !0
                }
                hide() {
                    this.visible = !1
                }
                onResize() {
                    const t = n.NolimitApplication.screenBounds;
                    let e = .5 * t.width,
                        i = 40;
                    const r = this._title.width + this._logo.width + 24;
                    n.NolimitApplication.isLandscape && (i = 45, e = .5 * (t.width - a.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT)), this._logo.position.set(e - .5 * r - 3, 32.5 + i), this._title.position.set(this._logo.x + this._logo.width + 24, 32.5 + i)
                }
                get logo() {
                    return this._logo
                }
            }
            e.FeatureBasePanel = h
        },
        4524: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelLabelButton = e.createDefaultButtonStroke = e.createDefaultButtonBackPlate = void 0;
            const n = i(1057),
                r = i(393),
                o = i(3815),
                s = i(9756),
                a = i(6724),
                l = i(7886),
                h = i(2408);

            function u() {
                const t = new PIXI.NineSlicePlane(h.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.BUTTON_PLATE_20), 20, 20, 20, 20);
                return t.tint = 0, t.alpha = .15, t
            }
            e.createDefaultButtonBackPlate = u, e.createDefaultButtonStroke = function () {
                const t = new PIXI.NineSlicePlane(h.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.BUTTON_STROKE_20), 20, 20, 20, 20);
                return t.tint = 16777215, t.alpha = .6, t
            };
            class c extends r.GuiToggleButton {
                constructor(t, e = "", i, r, s, a, h, c, d = !1) {
                    super(t, (() => this.toggleCallback())), this._isToggledBtn = !1, this._colorSets = i && r && new o.ToggleStateSet(i, r), this.value = void 0, this._isToggledBtn = d, this._label = new n.Label(e, s || l.PromoPanelTextStyles.SETTINGS_BUTTON_LABEL_STYLE), this._backPlate = a || u(), this._stroke = h, this._backPlateOff = c, this.addChild(this._backPlate), this._backPlateOff && this.addChild(this._backPlateOff), this._stroke && this.addChild(this._stroke), this.addChild(this._label)
                }
                setSize(t, e) {
                    this._backPlate.width = t, this._backPlate.height = e, this._backPlateOff && (this._backPlateOff.width = t), this._backPlateOff && (this._backPlateOff.height = e), this._stroke && (this._stroke.width = t, this._stroke.height = e), this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e), this.pivot.set(.5 * t, .5 * e)
                }
                resize(t = 0) {
                    this._label.width + 5 >= this._backPlate.width && this.setSize(this._label.width + t, this._backPlate.height)
                }
                onPointerStateUpdate(t) {
                    this.setColors()
                }
                setColors() {
                    if (this._colorSets) {
                        const t = this._colorSets.getItem(this.toggleState).getItem(this.pointerState);
                        this._label.setColor(t), this._backPlate.alpha = .15 * (1 - this.toggleState), this._stroke && (this._stroke.tint = s.GuiUtils.getColorFromARGB(t), this._stroke.alpha = s.GuiUtils.getAlphaFromARGB(t), this._stroke.alpha *= this.toggled ? 1 : .6)
                    }
                }
                toggleCallback() {
                    this.setColors(), this._backPlateOff && (this._backPlate.alpha = this.toggled ? 1 : 0, this._backPlateOff.alpha = this.toggled ? 0 : 1)
                }
                get label() {
                    return this._label
                }
                get backPlate() {
                    return this._backPlate
                }
            }
            e.PromoPanelLabelButton = c
        },
        5892: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TextLabelAdvanced = e.PromoPanelTextLabel = void 0;
            const n = i(430),
                r = i(4514),
                o = i(8246),
                s = i(1057);
            class a extends s.Label {
                constructor(t, e, i) {
                    super(t, e.clone()), this._textStyle = e.clone(), this._options = i, this._fontSize = "string" == typeof this._textStyle.fontSize ? parseInt(this._textStyle.fontSize) : this._textStyle.fontSize, this.defaultSize = this._fontSize, this.anchor.set(.5)
                }
                onResize() {
                    const t = r.NolimitApplication.screenBounds,
                        e = r.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t) ? this._options.landscapeMaxWidth : this._options.portraitMaxWidth,
                        i = this.getStyleClone(),
                        s = ("string" == typeof i.fontSize ? parseInt(i.fontSize) : i.fontSize) / this.defaultSize,
                        a = e / (this.width / s),
                        l = Math.min(Math.floor(this.defaultSize * a), this.defaultSize);
                    l != this._fontSize && (this._fontSize = l, this.setStyle(i)), o.PromoPanelConfig.TEXT_LABEL_DRAW_BORDER && this.drawBorder()
                }
                setStyle(t) {
                    t.fontSize = this._fontSize, super.setStyle(t)
                }
                drawBorder() {
                    this._border || (this._border = new PIXI.Graphics, this._border.name = this.text + "_BORDER", this.parent && this.parent.addChild(this._border));
                    const t = r.NolimitApplication.screenBounds,
                        e = r.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t);
                    this._border.clear(), this._border.beginFill(0), this._border.alpha = .2, e ? this._border.drawRect(0, 0, this._options.landscapeMaxWidth, this.height) : this._border.drawRect(0, 0, this._options.portraitMaxWidth, this.height), this._border.pivot.set(this._border.width * this.anchor.x, this._border.height * this.anchor.y), this._border.position.set(this.x, this.y)
                }
                get value() {
                    return this._value
                }
                set value(t) {
                    this._value = t, this.text = t, this.onResize()
                }
                get textStyle() {
                    return this._textStyle
                }
            }
            e.PromoPanelTextLabel = a, e.TextLabelAdvanced = class extends a {
                get latestValue() {
                    return this._latestValue
                }
                set latestValue(t) {
                    this._latestValue = t
                }
            }
        },
        3272: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASBetPanelView = void 0;
            const n = i(5023),
                r = i(4071),
                o = i(1410),
                s = i(1219);
            class a extends n.BetPanelView {
                constructor(t, e, i, n, r = !1) {
                    a._isRoundsView = r, super(t, e, i, n), this.setBackgroundAlpha(1)
                }
                resize(t) {
                    this.setBackgroundSize(633, 120), this._betDisplay.position.set(.5 * this._betBackground.width - 177, 13), this._betSelector.position.set(.5 * this._betBackground.width + 177, 60), this._betDisplay.resize()
                }
                createBetDisplay() {
                    let t;
                    return a._isRoundsView ? (this._formatValueAsCurrency = !1, t = o.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.ROUNDS)) : t = o.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.BET), new r.BetDisplay(t)
                }
            }
            e.ASBetPanelView = a
        },
        7815: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinMainGameView = void 0;
            const n = i(9585),
                r = i(4514),
                o = i(430);
            class s extends PIXI.Container {
                get actionButtonView() {
                    return this._actionButtonView
                }
                constructor(t) {
                    super(), this._controller = t, this.init()
                }
                resize(t) {
                    this._actionButtonView.resize(t), this._actionButtonView.position.set(0, Math.floor(.5 * this._actionButtonView.height))
                }
                init() {
                    this._actionButtonView = new n.ASMainGameActionButtonView(this._controller), this.addChild(this._actionButtonView), this.resize(r.NolimitApplication.isLandscape && o.Helper.isDefaultScreenRatio(r.NolimitApplication.screenBounds))
                }
            }
            e.ActionSpinMainGameView = s
        },
        6439: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinsController = void 0;
            const n = i(2009),
                r = i(1410),
                o = i(5016),
                s = i(361),
                a = i(8680),
                l = i(4968),
                h = i(4514),
                u = i(7185),
                c = i(6358),
                d = i(8562),
                p = i(8246),
                f = i(1558),
                g = i(6418),
                m = i(2674),
                _ = i(8948),
                y = i(7835),
                S = i(2379),
                v = i(1133),
                b = i(8943),
                T = i(665);
            class P {
                get spinsLeft() {
                    return this._spinsLeft
                }
                set spinsLeft(t) {
                    this._spinsLeft = t
                }
                get nextMode() {
                    return this._nextMode
                }
                set nextMode(t) {
                    this._nextMode = t
                }
                get view() {
                    return this._view
                }
                set view(t) {
                    this._view = t
                }
                get replayController() {
                    return this._replayController
                }
                get promotionPlugin() {
                    return this._promotionPlugin
                }
                get isPaused() {
                    return this._isPaused
                }
                constructor(t) {
                    this._normalMode = "NORMAL", this._spinsLeft = -1, this._isResponseReceived = !1, this._isPaused = !1, this._isOpen = !1, this._isFreeBetsAwarded = !1, this._freeFeatureBetsAwarded = !1, this._spinCountList = new v.StepList([5, 10, 20, 50, 100, 200, 500, 1e3]), this._wantsPause = !1, this._isPlayingBonusInGame = !1, this._returnedFromGame = !1, this.actionSpinsBetDataInjector = t => (this._isPlayingBonusInGame && (t.playerInteraction ? t.playerInteraction.actionSpin = !0 : t.playerInteraction = {
                        actionSpin: !0
                    }), t), this.onGameOptionUpdate = () => {
                        var t;
                        console.log(this.view.gameOptionsView.selectedOptions), this.updateStartButtonState(), this.view.buyFeatureController.onGameOptionsUpdate(this.view.gameOptionsView.selectedOptions), (null === (t = r.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === t ? void 0 : t.onActionSpinGameOptionSelection) && r.NolimitPromotionPlugin.promoPanelGameConfiguration.onActionSpinGameOptionSelection(this.view.gameOptionsView.selectedOptions)
                    }, this._promotionPlugin = t, this.init(), P.settings = new _.ASSettingsModel, this._betLevels = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels(), r.NolimitPromotionPlugin.apiPlugIn.betHandler.addBetDataInjectCallback(this.actionSpinsBetDataInjector)
                }
                reset() {
                    this.setBetLevels(), this.updateSpinsCountButtons(), this.resetLightningSpinsWindow(), f.ResponseParser.setBoostAndGetCost("", !0), this._isFreeBetsAwarded = !1, this._isPaused = !1
                }
                resetLightningSpinsWindow() {
                    h.NolimitApplication.events.trigger(o.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, !0), this.view.mainGameView.actionButtonView.startButton.toggleSpinBtn(!0), this.view.mainGameView.actionButtonView.startButton.enableStartBtn(!0), this.onBetDownBtnPressed(!0), P.bonusBuyData = void 0
                }
                init() {
                    this.addEventListeners()
                }
                addEventListeners() {
                    h.NolimitApplication.events.on(o.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.onNavButtonPressed(t))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.BALANCE, (() => this.updateBalance())), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.DIALOG, (t => this.onDialog(t))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.PAUSE, (() => this.onExternalPause(!0))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.RESUME, (() => this.onExternalPause(!1))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.HALT, (() => this.onHalt())), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.FREE_BETS, (t => this.onFreeBets(t))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.FREE_FEATURE_BETS, (t => this.onFreeFeatureBets(t))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.BALANCE, (t => this.onBalanceUpdate(t))), r.NolimitPromotionPlugin.apiPlugIn.events.on(u.APIEvent.REFRESH, (() => this.onRefresh()))
                }
                createView(t) {
                    null == this._view && (this._view = new n.ActionSpinsView(this, t), this._replayController = new d.ASReplayController(this), this._popUpView = this._promotionPlugin.view.popUpView)
                }
                open() {
                    this.view && (this._isOpen || (this._view.open(), this._isOpen = !0), this.reset())
                }
                onReplayCloseButtonClick() {
                    h.NolimitApplication.events.trigger(o.PromoPanelEvents.SHOW_HIDE_CLOSE_BUTTON, !0), this._promotionPlugin.isActionSpinRound = !1, this.reset(), this.view.showWrapper(), this.replayController.close()
                }
                close() {
                    this._view && (this._isOpen = !1, this._view.close())
                }
                buttonClick(t, e, i = !1) {
                    switch (a.Logger.logDev("Action Spin controller :: onButtonClick", t), !i && r.NolimitPromotionPlugin.sound.playKeypadEffect("click"), t.name) {
                        case s.PromoPanelButtonIDs.ACTION_SPINS_BET_DOWN:
                            this.onBetDownBtnPressed();
                            break;
                        case s.PromoPanelButtonIDs.ACTION_SPINS_BET_UP:
                            this.onBetUpBtnPressed();
                            break;
                        case s.PromoPanelButtonIDs.ACTION_SPINS_COUNT_UP:
                            this.stepSpinCount(!0);
                            break;
                        case s.PromoPanelButtonIDs.ACTION_SPINS_COUNT_DOWN:
                            this.stepSpinCount(!1);
                            break;
                        case s.PromoPanelButtonIDs.ACTION_SPINS_BONUS_PICK_POP_UP_CLOSE:
                            break;
                        case s.PromoPanelButtonIDs.ACTION_SPINS_SPIN_BUTTON:
                            this.showConfirmationView();
                            break;
                        case s.PromoPanelButtonIDs.ACTION_SPINS_SETTINGS:
                        case s.PromoPanelButtonIDs.OK_BTN:
                            break;
                        case s.PromoPanelButtonIDs.AS_BONUS_SELECTION_OK_BTN:
                        case s.PromoPanelButtonIDs.AS_BONUS_SELECTION_CANCEL_BTN:
                            this.view.showWrapper();
                            break;
                        default:
                            a.Logger.warn("Button click : default case : ", t)
                    }
                }
                onBuyButtonClicked(t, e) {
                    e && e(t)
                }
                setBetLevels() {
                    this._betLevels = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels();
                    const t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
                        e = this._betLevels.indexOf(t);
                    this._betLevels.length || (this._betLevels = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getUnavailableLevels()), -1 != e && this.updateBetButtons(e)
                }
                updateStartButtonState() {
                    let t = +r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    const e = this.view.gameOptionsView.selectedOptions.get(y.ASMainGamePickOptions.BOOSTED_BET);
                    e && e.id > 0 && (t = f.ResponseParser.getBetCost(e.name));
                    const i = t <= r.NolimitPromotionPlugin.apiPlugIn.balance.getAmount(),
                        n = this.view.gameOptionsView.isAllMandatorySelected(),
                        o = i && n;
                    this._view.mainGameView.actionButtonView.startButton.enableStartBtn(o)
                }
                getSelectedBonusOption(t) {
                    let e = -1;
                    const i = this._view.gameOptionsView.selectedOptions.get(y.ASBonusPickOptions.PICK_MODE);
                    return null != i && i.id > -1 && (e = i.id), e
                }
                showConfirmationView() {
                    const t = {
                        isBonusBuy: !1,
                        bet: S.CurrencyUtils.formatWithDecimalCutOff(this.view.getBet()),
                        rounds: this.spinsLeft,
                        image: "AS_GAME_LOGO"
                    };
                    t.stopOnBonus = P.settings.stopOnBonus, t.options = [];
                    const e = this.view.gameOptionsView.selectedOptions.get(y.ASMainGamePickOptions.BOOSTED_BET);
                    e && e.id > 0 && t.options.push(e);
                    const i = this.view.gameOptionsView.selectedOptions.get(y.ASMainGamePickOptions.VOLATILITY);
                    if (i && t.options.push(i), !P.settings.stopOnBonus) {
                        const e = this.view.gameOptionsView.selectedOptions.get(y.ASBonusPickOptions.ROW_OPTIONS);
                        e && t.options.push(e);
                        const i = this.view.gameOptionsView.selectedOptions.get(y.ASBonusPickOptions.PICK_MODE);
                        i && t.options.push(i)
                    }
                    this._popUpView.openActionSpins(((t, i) => {
                        t.name == s.PromoPanelButtonIDs.OK_BTN ? (e && 0 != e.id ? f.ResponseParser.setBoostAndGetCost(e.name, !0) : f.ResponseParser.setBoostAndGetCost("", !0), this._popUpView.close(), this.view.hideWrapper(), this.startActionSpins()) : (this._popUpView.close(), this.enableASMainScreen())
                    }), t)
                }
                onBetDownBtnPressed(t = !1) {
                    const e = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    let i = this._betLevels.indexOf(e); - 1 != i ? (!t && --i, r.NolimitPromotionPlugin.apiPlugIn.betLevel.setLevel(this._betLevels[i]), this.view.setBet(this._betLevels[i]), this.updateBetButtons(i)) : a.Logger.warn("Error invalid bet index : ", i)
                }
                onBetUpBtnPressed() {
                    const t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    let e = this._betLevels.indexOf(t); - 1 != e ? (++e, r.NolimitPromotionPlugin.apiPlugIn.betLevel.setLevel(this._betLevels[e]), this.view.setBet(this._betLevels[e]), this.updateBetButtons(e)) : a.Logger.warn("Error invalid bet index : ", e)
                }
                stepSpinCount(t) {
                    if (this._spinCountList.current() != this._spinsLeft) {
                        let e = this._spinCountList.getListClone(!1),
                            i = 0;
                        for (let n = 0; n < e.length; n++)
                            if (e[n] > this._spinsLeft) {
                                i = t ? n : --n;
                                break
                            } this._spinCountList.setIndex(i)
                    } else t ? this._spinCountList.next() : this._spinCountList.prev();
                    this.updateSpinsCountButtons()
                }
                updateSpinsCountButtons() {
                    this.spinsLeft = this._spinCountList.current(), this.view.spinsPanel.setValue(this.spinsLeft), this.replayController.view.setSpinsLeft(this.spinsLeft), this.replayController.view.enablePlayPauseBtn(this.eligibleForNextSpin()), this._spinCountList.isFirst() ? this._view.spinsPanel.betSelector.enableDownButton(!1) : this._view.spinsPanel.betSelector.enableDownButton(!0), this._spinCountList.isLast() ? this._view.spinsPanel.betSelector.enableUpButton(!1) : this._view.spinsPanel.betSelector.enableUpButton(!0);
                    const t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    this.view.onUpdateBuyFeaturePrice(t)
                }
                updateBetButtons(t) {
                    const e = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    this._view.onBetChange(e), this._view.disableBetButtons();
                    const i = r.NolimitPromotionPlugin.apiPlugIn.balance.getAmount();
                    t < this._betLevels.length - 1 && +this._betLevels[t] < i && this._view.betPanel.betSelector.enableUpButton(!0), t > 0 && this._view.betPanel.betSelector.enableDownButton(!0), this.view.onUpdateBuyFeaturePrice(e), this.updateStartButtonState()
                }
                onBalanceUpdate(t) {
                    if (this._isOpen && !this._replayController.view.isOpen) {
                        const t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
                            e = this._betLevels.indexOf(t);
                        m.ASStopSettings.update(!0), this.updateBetButtons(e)
                    }
                }
                isOpen() {
                    return this._promotionPlugin.view.isOpen && this.replayController.view.isOpen && !r.NolimitPromotionPlugin.IS_MINIMIZED
                }
                startActionSpins(t) {
                    t && (P.bonusBuyData = {
                        featureData: t
                    }, f.ResponseParser.setBoostAndGetCost("", !0), this.view.hideWrapper(), this.view.closeBonusBuyWindow()), this.replayController.open(), this._promotionPlugin.isActionSpinRound = !0, this._wantsPause = !1, this.nextMode = this._normalMode, this.startSpin()
                }
                updateBalance() {
                    this.promotionPlugin.view.isOpen && setTimeout((() => {
                        r.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.ACTION_SPINS_ROUND_COMPLETE)
                    }), 0)
                }
                enableASMainScreen() {
                    this.onBetDownBtnPressed(!0), this.view.enableASMainTab()
                }
                onNavButtonPressed(t) {
                    t == s.PromoPanelButtonIDs.ACTION_SPINS ? this.open() : this.close()
                }
                pauseGame(t, e = !1) {
                    this._wantsPause = t, t || (this._isPaused = !1, e && this.startWhenReady())
                }
                isLowBalance() {
                    const t = r.NolimitPromotionPlugin.apiPlugIn.balance.getAmount();
                    let e = this.view.getBet();
                    return P.bonusBuyData && (e = P.bonusBuyData.featureData.price * e), a.Logger.logDev("Action Spin : isLowBalance check ", e, t), e > t
                }
                stopSpin() {
                    var t;
                    (null === (t = this._roundInfoTl) || void 0 === t ? void 0 : t.isActive()) ? this._roundInfoTl.add((() => {
                        h.NolimitApplication.apiPlugin.slotStates.stateIsReady().then((() => {
                            this.onGameStopped()
                        }))
                    })) : h.NolimitApplication.apiPlugin.slotStates.stateIsReady().then((() => {
                        this.onGameStopped()
                    }))
                }
                onHalt() {
                    this.isOpen() && this.onExternalPause(!0)
                }
                onExternalPause(t) {
                    this.isOpen() && (t ? (this.pauseGame(!0), this.replayController.view.addBlur()) : this.replayController.view.removeBlur())
                }
                onFreeBets(t) {
                    this.isOpen() && (this._isFreeBetsAwarded = !0, this.onExternalPause(!0))
                }
                onFreeFeatureBets(t) {
                    this.isOpen() && (this._freeFeatureBetsAwarded = !0, this.pauseGame(!0))
                }
                onDialog(t) {
                    this.isOpen() && (this.onExternalPause("open" == t), this._isFreeBetsAwarded && "close" == t && (this._isFreeBetsAwarded = !1, this.closeDownActionSpins()))
                }
                closeDownActionSpins() {
                    this.onReplayCloseButtonClick(), this._promotionPlugin.close()
                }
                onRefresh() {
                    this._isOpen && (this.setBetLevels(), this._replayController.view.isOpen && this._isPaused && this.replayController.onGameStopped(this.eligibleForNextSpin()))
                }
                onGameStopped() {
                    if (this._isPaused = !0, this._wantsPause = !1, 1 == this._freeFeatureBetsAwarded) return this._freeFeatureBetsAwarded = !1, void this.closeDownActionSpins();
                    this.replayController.onGameStopped(this.eligibleForNextSpin())
                }
                startWhenReady() {
                    this._wantsPause ? this.stopSpin() : r.NolimitPromotionPlugin.apiPlugIn.slotStates.checkState(b.SlotState.SCREEN) && 1 == this._returnedFromGame ? (this._returnedFromGame = !1, this.startSpin()) : r.NolimitPromotionPlugin.apiPlugIn.slotStates.stateIsReady().then((() => {
                        this._returnedFromGame = !1, this.startSpin()
                    }))
                }
                startSpin() {
                    if (this.nextMode === this._normalMode) {
                        if (this.isLowBalance()) return void this.showInsufficientFunds();
                        this.spinsLeft--
                    }
                    this.spinsLeft > -1 ? (this.makeBet(), this._isResponseReceived = !1) : this.onGameStopped()
                }
                makeBet() {
                    r.NolimitPromotionPlugin.apiPlugIn.dialog.lock("PIXIDialog");
                    let t = l.APIBetType.NORMAL_BET;
                    if (this.nextMode !== this._normalMode && -1 === this.nextMode.indexOf("PICK")) t = l.APIBetType.ZERO_BET;
                    else if (this.nextMode.indexOf("PICK") > -1) {
                        h.NolimitApplication.apiPlugin.events.once(u.APIEvent.GAME, (t => {
                            this.onBetResponseReceived(t)
                        }));
                        const t = this.getSelectedBonusOption(this.nextMode);
                        if (t > -1) r.NolimitPromotionPlugin.apiPlugIn.betHandler.pickAndClickBet(t, !0), a.Logger.logDev("Action Spin : Saved pick mode has been taken : ", t);
                        else {
                            a.Logger.warn("Error :: Action Spin Bonus mode not selected, default zero index picked", this.view.gameOptionsView.selectedOptions);
                            const t = 0;
                            r.NolimitPromotionPlugin.apiPlugIn.betHandler.pickAndClickBet(t, !0)
                        }
                        return
                    }
                    let e = 0;
                    const i = this.actionSpinDataPromise();
                    f.ResponseParser.gameDataPromise().then((t => {
                        this.replayController.accumulatedBet += e, this.onGameDataPromiseResolved(t, i)
                    })).catch((t => {
                        this.stopSpin()
                    })), P.bonusBuyData && t !== l.APIBetType.ZERO_BET ? (r.NolimitPromotionPlugin.apiPlugIn.betHandler.lightningSpinsFeatureBet(P.bonusBuyData.featureData.name), g.Timer.measureTimeAtStateStart(p.Mode.NORMAL, g.FlowState.BET), this.replayController.placedBet = P.bonusBuyData.featureData.price * this.view.betPanel.getValue(), e = this.replayController.placedBet) : (t === l.APIBetType.NORMAL_BET && (this.replayController.placedBet = m.ASStopSettings.appliedBet, e = this.replayController.placedBet), r.NolimitPromotionPlugin.apiPlugIn.betHandler.lightningSpinsBet(t), g.Timer.measureTimeAtStateStart(p.Mode.NORMAL, g.FlowState.BET)), this.replayController.updateSpinsLeft(this.spinsLeft)
                }
                onGameDataPromiseResolved(t, e) {
                    const i = f.ResponseParser.getASReplayWinData(t, this._view.betPanel.getValue(), this._fsData);
                    if (f.ResponseParser.addASData(t, i), (i.freeSpinTriggeredThisSpin || this._fsData) && (this._fsData = t), t.nextMode === p.Mode.NORMAL && this._fsData && (this._fsData = void 0), t.isRoundComplete)
                        if (a.Logger.logDev("Action Spin : onGameDataPromiseResolved round finished ", t, i), t.nextMode === this._normalMode)
                            if (this._actionSpinData) {
                                const e = {
                                    time: this._actionSpinData.time,
                                    gameRoundId: this._actionSpinData.gameRoundId
                                };
                                this._roundInfoTl = this._replayController.updateRawData(i, e), this.onBetResponseReceived(t, i.waitForAnimation), this._actionSpinData = void 0
                            } else e.then((e => {
                                this._roundInfoTl = this._replayController.updateRawData(i, e), this.onBetResponseReceived(t, i.waitForAnimation), this._actionSpinData = void 0
                            }));
                        else this._roundInfoTl = this._replayController.updateRawData(i), this.onBetResponseReceived(t, i.waitForAnimation);
                    else a.Logger.logDev("Action Spin : onGameDataPromiseResolved round not finished ", t, i), this.onBetResponseReceived(t, i.waitForAnimation)
                }
                actionSpinDataPromise() {
                    return new Promise((t => {
                        r.NolimitPromotionPlugin.apiPlugIn.events.once(o.PromoPanelEvents.ACTION_SPIN_DATA, (e => {
                            this._actionSpinData = e, t(e)
                        }))
                    }))
                }
                showInsufficientFunds() {
                    this.stopSpin(), T.show(h.NolimitApplication.apiPlugin)
                }
                eligibleForNextSpin() {
                    let t;
                    const e = r.NolimitPromotionPlugin.apiPlugIn.balance.getAmount(),
                        i = this._replayController.placedBet || m.ASStopSettings.appliedBet;
                    return m.ASStopSettings.shouldReset = !1, t = i <= e, t && m.ASStopSettings.maxBalanceLimitAmount && (t = !(h.NolimitApplication.apiPlugin.balance.getAmount() > m.ASStopSettings.maxBalanceLimitAmount), m.ASStopSettings.shouldReset = !t), t && m.ASStopSettings.minBalanceLimitAmount && (t = !(h.NolimitApplication.apiPlugin.balance.getAmount() < m.ASStopSettings.minBalanceLimitAmount + i), m.ASStopSettings.shouldReset = !t), t && this.spinsLeft > -1
                }
                isBuyFeatureScreen() {
                    return !this.view.mainGameView.visible
                }
                onBetResponseReceived(t, e = !1) {
                    a.Logger.logDev("onBetResponseReceived : data ", t), r.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.STOP);
                    let i = .001 * r.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.minimumSpinTime || .001;
                    e && (i = Math.max(this._roundInfoTl.duration() - this._roundInfoTl.time() - .2, i)), c.TweenLite.to({}, i, {
                        onComplete: () => this.proceedBetResponse(t)
                    })
                }
                proceedBetResponse(t) {
                    if (r.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.DONE), g.Timer.measureTimeAtStateStart(p.Mode.NORMAL, g.FlowState.WIN), this._isResponseReceived = !0, this.nextMode = t.nextMode, this._singleWin = t.totalBetLineWinnings, this.nextMode === this._normalMode) h.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.ACTION_SPINS_ROUND_COMPLETE), r.NolimitPromotionPlugin.apiPlugIn.events.trigger(u.APIEvent.FINISH), r.NolimitPromotionPlugin.apiPlugIn.dialog.unlock("PIXIDialog"), this.startWhenReady();
                    else {
                        if (P.isLegalStopOnBonusMode(t) && !this.isBuyFeatureScreen() && P.settings.stopOnBonus && t.freespinTriggeredThisSpin) {
                            const e = t.featureName || "";
                            return this._replayController.view.createStopOnBonusRound(e, t.nextMode), this._replayController.view.enablePlayPauseBtn(!1), this._replayController.onClickContinuePlayBonusInReplayFunc = () => {
                                this._replayController.view.removeStopOnBonusRound(), this.replayController.view.enablePlayPauseBtn(!0), this.startSpin()
                            }, void (this._replayController.onClickPlayBonusInGamePlayFunc = () => {
                                this.launchBonusInGame(t), this.replayController.view.removeStopOnBonusRound(), this.replayController.view.enablePlayPauseBtn(!0)
                            })
                        }
                        this.startSpin()
                    }
                }
                launchBonusInGame(t) {
                    var e;
                    this.promotionPlugin.minimize(), this._isPlayingBonusInGame = !0;
                    const i = {
                        type: "FAKE_BET",
                        isFakeBet: !0,
                        replayAndFeatureBuy: !0
                    };
                    if (null === (e = r.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.onPlayBonusInGame) r.NolimitPromotionPlugin.promoPanelGameConfiguration.onPlayBonusInGame(t), this.onBonusRedirectToGameSide();
                    else {
                        const e = new c.TimelineMax;
                        e.add((() => {
                            h.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.BET, i)
                        })), e.add((() => {
                            h.NolimitApplication.apiPlugin.events.trigger(u.APIEvent.GAME, t)
                        }), .1), e.add((() => {
                            this.onBonusRedirectToGameSide()
                        }), .2)
                    }
                    h.NolimitApplication.apiPlugin.slotStates.stateIsReady().then((() => {
                        this._returnedFromGame = !0, this._isPlayingBonusInGame = !1, this._replayController.view.maximized(), this.promotionPlugin.maximize(), this.startSpin()
                    }))
                }
                onBonusRedirectToGameSide() {
                    h.NolimitApplication.apiPlugin.events.once(u.APIEvent.GAME, (t => {
                        const e = f.ResponseParser.getASReplayWinData(t, this._view.betPanel.getValue(), this._fsData);
                        if (f.ResponseParser.addASData(t, e), this.nextMode = t.nextMode, t.isRoundComplete)
                            if (t.nextMode === this._normalMode)
                                if (this._actionSpinData) {
                                    const t = {
                                        time: this._actionSpinData.time,
                                        gameRoundId: this._actionSpinData.gameRoundId
                                    };
                                    a.Logger.logDev("Action Spin : afterRedirectToMainGame data ", t, e), this._roundInfoTl = this._replayController.updateRawData(e, t), this._actionSpinData = void 0
                                } else this.actionSpinDataPromise().then((t => {
                                    a.Logger.logDev("Action Spin : afterRedirectMainGame roundId data ", t, e), this._roundInfoTl = this._replayController.updateRawData(e, t), this._actionSpinData = void 0
                                }));
                            else a.Logger.logDev("Action Spin : onBonusRedirectToGameSide nextMode is not normal :: roundId data ", e), this._roundInfoTl = this._replayController.updateRawData(e), setTimeout((() => this.onBonusRedirectToGameSide()), 0);
                        else setTimeout((() => this.onBonusRedirectToGameSide()), 0)
                    }))
                }
                static isLegalStopOnBonusMode(t) {
                    var e;
                    return (null === (e = r.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.isLegalStopOnBonusMode) ? r.NolimitPromotionPlugin.promoPanelGameConfiguration.isLegalStopOnBonusMode(t) : P.isNormalMode(t.mode) || P.isPickMode(t.nextMode)
                }
                static isNormalMode(t) {
                    return t.indexOf("NORMAL") > -1
                }
                static isPickMode(t) {
                    return t.indexOf("PICK") > -1
                }
                static triggerSound(t) {
                    var e;
                    (null === (e = r.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === e ? void 0 : e.onActionSpinPlaySound) && r.NolimitPromotionPlugin.promoPanelGameConfiguration.onActionSpinPlaySound(t)
                }
            }
            P.bonusBuyData = void 0, e.ActionSpinsController = P
        },
        2009: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinsView = void 0;
            const n = i(3672),
                r = i(6724),
                o = i(1410),
                s = i(1219),
                a = i(7886),
                l = i(6439),
                h = i(4514),
                u = i(430),
                c = i(8246),
                d = i(361),
                p = i(7505),
                f = i(2757),
                g = i(7815),
                m = i(2674),
                _ = i(7835),
                y = i(5016),
                S = i(3272),
                v = i(2408),
                b = i(3851),
                T = i(865);
            class P extends n.FeatureBasePanel {
                get buyFeatureController() {
                    return this._buyFeatureController
                }
                get mainGameView() {
                    return this._mainGameView
                }
                get gameOptionsView() {
                    return this._gameOptionsView
                }
                constructor(t, e) {
                    super(r.PromoPanelAssetConfig.ACTION_SPINS_ICON, o.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.ACTION_SPINS), a.PromoPanelTextStyles.FEATURE_ACTION_SPIN_REPLAY_TITLE), this._currentState = "", this.stopOnBonusCallback = t => {
                        switch (this._currentState) {
                            case d.PromoPanelButtonIDs.ACTION_SPINS_MAIN_GAME:
                                this._gameOptionsView.enableBonusOption(!t);
                                break;
                            case d.PromoPanelButtonIDs.ACTION_SPINS_BONUS_BUY:
                                this._gameOptionsView.enableBonusOption(!0)
                        }
                        this._controller.onGameOptionUpdate()
                    }, this._controller = t, this._scroll = e
                }
                init() {
                    super.init(), this._wrapper = new PIXI.Container, this._wrapper.name = "MAIN_VIEW_WRAPPER", this.addChild(this._wrapper), this._mainGameView = new g.ActionSpinMainGameView(this._controller), this._gameOptionsView = new b.ASGameOptionsView(o.NolimitPromotionPlugin.ASOptionsData, this._controller.onGameOptionUpdate), this.betPanel = new S.ASBetPanelView(d.PromoPanelButtonIDs.ACTION_SPINS_BET_UP, d.PromoPanelButtonIDs.ACTION_SPINS_BET_DOWN, (t => this._controller.buttonClick(t)), P.ACTIVE_COLOR), this.spinsPanel = new S.ASBetPanelView(d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_UP, d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_DOWN, (t => this._controller.buttonClick(t)), P.ACTIVE_COLOR, !0), this._betAndSpinsContainer = new PIXI.Container, this._betAndSpinsContainer.addChild(this.betPanel, this.spinsPanel), this._betAndSpinsContainer.name = "betAndSpinsContainer";
                    const t = o.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.allTypesByCategory[f.GameFeatureCategory.BONUS_BUY],
                        e = o.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByTypes(t);
                    this._buyFeatureController = new p.ActionSpinsBuyFeatureController(this._controller, e), this._buyFeatureController.createView(), this._scroll.addContent(this._buyFeatureController.view), this._wrapper.addChild(this._logo, this._title), this._topBtnContainer = this.createTopButtonContainer(), this._wrapper.addChild(this._topBtnContainer, this._betAndSpinsContainer, this._gameOptionsView, this._mainGameView), this._wrapper.addChild(this._buyFeatureController.view), this._controller.promotionPlugin.hasNolimitBonus() || (this._topBtnContainer.visible = !1), this._gameOptionsView.init(), l.ActionSpinsController.settings.addCallback(l.ActionSpinsController.settings.STOP_ON_BONUS, this.stopOnBonusCallback)
                }
                toggleGameTypeButtons(t) {
                    if (this._currentState !== t) {
                        switch (this._currentState = t, t) {
                            case d.PromoPanelButtonIDs.ACTION_SPINS_MAIN_GAME:
                                o.NolimitPromotionPlugin.saveToLocalStorage(_.LocalStorageSettingsKey.AS_BONUS_TAB_SELECTED, !1), this._bonusBuyViewBtn.toggled = !1, this._mainGameViewBtn.toggled = !0, this._mainGameView.visible = !0, this._gameOptionsView.setVisibleSelectors(!0, !0, !0), this.stopOnBonusCallback(l.ActionSpinsController.settings.stopOnBonus), this._wrapper.removeChild(this._buyFeatureController.view);
                                break;
                            case d.PromoPanelButtonIDs.ACTION_SPINS_BONUS_BUY:
                                o.NolimitPromotionPlugin.saveToLocalStorage(_.LocalStorageSettingsKey.AS_BONUS_TAB_SELECTED, !0), this._bonusBuyViewBtn.toggled = !0, this._mainGameViewBtn.toggled = !1, this._mainGameView.visible = !1, this.showBonusBuyWindow(), this._gameOptionsView.setVisibleSelectors(!0, !1, !1), this.stopOnBonusCallback(l.ActionSpinsController.settings.stopOnBonus), this._wrapper.addChild(this._buyFeatureController.view)
                        }
                        this.onResize(), this._scroll.updateContent()
                    }
                }
                onOrientationChanged() {
                    this._controller.replayController.view.onOrientationChanged()
                }
                onResize() {
                    if (this._isOpen) {
                        const t = h.NolimitApplication.screenBounds,
                            e = h.NolimitApplication.isLandscape && u.Helper.isDefaultScreenRatio(t);
                        let i = t.width;
                        this._scroll.position.set(0, 105);
                        const n = new PIXI.Rectangle(c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0, t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - o.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
                        if (e) i = t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT;
                        else if (h.NolimitApplication.isLandscape && !u.Helper.isDefaultScreenRatio(t)) i = t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT;
                        else {
                            const e = v.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.TOP_BAR).height - 10;
                            n.width = i, n.height = t.height - o.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, n.x = 0, n.y = e
                        }
                        this._scroll.resize(n.width, n.height), this._scroll.position.set(n.x, n.y), this.position.set(0, 0), super.onResize(), this.buyFeatureController.view.onResize(), this._scroll.updateContent();
                        const s = 7;
                        this._topBtnContainer.position.set(.5 * i, 190), this.betPanel.resize(e), this.betPanel.pivot.set(.5 * this.betPanel.width, 0), this.spinsPanel.resize(e), this.spinsPanel.pivot.set(.5 * this.spinsPanel.width, 0), this.spinsPanel.position.set(0, this.betPanel.height + s);
                        let a = this._topBtnContainer.visible ? 260 : 145;
                        this._betAndSpinsContainer.position.set(.5 * i, a), a += this._betAndSpinsContainer.height, a += 2 * s, this._gameOptionsView.position.set(.5 * i, a), this._gameOptionsView.pivot.set(.5 * this.betPanel.width, 0), a += this._gameOptionsView.height, a += 4 * s, this.buyFeatureController.view.y = a, this._mainGameView.resize(e), this._mainGameView.position.set(.5 * i, a), this._controller.replayController.view.onResize()
                    }
                }
                onUpdateBuyFeaturePrice(t) {
                    return this._bonusBuyViewBtn.toggled ? this._buyFeatureController.view.updateFeaturePrice(t) : 0
                }
                getNextBetMinFeaturePrice(t, e) {
                    return this._buyFeatureController.view.getNextBetMinFeaturePrice(t, e)
                }
                open() {
                    super.open(), this.showWrapper(), this.toggleGameTypeButtons(o.NolimitPromotionPlugin.getFromLocalStorage(_.LocalStorageSettingsKey.AS_BONUS_TAB_SELECTED, !1) ? this._bonusBuyViewBtn.name : this._mainGameViewBtn.name), this._controller.onGameOptionUpdate(), this._scroll.visible = !0, this.enableScroll(!0), this._scroll.updateContent()
                }
                close() {
                    super.close(), m.ASStopSettings.reset(), this.enableScroll(!1), this._scroll.visible = !1, this._buyFeatureController.close(), this._currentState = ""
                }
                disableBetButtons() {
                    this.betPanel.betSelector.enableUpButton(!1), this.betPanel.betSelector.enableDownButton(!1)
                }
                onBetChange(t) {
                    this.gameOptionsView.onUpdateBet(), this.betPanel.setValue(+t)
                }
                setBet(t) {
                    this.betPanel.setValue(+t)
                }
                getBet() {
                    return this.betPanel.getValue()
                }
                showBonusBuyWindow() {
                    this._buyFeatureController.open()
                }
                closeBonusBuyWindow() {
                    this._buyFeatureController.close(!0), this._scroll.updateContent()
                }
                hideWrapper() {
                    this._wrapper.visible = !1, this._scroll.updateContent()
                }
                showWrapper() {
                    this._wrapper.visible = !0, this._bonusBuyViewBtn.toggled && this.showBonusBuyWindow(), this._scroll.reAddMouseHoverListener(), this._scroll.updateContent()
                }
                enableScroll(t) {
                    this._scroll.scrollEnabled = t
                }
                enableASMainTab() {
                    this._controller.updateStartButtonState(), h.NolimitApplication.events.trigger(y.PromoPanelEvents.TOGGLE_BUTTONS_ON_LIGHTING_SPINS, !0)
                }
                createTopButtonContainer() {
                    const t = new PIXI.Container;
                    this._mainGameViewBtn = this.createToggleButton(d.PromoPanelButtonIDs.ACTION_SPINS_MAIN_GAME, s.PromoPanelLabelIDs.ACTION_SPINS_MAIN_GAME_LABEL), this._bonusBuyViewBtn = this.createToggleButton(d.PromoPanelButtonIDs.ACTION_SPINS_BONUS_BUY, s.PromoPanelLabelIDs.ACTION_SPINS_BONUS_BUY_LABEL);
                    const e = new PIXI.Sprite(PIXI.Texture.WHITE);
                    return e.anchor.set(.5, .5), e.tint = 16088864, e.height = 90, e.width = 2, this._mainGameViewBtn.position.set(.5 * -this._mainGameViewBtn.width - 37, 0), this._bonusBuyViewBtn.position.set(.5 * this._bonusBuyViewBtn.width + 37, 0), t.name = "TOP_BUTTON_CONTAINER", t.addChild(this._mainGameViewBtn, e, this._bonusBuyViewBtn), t
                }
                createToggleButton(t, e) {
                    const i = o.NolimitPromotionPlugin.apiPlugIn.translations.translate(e),
                        n = new T.ASTopMenuToggleButton(t, i);
                    return n.addClickCallback((() => {
                        this.toggleGameTypeButtons(n.name), o.NolimitPromotionPlugin.sound.playKeypadEffect("click")
                    })), n.toggled = !1, n.enable(!0), n.pivot.set(.5 * n.width, .5 * n.height), n
                }
            }
            P.ACTIVE_COLOR = PIXI.utils.string2hex("#f57f20"), e.ActionSpinsView = P
        },
        7505: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinsBuyFeatureController = void 0;
            const n = i(1410),
                r = i(8680),
                o = i(361),
                s = i(5016),
                a = i(4514),
                l = i(336);
            e.ActionSpinsBuyFeatureController = class {
                get actionSpinsController() {
                    return this._actionSpinsController
                }
                constructor(t, e) {
                    this._featureData = [], this._actionSpinsController = t, this._featureData = e, this._betLevels = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels()
                }
                createView() {
                    this._view = new l.ActionSpinsBuyFeatureView(this), this._view.createGameFeatureList(this._featureData), this._view.init(), this.addEventListeners()
                }
                buttonClick(t, e, i = !1) {
                    switch (!i && n.NolimitPromotionPlugin.sound.playKeypadEffect("click"), t.name) {
                        case o.PromoPanelButtonIDs.BUY:
                            if (null == e) return void r.Logger.warn("featureData is undefined");
                            this._actionSpinsController.onBuyButtonClicked(e, (() => this.onBuyBtnPressed(e)));
                            break;
                        case o.PromoPanelButtonIDs.OK_BTN:
                            this.onPopUpOkBtnPressed(e);
                            break;
                        case o.PromoPanelButtonIDs.POP_UP_CLOSE:
                            this.onPopUpCloseBtnPressed();
                            break;
                        default:
                            r.Logger.warn("Button click : default case : ", t)
                    }
                }
                addEventListeners() {
                    a.NolimitApplication.events.on(s.PromoPanelEvents.BALANCE_UPDATE_EVENT, (t => this.onBalanceUpdate(t)))
                }
                open() {
                    this._view.open(), this.setBetLevels(), this._view.closePopUp()
                }
                close(t = !1) {
                    var e;
                    null === (e = this._view) || void 0 === e || e.close(t)
                }
                setBetLevels() {
                    if (this._betLevels = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels(), this._betLevels.length) {
                        const t = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(); - 1 != this._betLevels.indexOf(t) && this._view.updateFeaturePrice(t)
                    } else {
                        this._betLevels = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getUnavailableLevels();
                        const t = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(); - 1 != this._betLevels.indexOf(t) && this._view.updateFeaturePrice(t)
                    }
                }
                onBalanceUpdate(t) {
                    this._view && (this.setBetLevels(), this._view.onBalanceUpdate(t))
                }
                onBuyBtnPressed(t) {
                    this._actionSpinsController.view.enableScroll(!1), this.view.openPopUp(t)
                }
                onPopUpOkBtnPressed(t) {
                    null != t && (this._actionSpinsController.startActionSpins(t), this.close(), this._actionSpinsController.view.enableScroll(!0))
                }
                onPopUpCloseBtnPressed() {
                    this._actionSpinsController.view.enableScroll(!0), this._view.closePopUp()
                }
                get view() {
                    return this._view
                }
                set view(t) {
                    this._view = t
                }
                get promotionPlugin() {
                    return this._actionSpinsController.promotionPlugin
                }
                onGameOptionsUpdate(t) {
                    this._view.onGameOptionsUpdate(t)
                }
            }
        },
        336: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinsBuyFeatureView = void 0;
            const n = i(6724),
                r = i(1410),
                o = i(1219),
                s = i(7886),
                a = i(3672),
                l = i(4514),
                h = i(430),
                u = i(8987),
                c = i(8246),
                d = i(2408),
                p = i(7835),
                f = i(2379);
            class g extends a.FeatureBasePanel {
                constructor(t) {
                    super(n.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON, r.NolimitPromotionPlugin.apiPlugIn.translations.translate(o.PromoPanelLabelIDs.ACTION_SPINS_BONUS_BUY), s.PromoPanelTextStyles.FEATURE_BASE_BUY_FEATURE_TITLE), this._featureBuyTickets = [], this._controller = t, this._featureContainer = new PIXI.Container, this._featureContainer.name = "AS_FEATURE_CONTAINER"
                }
                onBalanceUpdate(t) {
                    var e;
                    null === (e = this._featureBuyTickets) || void 0 === e || e.forEach((t => {
                        t.updateButtons()
                    }))
                }
                onGameOptionsUpdate(t) {
                    var e;
                    const i = r.NolimitPromotionPlugin.ASOptionsData;
                    null === (e = this._featureBuyTickets) || void 0 === e || e.forEach((e => {
                        e.allowedByOptions = !0, i.bonusGame && i.bonusGame.pickNeededForBuyFeatures.indexOf(e.featureData.name) > -1 && null == t.get(i.bonusGame.type) && (e.allowedByOptions = !1), e.updateButtons()
                    }))
                }
                init() {
                    this._init || (this.addChild(this._featureContainer), this._init = !0)
                }
                createGameFeatureList(t) {
                    this._featureContainer.removeChildren(), this._featureBuyTickets.length = 0;
                    const e = d.ImgLoader.getImgTexture(n.PromoPanelAssetConfig.ACTION_SPINS_BUY_BTN);
                    for (let i of t) {
                        const t = new u.FeatureBuyTicket(i, ((t, e) => this._controller.buttonClick(t, e)), e);
                        this._featureContainer.addChild(t), this._featureBuyTickets.push(t)
                    }
                }
                close(t = !0) {
                    this.closePopUp(), t && super.close()
                }
                openPopUp(t) {
                    const e = +r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel() * t.price,
                        i = {
                            isBonusBuy: !0,
                            bet: f.CurrencyUtils.formatWithDecimalCutOff(e),
                            featureData: t,
                            image: t.name,
                            rounds: this._controller.actionSpinsController.spinsLeft,
                            stopOnBonus: !1,
                            options: []
                        },
                        n = this._controller.actionSpinsController.view.gameOptionsView.selectedOptions.get(p.ASBonusPickOptions.ROW_OPTIONS);
                    n && i.options.push(n);
                    const o = this._controller.actionSpinsController.view.gameOptionsView.selectedOptions.get(p.ASBonusPickOptions.PICK_MODE);
                    o && i.options.push(o), this._controller.promotionPlugin.view.popUpView.openActionSpins(((t, e) => this._controller.buttonClick(t, e)), i)
                }
                closePopUp() {
                    this._controller.promotionPlugin.view.popUpView.close()
                }
                show() {
                    super.show()
                }
                hide() {
                    super.hide()
                }
                updateFeaturePrice(t) {
                    let e = Number.MAX_VALUE;
                    return this._featureBuyTickets.forEach((i => {
                        i.updatePrice(t), e = Math.min(e, i.price)
                    })), e
                }
                getNextBetMinFeaturePrice(t, e) {
                    let i = Number.MAX_VALUE;
                    return this._featureBuyTickets.forEach((n => {
                        n.updateNextBetPrice(t, e), i = Math.min(i, n.nextBetPrice)
                    })), i
                }
                onResize() {
                    if (this._isOpen) {
                        const t = l.NolimitApplication.screenBounds,
                            e = l.NolimitApplication.isLandscape && h.Helper.isDefaultScreenRatio(t),
                            i = new PIXI.Rectangle(c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0, t.width - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - r.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
                        if (e);
                        else if (l.NolimitApplication.isLandscape && !h.Helper.isDefaultScreenRatio(t));
                        else {
                            const e = d.ImgLoader.getImgTexture(n.PromoPanelAssetConfig.TOP_BAR).height - 10;
                            i.width = t.width, i.height = t.height - r.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - c.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, i.x = 0, i.y = e
                        }
                        const o = l.NolimitApplication.isLandscape && h.Helper.isDefaultScreenRatio(t);
                        this._featureBuyTickets.forEach((t => {
                            t.resize(o)
                        }));
                        const s = i.width;
                        let a = 0;
                        for (let t of this._featureBuyTickets) t.x = .5 * (s - t.width), t.y = a, a += t.height - 3
                    }
                }
            }
            e.ActionSpinsBuyFeatureView = g
        },
        9585: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASMainGameActionButtonView = void 0;
            const n = i(361),
                r = i(6439),
                o = i(5638),
                s = i(2555),
                a = i(5892),
                l = i(1410),
                h = i(7886),
                u = i(1219);
            class c extends PIXI.Container {
                constructor(t) {
                    super(), this._controller = t, this.initAnimation()
                }
                get stopSpinOnBonusBtn() {
                    return this._stopSpinOnBonusBtn
                }
                get startButton() {
                    return this._startButton
                }
                resize(t) {
                    this._startButton.position.set(177, 0), this._stopOnBonusContainer.position.set(-177, -51)
                }
                initAnimation() {
                    this._stopOnBonusContainer = new PIXI.Container, this._stopSpinOnBonusBtn = new o.StopOnBonusTriggeredToggleBtn(n.PromoPanelButtonIDs.ACTION_SPIN_STOP_ON_BONUS_TRIGGERED);
                    const t = new a.PromoPanelTextLabel(l.NolimitPromotionPlugin.apiPlugIn.translations.translate(u.PromoPanelLabelIDs.STOP_ON_BONUS), h.PromoPanelTextStyles.ACTION_SPINS_STOP_ON_BONUS_LABEL, {
                        landscapeMaxWidth: 300,
                        portraitMaxWidth: 300
                    });
                    t.anchor.set(.5, 0), this._stopSpinOnBonusBtn.pivot.set(.5 * this._stopSpinOnBonusBtn.width, 0), this._stopSpinOnBonusBtn.position.set(0, 38), this._stopOnBonusContainer.addChild(this._stopSpinOnBonusBtn, t);
                    const e = new PIXI.Sprite(PIXI.Texture.WHITE);
                    e.anchor.set(.5, .5), e.tint = PIXI.utils.string2hex("#f57f20"), e.height = 90, e.width = 2, this._startButton = new s.ActionSpinsStartButton(this._controller), this.addChild(this._stopOnBonusContainer, e, this._startButton), this._stopSpinOnBonusBtn.toggled = r.ActionSpinsController.settings.stopOnBonus
                }
            }
            e.ASMainGameActionButtonView = c
        },
        2555: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinsStartButton = void 0;
            const n = i(5892),
                r = i(3606),
                o = i(2974),
                s = i(8760),
                a = i(6724),
                l = i(5991),
                h = i(361),
                u = i(1410),
                c = i(1219),
                d = i(7886),
                p = i(8246),
                f = i(2408);
            class g extends PIXI.Container {
                constructor(t) {
                    super(), this._controller = t, this.initAnimation()
                }
                enableStartBtn(t) {
                    this._spinBtn.alpha = t ? p.PromoPanelConfig.ENABLE_BTN_ALPHA : p.PromoPanelConfig.DISABLE_BTN_ALPHA, this._spinBtn.enable(t)
                }
                toggleSpinBtn(t) {
                    this._spinBtn.visible = t
                }
                initAnimation() {
                    this._startLabel = this.createLabel(), this._spinBtn = this.createButton(), this._spinBtn.position.set(.5 * -this._spinBtn.width, .5 * -this._spinBtn.height), this._startLabel.position.set(0, -7), this.addChild(this._spinBtn, this._startLabel)
                }
                createButton() {
                    const t = new r.PointerStateColorSet(4294967295);
                    let e = new o.PointerStateIconSet(new s.Icon(f.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.ACTION_SPINS_BUY_BTN)));
                    const i = new l.IconToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_SPIN_BUTTON, e, t);
                    return i.enable(!0), i.addClickCallback((() => {
                        this._controller.buttonClick(i)
                    })), i.toggled = !1, i.scale.set(1.25), i
                }
                createLabel() {
                    const t = new n.PromoPanelTextLabel(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(c.PromoPanelLabelIDs.START), d.PromoPanelTextStyles.GAME_FEATURE_BUY_TEXT, {
                        landscapeMaxWidth: 292,
                        portraitMaxWidth: 274
                    });
                    return t.anchor.set(.5), t
                }
            }
            e.ActionSpinsStartButton = g
        },
        5289: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASFreeSpinRoundInfoView = void 0;
            const n = i(1410),
                r = i(6932),
                o = i(6330),
                s = i(5892),
                a = i(7886),
                l = i(6358),
                h = i(9315),
                u = i(5701),
                c = i(8680),
                d = i(7075),
                p = i(7835),
                f = i(5901),
                g = i(2379),
                m = i(6439);
            class _ extends PIXI.Container {
                constructor(t, e, i, n) {
                    super(), this._winData = e, c.Logger.logDev("ASFreeSpinRoundInfoView constructor called win data is : ", e), this._controller = t, this._index = i, this._parentRound = n, this.init()
                }
                start(t = 0) {
                    const e = new l.TimelineLite;
                    return n.NolimitPromotionPlugin.IS_MINIMIZED ? (this.alpha = 1, this._parentRound.updateFSTotalBetAndWin(), e) : (t && e.delay(t), e.add((() => {
                        this._parentRound.updateFSTotalBetAndWin()
                    })), this._winData.isBigWin ? (e.add((() => {
                        this.alpha = 1
                    })), e.add(this.getBigWinAnimation())) : (e.add((() => {
                        this.alpha = 1, this._betGroup.alpha = 0, this._winText.alpha = 0, this._topLine.width = 0, this._bottomLine.width = 0
                    })), e.add(l.TweenLite.to(this._topLine, .2, {
                        ease: l.Power1.easeOut,
                        width: 500
                    }), 0), e.add(l.TweenLite.to(this._bottomLine, .2, {
                        ease: l.Power1.easeOut,
                        width: 500
                    }), 0), e.add(l.TweenLite.to(this._winText, .05, {
                        alpha: 1
                    }), .05), e.add(l.TweenLite.to(this._betGroup, .06, {
                        alpha: 1
                    }), .04), e.add(this.getWinAnimation(this._winData.totalSpinWinnings > 0), 0)), e)
                }
                init() {
                    this.createInfo(), this.onResize(), this.alpha = 0
                }
                onResize() {
                    this._winText.onResize(), this._betGroup.position.set(374, .5 * this._bottomLine.position.y), this._betGroup.pivot.x = this._betGroup.width, this._winText.position.set(this._topLine.position.x - 2, .5 * this._bottomLine.position.y)
                }
                createInfo() {
                    const t = new PIXI.Sprite(PIXI.Texture.WHITE);
                    t.width = 500, t.tint = 0, t.height = 1;
                    const e = new PIXI.Sprite(PIXI.Texture.WHITE);
                    e.width = 500, e.tint = 0, e.height = 1, this._topLine = t, this._bottomLine = e, this._topLine.position.set(r.ASRoundInfoView.NORMAL_ROUND_LEFT_MARGIN + this._topLine.width, 0), this._bottomLine.position.set(r.ASRoundInfoView.NORMAL_ROUND_LEFT_MARGIN + this._bottomLine.width, 60), this._winText = new s.PromoPanelTextLabel("", a.PromoPanelTextStyles.AS_ROUND_INFO_WIN_STYLE, {
                        landscapeMaxWidth: 150,
                        portraitMaxWidth: 150
                    }), this._winText.name = "wintext", this._winText.anchor.set(1, .5), this.updateWin(this._winData.totalSpinWinnings);
                    let i = this._winData.winType === p.WINTYPE.MULTIPLIER ? this._winData.totalSpinWinnings : this._winData.calculatedTimesBetThisSpin;
                    this._betGroup = new o.BetGroup(i, 150), this._topLine.alpha = .5, this._bottomLine.alpha = .5, this._topLine.anchor.x = this._bottomLine.anchor.x = 1, this.addChild(this._topLine, this._betGroup, this._winText, this._bottomLine)
                }
                updateWin(t) {
                    const e = t > 0 ? "#fbc217" : "#000000",
                        i = this._winText.getStyleClone();
                    i.fill = PIXI.utils.string2hex(e), i.dropShadow = t > 0, this._winText.setStyle(i), this._winData.winType === p.WINTYPE.MULTIPLIER ? this._winText.text = t + "x" : this._winText.text = g.CurrencyUtils.format(t), this._winText.onResize()
                }
                getWinAnimation(t) {
                    const e = new l.TimelineLite;
                    if (!this._winData.isWinBelowStake) {
                        const i = t ? "winCoins" : "noWin",
                            n = new h.TimelineSprite(f.AnimationHelper.getAnimationTextures(i));
                        n.visible = !1, n.anchor.set(.5), n.position.set(this._winText.x - .5 * this._winText.width, this._winText.y), e.add((() => {
                            t && m.ActionSpinsController.triggerSound(d.ActionSpinSound.WIN), this.addChild(n)
                        })), e.add(n.getAnimationAutoShowHide()), e.add((() => {
                            this.removeChild(n)
                        }))
                    }
                    return e
                }
                getBigWinAnimation() {
                    const t = new u.BigWin;
                    t.position.set(this._topLine.position.x + 65 - .5 * t.width, .5 * this.height - 4), this.addChild(t);
                    const e = new l.TimelineLite;
                    return e.add((() => {
                        m.ActionSpinsController.triggerSound(d.ActionSpinSound.BIG_WIN)
                    })), e.add(t.start()), e
                }
            }
            e.ASFreeSpinRoundInfoView = _
        },
        8562: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASReplayController = void 0;
            const n = i(1410),
                r = i(4093),
                o = i(4514),
                s = i(5016),
                a = i(8680),
                l = i(6358),
                h = i(7185);
            e.ASReplayController = class {
                get asController() {
                    return this._asController
                }
                get isPlaying() {
                    return this._isPlaying
                }
                set isPlaying(t) {
                    this._isPlaying = t
                }
                set fsCount(t) {
                    this._fsCount = t
                }
                get accumulatedBet() {
                    return this._accumulatedBet
                }
                set accumulatedBet(t) {
                    this._accumulatedBet = t, this._view.setAccumulatedBet(t), this._view.setNetPosition(this._accumulatedWin - this._accumulatedBet)
                }
                get accumulatedWin() {
                    return this._accumulatedWin
                }
                set accumulatedWin(t) {
                    this._accumulatedWin = t, this._view.setAccumulatedWin(t)
                }
                get placedBet() {
                    return this._placedBet
                }
                set placedBet(t) {
                    this._placedBet = t, this._view.setPlacedBet(t)
                }
                get view() {
                    return this._view
                }
                constructor(t) {
                    this._isPlaying = !0, this._fsCount = 0, this._accumulatedBet = 0, this._accumulatedWin = 0, this._placedBet = 0, this._asController = t;
                    const e = n.NolimitPromotionPlugin.apiPlugIn.communication.getParameters();
                    this._communicationDataKey = e.key, this._communicationReplayUrl = e.url.replace("gs", ""), this.createView()
                }
                playBonusInGame() {
                    this.onClickPlayBonusInGamePlayFunc && this.onClickPlayBonusInGamePlayFunc()
                }
                playContinueBonusInReplay() {
                    this.onClickContinuePlayBonusInReplayFunc && this.onClickContinuePlayBonusInReplayFunc()
                }
                updateRawData(t, e) {
                    a.Logger.logDev("updateRawData ", t, e);
                    const i = new l.TimelineLite;
                    return -1 === t.nextMode.indexOf("AVALANCHE") ? this._view.isFSStart ? (i.add(this._view.addFSRound(t, e)), "NORMAL" === t.nextMode && (this._view.isFSStart = !1)) : t.freeSpinTriggeredThisSpin ? (this._view.isFSStart = !0, i.add(this._view.addFSRound(t, e))) : i.add(this._view.addRound(t, e)) : console.warn("illegal data, need to check", t, e), i
                }
                openReplay(t) {
                    a.Logger.logDev("Action Spin : PlayReplay btn clicked gameRoundId : ", t), n.NolimitPromotionPlugin.apiPlugIn.openReplay(parseInt(t))
                }
                onExpandBtnClick(t) {
                    this._isPlaying || this._view.onExpandCollapse(t)
                }
                onPlayPauseBtnClick() {
                    const t = this._view.togglePlayPauseBtn();
                    t ? (this.isPlaying = !1, this._view.enablePlayPauseBtn(!1)) : (this.isPlaying = !0, this._view.onResume()), this._view.enableCloseBtn(!1), this._asController.pauseGame(t, !t)
                }
                onGameStopped(t = !1) {
                    this.isPlaying = !1, this._view.onGameStopped(t)
                }
                onReplayCloseButtonClick() {
                    n.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this._asController.onReplayCloseButtonClick()
                }
                open() {
                    this._isOpen = !0, o.NolimitApplication.apiPlugin.events.trigger(h.APIEvent.ACTION_SPINS_IS_ACTIVE, !0), o.NolimitApplication.events.trigger(s.PromoPanelEvents.SHOW_HIDE_CLOSE_BUTTON, !1), this.accumulatedBet = 0, this.accumulatedWin = 0, this.fsCount = 0, this.isPlaying = !0, this._view.reset(), this._view.setNetPosition(0), this._view.show()
                }
                close() {
                    this._isOpen && (this._isOpen = !1, o.NolimitApplication.apiPlugin.events.trigger(h.APIEvent.ACTION_SPINS_IS_ACTIVE, !1), n.NolimitPromotionPlugin.apiPlugIn.events.trigger(h.APIEvent.SCREEN, "open"), this._view.hide(), this._view.reset())
                }
                createView() {
                    null == this._view && (this._view = new r.ASReplayView(this), this._asController.promotionPlugin.view.addChild(this._view))
                }
                updateSpinsLeft(t) {
                    this._view.setSpinsLeft(t)
                }
            }
        },
        4093: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASReplayView = void 0;
            const n = i(4514),
                r = i(5991),
                o = i(5016),
                s = i(3606),
                a = i(2974),
                l = i(8760),
                h = i(361),
                u = i(6724),
                c = i(1410),
                d = i(8246),
                p = i(6932),
                f = i(5034),
                g = i(8680),
                m = i(6358),
                _ = i(7185),
                y = i(6439),
                S = i(2408),
                v = i(7766),
                b = i(5972),
                T = i(9980);
            class P extends PIXI.Container {
                get isOpen() {
                    return this._isOpen
                }
                get isFSStart() {
                    return this._isFSStart
                }
                set isFSStart(t) {
                    this._isFSStart = t
                }
                constructor(t) {
                    super(), this._replayRounds = [], this._isBlurred = !1, this._roundCounts = 0, this._isOpen = !1, this._isFSStart = !1, this._controller = t, this.addEventListeners(), this.init()
                }
                addBlur() {
                    const t = new m.TimelineLite;
                    return this._isBlurred || (this._isBlurred = !0, null == this.filters && (this.filters = []), this.filters.push(this._blur1, this._blur2), t.add([new m.TweenLite(this._blur1, .2, {
                        blurX: 16,
                        blurY: 16
                    }), new m.TweenLite(this._blur2, .2, {
                        blurX: 10,
                        blurY: 10
                    })])), t
                }
                removeBlur() {
                    if (this._isBlurred) {
                        const t = new m.TimelineLite({
                            onComplete: () => {
                                for (let t = this.filters.length - 1; t >= 0; t--) {
                                    const e = this.filters[t];
                                    e != this._blur1 && e != this._blur2 || this.filters.splice(t, 1)
                                }
                                this._isBlurred = !1
                            }
                        });
                        return t.add([new m.TweenLite(this._blur1, .2, {
                            blurX: 0,
                            blurY: 0
                        }), new m.TweenLite(this._blur2, .2, {
                            blurX: 0,
                            blurY: 0
                        })]), t
                    }
                }
                reset() {
                    this._gameFeed.removeAllItems(), this._gameFeed.enableScroll(!1), this._roundCounts = 0
                }
                addRound(t, e) {
                    g.Logger.logDev("addRound ", t, e);
                    const i = {
                        winData: t,
                        replayData: e || {
                            gameRoundId: "",
                            time: ""
                        }
                    };
                    let n;
                    const r = this._gameFeed.getLastRoundData(),
                        o = new m.TimelineLite;
                    r && !r.isFS && r.winText.latestValue <= 0 && i.winData.totalWin <= 0 ? (n = r, o.add(n.updateZeroWinRounds(i, this._roundCounts + 1))) : (n = new p.ASRoundInfoView(this._controller, i, this._roundCounts, !1), n.winText.latestValue = t.totalWin, this._controller.accumulatedWin += i.winData.totalWin, this._gameFeed.addRoundData(n), o.add(this._gameFeed.updateRoundPositions(!c.NolimitPromotionPlugin.IS_MINIMIZED)), o.add(n.start())), this._roundCounts++;
                    const s = this._gameFeed._topInfoBar.getAccumulatedWin() - this._gameFeed._topInfoBar.getAccumulatedBet();
                    return this.setNetPosition(s), o
                }
                addFSRound(t, e) {
                    g.Logger.logDev("addFSRound ", t, e);
                    const i = new m.TimelineLite,
                        n = t.freeSpinTriggeredThisSpin && !y.ActionSpinsController.isPickMode(t.mode),
                        r = t.nextMode === d.Mode.NORMAL;
                    if (g.Logger.logDev("addFSRound isNewRound ", n, " isLastRound : ", r), n) {
                        const e = {
                            winData: t,
                            replayData: {
                                gameRoundId: "",
                                time: ""
                            }
                        },
                            n = new p.ASRoundInfoView(this._controller, e, this._roundCounts, !0);
                        n.winText.latestValue = t.totalWin, n.betGroup.bet.latestValue = t.calculatedTotalWinTimesBet, this._gameFeed.addRoundData(n), i.add([n.start(), this._gameFeed.updateRoundPositions()]), this._roundCounts++
                    } else {
                        const n = this._gameFeed.getLastRoundData();
                        n.winText.latestValue = t.totalWin, n.betGroup.bet.latestValue = t.calculatedTotalWinTimesBet;
                        const o = 69,
                            s = 8,
                            a = 10,
                            l = 145;
                        let h = i.duration();
                        if (n.isFS ? (c.NolimitPromotionPlugin.IS_MINIMIZED ? r && (g.Logger.logDev("addFSRound lastRound : and minimized", t), n.updateFSOutline(!1, o + s + (n.addedFSCount ? 0 : a), o * (n.addedFSCount + 1) + l), n.resetFSRoundYPosOnNewRoundAdded(), this._gameFeed.updateRoundPositions(!1)) : (i.add([n.updateFSOutline(!0, o + s + (n.addedFSCount ? 0 : a), o * (n.addedFSCount + 1) + l), n.resetFSRoundYPosOnNewRoundAdded(), this._gameFeed.updateRoundPositions(!0)]), h = i.duration()), i.add(n.addFSRound(t).start(0), h)) : g.Logger.logDev("addFSRound winData", t), r) {
                            const r = {
                                winData: t,
                                replayData: e || {
                                    gameRoundId: "",
                                    time: ""
                                }
                            };
                            r.replayData.gameRoundId || g.Logger.warn("Invalid gameRoundId"), n.isFS && (r.winData.waitForAnimation = !0, h = i.duration()), i.add((() => {
                                n.onRoundComplete(r)
                            }), h), this._controller.accumulatedWin += t.totalWin;
                            const o = this._gameFeed._topInfoBar.getAccumulatedWin() - this._gameFeed._topInfoBar.getAccumulatedBet();
                            this.setNetPosition(o)
                        }
                    }
                    return i
                }
                onGameStopped(t) {
                    this.enablePlayPauseBtn(t), this.setPlayState(!0), this._spinControls.enableRoundsButtons(!0), this._gameFeed.enableInteraction(!0), this.enableCloseBtn(!0)
                }
                onResume() {
                    this._spinControls.enableRoundsButtons(!1), this._gameFeed.enableInteraction(!1)
                }
                show() {
                    this._isOpen = !0, this.onResize(), this.visible = !0, this.setPlayState(!1), this.enablePlayPauseBtn(!0), this.enableCloseBtn(!1), this._spinControls.enableRoundsButtons(!1), this._gameFeed.enableInteraction(!1), this.updateSoundButton()
                }
                maximized() {
                    this.updateSoundButton()
                }
                hide() {
                    this._soundButton.stopLoadingAnimation(), this._isOpen = !1, this.visible = !1
                }
                enableReplayButtons(t) {
                    this._replayRounds.forEach((e => {
                        e.enableReplayBtn(t)
                    })), this._gameFeed.enableScroll(!0)
                }
                createStopOnBonusRound(t, e) {
                    const i = this._gameFeed.getLastRoundData();
                    this._replayItemWithStopOnBonusView = i;
                    const n = new f.ASStopOnBonusRoundInfoView(this._controller, t, e);
                    n.position.y = 0, n.position.x = 22, this._replayItemWithStopOnBonusView.addStopOnBonusRoundInfo(n), this._gameFeed.updateRoundPositions()
                }
                removeStopOnBonusRound() {
                    this._replayItemWithStopOnBonusView && (this._replayItemWithStopOnBonusView.removeStopOnBonusRoundInfo(), this._gameFeed.updateRoundPositions())
                }
                onExpandCollapse(t) {
                    t.onExpandBtnClick(), this._gameFeed.updateRoundPositions(!1, this._gameFeed.currentlyVisible), this._gameFeed._scroll.updateContent()
                }
                onOrientationChanged() {
                    this._gameFeed.orientationChanged()
                }
                onResize() {
                    if (this._isOpen) {
                        const t = n.NolimitApplication.screenBounds;
                        this._bg.position.set(.5 * t.width, .5 * t.height), this._gameLogo.alpha = 1;
                        const e = 80;
                        if (n.NolimitApplication.isLandscape) {
                            this._gameFeed.position.set(t.width - 840, 40), this._gameFeed.resize(664);
                            const i = this._gameFeed.x + 16;
                            this._gameLogo.position.set(.5 * i, 26), this._gameLogo.scale.set(1, 1), this._gameLogo.width > i ? (this._gameLogo.width = i, this._gameLogo.scale.y = this._gameLogo.scale.x, this._gameLogo.scale.x < .5 && (this._gameLogo.visible = !1)) : this._gameLogo.visible = !0, this._closeButton.position.set(t.width - e - .5 * this._closeButton.width, 36), this._closeBtnXmark.position.set(this._closeButton.x + .5 * this._closeButton.width, this._closeButton.y + .5 * this._closeButton.height - 4), this._spinControls.position.set(t.width - e, 420), this._soundButton.position.set(20, t.height - this._soundButton.height - 60)
                        } else this._gameFeed.position.set(13, 210), this._gameLogo.position.set(.5 * t.width, 26), this._gameLogo.scale.set(1, 1), this._gameLogo.visible = !0, this._closeButton.position.set(t.width - this._closeButton.width - 5, 14), this._closeBtnXmark.position.set(this._closeButton.x + .5 * this._closeButton.width, this._closeButton.y + .5 * this._closeButton.height - 4), this._spinControls.position.set(.5 * t.width, Math.floor(t.height - this._spinControls.height - 10)), this._soundButton.position.set(20, t.height - this._soundButton.height - 60), this._gameFeed.resize(this._spinControls.y - this._gameFeed.position.y - 15);
                        this._gameFeed._scroll.updateContent(), this._spinControls.resize()
                    }
                }
                enableCloseBtn(t) {
                    this._closeButton.enable(t), t ? (this._closeButton.alpha = d.PromoPanelConfig.ENABLE_BTN_ALPHA, this._closeBtnXmark.alpha = d.PromoPanelConfig.ENABLE_BTN_ALPHA) : (this._closeButton.alpha = d.PromoPanelConfig.DISABLE_BTN_ALPHA, this._closeBtnXmark.alpha = d.PromoPanelConfig.DISABLE_BTN_ALPHA)
                }
                togglePlayPauseBtn() {
                    return this._spinControls.togglePlayButton()
                }
                setPlayState(t) {
                    this._spinControls.setPlayState(t)
                }
                enablePlayPauseBtn(t) {
                    this._spinControls.enablePlayPauseBtn(t)
                }
                setSpinsLeft(t) {
                    this._spinControls.setSpinsLeft(t)
                }
                setPlacedBet(t) {
                    this._gameFeed._topInfoBar.setPlacedBet(t)
                }
                setAccumulatedBet(t) {
                    this._gameFeed._topInfoBar.setAccumulatedBet(t)
                }
                setAccumulatedWin(t) {
                    this._gameFeed._topInfoBar.setAccumulatedWin(t)
                }
                setNetPosition(t) {
                    c.NolimitPromotionPlugin.apiPlugIn.events.trigger(_.APIEvent.WIN)
                }
                createBlurFilters() {
                    this._blur1 = new PIXI.filters.BlurFilter(0, 6), this._blur1.autoFit = !0, this._blur1.repeatEdgePixels = !1, this._blur2 = new PIXI.filters.BlurFilter(0, 6), this._blur2.autoFit = !0, this._blur2.repeatEdgePixels = !1
                }
                init() {
                    var t, e;
                    this._bg = new PIXI.Sprite(c.NolimitPromotionPlugin.imgLoader.getImgTexture((null === (e = null === (t = c.NolimitPromotionPlugin.ASOptionsData) || void 0 === t ? void 0 : t.graphics) || void 0 === e ? void 0 : e.backgroundTextureName) || "AS_REPLAY_BG")), this._bg.name = "AS_REPLAY_BG", this._bg.anchor.set(.5, .5), this._bg.interactive = !0, this._gameLogo = new PIXI.Sprite(c.NolimitPromotionPlugin.imgLoader.getImgTexture("AS_GAME_LOGO")), this._gameLogo.name = "AS_GAME_LOGO", this._gameLogo.anchor.set(.5, 0), this._gameFeed = new v.ActionSpinsGameFeedView;
                    const i = new a.PointerStateIconSet(new l.Icon(S.ImgLoader.getImgTexture(u.PromoPanelAssetConfig.CLOSE_BG_ICON))),
                        n = new s.PointerStateColorSet(4294967295);
                    this._closeButton = new r.IconToggleButton(h.PromoPanelButtonIDs.CLOSE, i, n), this._closeButton.addClickCallback((() => this._controller.onReplayCloseButtonClick())), this._closeButton.toggled = !1, this._closeButton.enable(!0), this._closeBtnXmark = new PIXI.Sprite(S.ImgLoader.getImgTexture(u.PromoPanelAssetConfig.CLOSE)), this._closeBtnXmark.tint = 0, this._closeBtnXmark.anchor.set(.5, .5), this._closeBtnXmark.pivot.y = -3, this._spinControls = new b.SpinControls(this._controller), this._soundButton = new T.SoundButton("sound"), this._soundButton.position.set(200, 200), this._soundButton.addClickCallback((() => {
                        c.NolimitPromotionPlugin.sound.toggleQuickMute(), this.updateSoundButton()
                    })), this.updateSoundButton(), this.addChild(this._bg, this._gameLogo, this._gameFeed, this._closeButton, this._closeBtnXmark, this._spinControls, this._soundButton), this.createBlurFilters(), this.hide()
                }
                updateSoundButton() {
                    const t = c.NolimitPromotionPlugin.sound.isLoaded,
                        e = c.NolimitPromotionPlugin.sound.loading,
                        i = !c.NolimitPromotionPlugin.sound.isQuickMute();
                    e || i && !t ? (this._soundButton.toggled = !1, this._soundButton.enable(!1), this._soundButton.startLoadingAnimation((() => {
                        this.updateSoundButton()
                    }))) : (this._soundButton.stopLoadingAnimation(), this._soundButton.toggled = i, this._soundButton.enable(!0))
                }
                addEventListeners() {
                    c.NolimitPromotionPlugin.apiPlugIn.events.on(o.PromoPanelEvents.AS_REPLAY_ADD_BLUR, (() => this.addBlur())), c.NolimitPromotionPlugin.apiPlugIn.events.on(o.PromoPanelEvents.AS_REPLAY_REMOVE_BLUR, (() => this.removeBlur()))
                }
            }
            e.ASReplayView = P
        },
        6932: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASRoundInfoView = void 0;
            const n = i(5991),
                r = i(430),
                o = i(3606),
                s = i(2974),
                a = i(8760),
                l = i(6724),
                h = i(361),
                u = i(1410),
                c = i(7886),
                d = i(5289),
                p = i(1057),
                f = i(5892),
                g = i(8246),
                m = i(8680),
                _ = i(6358),
                y = i(9315),
                S = i(6330),
                v = i(5701),
                b = i(7075),
                T = i(2408),
                P = i(5901),
                A = i(2379),
                I = i(7234),
                w = i(6439);
            class E extends PIXI.Container {
                get roundNo() {
                    return this._roundNo
                }
                get betGroup() {
                    return this._betGroup
                }
                get winText() {
                    return this._winText
                }
                get isFS() {
                    return this._isFS
                }
                get addedFSCount() {
                    return this._fsRoundContainer.children.length
                }
                get data() {
                    return this._data
                }
                get targetHeight() {
                    return this._targetHeight ? this._targetHeight : this.height
                }
                set targetHeight(t) {
                    this._targetHeight = t
                }
                constructor(t, e, i, n = !1) {
                    super(), this._isFS = !1, this._isFSTriggeredRound = !1, this._isEnabled = !1, this._data = e, this._controller = t, this._roundNo = i, this._isFS = n, this._isFSTriggeredRound = e.winData.freeSpinTriggeredThisSpin, this.alpha = 0, this.init()
                }
                enableInteraction(t) {
                    this._isEnabled = t, t ? this._isFS ? (this.enableReplayBtn(!0), this._balance.position.y = r.Helper.floorPos(65 + .5 * this._balance.height), this.updateFSOutline()) : this.enableReplayBtn(this._data.winData.totalWin > 0) : this.enableReplayBtn(!1)
                }
                start() {
                    const t = new _.TimelineLite;
                    return u.NolimitPromotionPlugin.IS_MINIMIZED ? (this.alpha = 1, this.isFS && (this.updateFSOutline(!1, 15), this._bonusSummaryContainer.alpha = 1), t) : (t.add((() => {
                        this.alpha = 1
                    })), this.isFS ? (t.add((() => {
                        this._stopOnBonusRoundInfoView || this.updateFSOutline(!1)
                    })), t.add(_.TweenLite.to(this._bonusSummaryContainer, .2, {
                        alpha: 1
                    }), .1)) : this._data.winData.isBigWin ? (t.add((() => {
                        this._idAndDate.alpha = 0
                    })), t.add(this.getBigWinAnimation()), t.add((() => {
                        _.TweenLite.to(this._idAndDate, t.totalDuration(), {
                            alpha: 1
                        })
                    }), .1)) : (t.add((() => {
                        this._balance.alpha = 0, this._betGroup.alpha = 0, this._winText.alpha = 0, this._border.scale.x = 0, this._idAndDate.alpha = 0
                    })), t.add(_.TweenLite.to(this._border.scale, .4, {
                        ease: _.Power1.easeOut,
                        x: 1
                    }), 0), t.add(_.TweenLite.to(this._winText, .15, {
                        alpha: 1
                    }), .1), t.add(_.TweenLite.to(this._betGroup, .18, {
                        alpha: 1
                    }), .15), t.add(_.TweenLite.to(this._balance, .12, {
                        alpha: 1
                    }), .28), t.add(_.TweenLite.to(this._idAndDate, .12, {
                        alpha: 1
                    }), .28), t.add(this.getWinAnimation(this._data.winData.totalWin > 0), 0)), t)
                }
                updateZeroWinRounds(t, e) {
                    return m.Logger.logDev("AS : updateZeroWinRounds : ", t, e, this._data), this.updateBalance(t), this._idAndDate.updateDate(t.replayData.time), this._idAndDate.updateId(e), this.updateTopline(), this._data.winData.totalWin > 0 && console.warn("invalid zero win rounds"), this.getWinAnimation(!1)
                }
                addStopOnBonusRoundInfo(t) {
                    this._stopOnBonusRoundInfoView = t, this.addChild(this._stopOnBonusRoundInfoView), this._winText.visible = !1, this._bonusSummaryContainer.visible = !1, this.updateFSOutline(!1, 15), this.updateTransform()
                }
                removeStopOnBonusRoundInfo() {
                    this._winText.visible = !0, this._bonusSummaryContainer.visible = !0, this._stopOnBonusRoundInfoView && (this.removeChild(this._stopOnBonusRoundInfoView), this._stopOnBonusRoundInfoView = void 0, this.updateFSOutline(!1, 15))
                }
                onExpandBtnClick() {
                    this._expandButton.toggled = !this._expandButton.toggled, this._expandButton.toggled ? (this._fsRoundContainer.visible = !1, this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !1), this._expandButton.angle = -90) : (this._expandButton.angle = 0, this._fsRoundContainer.visible = !0, this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !0)), this.updateFSOutline()
                }
                collapseRound() {
                    this._expandButton.toggled = !0, this._expandButton.toggled && (this._fsRoundContainer.visible = !1, this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !1), this._expandButton.angle = -90), this.updateFSOutline()
                }
                updateFSOutline(t = !1, e = 0, i = 0) {
                    const n = new _.TimelineLite;
                    if (!this.isFS) return n;
                    if (this._border instanceof PIXI.NineSlicePlane) {
                        this._border.visible = !1;
                        const r = i || Math.max(this.height + e, 60) - 5;
                        this._border.visible = !0, t ? n.add([_.TweenLite.to(this._border, .2, {
                            height: r
                        })]) : this._border.height = r, this.targetHeight = r - this.pivot.y
                    }
                    return n
                }
                enableReplayBtn(t) {
                    t ? (this.isFS || +this._data.winData.totalWin > 0) && this._replayBtn.enable(t) : this._replayBtn.enable(t)
                }
                onRoundComplete(t) {
                    this.setPlayBtnName(t.replayData.gameRoundId), this.isFS && (this._expandButton.visible = !0, this._controller.view.onExpandCollapse(this), this._idAndDate.updateDate(t.replayData.time), this.updateBalance(t))
                }
                updateTopline() {
                    this._topLine && (this._topLine.position.set(this._idAndDate.width + 8, 0), this._topLine.width = 500 - this._topLine.position.x)
                }
                init() {
                    var t;
                    this._border = this.createInitialBorder(), this._border.name = "border", this.addChild(this._border), this._idAndDate = new I.IdAndDateBox(this._roundNo + 1 + "", null === (t = this._data.replayData) || void 0 === t ? void 0 : t.time), this._idAndDate.name = "idAndDate", this._idAndDate.position.set(50, -10), this.addChild(this._idAndDate), this.updateTopline(), this.createInfo(), this.createBtn(), this.isFS || this.setPlayBtnName(this._data.replayData.gameRoundId), this.onResize(), this.pivot.y = -10, this.targetHeight = this.height
                }
                addFSRound(t) {
                    const e = this._fsRoundContainer.children.length,
                        i = new d.ASFreeSpinRoundInfoView(this._controller, t, e, this);
                    if (i.position.y = 8, this.updateFsRoundHeader(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(t.featureName || "")), this._fsRoundContainer.addChild(i), t.nextMode === g.Mode.NORMAL) {
                        const t = (new PIXI.Graphics).lineStyle(0, 0).moveTo(360, 1).lineTo(400, 1);
                        this._fsRoundContainer.addChild(t), t.position.y = this._fsRoundContainer.height + 8
                    }
                    return this._bonusSummaryContainer && (this._bonusSummaryContainer.visible = !0), i
                }
                updateFsRoundHeader(t) {
                    if (this._featureName.text != t && (this._featureName.text = t, this._featureName.width >= 330)) {
                        const t = 330 / this._featureName.width,
                            e = this._featureName.getStyleClone();
                        e.fontSize = Number(e.fontSize) * t, this._featureName.setStyle(e)
                    }
                }
                resetFSRoundYPosOnNewRoundAdded() {
                    const t = new _.TimelineLite;
                    let e = 8;
                    for (let i = this._fsRoundContainer.children.length - 1; i >= 0; i--) {
                        const n = this._fsRoundContainer.children[i];
                        e += 69, t.to(n, .2, {
                            y: e
                        }, 0)
                    }
                    return t
                }
                createInitialBorder() {
                    let t = new PIXI.Container;
                    if (this.isFS) t = new PIXI.NineSlicePlane(T.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.BONUS_ROUND_OUTLINE), 140, 23, 23, 23), t.position.set(25, 0), t.width = 608, t.height = 44;
                    else {
                        const e = 500,
                            i = new PIXI.Sprite(PIXI.Texture.WHITE);
                        i.position.set(108, 0), i.width = e - 108, i.tint = 0, i.height = 1, this._topLine = i;
                        const n = new PIXI.Sprite(PIXI.Texture.WHITE);
                        n.tint = 0, n.width = e, n.height = 1, n.position.set(0, 60), t.addChild(i, n), t.pivot.set(e, 30), t.position.set(E.NORMAL_ROUND_LEFT_MARGIN + e, 30)
                    }
                    return t
                }
                updateFSTotalBetAndWin() {
                    this._betGroup.updateTimesBet(this._betGroup.bet.latestValue), this.updateWin(this.winText.latestValue), this.setBetGroupPos()
                }
                createInfo() {
                    if (this._balance = new f.PromoPanelTextLabel("", c.PromoPanelTextStyles.AS_ROUND_INFO_X_BET_STYLE, {
                        landscapeMaxWidth: 165,
                        portraitMaxWidth: 165
                    }), this._balance.name = "balance", this._balance.anchor.set(0, .5), this._balance.position.set(E.NORMAL_ROUND_LEFT_MARGIN, 30), this._betGroup = new S.BetGroup(this._data.winData.calculatedTotalWinTimesBet, 150), this._winText = new f.TextLabelAdvanced("", c.PromoPanelTextStyles.AS_ROUND_INFO_WIN_STYLE, {
                        landscapeMaxWidth: 145,
                        portraitMaxWidth: 145
                    }), this._winText.name = "wintext", this._winText.anchor.set(1, .5), this.addChild(this._balance, this._betGroup, this._winText), this.updateWin(this._data.winData.totalWin), this.updateBalance(this._data), this.isFS) {
                        const t = u.NolimitPromotionPlugin.apiPlugIn.translations.translate(this._data.winData.featureName || "");
                        this._featureName = new p.Label("", c.PromoPanelTextStyles.AS_ROUND_INFO_RE_SPIN_STYLE), this._featureName.name = "featureName", this._featureName.anchor.set(0, .5), this.updateFsRoundHeader(t), this._fsRoundContainer = new PIXI.Container, this._fsRoundContainer.name = "subRoundContainer", this._fsRoundContainer.position.y = 102, this.addChild(this._featureName, this._fsRoundContainer), this._isFSTriggeredRound && (this._bonusSummaryContainer = new PIXI.Container, this._bonusSummaryContainer.name = "BonusSummeryContainer", this._blueBG = new PIXI.Sprite(T.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.GAME_FEED_BONUS_INFO_BG)), this._blueBG.width = 608, this._blueBG.position.set(.5 * E.NORMAL_ROUND_LEFT_MARGIN, 60), this._balance.position.y = this._blueBG.position.y + .5 * this._blueBG.height, this._winText.position.y = this._blueBG.position.y + .5 * this._blueBG.height, this._bonusSummaryContainer.addChild(this._blueBG, this._balance, this._betGroup), this.addChildAt(this._bonusSummaryContainer, 0), this._bonusSummaryContainer.alpha = 0)
                    }
                }
                updateWin(t) {
                    const e = t > 0 ? "#fbc217" : "#000000",
                        i = this._winText.getStyleClone();
                    i.fill = PIXI.utils.string2hex(e), i.dropShadow = t > 0, this._winText.setStyle(i), this._winText.text = A.CurrencyUtils.format(t), this._winText.onResize()
                }
                onResize() {
                    var t;
                    this._winText.onResize(), this.setBetGroupPos(), this._isFS ? (this._winText.position.set(548, 30), this._balance.position.y = this._blueBG.position.y + .5 * this._blueBG.height) : this._winText.position.set(548, 30), this._isFS ? (this._expandButton.position.set(50, 30), null === (t = this._featureName) || void 0 === t || t.position.set(70, 30), this._replayBtn.position.x = r.Helper.floorPos(E.NORMAL_ROUND_LEFT_MARGIN + 500 + this._replayBtn.pivot.x + 10), this._replayBtn.position.y = 30) : (this._replayBtn.position.x = r.Helper.floorPos(E.NORMAL_ROUND_LEFT_MARGIN + this._border.width + this._replayBtn.pivot.x + 10), this._replayBtn.position.y = 30)
                }
                setBetGroupPos() {
                    this._betGroup.position.set(374, 30), this.isFS && (this._betGroup.position.y = this._blueBG.position.y + .5 * this._blueBG.height), this._betGroup.pivot.x = this._betGroup.width
                }
                getWinAnimation(t) {
                    const e = new _.TimelineLite;
                    if (!this._data.winData.isWinBelowStake) {
                        const i = t ? "winCoins" : "noWin",
                            n = new y.TimelineSprite(P.AnimationHelper.getAnimationTextures(i));
                        n.visible = !1, n.anchor.set(.5), n.position.set(this._winText.x - .5 * this._winText.width, this._winText.y), e.add((() => {
                            t && w.ActionSpinsController.triggerSound(b.ActionSpinSound.WIN), this.addChild(n)
                        })), e.add(n.getAnimationAutoShowHide()), e.add((() => {
                            this.removeChild(n)
                        }))
                    }
                    return e
                }
                getBigWinAnimation() {
                    const t = new v.BigWin;
                    t.position.set(E.INFO_BG_WIDTH_LANDSCAPE / 2 + 4, .5 * this.height - 4), this.addChild(t);
                    const e = new _.TimelineLite;
                    return e.add((() => {
                        w.ActionSpinsController.triggerSound(b.ActionSpinSound.BIG_WIN)
                    })), e.add(t.start()), e
                }
                updateBalance(t) {
                    t.winData.balance && (this._balance.value = A.CurrencyUtils.format(+t.winData.balance))
                }
                setPlayBtnName(t) {
                    this._replayBtn.name = t
                }
                createToggleButton(t, e, i, r = 4294967295) {
                    const l = new o.PointerStateColorSet(r);
                    let h = new s.PointerStateIconSet(new a.Icon(T.ImgLoader.getImgTexture(e))),
                        u = new s.PointerStateIconSet(new a.Icon(T.ImgLoader.getImgTexture(i)));
                    const c = new n.IconToggleButton(t, h, l, u);
                    return c.toggled = !1, c.enable(!0), c.pivot.set(.5 * c.width, .5 * c.height), c
                }
                createBtn() {
                    const t = new o.PointerStateColorSet(4294967295);
                    let e = new s.PointerStateIconSet(new a.Icon(T.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_REPLAY_BTN)), void 0, void 0, new a.Icon(T.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_REPLAY_DISABLED_BTN)));
                    const i = new n.IconToggleButton(h.PromoPanelButtonIDs.PLAY_BTN, e, t);
                    if (i.addClickCallback((() => this._controller.openReplay(i.name))), i.toggled = !1, i.enable(!1), this.addChild(i), i.pivot.set(i.width / 2, i.height / 2), this._replayBtn = i, this.isFS) {
                        const t = this.createToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_REPLAY_EXPAND_BUTTON, l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_EXPAND, l.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_GAME_EXPAND);
                        t.addClickCallback((() => {
                            this._controller.onExpandBtnClick(this)
                        })), t.toggled = !1, t.enable(!0), t.name = "PLUS_MINUS", t.visible = !1, t.pivot.set(.5 * t.width, .5 * t.height), this._expandButton = t, this.addChild(this._expandButton)
                    }
                }
            }
            E.INFO_BG_WIDTH_LANDSCAPE = 590, E.NORMAL_ROUND_LEFT_MARGIN = 50, E.BONUS_ROUND_LEFT_MARGIN = 25, e.ASRoundInfoView = E
        },
        5034: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASStopOnBonusRoundInfoView = void 0;
            const n = i(1057),
                r = i(5991),
                o = i(3606),
                s = i(2974),
                a = i(8760),
                l = i(6724),
                h = i(361),
                u = i(1410),
                c = i(7886),
                d = i(1219),
                p = i(2408),
                f = i(4931);
            class g extends PIXI.Container {
                constructor(t, e, i) {
                    super(), this.createInfo(e), this.createPlayInGameBtn(t);
                    const n = u.NolimitPromotionPlugin.ASOptionsData;
                    if (n.bonusGame && n.bonusGame.pickNeededForModes.indexOf(i) > -1) {
                        const e = e => {
                            t.asController.view.gameOptionsView.selectedOptions.set(i.type, e.getSelection()), t.playContinueBonusInReplay()
                        },
                            i = new f.GameOptionSelectorComponent(n.bonusGame.type, e, n.bonusGame.options, "", "");
                        i.position.set(0, 35), i.updateLayout(!0, 618), i.addContinueButtonGraphics(), this.addChild(i)
                    } else this.createContinueBtn(t)
                }
                createContinueBtn(t) {
                    const e = new o.PointerStateColorSet(4294967295);
                    let i = new s.PointerStateIconSet(new a.Icon(p.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CONTINUE))),
                        f = new s.PointerStateIconSet(new a.Icon(p.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CONTINUE)));
                    const g = new r.IconToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_GAME_CONTINUE_BUTTON, i, e, f);
                    g.addClickCallback((() => t.playContinueBonusInReplay())), g.toggled = !1, g.enable(!0), g.pivot.set(.5 * g.width, .5 * g.height), g.position.set(295, 105), this.addChild(g);
                    const m = new n.Label(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(d.PromoPanelLabelIDs.CONTINUE), c.PromoPanelTextStyles.AS_ROUND_INFO_CONTINUE_STYLE);
                    m.pivot.x = .5 * m.width, m.position.set(g.position.x, g.position.y + .5 * g.height + 5), this.addChild(m)
                }
                createPlayInGameBtn(t) {
                    const e = new o.PointerStateColorSet(4294967295);
                    let i = new s.PointerStateIconSet(new a.Icon(p.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_PLAY_BTN)));
                    const f = new r.IconToggleButton(h.PromoPanelButtonIDs.ACTION_SPINS_GAME_PLAY_BUTTON, i, e);
                    f.addClickCallback((() => t.playBonusInGame())), f.toggled = !1, f.enable(!0), f.pivot.set(f.width / 2, f.height / 2), f.position.set(562, 30), this.addChild(f);
                    const g = new n.Label(u.NolimitPromotionPlugin.apiPlugIn.translations.translate(d.PromoPanelLabelIDs.PLAY_BONUS_IN_GAME), c.PromoPanelTextStyles.AS_ROUND_INFO_PLAY_BONUS_IN_GAME_STYLE);
                    if (g.width >= 145) {
                        const t = 145 / g.width,
                            e = g.getStyleClone();
                        e.fontSize = Number(e.fontSize) * t, g.setStyle(e)
                    }
                    g.pivot.x = g.width, g.pivot.y = .5 * g.height, g.position.set(530, 30), this.addChild(g)
                }
                createInfo(t) {
                    const e = new PIXI.Sprite(u.NolimitPromotionPlugin.imgLoader.getImgTexture(l.PromoPanelAssetConfig.BONUS_ROUND_BONUS_SUMMARY));
                    e.position.set(30, 60), this.addChild(e)
                }
            }
            e.ASStopOnBonusRoundInfoView = g
        },
        7766: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinsGameFeedView = void 0;
            const n = i(2408),
                r = i(6724),
                o = i(3151),
                s = i(3128),
                a = i(1278),
                l = i(6358),
                h = i(9455),
                u = i(7886),
                c = i(3606),
                d = i(9756),
                p = i(430);
            class f extends PIXI.Container {
                constructor() {
                    super(), this.currentlyVisible = 50, this._replayRounds = [], this._itemSpacing = 10, this._background = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_FEED_BG), 30, 30, 30, 36), this._background.name = "_background", this._background.width = 692, this._background.height = 664, this._topInfoBar = new o.TopBar, this._topInfoBar.pivot.set(.5 * this._topInfoBar.width, .5 * this._topInfoBar.height), this._topInfoBar.position.set(.5 * this._background.width, 14), this._sortControls = new a.SortControls((t => this.sort(t))), this._sortControls.position.set(66, 55);
                    const t = new c.PointerStateColorSet(d.GuiUtils.getARGB(0, 1));
                    this._loadMoreButton = new h.SimpleLabelButton("loadmore", p.Helper.translate("Load more"), u.PromoPanelTextStyles.ROUND_INFO_DATE_TEXT, t), this._loadMoreButton.resizeButtonToLabelWithMargin(5, 15, 5, 15), this._loadMoreButton.pivot.set(.5 * this._loadMoreButton.width, 0), this._loadMoreButton.addClickCallback((() => {
                        null != this._loadMoreCallback && (this._scroll.removeContent(this._loadMoreButton), this._loadMoreCallback())
                    })), this._loadMoreButton.enable(!0), this._scroll = new s.GUIScrollContainer(660, this._background.height - 72, !1, !0, !0, {
                        color: 16695821,
                        thickness: 3
                    }), this._scroll.position.set(17, 80), this._scrollContent = new PIXI.Container, this._scroll.addContent(this._scrollContent), this.addChild(this._background, this._scroll, this._topInfoBar, this._sortControls)
                }
                orientationChanged() {
                    this._scroll.setScrollDelta(this._scroll, 0, 0)
                }
                resize(t) {
                    this._background.height = t, this._scroll.resize(660, this._background.height - 111), this._topInfoBar.resize()
                }
                sort(t) {
                    t ? this._replayRounds.sort(((t, e) => t.winText.latestValue - e.winText.latestValue)) : this._replayRounds.sort(((t, e) => t.roundNo - e.roundNo)), this._sortControls.update(t), this.updateRoundPositions(), this._scroll.setScrollDelta(this._scroll, 0, this._scroll.height)
                }
                addRoundData(t) {
                    this._replayRounds.push(t)
                }
                getLastRoundData() {
                    return this._replayRounds[this._replayRounds.length - 1]
                }
                removeAllItems() {
                    this._replayRounds = [], this._scrollContent.removeChildren(), this._scroll.updateContent()
                }
                enableInteraction(t) {
                    t ? (this.enableInteractionAllRounds(), this.interactionEnabled = !0) : (this.interactionEnabled = !1, this.collapseAll(), this.sort(!1), null != this._loadMoreButton.parent && this._loadMoreButton.parent.removeChild(this._loadMoreButton)), this.updateRoundPositions(), this._scroll.updateContent(), this._sortControls.enable(t), this.enableScroll(t);
                    const e = t ? 1 : .6;
                    l.TweenMax.to(this._background, .2, {
                        alpha: e
                    })
                }
                enableScroll(t) {
                    this._scroll.scrollEnabled = t
                }
                addLoadMoreButton(t, e) {
                    this._loadMoreButton.parent || (this._loadMoreCallback = e, this._scroll.addContent(this._loadMoreButton)), this._loadMoreButton.position.set(.5 * this._background.width, t)
                }
                updateRoundPositions(t = !1, e = 50) {
                    const i = new l.TimelineLite,
                        n = this._replayRounds.length - 1,
                        r = n - 16,
                        o = n - e;
                    this.currentlyVisible = e;
                    let s = 0;
                    for (let a = n; a >= 0; a--) {
                        const n = this._replayRounds[a];
                        a > o ? (null == n.parent && this._scrollContent.addChild(n), t && a > r ? i.to(n, .2, {
                            y: s
                        }, 0) : n.position.y = s, s += n.targetHeight + this._itemSpacing) : (this._scrollContent.removeChild(n), this.interactionEnabled && this.addLoadMoreButton(s, (() => {
                            this.loadMoreRounds(e), this._scroll.updateContent()
                        })))
                    }
                    return i
                }
                enableInteractionAllRounds() {
                    this._replayRounds.forEach((t => {
                        t.enableInteraction(!0)
                    }))
                }
                collapseAll() {
                    this._replayRounds.forEach((t => {
                        t.enableInteraction(!1), t.isFS && t.collapseRound()
                    }))
                }
                loadMoreRounds(t) {
                    this.updateRoundPositions(!1, t + 20)
                }
            }
            e.ActionSpinsGameFeedView = f
        },
        6330: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetGroup = void 0;
            const n = i(5892),
                r = i(1057),
                o = i(1410),
                s = i(6724),
                a = i(7886),
                l = i(2379);
            class h extends PIXI.Container {
                constructor(t, e) {
                    super(), this._betSign = new PIXI.Sprite(o.NolimitPromotionPlugin.imgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_MENU_BET)), this._betSign.anchor.set(0, .5), this._betSign.tint = 0, this._betGroupMaxWidth = e || 150, this._betGroupMaxWidth -= this._betSign.width + 10, this._bet = new n.TextLabelAdvanced("", a.PromoPanelTextStyles.AS_ROUND_INFO_X_BET_STYLE, {
                        landscapeMaxWidth: this._betGroupMaxWidth,
                        portraitMaxWidth: this._betGroupMaxWidth
                    }), this._bet.anchor.set(0, .5);
                    const i = new r.Label("x", a.PromoPanelTextStyles.AS_ROUND_INFO_X_BET_STYLE);
                    i.anchor.set(0, .5), this._xText = i, this.addChild(this._bet, this._xText, this._betSign), this.updateTimesBet(t)
                }
                updateTimesBet(t) {
                    this._bet.text = l.CurrencyUtils.formatValueWithDecimalCutOff(t), this.onResize()
                }
                onResize() {
                    this._bet.onResize(), this._bet.position.set(0, 0), this._xText.position.set(this._bet.width + 5, 0), this._betSign.position.set(this._xText.x + this._xText.width + 5, 0)
                }
                get bet() {
                    return this._bet
                }
            }
            e.BetGroup = h
        },
        5701: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BigWin = void 0;
            const n = i(9315),
                r = i(6358),
                o = i(5901);
            class s extends PIXI.Container {
                constructor() {
                    super(), this.init(), this.name = "BIGWIN"
                }
                start() {
                    const t = new r.TimelineLite;
                    return t.add((() => {
                        this._baseAnim.setFrame(0), this._textAnim.setFrame(0), this._coinAnim[0].setFrame(0), this._coinAnim[1].setFrame(0), this._coinAnim[2].setFrame(0), this._coinAnim[3].setFrame(0), this.visible = !0
                    })), t.add([this._baseAnim.getAnimationAutoShowHide(!0, !0), this._textAnim.getAnimationAutoShowHide(!0, !0)], 0), t.add([this._coinAnim[1].getAnimationAutoShowHide(!0, !0), this._coinAnim[2].getAnimationAutoShowHide(!0, !0)], 1 / 30 * 4), t.add([this._coinAnim[0].getAnimationAutoShowHide(!0, !0), this._coinAnim[3].getAnimationAutoShowHide(!0, !0)], .2), t.add((() => {
                        var t;
                        this.visible = !1, null === (t = this.parent) || void 0 === t || t.removeChild(this)
                    })), t
                }
                init() {
                    this._baseAnim = new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("bigWinBase")), this._textAnim = new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("bigWinText")), this._coinAnim = [new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins")), new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins")), new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins")), new n.TimelineSprite(o.AnimationHelper.getAnimationTextures("winCoins"))], this._baseAnim.anchor.set(.5), this._textAnim.anchor.set(.5), this._coinAnim[0].anchor.set(.5), this._coinAnim[1].anchor.set(.5), this._coinAnim[2].anchor.set(.5), this._coinAnim[3].anchor.set(.5), this._coinAnim[0].position.x = -210, this._coinAnim[1].position.x = -150, this._coinAnim[2].position.x = 140, this._coinAnim[3].position.x = 200, this._textAnim.position.y = 18, this.addChild(this._baseAnim, this._coinAnim[0], this._coinAnim[1], this._coinAnim[2], this._coinAnim[3], this._textAnim), this.visible = !1
                }
            }
            e.BigWin = s
        },
        8766: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SignLabel = e.SignLabelAlign = void 0;
            const n = i(5892),
                r = i(7886),
                o = i(2408),
                s = i(2379);
            var a;
            ! function (t) {
                t[t.LEFT = 0] = "LEFT", t[t.CENTER = 1] = "CENTER", t[t.RIGHT = 2] = "RIGHT"
            }(a = e.SignLabelAlign || (e.SignLabelAlign = {}));
            class l extends PIXI.Container {
                constructor(t, e, i, s, l) {
                    super(), this._allowNegative = !1, this._margin = 5, this._align = a.LEFT, this.useDecimalCutoff = !0, this.name = "SignLabel_" + t, this.mainContainer = new PIXI.Container, this._sign = new PIXI.Sprite(o.ImgLoader.getImgTexture(e)), this._sign.anchor.set(0, .5), this.mainContainer.addChild(this._sign), this._label = new n.PromoPanelTextLabel("", i || r.PromoPanelTextStyles.AS_REPLAY_NUMBER_TEXT_STYLE, {
                        landscapeMaxWidth: s || 158,
                        portraitMaxWidth: l || 158
                    }), this._label.anchor.set(0, .5), this._label.position.set(this._sign.width + this._margin, 0), this.mainContainer.addChild(this._label), this.addChild(this.mainContainer), this.value = 0
                }
                set value(t) {
                    this._value != t && (this._value = t, (this._allowNegative || this._value > -1) && (this.useDecimalCutoff ? this._label.value = s.CurrencyUtils.formatWithDecimalCutOff(this.value) : this._label.value = s.CurrencyUtils.format(this.value)), this.align(this._align))
                }
                align(t) {
                    this._align = t, this._align == a.RIGHT ? this.mainContainer.pivot.set(this.mainContainer.width, 0) : this._align == a.CENTER ? this.mainContainer.pivot.set(.5 * this.mainContainer.width, 0) : this.mainContainer.pivot.set(0, 0)
                }
                set allowNegative(t) {
                    this._allowNegative = t
                }
                get value() {
                    return this._value
                }
                onResize() {
                    this._label.onResize()
                }
            }
            e.SignLabel = l
        },
        7234: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.IdAndDateBox = void 0;
            const n = i(3832),
                r = i(1057),
                o = i(2408),
                s = i(6724),
                a = i(7886),
                l = i(430),
                h = i(1028);
            class u extends n.Container {
                constructor(t, e) {
                    super(), this._bp = new PIXI.NineSlicePlane(o.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_ROUNDS_NUMBER_BG), 7, 7, 7, 7), this._id = new r.Label(t, a.PromoPanelTextStyles.AS_ROUND_INFO_SPIN_NUMBER_TEXT_STYLE), this._id.anchor.set(.5, .5), this._bp.addChild(this._id), this._date = new r.Label(u.formatTime(e), a.PromoPanelTextStyles.ROUND_INFO_DATE_TEXT), this.addChild(this._bp, this._date), this.resize()
                }
                static formatTime(t) {
                    if (null == t || "" == t) return "";
                    const e = new Date(t);
                    return l.Helper.padZero(e.getHours()) + ":" + l.Helper.padZero(e.getMinutes()) + ":" + l.Helper.padZero(e.getSeconds())
                }
                updateDate(t) {
                    this._date.text = u.formatTime(t)
                }
                updateId(t) {
                    const e = this._id.text.split("-")[0];
                    this._id.text = e + "-" + t, this.resize()
                }
                resize() {
                    this._bp.width = Math.max(this._id.width + 10, 30), this._bp.height = 14, this._id.position.set(.5 * this._bp.width, .5 * this._bp.height), h.GuiLayout.align([this._bp, this._date], 8, h.Align.CENTER, h.Direction.HORIZONTAL)
                }
            }
            e.IdAndDateBox = u
        },
        9455: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SimpleLabelButton = e.createDefaultButtonStroke = e.createDefaultButtonBackPlate = void 0;
            const n = i(2408),
                r = i(6724),
                o = i(393),
                s = i(1057),
                a = i(3815),
                l = i(3606),
                h = i(3663),
                u = i(9756);

            function c() {
                const t = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.BUTTON_PLATE_20), 20, 20, 20, 20);
                return t.tint = 0, t.alpha = .15, t
            }

            function d() {
                const t = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.BUTTON_STROKE_20), 20, 20, 20, 20);
                return t.tint = 16777215, t.alpha = .6, t
            }
            e.createDefaultButtonBackPlate = c, e.createDefaultButtonStroke = d;
            class p extends o.GuiToggleButton {
                constructor(t, e = "", i, n, r, o, u) {
                    super(t, (() => this.toggleCallback())), i = i || h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE, n = n || new l.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), r = r || new l.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this._colorSets = new a.ToggleStateSet(n, r), this.value = void 0, this._label = new s.Label(e, i), this._backplate = o || c(), this._stroke = u || d(), this.addChild(this._backplate), this.addChild(this._stroke), this.addChild(this._label)
                }
                get label() {
                    return this._label
                }
                get backplate() {
                    return this._backplate
                }
                set backplate(t) {
                    this._backplate = t
                }
                get stroke() {
                    return this._stroke
                }
                set stroke(t) {
                    this._stroke = t
                }
                setSize(t, e) {
                    this._backplate.width = t, this._backplate.height = e, this._stroke.width = t, this._stroke.height = e, this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e)
                }
                resizeButtonToLabelWithMargin(t = 0, e = 0, i = 0, n = 0) {
                    this.setSize(this._label.width + n + e, this._label.height + t + i), this._label.anchor.set(0, 0), this._label.position.set(n, t)
                }
                onPointerStateUpdate(t) {
                    this.setColors()
                }
                setColors() {
                    const t = this._colorSets.getItem(this.toggleState).getItem(this.pointerState);
                    this._label.setColor(t), this._backplate.alpha = this.toggleState * u.GuiUtils.getAlphaFromARGB(t), this._stroke.tint = u.GuiUtils.getColorFromARGB(t), this._stroke.alpha = (1 - this.toggleState) * u.GuiUtils.getAlphaFromARGB(t)
                }
                toggleCallback() {
                    this.setColors()
                }
            }
            e.SimpleLabelButton = p
        },
        7905: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SortButton = void 0;
            const n = i(5991),
                r = i(3606),
                o = i(2408),
                s = i(6724),
                a = i(8760),
                l = i(2974),
                h = i(1057),
                u = i(7886);
            class c extends n.IconToggleButton {
                constructor(t, e) {
                    const i = new r.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208),
                        n = new r.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231),
                        c = new l.PointerStateIconSet(new a.Icon(o.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_SORT_ARROW_RIGHT)));
                    super(t, new l.PointerStateIconSet(new a.Icon(o.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_SORT_ARROW_DOWN))), i, c, n), null != e && (this.label = new h.Label(e, u.PromoPanelTextStyles.SORT_BUTTON), this.label.anchor.set(0, .5), this.addSubComponent(this.label, {
                        x: 1,
                        y: .5
                    }, {
                        x: 5,
                        y: 0
                    }))
                }
                enable(t) {
                    super.enable(t), this.label && (this.label.tint = this._icon.tint, this.label.alpha = this._icon.alpha)
                }
            }
            e.SortButton = c
        },
        1278: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SortControls = void 0;
            const n = i(3606),
                r = i(9756),
                o = i(956),
                s = i(1410),
                a = i(430),
                l = i(7905);
            class h extends PIXI.Container {
                constructor(t) {
                    super(), this.sortCallback = t, PIXI.utils.string2hex("#fbc217"), PIXI.utils.string2hex("#f57f20");
                    const e = PIXI.utils.string2hex("#ffffff"),
                        i = PIXI.utils.string2hex("#000000");
                    new n.PointerStateColorSet(r.GuiUtils.getARGB(e, 1))[o.PointerState.DISABLED] = r.GuiUtils.getARGB(e, .5), new n.PointerStateColorSet(r.GuiUtils.getARGB(i, 1))[o.PointerState.DISABLED] = r.GuiUtils.getARGB(i, .5), this.roundButton = new l.SortButton("RoundId", a.Helper.translate("TIME")), this.winButton = new l.SortButton("WinId", a.Helper.translate("WIN")), this.winButton.position.set(415, 0), this.roundButton.addClickCallback((() => this.click(this.roundButton))), this.winButton.addClickCallback((() => this.click(this.winButton))), this.roundButton.enable(!1), this.winButton.enable(!1), this.roundButton.toggled = !0, this.winButton.toggled = !1, this.addChild(this.roundButton, this.winButton)
                }
                enable(t) {
                    this.roundButton.enable(t), this.winButton.enable(t)
                }
                update(t) {
                    this.roundButton.toggled = !t, this.winButton.toggled = t
                }
                click(t) {
                    s.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this.sortCallback(t == this.winButton)
                }
            }
            e.SortControls = h
        },
        5972: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpinControls = void 0;
            const n = i(5892),
                r = i(7886),
                o = i(1410),
                s = i(6724),
                a = i(3606),
                l = i(2974),
                h = i(8760),
                u = i(2408),
                c = i(5991),
                d = i(361),
                p = i(8246),
                f = i(4514);
            class g extends PIXI.Container {
                constructor(t) {
                    super(), this._controller = t, this._spinsLeft = new n.PromoPanelTextLabel("", r.PromoPanelTextStyles.AS_ROUND_INFO_SPINS_LEFT_STYLE, {
                        landscapeMaxWidth: 100,
                        portraitMaxWidth: 100
                    });
                    const e = new a.PointerStateColorSet(4294967295);
                    let i = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_BTN_PLAY))),
                        p = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_BTN_PAUSE)));
                    this._playPauseBtn = new c.IconToggleButton(d.PromoPanelButtonIDs.PLAY_BTN, i, e, p), this._playPauseBtn.addClickCallback((() => {
                        o.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this._controller.onPlayPauseBtnClick()
                    })), this._playPauseBtn.toggled = !1, this._playPauseBtn.enable(!0), this._playPauseBtn.pivot.x = .5 * this._playPauseBtn.width, this._playPauseBtn.position.x = this._spinsLeft.position.x, this._playPauseBtn.position.y = .5 * this._spinsLeft.height + 10;
                    const f = new PIXI.Sprite(o.NolimitPromotionPlugin.imgLoader.getImgTexture(s.PromoPanelAssetConfig.ACTION_SPINS_PLAYED_ROUNDS_BG));
                    f.anchor.set(.5);
                    const g = d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_UP,
                        m = d.PromoPanelButtonIDs.ACTION_SPINS_COUNT_DOWN,
                        _ = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.BET_UP)));
                    this._upButton = new c.IconToggleButton(g, _, e), this._upButton.addClickCallback((() => this.buttonClick(this._upButton))), this._upButton.toggled = !1, this._upButton.pivot.set(38, 35), this._upButton.scale.set(.75, .75);
                    const y = new l.PointerStateIconSet(new h.Icon(u.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.BET_DOWN)));
                    this._downButton = new c.IconToggleButton(m, y, e), this._downButton.addClickCallback((() => this.buttonClick(this._downButton))), this._downButton.toggled = !1, this._downButton.pivot.set(38, 35), this._downButton.scale.set(.75, .75), this._divider = new PIXI.Sprite(PIXI.Texture.WHITE), this._divider.width = 2, this._divider.height = 50, this._divider.position.set(0, -80), this._divider.alpha = .6, this._upButton.enable(!0), this._downButton.enable(!0), this.addChild(f, this._spinsLeft, this._upButton, this._divider, this._downButton, this._playPauseBtn), this.resize()
                }
                resize() {
                    f.NolimitApplication.isLandscape ? (this._upButton.position.set(40, this._spinsLeft.position.y - 55), this._downButton.position.set(-40, this._spinsLeft.position.y - 55), this._divider.visible = this._upButton.visible) : (this._upButton.position.set(75, this._spinsLeft.position.y), this._downButton.position.set(-75, this._spinsLeft.position.y), this._divider.visible = !1)
                }
                togglePlayButton() {
                    return this._playPauseBtn.toggled = !this._playPauseBtn.toggled, this._playPauseBtn.toggled
                }
                setPlayState(t) {
                    this._playPauseBtn.toggled = t
                }
                enablePlayPauseBtn(t) {
                    this._playPauseBtn.enable(t), this._playPauseBtn.alpha = t ? p.PromoPanelConfig.ENABLE_BTN_ALPHA : p.PromoPanelConfig.DISABLE_BTN_ALPHA
                }
                setSpinsLeft(t) {
                    t <= 0 && this.enablePlayPauseBtn(!1), this._spinsLeft.text = t.toString()
                }
                enableRoundsButtons(t) {
                    this._divider.visible = t && f.NolimitApplication.isLandscape, this._upButton.visible = t, this._upButton.enable(t), this._downButton.visible = t, this._downButton.enable(t)
                }
                buttonClick(t) {
                    this._controller.asController.buttonClick(t)
                }
            }
            e.SpinControls = g
        },
        3151: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TopBar = void 0;
            const n = i(2408),
                r = i(6724),
                o = i(8766);
            class s extends PIXI.Container {
                constructor() {
                    super(), this.name = "TOP_BAR", this.bg = new PIXI.Sprite(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_INFO_BG)), this._placedBet = new o.SignLabel("placedBet", r.PromoPanelAssetConfig.ACTION_SPINS_MENU_BET), this._accumulatedBet = new o.SignLabel("accumulatedBet", r.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_MENU_TOTAL_BET), this._accumulatedWin = new o.SignLabel("accumulatedWin", r.PromoPanelAssetConfig.ACTION_SPINS_REPLAY_MENU_WIN), this._placedBet.align(o.SignLabelAlign.LEFT), this._accumulatedBet.align(o.SignLabelAlign.LEFT), this._accumulatedWin.align(o.SignLabelAlign.RIGHT), this._accumulatedWin.useDecimalCutoff = !1, this.addChild(this.bg), this.addChild(this._placedBet, this._accumulatedBet, this._accumulatedWin), this.resize()
                }
                resize() {
                    this._placedBet.onResize(), this._accumulatedBet.onResize(), this._accumulatedWin.onResize(), this.reAlign()
                }
                setPlacedBet(t) {
                    this._placedBet.value = t, this.reAlign()
                }
                setAccumulatedBet(t) {
                    this._accumulatedBet.value = t, this.reAlign()
                }
                setAccumulatedWin(t) {
                    this._accumulatedWin.value = t, this.reAlign()
                }
                getAccumulatedWin() {
                    return this._accumulatedWin.value
                }
                getAccumulatedBet() {
                    return this._accumulatedBet.value
                }
                reAlign() {
                    this._placedBet.position.set(26, 36), this._accumulatedBet.position.set(this._placedBet.x + this._placedBet.width + 10, 36), this._accumulatedWin.position.set(this.bg.width - 26, 36)
                }
            }
            e.TopBar = s
        },
        8948: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASSettingsModel = void 0;
            const n = i(1410),
                r = i(7835);
            e.ASSettingsModel = class {
                constructor() {
                    this.STOP_ON_BONUS = "stopOnBonus", this.callbacks = {}, this._stopOnBonus = !0, this._stopOnBonus = n.NolimitPromotionPlugin.getFromLocalStorage(r.LocalStorageSettingsKey.AS_STOP_ON_BONUS, this._stopOnBonus)
                }
                addCallback(t, e) {
                    this.callbacks[t] = this.callbacks[t] || [], this.callbacks[t].push(e)
                }
                triggerCallback(t, e) {
                    if (this.callbacks[t])
                        for (let i of this.callbacks[t]) i(e)
                }
                get stopOnBonus() {
                    return this._stopOnBonus
                }
                set stopOnBonus(t) {
                    this._stopOnBonus = t, n.NolimitPromotionPlugin.saveToLocalStorage(r.LocalStorageSettingsKey.AS_STOP_ON_BONUS, t), this.triggerCallback(this.STOP_ON_BONUS, t)
                }
            }
        },
        2674: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASStopSettings = void 0;
            const n = i(1410);
            class r {
                constructor() {
                    r.reset()
                }
                static get remainingRounds() {
                    return this._remainingRounds
                }
                static set remainingRounds(t) {
                    this._remainingRounds = t
                }
                static get minBalanceLimit() {
                    return this._minBalanceLimit
                }
                static set minBalanceLimit(t) {
                    this._minBalanceLimit = t, this._minBalanceLimitAmount = this.minBalanceLimit * n.NolimitPromotionPlugin.apiPlugIn.balance.getAmount()
                }
                static get minBalanceLimitAmount() {
                    return this._minBalanceLimitAmount
                }
                static get maxBalanceLimit() {
                    return this._maxBalanceLimit
                }
                static set maxBalanceLimit(t) {
                    this._maxBalanceLimit = t, this._maxBalanceLimitAmount = this.maxBalanceLimit * n.NolimitPromotionPlugin.apiPlugIn.balance.getAmount()
                }
                static get maxBalanceLimitAmount() {
                    return this._maxBalanceLimitAmount
                }
                static get xBetLimit() {
                    return this._xBetLimit
                }
                static set xBetLimit(t) {
                    this._xBetLimit = t
                }
                static get xBetLimitAmount() {
                    return this._xBetLimit * +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel()
                }
                static get shouldReset() {
                    return this._shouldReset
                }
                static set shouldReset(t) {
                    this._shouldReset = t
                }
                static get appliedBet() {
                    const t = n.NolimitPromotionPlugin.apiPlugIn.betHandler.betBoost;
                    return t ? t.calculatedPrice : +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel()
                }
                static reset() {
                    r.minBalanceLimit = 0, r.maxBalanceLimit = 0, r.xBetLimit = 0, r.remainingRounds = 0, r.shouldReset = !1
                }
                static update(t = !1) {
                    (r.shouldReset || t) && (r.minBalanceLimit = r._minBalanceLimit, r.maxBalanceLimit = r._maxBalanceLimit)
                }
            }
            e.ASStopSettings = r
        },
        5638: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.StopOnBonusTriggeredToggleBtn = void 0;
            const n = i(5991),
                r = i(3606),
                o = i(2974),
                s = i(8760),
                a = i(3663),
                l = i(1057),
                h = i(1410),
                u = i(6724),
                c = i(6439);
            class d extends n.IconToggleButton {
                constructor(t, e) {
                    const i = new r.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208),
                        n = new r.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231),
                        c = h.NolimitPromotionPlugin.imgLoader.getImgTexture(u.PromoPanelAssetConfig.ACTION_SPINS_GAME_CHECK_BOX_ACTIVE).clone(),
                        d = new o.PointerStateIconSet(new s.Icon(h.NolimitPromotionPlugin.imgLoader.getImgTexture(u.PromoPanelAssetConfig.ACTION_SPINS_GAME_CHECK_BOX_INACTIVE)));
                    if (super(t, new o.PointerStateIconSet(new s.Icon(c.clone())), i, d, n), this.toggleState = 0, this.enable(!0), this.addClickCallback((() => this.changeBtnState())), null != e) {
                        const t = new l.Label(e, a.GuiDefaults.DEFAULT_RADIO_BUTTON_LABEL);
                        t.anchor.set(0, .5), this.addSubComponent(t, {
                            x: 1,
                            y: .5
                        }, {
                            x: 20,
                            y: 0
                        })
                    }
                }
                changeBtnState() {
                    h.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this.toggleState = Number(!this.toggled), c.ActionSpinsController.settings.stopOnBonus = this.toggled
                }
            }
            e.StopOnBonusTriggeredToggleBtn = d
        },
        3851: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASGameOptionsView = void 0;
            const n = i(4931),
                r = i(1028),
                o = i(7835),
                s = i(1410),
                a = i(1558),
                l = i(1219);
            class h extends PIXI.Container {
                constructor(t, e) {
                    if (super(), this.selectedOptions = new Map, this.visibleSelectors = [], this.selectors = [], this.onSelection = t => {
                        const e = t.getSelection();
                        if (t.type == o.ASMainGamePickOptions.BOOSTED_BET) {
                            if (e) {
                                let i = "";
                                e.id > 0 && (i = this.getTotalXBetCostFromFeatureName((null == e ? void 0 : e.name) || "")), t.setTitleValue(i), e.displayValue = i
                            }
                        } else t.setTitleValue((null == e ? void 0 : e.name) || "");
                        this.selectedOptions.set(t.type, e), this.onUpdateCallback()
                    }, this.onUpdateCallback = e, this.originalOptionData = t, t.mainGame && (t.mainGame.type != o.ASMainGamePickOptions.BOOSTED_BET || s.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.boostedBetAllowed)) {
                        const e = new n.GameOptionSelectorComponent(t.mainGame.type, this.onSelection, t.mainGame.options, t.mainGame.header(), "");
                        this.selectors.push(e), this.selectedOptions.set(e.type, void 0)
                    }
                    if (t.bonusGame) {
                        const e = new n.GameOptionSelectorComponent(t.bonusGame.type, this.onSelection, t.bonusGame.options, t.bonusGame.header(), "");
                        this.selectors.push(e), this.selectedOptions.set(e.type, void 0)
                    }
                }
                init() {
                    for (let t of this.selectors) t.type == o.ASMainGamePickOptions.BOOSTED_BET && t.select(0), t.type == o.ASMainGamePickOptions.VOLATILITY && t.select(0), t.type == o.ASBonusPickOptions.PICK_MODE && t.select(0), t.type == o.ASBonusPickOptions.ROW_OPTIONS && t.select(0)
                }
                enableBonusOption(t) {
                    for (let e of this.selectors) e.type != o.ASBonusPickOptions.ROW_OPTIONS && e.type != o.ASBonusPickOptions.PICK_MODE || (e.enable(t), t ? this.selectedOptions.set(e.type, e.getSelection()) : this.selectedOptions.delete(e.type))
                }
                setVisibleSelectors(t, e, i) {
                    this.removeChild(...this.visibleSelectors), this.visibleSelectors = [];
                    for (let n of this.selectors) n.type == o.ASMainGamePickOptions.BOOSTED_BET && e && this.visibleSelectors.push(n), n.type == o.ASMainGamePickOptions.VOLATILITY && i && this.visibleSelectors.push(n), n.type == o.ASBonusPickOptions.PICK_MODE && t && this.visibleSelectors.push(n), n.type == o.ASBonusPickOptions.ROW_OPTIONS && t && this.visibleSelectors.push(n);
                    this.visibleSelectors.length > 0 && (r.GuiLayout.align(this.visibleSelectors, 25, r.Align.LEFT, r.Direction.VERTICAL), this.addChild(...this.visibleSelectors))
                }
                onUpdateBet() {
                    for (let t of this.selectors) {
                        if (t.type == o.ASMainGamePickOptions.BOOSTED_BET) {
                            const e = t.getSelection();
                            if (e) {
                                let i = "";
                                e.id > 0 && (i = this.getTotalXBetCostFromFeatureName((null == e ? void 0 : e.name) || "")), t.setTitleValue(i), e.displayValue = i
                            }
                        }
                        t.type == o.ASMainGamePickOptions.VOLATILITY && this.visibleSelectors.push(t)
                    }
                }
                isAllMandatorySelected() {
                    for (let t of this.selectedOptions.values())
                        if (null == t) return !1;
                    return !0
                }
                getTotalXBetCostFromFeatureName(t) {
                    const e = a.ResponseParser.getBoostCost(t),
                        i = s.NolimitPromotionPlugin.apiPlugIn.currency.format(+e);
                    return s.NolimitPromotionPlugin.apiPlugIn.translations.translate(l.PromoPanelLabelIDs.TOTAL_COST) + " " + i
                }
            }
            e.ASGameOptionsView = h
        },
        865: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ASTopMenuToggleButton = void 0;
            const n = i(5991),
                r = i(3606),
                o = i(9756),
                s = i(2974),
                a = i(8760),
                l = i(2408),
                h = i(6724),
                u = i(5892),
                c = i(7886);
            class d extends n.IconToggleButton {
                constructor(t, e) {
                    super(t, new s.PointerStateIconSet(new a.Icon(l.ImgLoader.getImgTexture(h.PromoPanelAssetConfig.GAME_TYPE_ACTIVE))), new r.PointerStateColorSet(o.GuiUtils.getARGB(PIXI.utils.string2hex("#f57f20"))), new s.PointerStateIconSet(new a.Icon(l.ImgLoader.getImgTexture(h.PromoPanelAssetConfig.GAME_TYPE_INACTIVE)))), this.label = this.createLabel(e, 250), this.label.onResize(), this.addSubComponent(this.label, {
                        x: .5,
                        y: .5
                    }, {
                        x: 0,
                        y: 0
                    })
                }
                get toggled() {
                    return super.toggled
                }
                set toggled(t) {
                    super.toggled = t, this.updateLabel()
                }
                updateLabel() {
                    this.toggled ? this.label.setColor(o.GuiUtils.getARGB(PIXI.utils.string2hex("#ffffff"))) : this.label.setColor(o.GuiUtils.getARGB(PIXI.utils.string2hex("#f57f20"))), this.addSubComponent(this.label, {
                        x: .5,
                        y: .5
                    }, {
                        x: 0,
                        y: 0
                    })
                }
                createLabel(t, e) {
                    const i = new u.PromoPanelTextLabel(t, c.PromoPanelTextStyles.ACTION_SPINS_MAIN_GAME_LABEL, {
                        landscapeMaxWidth: e,
                        portraitMaxWidth: e
                    });
                    return i.anchor.set(.5, .5), i
                }
            }
            e.ASTopMenuToggleButton = d
        },
        1974: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameOptionButton = void 0;
            const n = i(393),
                r = i(2408),
                o = i(6724),
                s = i(3815);
            class a extends n.GuiToggleButton {
                constructor(t) {
                    super(t.name, (() => this.toggleCallback())), this.data = t;
                    const e = new PIXI.Container;
                    if (t.image) {
                        let i = r.ImgLoader.getImgTexture(t.image);
                        i.baseTexture.setResolution(2);
                        const n = new PIXI.Sprite(i),
                            s = new PIXI.Sprite(r.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.ACTION_SPINS_OPTIONS_BUTTON_MASK));
                        e.addChild(n), e.addChild(s), n.mask = s
                    }
                    const i = new PIXI.Container;
                    this.onSprite = new PIXI.Sprite(r.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.ACTION_SPINS_OPTIONS_BUTTON_ACTIVE)), this.offSprite = new PIXI.Sprite(r.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.ACTION_SPINS_OPTIONS_BUTTON_INACTIVE)), i.addChild(this.offSprite, this.onSprite), this.addChild(i), this.addChild(e)
                }
                virtualClick() {
                    this.onClick()
                }
                toggleCallback() {
                    this.onSprite.visible = this.toggleState == s.ToggleState.ON, this.offSprite.visible = !this.onSprite.visible
                }
            }
            e.GameOptionButton = a
        },
        4931: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameOptionSelectorComponent = void 0;
            const n = i(1057),
                r = i(1028),
                o = i(7886),
                s = i(1974),
                a = i(2408),
                l = i(6724),
                h = i(1410),
                u = i(1219);
            class c extends PIXI.Container {
                constructor(t, e, i, r, a = "", l = !1) {
                    super(), this.buttons = [], this._enabled = !0, this.skipSound = !1, this.type = t, this.stateChangeCallback = e, this.deselectable = l, this.textContainer = new PIXI.Container, this.title = new n.Label(r, o.PromoPanelTextStyles.ACTION_SPINS_OPTIONS_TITLE), this.titleValue = new n.Label(a, o.PromoPanelTextStyles.ACTION_SPINS_OPTIONS_VALUE), this.textContainer.addChild(this.title, this.titleValue), this.buttonsContainer = new PIXI.Container;
                    for (let t of i) {
                        t.header = r;
                        const e = new s.GameOptionButton(t);
                        e.addClickCallback((() => {
                            this.buttonClicked(e)
                        })), e.toggled = !1, e.enable(!0), this.buttons.push(e), this.buttonsContainer.addChild(e)
                    }
                    this.updateLayout(!1, 633), this.addChild(this.textContainer, this.buttonsContainer)
                }
                enable(t) {
                    this._enabled = t, this.alpha = t ? 1 : .4
                }
                addContinueButtonGraphics() {
                    for (let t of this.buttons) {
                        const e = new PIXI.Container,
                            i = new PIXI.Sprite(a.ImgLoader.getImgTexture(l.PromoPanelAssetConfig.ACTION_SPINS_GAME_CONTINUE_SMALL));
                        i.anchor.set(0, 0);
                        const r = new n.Label(h.NolimitPromotionPlugin.apiPlugIn.translations.translate(u.PromoPanelLabelIDs.CONTINUE), o.PromoPanelTextStyles.AS_ROUND_INFO_CONTINUE_STYLE);
                        r.anchor.set(0, .5), r.position.set(i.width + 5, .5 * i.height), e.addChild(i, r), e.pivot.set(.5 * e.width, 0), e.position.set(.5 * t.width, t.height + 5), t.addChild(e)
                    }
                }
                updateLayout(t, e) {
                    t ? (r.GuiLayout.align([this.title, this.titleValue], 10, r.Align.LEFT, r.Direction.HORIZONTAL), r.GuiLayout.align(this.buttons, 25, r.Align.CENTER, r.Direction.HORIZONTAL), r.GuiLayout.align([this.textContainer, this.buttonsContainer], 10, r.Align.LEFT, r.Direction.VERTICAL), this.buttonsContainer.position.x = .5 * (e - this.buttonsContainer.width)) : (r.GuiLayout.align([this.title, this.titleValue], 10, r.Align.LEFT, r.Direction.HORIZONTAL), r.GuiLayout.align(this.buttons, 25, r.Align.CENTER, r.Direction.HORIZONTAL), r.GuiLayout.align([this.textContainer, this.buttonsContainer], 10, r.Align.LEFT, r.Direction.VERTICAL), this.buttonsContainer.position.x = 60)
                }
                getSelection() {
                    return this.selection
                }
                setTitleValue(t) {
                    this.titleValue.text = t
                }
                select(t) {
                    this.skipSound = !0, this.buttons[t].virtualClick()
                }
                buttonClicked(t) {
                    if (this._enabled)
                        if (this.skipSound || h.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this.skipSound = !1, t.toggled) this.deselectable && (t.toggled = !1, this.selection = void 0, this.stateChangeCallback(this));
                        else {
                            t.toggled = !0;
                            for (let e of this.buttons) e != t && (e.toggled = !1);
                            this.selection = t.data, this.stateChangeCallback(this)
                        }
                }
            }
            e.GameOptionSelectorComponent = c
        },
        9493: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitBonusController = void 0;
            const n = i(5851),
                r = i(1410),
                o = i(4514),
                s = i(5016),
                a = i(361),
                l = i(8680);
            e.NolimitBonusController = class {
                constructor(t, e) {
                    this._featureData = [], this._promotionPlugin = t, this._featureData = e, this._betLevels = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels()
                }
                createView(t) {
                    this._view = new n.NolimitBonusView(this, t), this._view.createGameFeatureList(this._featureData), this.addEventListeners()
                }
                buttonClick(t, e, i = !1) {
                    switch (l.Logger.logDev("BuyFeature controller :: onButtonClick", t), !i && r.NolimitPromotionPlugin.sound.playKeypadEffect("click"), t.name) {
                        case a.PromoPanelButtonIDs.BET_DOWN:
                            this.onBetDownBtnPressed();
                            break;
                        case a.PromoPanelButtonIDs.BET_UP:
                            this.onBetUpBtnPressed();
                            break;
                        case a.PromoPanelButtonIDs.BUY:
                            if (null == e) return void l.Logger.warn("featureData is undefined");
                            this.onBuyBtnPressed(e);
                            break;
                        case a.PromoPanelButtonIDs.OK_BTN:
                            this.onPopUpOkBtnPressed(e);
                            break;
                        case a.PromoPanelButtonIDs.POP_UP_CLOSE:
                            this.onPopUpCloseBtnPressed();
                            break;
                        case a.PromoPanelButtonIDs.CLOSE:
                            this._promotionPlugin.buttonClick(t);
                            break;
                        default:
                            l.Logger.warn("Button click : default case : ", t)
                    }
                }
                onBetDownBtnPressed() {
                    let t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
                        e = this._betLevels.indexOf(t); - 1 != e ? (--e, r.NolimitPromotionPlugin.apiPlugIn.betLevel.setLevel(this._betLevels[e]), this.updateBetButtons(e)) : l.Logger.warn("Error invalid bet index : ", e)
                }
                onBetUpBtnPressed() {
                    let t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
                        e = this._betLevels.indexOf(t); - 1 != e ? (++e, r.NolimitPromotionPlugin.apiPlugIn.betLevel.setLevel(this._betLevels[e]), this.updateBetButtons(e)) : l.Logger.warn("Error invalid bet index : ", e)
                }
                addEventListeners() {
                    o.NolimitApplication.events.on(s.PromoPanelEvents.BALANCE_UPDATE_EVENT, (t => this.onBalanceUpdate(t))), o.NolimitApplication.events.on(s.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.onNavButtonPressed(t)))
                }
                onNavButtonPressed(t) {
                    t == a.PromoPanelButtonIDs.NOLIMIT_BONUS ? this.open() : this.close()
                }
                onBalanceUpdate(t) {
                    this._view && (this.setBetLevels(), this._view.onBalanceUpdate(t))
                }
                updateBetButtons(t) {
                    const e = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    this._view.onBetChange(e), this._view.betPanel.betSelector.enableUpButton(!1), this._view.betPanel.betSelector.enableDownButton(!1);
                    const i = this._view.updateFeaturePrice(e),
                        n = r.NolimitPromotionPlugin.apiPlugIn.balance.getAmount();
                    t < this._betLevels.length - 1 && +this._betLevels[t] < n && i < n && this.view.getNextBetMinFeaturePrice(this._betLevels[t + 1]) <= n && this._view.betPanel.betSelector.enableUpButton(!0), t > 0 && this._view.betPanel.betSelector.enableDownButton(!0)
                }
                onBuyBtnPressed(t) {
                    this.view.openPopUp(t)
                }
                onPopUpOkBtnPressed(t) {
                    null != t && (r.NolimitPromotionPlugin.apiPlugIn.betHandler.buyFeatureBet(t.name), this._view.closePopUp(), this._promotionPlugin.close(!0))
                }
                onPopUpCloseBtnPressed() {
                    this._view.closePopUp()
                }
                open() {
                    this._view.open(), this.setBetLevels(), this._view.closePopUp()
                }
                close() {
                    this._view.close()
                }
                setBetLevels() {
                    if (this._betLevels = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getAvailableLevels(), this._betLevels.length) {
                        let t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
                            e = this._betLevels.indexOf(t); - 1 != e && this.updateBetButtons(e)
                    } else {
                        this._betLevels = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getUnavailableLevels();
                        let t = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(),
                            e = this._betLevels.indexOf(t); - 1 != e && this.updateBetButtons(e)
                    }
                }
                get view() {
                    return this._view
                }
                set view(t) {
                    this._view = t
                }
                get promotionPlugin() {
                    return this._promotionPlugin
                }
            }
        },
        5851: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitBonusView = void 0;
            const n = i(3672),
                r = i(5023),
                o = i(8987),
                s = i(4514),
                a = i(6724),
                l = i(1219),
                h = i(8246),
                u = i(1410),
                c = i(430),
                d = i(7886),
                p = i(2408),
                f = i(361);
            class g extends n.FeatureBasePanel {
                constructor(t, e) {
                    super(a.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON, u.NolimitPromotionPlugin.apiPlugIn.translations.translate(l.PromoPanelLabelIDs.BUY_FEATURE_TITLE), d.PromoPanelTextStyles.FEATURE_BASE_BUY_FEATURE_TITLE), this._featureBuyTickets = [], this._controller = t, this._featureContainer = new PIXI.Container, this._featureContainer.name = "FEATURE_CONTAINER", this._scroll = e, this.init()
                }
                onBetChange(t) {
                    this.betPanel.setValue(+t)
                }
                onBalanceUpdate(t) {
                    this._featureBuyTickets.forEach((t => {
                        t.updateButtons()
                    }))
                }
                init() {
                    super.init(), this.betPanel = new r.BetPanelView(f.PromoPanelButtonIDs.BET_UP, f.PromoPanelButtonIDs.BET_DOWN, (t => this._controller.buttonClick(t)), PIXI.utils.string2hex("#d61d49")), this.addChild(this.betPanel), this.addChild(this._featureContainer), this.popUp = this._controller.promotionPlugin.view.popUpView
                }
                createGameFeatureList(t) {
                    this._featureContainer.removeChildren(), this._featureBuyTickets.length = 0;
                    const e = p.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.BUY_BTN);
                    for (let i of t) {
                        const t = new o.FeatureBuyTicket(i, ((t, e) => this._controller.buttonClick(t, e)), e);
                        this._featureContainer.addChild(t), this._featureBuyTickets.push(t)
                    }
                    this._scroll.scrollEnabled = !0, this._scroll.updateContent()
                }
                close() {
                    this.closePopUp(), super.close(), this._scroll.visible = !1
                }
                openPopUp(t) {
                    this.popUp.openBonusBuy(((t, e) => this._controller.buttonClick(t, e)), t)
                }
                closePopUp() {
                    this.popUp.close(), this._scroll.updateContent()
                }
                show() {
                    this.betPanel.visible = !0, this._scroll.visible = !0, super.show(), this._scroll.scrollEnabled = !0, this._scroll.updateContent()
                }
                hide() {
                    this.betPanel.visible = !1, this._scroll.visible = !1, super.hide()
                }
                updateFeaturePrice(t) {
                    let e = Number.MAX_VALUE;
                    return this._featureBuyTickets.forEach((i => {
                        i.updatePrice(t), e = Math.min(e, i.price)
                    })), e
                }
                getNextBetMinFeaturePrice(t) {
                    let e = Number.MAX_VALUE;
                    return this._featureBuyTickets.forEach((i => {
                        i.updateNextBetPrice(t), e = Math.min(e, i.nextBetPrice)
                    })), +e.toFixed(2)
                }
                onResize() {
                    if (this._isOpen) {
                        const t = s.NolimitApplication.screenBounds,
                            e = s.NolimitApplication.isLandscape && c.Helper.isDefaultScreenRatio(t),
                            i = new PIXI.Rectangle(h.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0, t.width - h.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - u.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
                        if (e) this._scroll.addChild(this.betPanel), this._featureContainer.y = 162;
                        else if (s.NolimitApplication.isLandscape && !c.Helper.isDefaultScreenRatio(t)) this.addChild(this.betPanel), this._featureContainer.y = 328;
                        else {
                            this.addChild(this.betPanel), this._featureContainer.y = 328;
                            const e = p.ImgLoader.getImgTexture(a.PromoPanelAssetConfig.TOP_BAR).height - 10;
                            i.width = t.width, i.height = t.height - u.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - h.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, i.x = 0, i.y = e
                        }
                        if (this._scroll.resize(i.width, i.height), this._scroll.position.set(i.x, i.y), this.betPanel.resize(e), super.onResize(), this.position.set(0, 0), this._featureBuyTickets.forEach(((t, i) => {
                            t.resize(e)
                        })), e) {
                            const t = this._featureBuyTickets[0].width;
                            let e = 17;
                            const n = t + e + this.betPanel.width;
                            let r = .5 * (i.width - n);
                            r < -7 && (e -= 2 * Math.abs(r) + 7, r = -7), this.betPanel.x = r + t + e, this.betPanel.y = this._featureContainer.y;
                            let o = 0;
                            for (let t of this._featureBuyTickets) t.x = r, t.y = o, o += t.height + 5
                        } else {
                            const t = i.width;
                            this.betPanel.x = .5 * (t - this.betPanel.width), this.betPanel.y = this._featureContainer.y - 33 - this.betPanel.height;
                            let e = 0;
                            for (let i of this._featureBuyTickets) i.x = .5 * (t - i.width), i.y = e, e += i.height + 5
                        }
                        this._scroll.updateContent()
                    }
                }
            }
            e.NolimitBonusView = g
        },
        605: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BonusBuyPopUpContent = void 0;
            const n = i(2408),
                r = i(1410),
                o = i(1057),
                s = i(2379),
                a = i(7886),
                l = i(1219);
            class h extends PIXI.Container {
                constructor(t) {
                    super(), this.featureName = t.name, this.featureImage = new PIXI.Sprite(n.ImgLoader.getImgTexture(t.name)), this.featureImage.anchor.set(.5, .5), this.bet = r.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel(), this.price = +this.bet * t.price, this.priceString = s.CurrencyUtils.formatWithDecimalCutOff(this.price), this.priceLabel = new o.Label(this.priceString, a.PromoPanelTextStyles.POP_UP_FORMATTED_PRICE), this.priceLabel.anchor.set(.5, .5), this.textLabel = new o.Label(r.NolimitPromotionPlugin.apiPlugIn.translations.translate(l.PromoPanelLabelIDs.CHARGE_FROM_WALLET), a.PromoPanelTextStyles.POP_UP_CHARGE_FROM_WALLET_TEXT), this.textLabel.anchor.set(.5, .5), this.featureImage.position.set(0, 150), this.priceLabel.position.set(0, 340), this.textLabel.position.set(0, 380), this.addChild(this.featureImage, this.priceLabel, this.textLabel)
                }
            }
            e.BonusBuyPopUpContent = h
        },
        8121: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ConfirmBetPopUpView = void 0;
            const n = i(2408),
                r = i(6724),
                o = i(3606),
                s = i(361),
                a = i(4524),
                l = i(1410),
                h = i(1219),
                u = i(7886),
                c = i(8246),
                d = i(1057),
                p = i(4514),
                f = i(1653),
                g = i(5383),
                m = i(1028),
                _ = i(6358),
                y = i(2379),
                S = i(605);
            class v extends PIXI.Container {
                get isOpen() {
                    return this.visible
                }
                constructor() {
                    super(), this.init()
                }
                resize() {
                    this._background.width = p.NolimitApplication.screenBounds.width, this._background.height = p.NolimitApplication.screenBounds.height, this._background.position.set(0, 0);
                    const t = p.NolimitApplication.isLandscape ? 0 : p.NolimitApplication.screenBounds.height - this._popUpPlate.height;
                    this._popUpPlate.position.set(.5 * p.NolimitApplication.screenBounds.width, .5 * t)
                }
                openBonusBuy(t, e) {
                    var i;
                    let n = this.createBonusBuyContent(e);
                    (null === (i = l.NolimitPromotionPlugin.promoPanelGameConfiguration) || void 0 === i ? void 0 : i.replaceBonusBuyPopUpContent) && (n = l.NolimitPromotionPlugin.promoPanelGameConfiguration.replaceBonusBuyPopUpContent(n)), this._contentContainer.addChild(n), this._buttonClickCallback = t, this._featureData = e, this.show()
                }
                openActionSpins(t, e) {
                    const i = this.createActionSpinsContent(e);
                    this._contentContainer.addChild(i), this._buttonClickCallback = t, this._featureData = e.featureData, this.show()
                }
                close() {
                    this._buttonClickCallback = void 0, this._contentContainer.removeChildren(), this.blinkAnim && (this.blinkAnim.pause(), this.blinkAnim = void 0), this._featureData = void 0, this.hide()
                }
                init() {
                    this._background = new PIXI.Sprite(PIXI.Texture.WHITE), this._background.tint = 0, this._background.alpha = .6, this._background.interactive = !0, this._background.name = "_background", this._popUpPlate = new PIXI.NineSlicePlane(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.POP_UP_BG), 64, 64, 64, 64), this._popUpPlate.width = 640, this._popUpPlate.height = 700, this._popUpPlate.pivot.set(.5 * this._popUpPlate.width, 0), this._popUpPlate.name = "_popUpPlate";
                    let t = new o.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231),
                        e = new o.PointerStateColorSet(4278190080, 4294966272, 4278190080, 872414208);
                    this._cancelButton = new a.PromoPanelLabelButton(s.PromoPanelButtonIDs.POP_UP_CLOSE, l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.POPUP_CANCEL), e, t, u.PromoPanelTextStyles.GAME_FEATURE_OK_TEXT, void 0, (0, a.createDefaultButtonStroke)()), this._cancelButton.setSize(c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.width, c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.height), this._cancelButton.enable(!0), this._cancelButton.addClickCallback((() => {
                        this.buttonClicked(this._cancelButton)
                    })), this._okButton = new a.PromoPanelLabelButton(s.PromoPanelButtonIDs.OK_BTN, l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.POPUP_OK), e, t, u.PromoPanelTextStyles.GAME_FEATURE_OK_TEXT, void 0, (0, a.createDefaultButtonStroke)()), this._okButton.setSize(c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.width, c.PromoPanelConfig.DEFAULT_LARGE_BUTTON_SIZE.height), this._okButton.enable(!0), this._okButton.addClickCallback((() => {
                        this.buttonClicked(this._okButton)
                    })), this._cancelButton.resize(30), this._okButton.resize(30);
                    const i = Math.max(this._cancelButton.width, this._okButton.width);
                    this._cancelButton.setSize(i, this._cancelButton.height), this._okButton.setSize(i, this._okButton.height), this._okButton.pivot.set(0, 0), this._cancelButton.pivot.set(0, 0);
                    const d = new PIXI.Container;
                    d.addChild(this._cancelButton, this._okButton), d.position.set(320, 590), m.GuiLayout.align([this._cancelButton, this._okButton], 30, m.Align.LEFT, m.Direction.HORIZONTAL), d.pivot.set(.5 * d.width, .5 * d.height), this._contentContainer = new PIXI.Container, this._contentContainer.name = "content", this._contentContainer.position.set(320, 48), this._popUpPlate.addChild(d, this._contentContainer), this.addChild(this._background, this._popUpPlate), this.close()
                }
                buttonClicked(t) {
                    l.NolimitPromotionPlugin.sound.playKeypadEffect("click"), this._buttonClickCallback && this._buttonClickCallback(t, this._featureData)
                }
                show() {
                    this.resize(), this.visible = !0, this._background.alpha = 0, _.TweenMax.to(this._background, .1, {
                        alpha: .6
                    })
                }
                hide() {
                    this.visible = !1
                }
                createBonusBuyContent(t) {
                    return new S.BonusBuyPopUpContent(t)
                }
                createActionSpinsContent(t) {
                    const e = new PIXI.Container,
                        i = new PIXI.Container;
                    i.name = "Header";
                    const o = new d.Label(h.PromoPanelLabelIDs.ACTION_SPINS, u.PromoPanelTextStyles.ACTION_SPINS_SETTINGS_HEADER);
                    if (i.addChild(o), t.isBonusBuy) {
                        const t = new PIXI.TextStyle({
                            fontFamily: f.OpenSans.FAMILY,
                            fontSize: 14,
                            fontStyle: g.FontStyle.NORMAL,
                            fontWeight: g.FontWeight.BOLD,
                            fill: 0,
                            wordWrap: !0,
                            wordWrapWidth: 500,
                            align: "center"
                        }),
                            e = l.NolimitPromotionPlugin.apiPlugIn.translations.translate("Warning! You are about to play Nolimit Bonus in Hyper speed!"),
                            s = new d.Label(e, t);
                        s.position.set(.5 * (500 - s.width), o.y + o.height + 15);
                        const a = new PIXI.Sprite(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.NAV_NOLIMIT_BONUS));
                        a.scale.set(.5, .5), a.anchor.set(1, 0), a.position.set(500, -9), this.blinkAnim = _.TweenMax.fromTo(a, .8, {
                            alpha: 0
                        }, {
                            alpha: 1,
                            repeat: -1,
                            yoyo: !0,
                            ease: _.Expo.easeInOut
                        }), i.addChild(s, a)
                    }
                    const s = new PIXI.Container,
                        a = [],
                        c = this.createBasicAsSetting(l.NolimitPromotionPlugin.apiPlugIn.translations.translate("Bet"), t.bet);
                    a.push(c);
                    const p = this.createBasicAsSetting(l.NolimitPromotionPlugin.apiPlugIn.translations.translate("Rounds"), t.rounds + "");
                    if (a.push(p), m.GuiLayout.align(a, 40, m.Align.LEFT, m.Direction.HORIZONTAL), s.addChild(...a), s.pivot.set(.5 * s.width, 0), t.image) {
                        const i = new PIXI.Sprite(n.ImgLoader.getImgTexture(t.image));
                        i.anchor.set(.5, .5), i.position.set(0, 200), e.addChild(i)
                    }
                    const S = new PIXI.Container,
                        v = [];
                    if (t.isBonusBuy && t.featureData) {
                        const e = +l.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel() * t.featureData.price * t.rounds;
                        v.push(this.createOneLabelOption(`(${t.bet} x ${t.rounds} = ${y.CurrencyUtils.formatWithDecimalCutOff(e)})`))
                    }
                    if (t.options)
                        for (let e of t.options) null != e.displayValue ? v.push(this.createOption(e.header || "", e.displayValue)) : v.push(this.createOption(e.header || "", e.name));
                    return t.stopOnBonus && v.push(this.createOption(l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.STOP_ON_BONUS), l.NolimitPromotionPlugin.apiPlugIn.translations.translate(h.PromoPanelLabelIDs.YES))), v.length > 0 && (m.GuiLayout.align(v, 10, m.Align.CENTER, m.Direction.VERTICAL), S.addChild(...v)), S.pivot.set(.5 * S.width, 0), i.position.set(-250, 0), s.position.set(0, 350), S.position.set(0, 430), e.addChild(i, s, S), e
                }
                createBasicAsSetting(t, e) {
                    const i = new PIXI.TextStyle({
                        fontFamily: f.OpenSans.FAMILY,
                        fontSize: 20,
                        fontStyle: g.FontStyle.NORMAL,
                        fontWeight: g.FontWeight.LIGHT,
                        fill: 0
                    });
                    let n = new PIXI.TextStyle({
                        fontFamily: f.OpenSans.FAMILY,
                        fontSize: 35,
                        fontStyle: g.FontStyle.NORMAL,
                        fontWeight: g.FontWeight.NORMAL,
                        fill: 0
                    });
                    const r = new d.Label(t, i),
                        o = new d.Label(e, n);
                    m.GuiLayout.align([r, o], 0, m.Align.CENTER, m.Direction.VERTICAL);
                    const s = new PIXI.Container;
                    return s.addChild(r, o), s.name = t, s
                }
                createOption(t, e) {
                    const i = new PIXI.TextStyle({
                        fontFamily: f.OpenSans.FAMILY,
                        fontSize: 20,
                        fontStyle: g.FontStyle.NORMAL,
                        fontWeight: g.FontWeight.NORMAL,
                        fill: 0
                    });
                    let n = new PIXI.TextStyle({
                        fontFamily: f.OpenSans.FAMILY,
                        fontSize: 20,
                        fontStyle: g.FontStyle.NORMAL,
                        fontWeight: g.FontWeight.BOLD,
                        fill: 0
                    });
                    const r = new d.Label(t, i),
                        o = new d.Label(e, n);
                    m.GuiLayout.align([r, o], 10, m.Align.LEFT, m.Direction.HORIZONTAL);
                    const s = new PIXI.Container;
                    return s.addChild(r, o), s.name = t, s
                }
                createOneLabelOption(t) {
                    let e = new PIXI.TextStyle({
                        fontFamily: f.OpenSans.FAMILY,
                        fontSize: 20,
                        fontStyle: g.FontStyle.NORMAL,
                        fontWeight: g.FontWeight.BOLD,
                        fill: 0
                    });
                    const i = new d.Label(t, e);
                    i.anchor.set(0, .5);
                    const n = new PIXI.Container;
                    return n.addChild(i), n
                }
            }
            e.ConfirmBetPopUpView = v
        },
        734: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ReplayController = void 0;
            const n = i(4167),
                r = i(1410),
                o = i(4514),
                s = i(5016),
                a = i(361),
                l = i(1077),
                h = i(6840),
                u = i(8246),
                c = i(8680),
                d = i(3486);
            e.ReplayController = class {
                constructor(t) {
                    this._isRequestCompleted = !0, this._isCurrentGame = !0, this._isXBet = !0, this._isSinglePlayer = !1, this._promotionPlugin = t, this.init()
                }
                static makeIFrame(t) {
                    const e = document.createElement("iframe");
                    return e.name = t, e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.zIndex = "2147483647", e.style.overflow = "hidden", e.style.backgroundColor = "black", e.setAttribute("frameborder", "0"), e.setAttribute("allowfullscreen", ""), e.setAttribute("sandbox", "allow-forms allow-scripts allow-same-origin allow-top-navigation allow-popups"), e.setAttribute("allowfullscreen", ""), e.setAttribute("allow", "autoplay; fullscreen"), e.id = t, e
                }
                init() {
                    this._communication = new h.Communication(r.NolimitPromotionPlugin.apiPlugIn), this.addEventListeners()
                }
                addEventListeners() {
                    o.NolimitApplication.events.on(s.PromoPanelEvents.NAV_BUTTON_PRESSED, (t => this.onNavButtonPressed(t)))
                }
                createView(t) {
                    null == this._view && (this._view = new n.ReplayView(this, t))
                }
                open() {
                    this._view && (this._view.open(), this.isCurrentGame ? this.buttonClick(new l.GuiButton(a.PromoPanelButtonIDs.CURRENT_GAME_BTN), void 0, !0) : this.buttonClick(new l.GuiButton(a.PromoPanelButtonIDs.ALL_GAME_BTN), void 0, !0))
                }
                close() {
                    this._view && this._view.close()
                }
                buttonClick(t, e, i = !1) {
                    if (this._isRequestCompleted) switch (!i && r.NolimitPromotionPlugin.sound.playKeypadEffect("click"), t.name) {
                        case a.PromoPanelButtonIDs.CURRENT_GAME_BTN:
                            this.isCurrentGame = !0, this.getData();
                            break;
                        case a.PromoPanelButtonIDs.ALL_GAME_BTN:
                            this.isCurrentGame = !1, this.getData();
                            break;
                        case a.PromoPanelButtonIDs.SINGLE_PLAYER_BTN:
                            this.isSinglePlayer = !0, this.getData();
                            break;
                        case a.PromoPanelButtonIDs.ALL_PLAYER_BTN:
                            this.isSinglePlayer = !1, this.getData();
                            break;
                        case a.PromoPanelButtonIDs.X_BET_FILTER_BTN:
                            this.isXBet = !0, this.getData();
                            break;
                        case a.PromoPanelButtonIDs.X_WIN_FILTER_BTN:
                            this.isXBet = !1, this.getData();
                            break;
                        default:
                            c.Logger.warn("Replay Controller Button click :: no case match : ", t)
                    }
                }
                openReplay(t) {
                    r.NolimitPromotionPlugin.apiPlugIn.openReplay(t)
                }
                getTopMonetaryData(t) {
                    this._isRequestCompleted = !1, this._communication.getTopMonetaryData(t).then((t => {
                        this._view.update(t.rounds), this._isRequestCompleted = !0
                    }), (t => {
                        c.Logger.warn("ReplayController : promise reject data : ", t)
                    }))
                }
                getXBetGameSpecificData(t, e) {
                    this._isRequestCompleted = !1, this._communication.getXBetGameSpecificData(t, e).then((t => {
                        this._view.update(t.rounds), this._isRequestCompleted = !0
                    }), (t => {
                        c.Logger.warn("ReplayController : promise reject data : ", t)
                    }))
                }
                getMonetaryGameSpecificData(t, e) {
                    this._isRequestCompleted = !1, this._communication.getMonetaryGameSpecificData(t, e).then((t => {
                        this._view.update(t.rounds), this._isRequestCompleted = !0
                    }), (t => {
                        c.Logger.warn("ReplayController : promise reject data : ", t)
                    }))
                }
                onNavButtonPressed(t) {
                    t == a.PromoPanelButtonIDs.NOLIMIT_WINNERS ? this.open() : this.close()
                }
                receiveMessage(t) {
                    var e;
                    "exit-replay" === t.data && (null === (e = document.getElementById("replayIframe")) || void 0 === e || e.remove(), r.NolimitPromotionPlugin.sound.resume(), this._replayGameWindow && (this._replayGameWindow.close(), this._replayGameWindow = null))
                }
                getData() {
                    this._view.update([]), this._view.playLoadingAnimation();
                    const t = r.NolimitPromotionPlugin.apiPlugIn.options.operator;
                    let e = r.NolimitPromotionPlugin.apiPlugIn.options.game;
                    e = e.replace(u.PromoPanelConfig.GAME_NAME_FILTER_REG_EXP, ""), this.isCurrentGame ? this.isSinglePlayer ? this._isXBet ? this.getCurrentPlayerCurrentGameTopList(d.ReplayFilterTypes.MULTIPLIER) : this.getCurrentPlayerCurrentGameTopList(d.ReplayFilterTypes.MONETARY) : this._isXBet ? this.getXBetGameSpecificData(e, t) : this.getMonetaryGameSpecificData(e, t) : this.isSinglePlayer ? this._isXBet ? this.getCurrentPlayerAllGameTopList(d.ReplayFilterTypes.MULTIPLIER) : this.getCurrentPlayerAllGameTopList(d.ReplayFilterTypes.MONETARY) : this._isXBet ? this.getTopXBetData(t) : this.getTopMonetaryData(t)
                }
                getCurrentPlayerCurrentGameTopList(t) {
                    this._isRequestCompleted = !1, this._communication.getTopListCurrentGame(t).then((t => {
                        this._view.update(t), this._isRequestCompleted = !0
                    }), (t => {
                        c.Logger.warn("ReplayController : promise reject data : ", t)
                    }))
                }
                getCurrentPlayerAllGameTopList(t) {
                    this._isRequestCompleted = !1, this._communication.getTopListAnyGame(t).then((t => {
                        this._view.update(t), this._isRequestCompleted = !0
                    }), (t => {
                        c.Logger.warn("ReplayController : promise reject data : ", t)
                    }))
                }
                getTopXBetData(t) {
                    this._isRequestCompleted = !1, this._communication.getTopXBetData(t).then((t => {
                        this._view.update(t.rounds), this._isRequestCompleted = !0
                    }), (t => {
                        c.Logger.warn("ReplayController : promise reject data : ", t)
                    }))
                }
                get view() {
                    return this._view
                }
                set view(t) {
                    this._view = t
                }
                get isCurrentGame() {
                    return this._isCurrentGame
                }
                set isCurrentGame(t) {
                    this._isCurrentGame = t, this._view.toggleButtons()
                }
                get isXBet() {
                    return this._isXBet
                }
                set isXBet(t) {
                    this._isXBet = t, this._view.toggleButtons()
                }
                get isSinglePlayer() {
                    return this._isSinglePlayer
                }
                set isSinglePlayer(t) {
                    this._isSinglePlayer = t, this._view.toggleButtons()
                }
            }
        },
        4167: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ReplayView = void 0;
            const n = i(3672),
                r = i(4514),
                o = i(6724),
                s = i(1219),
                a = i(3606),
                l = i(2974),
                h = i(8760),
                u = i(5991),
                c = i(361),
                d = i(1057),
                p = i(7886),
                f = i(1410),
                g = i(3767),
                m = i(8246),
                _ = i(430),
                y = i(5892),
                S = i(4524),
                v = i(6358),
                b = i(2408);
            class T extends n.FeatureBasePanel {
                constructor(t, e) {
                    super(o.PromoPanelAssetConfig.NOLIMIT_WINNERS_ICON, f.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.REPLAY_FEATURE_TITLE), p.PromoPanelTextStyles.FEATURE_BASE_REPLAY_TITLE), this._controller = t, this._scroll = e
                }
                init() {
                    super.init(), this.createButtons(), this.createMiddleBarWithText(), this.createFilters(), this._roundInfoContainer = new PIXI.Container, this._roundInfoContainer.name = "ROUND_INFO_CONTAINER", this.addChild(this._roundInfoContainer), this.createLoadingAnimation()
                }
                toggleButtons() {
                    this._currentGameBtn.toggled = this._controller.isCurrentGame, this._allGamesBtn.toggled = !this._controller.isCurrentGame, this._xBetFilterLabelBtn.toggled = this._controller.isXBet, this._xWinFilterLabelBtn.toggled = !this._controller.isXBet, this._singlePlayer.toggled = this._controller.isSinglePlayer, this._allPlayer.toggled = !this._controller.isSinglePlayer, this.updateButtonStyle(), this.updateMiddleBarText(this._singlePlayer.toggled)
                }
                clearRoundInfoData() {
                    this._roundInfoContainer.removeChildren()
                }
                update(t) {
                    this.stopLoadingAnimation(), this.clearRoundInfoData(), t.forEach(((t, e) => {
                        this._roundInfoContainer.addChild(new g.RoundInfoView(this._controller, t, e))
                    })), this._roundInfoContainer.children.forEach(((t, e) => {
                        t.updateButtonStyle(this._xBetFilterLabelBtn.toggled)
                    })), this._scroll.scrollEnabled = !0, this.updateScroll(), this._scroll.reAddMouseHoverListener(), this._scroll.updateContent()
                }
                disableButtons() { }
                onResize() {
                    if (this._isOpen) {
                        const t = r.NolimitApplication.screenBounds,
                            e = r.NolimitApplication.isLandscape && _.Helper.isDefaultScreenRatio(t);
                        let i = t.width;
                        this._scroll.position.set(0, 105);
                        let n = 10,
                            s = g.RoundInfoView.INFO_BG_WIDTH_PORTRAIT;
                        if (e) s = g.RoundInfoView.INFO_BG_WIDTH_LANDSCAPE, n = 25, i = t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, this._separator.position.set(_.Helper.floorPos(i / 2), 213), this._scroll.resize(t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - f.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1), this._scroll.position.set(m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0);
                        else if (r.NolimitApplication.isLandscape && !_.Helper.isDefaultScreenRatio(t)) i = t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, this._separator.position.set(_.Helper.floorPos(i / 2), 213), this._scroll.position.set(m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0), this._scroll.resize(t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - f.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
                        else {
                            this._separator.position.set(_.Helper.floorPos(i / 2), 203);
                            const e = b.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.TOP_BAR).height - 10;
                            this._scroll.position.set(0, e), this._scroll.resize(i, t.height - f.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT)
                        }
                        this._loadingCircle.position.set(Math.floor(i / 2), 360), this._currentGameBtn.position.set(_.Helper.floorPos(i / 2 - .5 * this._currentGameBtn.width - 38), this._separator.y), this._allGamesBtn.position.set(_.Helper.floorPos(i / 2 + .5 * this._currentGameBtn.width + 38), this._separator.y), this._currentGameText.position.set(this._currentGameBtn.x, this._currentGameBtn.y), this._allGameText.position.set(this._allGamesBtn.x, this._allGamesBtn.y), this._singlePlayer.position.set(_.Helper.floorPos(i / 2 - .5 * this._singlePlayer.width - 16), 338), this._allPlayer.position.set(_.Helper.floorPos(i / 2 + .5 * this._singlePlayer.width + 16), 338), this._middleBar.clear(), this._middleBar.beginFill(4283005114, 1), this._middleBar.drawRect(0, 407, i, 45), this._middleBarText.position.set(_.Helper.floorPos(i / 2), 432), this._xBetFilterLabelBtn.position.set(_.Helper.floorPos(i / 2), 506), this._xWinFilterLabelBtn.position.set(_.Helper.floorPos(i / 2 + .5 * s - this._xWinFilterLabelBtn.pivot.x - n), 506), this._roundInfoContainer.position.set(0, 518), this.position.set(0, 0), this._roundInfoContainer.children.forEach(((t, e) => {
                            t.onResize()
                        })), this._xBetFilterLabelBtn.resize(p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding), this._xWinFilterLabelBtn.resize(p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding), super.onResize(), this.resizeTextLabel(), this._scroll.scrollEnabled = !0, this._scroll.updateContent()
                    }
                }
                playLoadingAnimation() {
                    this._loadingCircle.visible = !0, this._loadingAnimation.play()
                }
                show() {
                    this._scroll.visible = !0, super.show(), this._scroll.scrollEnabled = !0, this._scroll.updateContent()
                }
                hide() {
                    super.hide(), this._scroll.visible = !1
                }
                updateScroll() {
                    const t = r.NolimitApplication.screenBounds,
                        e = r.NolimitApplication.isLandscape && _.Helper.isDefaultScreenRatio(t);
                    if (this._scroll.position.set(0, 105), e) this._scroll.resize(t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - f.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1), this._scroll.position.set(m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0);
                    else if (r.NolimitApplication.isLandscape && !_.Helper.isDefaultScreenRatio(t)) this._separator.position.set(_.Helper.floorPos(t.width / 2), 213), this._scroll.position.set(m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, 0), this._scroll.resize(t.width - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT, t.height - f.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - 1);
                    else {
                        const e = b.ImgLoader.getImgTexture(o.PromoPanelAssetConfig.TOP_BAR).height - 10;
                        this._scroll.position.set(0, e), this._scroll.resize(t.width, t.height - f.NolimitPromotionPlugin.keypadPlugin.getBalanceBarHeight() - e - m.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT)
                    }
                }
                createButtons() {
                    this._buttonContainer = new PIXI.Container, this.addChild(this._buttonContainer), this._currentGameBtn = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.CURRENT_GAME_BTN, o.PromoPanelAssetConfig.GAME_TYPE_ACTIVE, o.PromoPanelAssetConfig.GAME_TYPE_INACTIVE, 4280173447, 4280173447), this._separator = new PIXI.Sprite(PIXI.Texture.WHITE), this._separator.anchor.set(.5, .5), this._separator.tint = 4280173447, this._separator.height = 90, this._separator.width = 2, this._allGamesBtn = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.ALL_GAME_BTN, o.PromoPanelAssetConfig.GAME_TYPE_ACTIVE, o.PromoPanelAssetConfig.GAME_TYPE_INACTIVE, 4280173447, 4280173447), this._singlePlayer = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.SINGLE_PLAYER_BTN, o.PromoPanelAssetConfig.PLAYER_ACTIVE, o.PromoPanelAssetConfig.PLAYER_INACTIVE), this._allPlayer = this.createToggleButton(this._buttonContainer, c.PromoPanelButtonIDs.ALL_PLAYER_BTN, o.PromoPanelAssetConfig.ALL_PLAYER_ACTIVE, o.PromoPanelAssetConfig.ALL_PLAYER_INACTIVE), this._currentGameText = new y.PromoPanelTextLabel(f.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.REPLAY_CURRENT_GAME), p.PromoPanelTextStyles.REPLAY_GAME_BTN_ACTIVE, {
                        portraitMaxWidth: this._currentGameBtn.width - 15,
                        landscapeMaxWidth: this._currentGameBtn.width - 15
                    }), this._allGameText = new y.PromoPanelTextLabel(f.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.REPLAY_ALL_GAMES), p.PromoPanelTextStyles.REPLAY_GAME_BTN_INACTIVE, {
                        portraitMaxWidth: this._allGamesBtn.width - 15,
                        landscapeMaxWidth: this._allGamesBtn.width - 15
                    }), this._currentGameText.anchor.set(.5, .5), this._allGameText.anchor.set(.5, .5), this._buttonContainer.addChild(this._currentGameText, this._separator, this._allGameText)
                }
                createToggleButton(t, e, i, n, r = 4294967295, o) {
                    const s = new a.PointerStateColorSet(r);
                    let c = new l.PointerStateIconSet(new h.Icon(b.ImgLoader.getImgTexture(i))),
                        d = new l.PointerStateIconSet(new h.Icon(b.ImgLoader.getImgTexture(n)));
                    const p = new u.IconToggleButton(e, c, s, d);
                    return p.addClickCallback((() => this._controller.buttonClick(p))), p.toggled = !1, p.enable(!0), t && (t.addChild(p), p.pivot.set(.5 * p.width, .5 * p.height)), p
                }
                updateButtonStyle() {
                    this._currentGameText.setStyle(this._currentGameBtn.toggled ? p.PromoPanelTextStyles.REPLAY_GAME_BTN_ACTIVE : p.PromoPanelTextStyles.REPLAY_GAME_BTN_INACTIVE), this._allGameText.setStyle(this._allGamesBtn.toggled ? p.PromoPanelTextStyles.REPLAY_GAME_BTN_ACTIVE : p.PromoPanelTextStyles.REPLAY_GAME_BTN_INACTIVE), this._xBetFilterLabelBtn.label.setColor(this._xBetFilterLabelBtn.toggled ? p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_ACTIVE_FILL_COLOR : p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE_FILL_COLOR), this._xWinFilterLabelBtn.label.setColor(this._xWinFilterLabelBtn.toggled ? p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_ACTIVE_FILL_COLOR : p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE_FILL_COLOR)
                }
                updateMiddleBarText(t) {
                    this._middleBarText.text = f.NolimitPromotionPlugin.apiPlugIn.translations.translate(t ? s.PromoPanelLabelIDs.REPLAY_MY_TOP_WINS_HEADING : s.PromoPanelLabelIDs.REPLAY_TOP_WINS_HEADING)
                }
                createMiddleBarWithText() {
                    this._middleBar = new PIXI.Graphics, this._middleBarText = new d.Label(f.NolimitPromotionPlugin.apiPlugIn.translations.translate(s.PromoPanelLabelIDs.REPLAY_TOP_WINS_HEADING), p.PromoPanelTextStyles.REPLAY_MIDDLE_BAR_TEXT), this._middleBarText.anchor.set(.5, .5), this.addChild(this._middleBar, this._middleBarText)
                }
                createFilters() {
                    this._filterContainer = new PIXI.Container, this._filterContainer.name = "FILTER_CONTAINER", this.addChild(this._filterContainer), this._xBetFilterLabelBtn = this.createFilterButton(c.PromoPanelButtonIDs.X_BET_FILTER_BTN, s.PromoPanelLabelIDs.REPLAY_X_BET, p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE), this._xWinFilterLabelBtn = this.createFilterButton(c.PromoPanelButtonIDs.X_WIN_FILTER_BTN, s.PromoPanelLabelIDs.REPLAY_X_WIN, p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE), this._xBetFilterLabelBtn.label.text = "x" + m.PromoPanelConfig.SINGLE_BLANK_SPACE + this._xBetFilterLabelBtn.label.text, this._filterContainer.addChild(this._xBetFilterLabelBtn, this._xWinFilterLabelBtn);
                    const t = f.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.REPLAY_WIN_BUTTON_ACTIVE).height;
                    this._xBetFilterLabelBtn.setSize(this._xBetFilterLabelBtn.label.width + p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding, t), this._xWinFilterLabelBtn.setSize(this._xWinFilterLabelBtn.label.width + p.PromoPanelTextStyles.REPLAY_FILTER_STYLE_INACTIVE.padding, t), this._xBetFilterLabelBtn.toggled = !0, this._xWinFilterLabelBtn.toggled = !1
                }
                createFilterButton(t, e, i) {
                    const n = new PIXI.NineSlicePlane(f.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.REPLAY_WIN_BUTTON_ACTIVE), 20, 20, 20, 20),
                        r = new PIXI.NineSlicePlane(f.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.REPLAY_WIN_BUTTON), 20, 20, 20, 20),
                        s = new S.PromoPanelLabelButton(t, f.NolimitPromotionPlugin.apiPlugIn.translations.translate(e), void 0, void 0, i, n, void 0, r);
                    return s.addClickCallback((() => this._controller.buttonClick(s))), s.enable(!0), s
                }
                createLoadingAnimation() {
                    this._loadingCircle = new PIXI.Sprite(f.NolimitPromotionPlugin.imgLoader.getImgTexture(o.PromoPanelAssetConfig.LOADING_CIRCLE)), this._loadingCircle.anchor.set(.5), this._loadingAnimation = v.TweenMax.to(this._loadingCircle, 30, {
                        rotation: "360",
                        ease: v.Linear.easeNone,
                        repeat: -1
                    }), this.stopLoadingAnimation(), this.addChild(this._loadingCircle)
                }
                stopLoadingAnimation() {
                    this._loadingCircle.visible = !1, this._loadingAnimation.pause()
                }
                resizeTextLabel() {
                    this._currentGameText.onResize(), this._allGameText.onResize()
                }
            }
            e.ReplayView = T
        },
        3767: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.RoundInfoView = void 0;
            const n = i(1410),
                r = i(6724),
                o = i(5991),
                s = i(1057),
                a = i(3606),
                l = i(2974),
                h = i(8760),
                u = i(4514),
                c = i(361),
                d = i(7886),
                p = i(6883),
                f = i(430),
                g = i(8246),
                m = i(8680),
                _ = i(5892),
                y = i(2408),
                S = i(1028);
            class v extends PIXI.Container {
                constructor(t, e, i) {
                    super(), this._data = e, this._controller = t, this._index = i, this.init()
                }
                updateButtonStyle(t) {
                    this._bet.setStyle(t ? d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE : d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_INACTIVE), this._currency.setStyle(t ? d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_INACTIVE : d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE), this._win.setStyle(t ? d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_INACTIVE : d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE)
                }
                onResize() {
                    const t = u.NolimitApplication.screenBounds,
                        e = u.NolimitApplication.isLandscape && f.Helper.isDefaultScreenRatio(t);
                    let i = 20,
                        n = 1,
                        r = t.width - g.PromoPanelConfig.PROMO_PANEL_BTN_PANEL_HEIGHT,
                        o = v.INFO_BG_WIDTH_PORTRAIT;
                    e ? (i = 30, n = 1, o = v.INFO_BG_WIDTH_LANDSCAPE) : u.NolimitApplication.isLandscape && !f.Helper.isDefaultScreenRatio(t) || (r = t.width), this.resizeTextLabel(), this._infoBg.position.set(f.Helper.floorPos(r / 2), f.Helper.floorPos(this._infoBg.height / 2)), this._infoBg.width = o, this._infoBg.pivot.x = f.Helper.floorPos(.5 * o), this._trophy.position.set(f.Helper.floorPos(this._infoBg.x - this._infoBg.width / 2 - 50), this._infoBg.y), this._date.position.set(f.Helper.floorPos(this._infoBg.x - .5 * this._infoBg.width + i), this._infoBg.y - n), this._featureIcons.position.set(this._date.position.x + this._date.width + 5, this._date.position.y), this._gameName.position.set(this._date.x, this._infoBg.y + n), this._bet.position.set(this._infoBg.x, this._infoBg.y), this._win.position.set(f.Helper.floorPos(this._infoBg.x + .5 * this._infoBg.width - i), this._infoBg.y), this._currency.position.set(f.Helper.floorPos(this._win.x - this._win.width - 5), this._infoBg.y), this._playBtn.position.set(f.Helper.floorPos(this._infoBg.width / 2 + this._infoBg.x + 10), this._infoBg.y), this.y = f.Helper.floorPos(this._index * (this.height + 15) + .5 * this.height)
                }
                init() {
                    this.createTrophy(), this.createInfo(), this._featureIcons = this.createFeatureIcons(), this.addChild(this._featureIcons), this.createPlayBtn(), this.onResize()
                }
                createTrophy() {
                    let t;
                    switch (this._index) {
                        case p.TrophyTypes.TROPHY_GOLD:
                            t = new PIXI.Sprite(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.TROPHY_GOLD));
                            break;
                        case p.TrophyTypes.TROPHY_SILVER:
                            t = new PIXI.Sprite(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.TROPHY_SILVER));
                            break;
                        case p.TrophyTypes.TROPHY_BRONZE:
                            t = new PIXI.Sprite(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.TROPHY_BRONZE));
                            break;
                        default:
                            t = new s.Label(this._index + 1 + "", d.PromoPanelTextStyles.ROUND_INFO_TROPHY_TEXT)
                    }
                    t instanceof PIXI.Sprite && t.pivot.set(-4, -4), t.anchor.set(.5, .5), this.addChild(t), this._trophy = t
                }
                createPlayBtn() {
                    const t = new a.PointerStateColorSet(4294967295);
                    let e = new l.PointerStateIconSet(new h.Icon(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.REPLAY_BUTTON)));
                    const i = new o.IconToggleButton(c.PromoPanelButtonIDs.PLAY_BTN, e, t);
                    i.addClickCallback((() => this._controller.openReplay(this._data.url))), i.toggled = !1, i.enable(!0), this.addChild(i), i.pivot.set(0, i.height / 2), this._playBtn = i
                }
                createInfo() {
                    const t = new PIXI.NineSlicePlane(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.INFO_BG), 26, 26, 26, 26);
                    t.pivot.set(.5 * t.width, .5 * t.height), this.addChild(t), this._infoBg = t;
                    const e = new s.Label(this.getDateFormat(this._data.time), d.PromoPanelTextStyles.ROUND_INFO_DATE_TEXT);
                    e.anchor.set(0, 1);
                    const i = new s.Label(this.getGameNameFormat(this._data.game), d.PromoPanelTextStyles.ROUND_INFO_GAME_NAME_TEXT);
                    i.anchor.set(0, 0);
                    const o = new _.PromoPanelTextLabel(this._data.winMultiplication + " x", d.PromoPanelTextStyles.ROUND_INFO_BET_TEXT_ACTIVE, {
                        landscapeMaxWidth: 150,
                        portraitMaxWidth: 110
                    });
                    o.anchor.set(.5, .5);
                    const a = new s.Label(this._data.currency, d.PromoPanelTextStyles.ROUND_INFO_CURRENCY_TEXT);
                    a.anchor.set(1, .5), a.visible = !n.NolimitPromotionPlugin.apiPlugIn.options.hideCurrency;
                    const l = this._data.win < g.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || this._data.win % 1 != 0 ? 2 : 0,
                        h = n.NolimitPromotionPlugin.apiPlugIn.currency.formatValue(this._data.win, {
                            minimumPrecision: l
                        }),
                        u = new _.PromoPanelTextLabel(h + "", d.PromoPanelTextStyles.ROUND_INFO_WIN_TEXT, {
                            landscapeMaxWidth: 180,
                            portraitMaxWidth: 130
                        });
                    u.anchor.set(1, .5), this._date = e, this._gameName = i, this._bet = o, this._currency = a, this._win = u, this.addChild(this._date, this._gameName, this._bet, this._currency, this._win)
                }
                getDateFormat(t) {
                    try {
                        const e = new Date(t);
                        return f.Helper.padZero(e.getFullYear()) + g.PromoPanelConfig.DATE_SEPARATOR + f.Helper.padZero(+e.getMonth() + 1) + g.PromoPanelConfig.DATE_SEPARATOR + f.Helper.padZero(e.getDate())
                    } catch (e) {
                        return m.Logger.warn("Invalid date format : ", t), t
                    }
                }
                getGameNameFormat(t) {
                    return t.length > 16 && (t = t.slice(0, 14) + ".."), t
                }
                resizeTextLabel() {
                    this._bet.onResize(), this._win.onResize()
                }
                createFeatureIcons() {
                    const t = new PIXI.Container;
                    if (this._data.actionSpin) {
                        const e = new PIXI.Sprite(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ROUND_INFO_ACTION_SPINS_ICON));
                        e.anchor.set(0, 1), t.addChild(e)
                    }
                    if (this._data.bonusBuy) {
                        const e = new PIXI.Sprite(y.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.ROUND_INFO_BONUS_BUY_ICON));
                        e.anchor.set(0, 1), t.addChild(e)
                    }
                    return S.GuiLayout.align(t.children, 3, S.Align.LEFT, S.Direction.HORIZONTAL), t
                }
            }
            v.INFO_BG_WIDTH_LANDSCAPE = 745, v.INFO_BG_WIDTH_PORTRAIT = 525, e.RoundInfoView = v
        },
        7075: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ActionSpinSound = void 0, (i = e.ActionSpinSound || (e.ActionSpinSound = {}))[i.WIN = 0] = "WIN", i[i.BIG_WIN = 1] = "BIG_WIN"
        },
        1221: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.IntroPageCreator = void 0;
            const n = i(2408),
                r = i(4514),
                o = i(6037),
                s = i(6724),
                a = i(1653),
                l = i(2111),
                h = i(1410),
                u = i(9572),
                c = i(6625),
                d = i(3249),
                p = i(7886),
                f = i(1219);
            e.IntroPageCreator = class {
                constructor() { }
                getIntroPages(t, e) {
                    const i = new l.FontLoader(r.NolimitApplication.resourcePath);
                    i.add(a.OpenSans.NORMAL_600), i.add(a.OpenSans.NORMAL_800);
                    const g = new n.ImgLoader(r.NolimitApplication.resourcePath);
                    g.add("NolimitBonusAnimation", "/node_modules/@nolimit/promo-panel/resources/default/intro/NolimitBonusAnimation.json");
                    for (let t of s.PromoPanelAssetConfig.getIntroAssets()) g.add(t.name, t.url);
                    return Promise.all([g.load(), i.load()]).then((i => {
                        const n = [];
                        return e.hasNolimitBonus() && n.push(new o.NolimitBonusIntroPage(t, 15608146, h.NolimitPromotionPlugin.apiPlugIn.translations.translate(f.PromoPanelLabelIDs.BUY_FEATURE_TITLE), s.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON, p.PromoPanelTextStyles.FEATURE_BASE_BUY_FEATURE_TITLE)), e.hasActionSpin() && n.push(new d.NolimitActionSpinIntroPage(16695822, h.NolimitPromotionPlugin.apiPlugIn.translations.translate(f.PromoPanelLabelIDs.ACTION_SPINS), s.PromoPanelAssetConfig.ACTION_SPINS_ICON, p.PromoPanelTextStyles.FEATURE_ACTION_SPIN_REPLAY_TITLE)), e.hasNolimitWinners() && n.push(new u.NolimitWinnersIntroPage(6857945, h.NolimitPromotionPlugin.apiPlugIn.translations.translate(f.PromoPanelLabelIDs.REPLAY_FEATURE_TITLE), s.PromoPanelAssetConfig.NOLIMIT_WINNERS_ICON, p.PromoPanelTextStyles.FEATURE_BASE_REPLAY_TITLE)), e.hasNolimitTournaments() && n.push(new c.PromoPanelBaseIntroPage(16711680, "Nolimit Tournaments", s.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON)), e.hasNolimitVoucher() && n.push(new c.PromoPanelBaseIntroPage(16711680, "Nolimit Voucher", s.PromoPanelAssetConfig.NOLIMIT_BONUS_ICON)), n
                    }))
                }
            }
        },
        3249: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitActionSpinIntroPage = void 0;
            const n = i(2408),
                r = i(6724),
                o = i(6625),
                s = i(1410),
                a = i(3663),
                l = i(1057);
            class h extends o.PromoPanelBaseIntroPage {
                constructor(t, e, i, o) {
                    super(t, e, i, o);
                    const h = new l.Label(s.NolimitPromotionPlugin.apiPlugIn.translations.translate("Get your adrenaline flowing and play your regular or bonus rounds in HYPER MODE!"), a.GuiDefaults.INTRO_PAGE_TEXT);
                    h.anchor.x = 1, h.anchor.y = .5, h.position.x = -10, h.position.y = 35;
                    const u = new PIXI.Sprite(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.INTRO_ACTION_SPINS));
                    u.anchor.set(.5, .5), u.position.set(200, 38), this.icon.scale.set(.7, .7), this.icon.position.set(44, 9), this.addChild(u, h)
                }
            }
            e.NolimitActionSpinIntroPage = h
        },
        6037: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitBonusIntroPage = void 0;
            const n = i(2408),
                r = i(1653),
                o = i(5383),
                s = i(6724),
                a = i(1410),
                l = i(3663),
                h = i(6625),
                u = i(6358),
                c = i(1057),
                d = i(7241);
            class p extends h.PromoPanelBaseIntroPage {
                constructor(t, e, i, n, r) {
                    super(e, i, n, r);
                    const o = t.length > 1 ? 0 : 23,
                        s = this.createTickets(t);
                    s.position.set(0, o), this.addChild(s);
                    const h = Math.min(1, t.length - 1),
                        u = new c.Label(a.NolimitPromotionPlugin.apiPlugIn.translations.translate(["Buy your way into the most exciting feature of the game!", "Buy your way into the most exciting features of the game!"][h]), l.GuiDefaults.INTRO_PAGE_TEXT);
                    u.anchor.x = 1, u.anchor.y = .5, u.position.x = -10, u.position.y = 35, this.addChild(u)
                }
                createTickets(t) {
                    const e = new PIXI.Container,
                        i = [];
                    for (let e of t) i.push(this.createTicket(e));
                    let n = 0,
                        r = 0,
                        o = 0,
                        s = 0,
                        a = 0;
                    i.length > 1 && (n = .25 / (i.length - 1), o = -n * (i.length - 1) * .5, r = -.05, s = 23 / (i.length - 1), a = 78 / (i.length - 1));
                    const l = [];
                    for (let t = 0; t < i.length; t++) {
                        const h = i[t],
                            c = new u.TimelineLite,
                            d = n * t + o + r;
                        c.add(new u.TweenLite(h, .5, {
                            x: s * t,
                            y: a * t,
                            rotation: d,
                            ease: u.Elastic.easeOut.config(1, .75)
                        }));
                        const p = h.getChildByName("priceTag");
                        p && (c.add(new u.TweenLite(p, .5, {
                            rotation: -d,
                            ease: u.Elastic.easeOut.config(1, .75)
                        }), 0), p.rotation = -h.rotation), l.push(c), e.addChild(h)
                    }
                    return this._fanAnimation = new u.TimelineLite({
                        paused: !0
                    }), this._fanAnimation.add(l, 0), e
                }
                createTicket(t) {
                    const e = new PIXI.Container,
                        i = new PIXI.Sprite(n.ImgLoader.getImgTexture(t.name)),
                        r = new PIXI.Sprite(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.INTRO_NOLIMIT_BONUS_TICKET)),
                        o = this.makePriceTag(t.price);
                    return o.name = "priceTag", i.position.set(136, 77), i.scale.set(.65, .65), i.anchor.set(.5, .5), o.position.set(254, 10), e.addChild(r, i), e.pivot.set(-33, .5 * e.height), e.addChild(o), e
                }
                makePriceTag(t) {
                    const e = new PIXI.Container,
                        i = new d.NLCStaticText("x " + t, p.PRICE_TAG_STYLE);
                    i.anchor.set(.5, .5), i.position.set(0, 0);
                    const r = new PIXI.Sprite(n.ImgLoader.getImgTexture(s.PromoPanelAssetConfig.INTRO_NOLIMIT_BONUS_PRICE_TAG));
                    return r.anchor.set(.5, .4), e.addChild(r, i), e
                }
                enable(t) {
                    super.enable(t), this._fanAnimation && (t ? this._fanAnimation.play(0) : this._fanAnimation.pause(0))
                }
            }
            p.PRICE_TAG_STYLE = new PIXI.TextStyle({
                fontFamily: r.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: o.FontStyle.NORMAL,
                fontWeight: o.FontWeight.EXTRA_BOLD,
                dropShadow: !0,
                dropShadowAngle: 1.57,
                dropShadowColor: "#ef9720",
                dropShadowDistance: 2,
                fill: "#f4f2f3",
                padding: 3,
                stroke: "#FFAA05",
                strokeThickness: 2,
                lineJoin: "round"
            }), e.NolimitBonusIntroPage = p
        },
        9572: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitWinnersIntroPage = void 0;
            const n = i(2408),
                r = i(6724),
                o = i(6625),
                s = i(1410),
                a = i(3663),
                l = i(1057);
            class h extends o.PromoPanelBaseIntroPage {
                constructor(t, e, i, o) {
                    super(t, e, i, o);
                    const h = new l.Label(s.NolimitPromotionPlugin.apiPlugIn.translations.translate("Replay your own or others best game rounds for all Nolimit City games!"), a.GuiDefaults.INTRO_PAGE_TEXT);
                    h.anchor.x = 1, h.anchor.y = .5, h.position.x = -10, h.position.y = 35;
                    const u = new PIXI.Sprite(n.ImgLoader.getImgTexture(r.PromoPanelAssetConfig.INTRO_NOLIMIT_WINNERS));
                    u.anchor.set(.5, .5), u.position.set(200, 62), this.addChild(u, h)
                }
            }
            e.NolimitWinnersIntroPage = h
        },
        6625: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PromoPanelBaseIntroPage = void 0;
            const n = i(6724),
                r = i(2960),
                o = i(4514),
                s = i(2408),
                a = i(1028),
                l = i(1653),
                h = i(5383),
                u = i(6358),
                c = i(9315),
                d = i(1057);
            class p extends r.SlideShowPage {
                constructor(t, e, i, n) {
                    super(void 0, void 0, t);
                    const r = this.createHeader(e, i, n || p.HEADER_STYLE);
                    this._tabTarget = new PIXI.Point(-.5 * o.NolimitApplication.screenBounds.width - 40, -178), this._tab = this.createTab(), this._tab.alpha = 0, this.addChild(this._tab, r)
                }
                createHeader(t, e, i) {
                    const n = new PIXI.Container,
                        r = new PIXI.Sprite(s.ImgLoader.getImgTexture(e)),
                        o = new d.Label(t, i),
                        l = 65 / r.height;
                    return r.scale.set(l, l), n.addChild(r, o), a.GuiLayout.align([r, o], 24, a.Align.TOP, a.Direction.HORIZONTAL), n.pivot.set(.5 * n.width, .5 * n.height), n.position.set(0, -139), this.icon = r, n
                }
                createTab() {
                    const t = new PIXI.Container,
                        e = new PIXI.Sprite(s.ImgLoader.getImgTexture(n.PromoPanelAssetConfig.INTRO_NO_LIMIT_PROMOTIONS_TAB));
                    e.scale.set(.8, .8);
                    const i = ["gamificationStar_00282.png", "gamificationStar_00283.png", "gamificationStar_00284.png", "gamificationStar_00285.png", "gamificationStar_00286.png", "gamificationStar_00287.png", "gamificationStar_00288.png", "gamificationStar_00289.png", "gamificationStar_00290.png", "gamificationStar_00291.png", "gamificationStar_00292.png", "gamificationStar_00293.png", "gamificationStar_00294.png", "gamificationStar_00295.png", "gamificationStar_00296.png", "gamificationStar_00297.png", "gamificationStar_00298.png", "gamificationStar_00299.png", "gamificationStar_00300.png", "gamificationStar_00301.png", "gamificationStar_00302.png", "gamificationStar_00303.png", "gamificationStar_00304.png", "gamificationStar_00305.png", "gamificationStar_00306.png", "gamificationStar_00307.png", "gamificationStar_00308.png", "gamificationStar_00309.png", "gamificationStar_00310.png", "gamificationStar_00311.png", "gamificationStar_00312.png", "gamificationStar_00313.png", "gamificationStar_00314.png", "gamificationStar_00315.png", "gamificationStar_00316.png", "gamificationStar_00317.png", "gamificationStar_00318.png", "gamificationStar_00319.png", "gamificationStar_00320.png", "gamificationStar_00321.png", "gamificationStar_00322.png", "gamificationStar_00323.png", "gamificationStar_00324.png", "gamificationStar_00325.png", "gamificationStar_00326.png", "gamificationStar_00327.png", "gamificationStar_00328.png", "gamificationStar_00329.png", "gamificationStar_00330.png", "gamificationStar_00331.png", "gamificationStar_00332.png", "gamificationStar_00333.png", "gamificationStar_00334.png", "gamificationStar_00335.png", "gamificationStar_00336.png", "gamificationStar_00337.png", "gamificationStar_00338.png", "gamificationStar_00339.png", "gamificationStar_00340.png", "gamificationStar_00341.png", "gamificationStar_00342.png", "gamificationStar_00343.png", "gamificationStar_00344.png", "gamificationStar_00345.png", "gamificationStar_00346.png", "gamificationStar_00347.png", "gamificationStar_00348.png", "gamificationStar_00349.png", "gamificationStar_00350.png", "gamificationStar_00351.png", "gamificationStar_00352.png", "gamificationStar_00353.png", "gamificationStar_00354.png", "gamificationStar_00355.png", "gamificationStar_00356.png", "gamificationStar_00357.png"],
                        r = [];
                    for (let t of i) r.push(s.ImgLoader.getImgTexture(t));
                    const o = new c.TimelineSprite(r, 30);
                    return o.anchor.set(.5, .5), o.position.set(113, 56), o.scale.set(.53, .53), e.addChild(o), t.addChild(e), this._starTween = new u.TimelineLite, this._starTween.add(o.getAnimationAutoShowHide(!0, !1)), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [70, 50]), "+=0.9"), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [49]), "+=0.5"), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [70, 50]), "+=0.7"), this._starTween.add(o.getAnimationAutoShowHide(!0, !1, [49]), "+=0.9"), t
                }
                resize() {
                    this._tabTarget = new PIXI.Point(-.5 * o.NolimitApplication.screenBounds.width - 40, -178), this._tab.position.set(-.5 * o.NolimitApplication.screenBounds.width - 40, -178)
                }
                enable(t) {
                    super.enable(t), t ? (this._starTween.play(0), u.TweenLite.fromTo(this._tab, .2, {
                        x: this._tabTarget.x - 150
                    }, {
                        x: this._tabTarget.x
                    }), u.TweenLite.to(this._tab, .2, {
                        alpha: 1
                    })) : (this._starTween.pause(0), u.TweenLite.to(this._tab, .2, {
                        alpha: 0
                    }))
                }
            }
            p.HEADER_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: l.OpenSans.FAMILY,
                fontSize: 45,
                fontStyle: h.FontStyle.NORMAL,
                fontWeight: h.FontWeight.SEMI_BOLD,
                dropShadow: !0,
                dropShadowAngle: 1.57,
                dropShadowDistance: 3,
                dropShadowColor: "#000000",
                dropShadowAlpha: .2,
                padding: 50
            }), e.PromoPanelBaseIntroPage = p
        },
        5901: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AnimationHelper = void 0;
            const n = i(2408);
            class r {
                static getAnimationTextures(t) {
                    if (Array.isArray(r.animationTextures[t])) return r.animationTextures[t];
                    if (Array.isArray(r.animationTextureNames[t])) {
                        r.animationTextures[t] = [];
                        for (let e of r.animationTextureNames[t]) r.animationTextures[t].push(n.ImgLoader.getImgTexture(e));
                        return r.animationTextures[t]
                    }
                    throw new Error("AnimationHelper: Could not find animation")
                }
            }
            r.animationTextureNames = {
                bigWinBase: ["bigwin/bigwinBase/bigwinBase_00018", "bigwin/bigwinBase/bigwinBase_00019", "bigwin/bigwinBase/bigwinBase_00020", "bigwin/bigwinBase/bigwinBase_00021", "bigwin/bigwinBase/bigwinBase_00022", "bigwin/bigwinBase/bigwinBase_00023", "bigwin/bigwinBase/bigwinBase_00024", "bigwin/bigwinBase/bigwinBase_00025", "bigwin/bigwinBase/bigwinBase_00026", "bigwin/bigwinBase/bigwinBase_00027", "bigwin/bigwinBase/bigwinBase_00028", "bigwin/bigwinBase/bigwinBase_00029", "bigwin/bigwinBase/bigwinBase_00030", "bigwin/bigwinBase/bigwinBase_00031", "bigwin/bigwinBase/bigwinBase_00032", "bigwin/bigwinBase/bigwinBase_00033", "bigwin/bigwinBase/bigwinBase_00034"],
                bigWinText: ["bigwin/bigwinText/bigwinText_00018", "bigwin/bigwinText/bigwinText_00019", "bigwin/bigwinText/bigwinText_00020", "bigwin/bigwinText/bigwinText_00021", "bigwin/bigwinText/bigwinText_00022", "bigwin/bigwinText/bigwinText_00023", "bigwin/bigwinText/bigwinText_00024", "bigwin/bigwinText/bigwinText_00025", "bigwin/bigwinText/bigwinText_00026", "bigwin/bigwinText/bigwinText_00027", "bigwin/bigwinText/bigwinText_00028", "bigwin/bigwinText/bigwinText_00029", "bigwin/bigwinText/bigwinText_00030", "bigwin/bigwinText/bigwinText_00031", "bigwin/bigwinText/bigwinText_00032", "bigwin/bigwinText/bigwinText_00033", "bigwin/bigwinText/bigwinText_00034", "bigwin/bigwinText/bigwinText_00035", "bigwin/bigwinText/bigwinText_00036", "bigwin/bigwinText/bigwinText_00037", "bigwin/bigwinText/bigwinText_00038", "bigwin/bigwinText/bigwinText_00039", "bigwin/bigwinText/bigwinText_00040", "bigwin/bigwinText/bigwinText_00041", "bigwin/bigwinText/bigwinText_00042", "bigwin/bigwinText/bigwinText_00043", "bigwin/bigwinText/bigwinText_00044", "bigwin/bigwinText/bigwinText_00045"],
                noWin: ["noWin/nowin_00001", "noWin/nowin_00002", "noWin/nowin_00003", "noWin/nowin_00004", "noWin/nowin_00005", "noWin/nowin_00006", "noWin/nowin_00007", "noWin/nowin_00008", "noWin/nowin_00009", "noWin/nowin_00010", "noWin/nowin_00011", "noWin/nowin_00012", "noWin/nowin_00013", "noWin/nowin_00014"],
                winCoins: ["winCoins/winCoins_00018", "winCoins/winCoins_00019", "winCoins/winCoins_00020", "winCoins/winCoins_00021", "winCoins/winCoins_00022", "winCoins/winCoins_00023", "winCoins/winCoins_00024", "winCoins/winCoins_00025", "winCoins/winCoins_00026", "winCoins/winCoins_00027", "winCoins/winCoins_00028", "winCoins/winCoins_00029", "winCoins/winCoins_00030", "winCoins/winCoins_00031", "winCoins/winCoins_00032", "winCoins/winCoins_00033", "winCoins/winCoins_00034", "winCoins/winCoins_00035", "winCoins/winCoins_00036", "winCoins/winCoins_00037", "winCoins/winCoins_00038", "winCoins/winCoins_00039", "winCoins/winCoins_00040", "winCoins/winCoins_00041", "winCoins/winCoins_00042"]
            }, r.animationTextures = {}, e.AnimationHelper = r
        },
        6252: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ArrayUtils = void 0;
            class i {
                static sum(t) {
                    return t.reduce(((t, e) => t + e))
                }
                static multiplyAll(t) {
                    return t.reduce(((t, e) => t * e))
                }
                static isAllTrue(t) {
                    return !i.isAnyFalse(t)
                }
                static isAnyFalse(t) {
                    for (let e of t)
                        if (!e) return !0;
                    return !1
                }
                static isAllFalse(t) {
                    return !i.isAnyTrue(t)
                }
                static isAnyTrue(t) {
                    for (let e of t)
                        if (e) return !0;
                    return !1
                }
                static shuffleArray(t) {
                    let e = t.concat();
                    for (let t = e.length; t; t--) {
                        let i = Math.floor(Math.random() * t);
                        [e[t - 1], e[i]] = [e[i], e[t - 1]]
                    }
                    return e
                }
                static unique(t) {
                    return Array.from(new Set(t))
                }
                static getIndicesWhere(t, e) {
                    const i = [];
                    for (let n = 0; n < t.length; n++) e(t[n], n) && i.push(n);
                    return i
                }
            }
            e.ArrayUtils = i
        },
        2379: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.CurrencyUtils = void 0;
            const n = i(8246),
                r = i(1410);
            e.CurrencyUtils = class {
                constructor() { }
                static formatWithDecimalCutOff(t) {
                    const e = t < n.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
                    return r.NolimitPromotionPlugin.apiPlugIn.currency.format(t, {
                        minimumPrecision: e
                    })
                }
                static format(t) {
                    return r.NolimitPromotionPlugin.apiPlugIn.currency.format(t, {
                        minimumPrecision: 2
                    })
                }
                static formatValueWithDecimalCutOff(t) {
                    const e = t < n.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
                    return r.NolimitPromotionPlugin.apiPlugIn.currency.formatValue(t, {
                        minimumPrecision: e
                    })
                }
            }
        },
        430: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Helper = void 0;
            const n = i(8246),
                r = i(1410);
            class o {
                static translate(t) {
                    return r.NolimitPromotionPlugin.apiPlugIn.translations.translate(t)
                }
                static unique(t) {
                    return Array.from(new Set(t))
                }
                static shrinkTextWidth(t, e, i) {
                    for (; e.width > i;) {
                        if (this.isString(e.style.fontSize)) {
                            if (e.style.fontSize.indexOf("em") > -1) throw new Error("Helper.shrinkTextWidth(), I am lazy so I don't want to parse em, please use number or px.");
                            e.style.fontSize = parseInt(e.style.fontSize)
                        }
                        if (e.style.fontSize--, e.style.fontSize <= 10) return void (e.style.fontSize = 10)
                    }
                }
                static isDefaultScreenRatio(t) {
                    return Math.max(t.width, t.height) / Math.min(t.width, t.height) > n.PromoPanelConfig.DEFAULT_SCREEN_MIN_RATIO
                }
                static isIphoneScreenRatio(t) {
                    return Math.max(t.width, t.height) / Math.min(t.width, t.height) > n.PromoPanelConfig.DEFAULT_SCREEN_MIN_RATIO
                }
                static padZero(t) {
                    return t.toString().padStart(2, "0")
                }
                static floorPos(t) {
                    return Math.floor(t)
                }
                static getMaxFromArray(t) {
                    let e = Number.MIN_VALUE;
                    for (let i = 0; i < t.length; i++) e = Math.max(e, +t[i]);
                    return e
                }
                static getTotalMultipliedWin(t, e) {
                    const i = Math.pow(10, n.PromoPanelConfig.DECIMAL_CUTOFF - 1);
                    return t * i / (e * i)
                }
                static formatCost(t) {
                    return this.countDecimals(t) < 2 ? t.toFixed(2) : t.toString()
                }
                static isString(t) {
                    return "string" == typeof t
                }
                static ceilToDecimals(t, e) {
                    return Math.ceil(t * Math.pow(10, e)) / Math.pow(10, e)
                }
            }
            o.countDecimals = function (t) {
                return Math.floor(t) === t ? 0 : t.toString().split(".")[1].length || 0
            }, e.Helper = o
        },
        1558: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ResponseParser = void 0;
            const n = i(1410),
                r = i(8246),
                o = i(430),
                s = i(7835),
                a = i(8680),
                l = i(4514),
                h = i(7185),
                u = i(6418);
            class c {
                static getASReplayWinData(t, e, i) {
                    const l = c.getParsedData(t, e, i),
                        h = l.totalWin,
                        u = +l.totalSpinWinnings,
                        d = l.winType || s.WINTYPE.NORMAL,
                        p = {
                            totalWin: h,
                            totalSpinWinnings: u,
                            calculatedTotalWinTimesBet: o.Helper.getTotalMultipliedWin(h, t.playedBetValue),
                            calculatedTimesBetThisSpin: o.Helper.getTotalMultipliedWin(u, t.playedBetValue),
                            nextMode: t.nextMode,
                            mode: t.mode,
                            wasFeatureBuy: l.wasFeatureBuy,
                            freeSpinTriggeredThisSpin: l.freeSpinTriggeredThisSpin,
                            balance: n.NolimitPromotionPlugin.apiPlugIn.balance.getAmount().toFixed(r.PromoPanelConfig.DECIMAL_CUTOFF),
                            isBigWin: l.isBigWin,
                            winType: d,
                            featureName: l.featureName || "",
                            isRoundComplete: l.isRoundComplete,
                            isBonusEnd: l.isBonusEnd,
                            isWinCapHit: l.isWinCapHit,
                            isWinBelowStake: !1,
                            waitForAnimation: l.waitForAnimation
                        };
                    return p.isWinBelowStake = this.isWinBelowStake(p, t), a.Logger.logDev("Action Spin : ReplayData :", p), p
                }
                static getParsedData(t, e, i) {
                    var o;
                    return (null === (o = n.NolimitPromotionPlugin.ASOptionsData) || void 0 === o ? void 0 : o.getParsedData) ? n.NolimitPromotionPlugin.ASOptionsData.getParsedData(t, e, i) : {
                        totalWin: this.getTotalWin(t, e),
                        totalSpinWinnings: this.getThisSpinWin(t, e),
                        wasFeatureBuy: this.wasFeatureBuy(t),
                        freeSpinTriggeredThisSpin: this.freeSpinTriggeredThisSpin(t),
                        isBigWin: !1,
                        featureName: r.Mode.FREESPIN,
                        winType: s.WINTYPE.NORMAL,
                        isRoundComplete: this.isRoundComplete(t),
                        isBonusEnd: this.isBonusEnd(t),
                        isWinCapHit: t.brokeBank
                    }
                }
                static addASData(t, e) {
                    t.freespinTriggeredThisSpin = e.freeSpinTriggeredThisSpin, t.featureName = e.featureName, t.isRoundComplete = e.isRoundComplete, t.isBonusEnd = e.isBonusEnd, t.isWinCapHit = e.isWinCapHit
                }
                static getBetCost(t) {
                    let e, i = +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    return e = "string" == typeof t ? n.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByName(t) : t, e && (i = 100 * e.price * i * 1e4 / 1e6), i
                }
                static getBoostCost(t) {
                    let e, i = +n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    e = "string" == typeof t ? n.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByName(t) : t, e && (i = 100 * e.price * i * 1e4 / 1e6);
                    const o = i < r.PromoPanelConfig.NO_DECIMALS_CUTOFF_POINT || i % 1 != 0 ? 2 : 0;
                    return n.NolimitPromotionPlugin.apiPlugIn.currency.formatValue(i, {
                        minimumPrecision: o
                    })
                }
                static setBoostAndGetCost(t, e = !1) {
                    let i, r = n.NolimitPromotionPlugin.apiPlugIn.betLevel.getLevel();
                    if (t) {
                        const e = n.NolimitPromotionPlugin.apiPlugIn.bonusFeatures.getFeatureDataByName(t);
                        e && (i = {
                            featureName: e.name,
                            price: e.price
                        }, r = c.getBoostCost(e))
                    }
                    return e && n.NolimitPromotionPlugin.apiPlugIn.betHandler.setBoost(i), r
                }
                static isWinBelowStake(t, e) {
                    let i = +t.totalSpinWinnings;
                    return t.isRoundComplete && t.nextMode === r.Mode.NORMAL && (i = +t.totalWin), t.winType === s.WINTYPE.MULTIPLIER && (i *= e.playedBetValue), n.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.belowStakeWinRestriction && i <= e.playedBetValue
                }
                static gameDataPromise() {
                    return new Promise(((t, e) => {
                        l.NolimitApplication.apiPlugin.events.once(h.APIEvent.GAME, (i => {
                            i.isFakeData ? (n.NolimitPromotionPlugin.apiPlugIn.events.trigger(h.APIEvent.FINISH), e()) : (a.Logger.logDev("Promo Panel GameData", i.mode, i.nextMode), u.Timer.measureTimeAtStateStart(r.Mode.NORMAL, u.FlowState.BET_COMPLETED), t(i))
                        }))
                    }))
                }
                static isBonusEnd(t) {
                    return t.nextMode === r.Mode.NORMAL && -1 === t.mode.indexOf("NORMAL")
                }
                static isRoundComplete(t) {
                    return [r.Mode.FREESPIN, r.Mode.SUPER_FREESPIN, r.Mode.NORMAL].indexOf(t.nextMode) > -1
                }
                static isBigWin(t, e) {
                    return o.Helper.ceilToDecimals(t / e, 2) >= 15
                }
                static getThisSpinWin(t, e) {
                    return t.totalSpinWinnings
                }
                static getTotalWin(t, e) {
                    return t.accumulatedRoundWin
                }
                static wasFeatureBuy(t) {
                    return t.wasFeatureBuy
                }
                static freeSpinTriggeredThisSpin(t) {
                    return t.freeSpinTriggeredThisSpin
                }
            }
            e.ResponseParser = c
        },
        1133: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.StepList = void 0;
            const n = i(6252);
            e.StepList = class {
                constructor(t) {
                    if (this._randomizeOnWrapAround = !1, this._wrapAround = !1, t.length <= 0) throw new Error("List can't be empty.");
                    this._list = t, this._index = 0
                }
                get length() {
                    return this._list.length
                }
                replaceList(t) {
                    if (t.length <= 0) throw new Error("List can't be empty.");
                    this._list = t, this._index = this.wrapIndex(this._index)
                }
                reset() {
                    this._index = this._list.length - 1
                }
                setIndex(t) {
                    this._index = this.wrapIndex(t)
                }
                next() {
                    const t = this.increment();
                    return this._list[t]
                }
                prev() {
                    const t = this.decrement();
                    return this._list[t]
                }
                current() {
                    return this._list[this._index]
                }
                isFirst() {
                    return 0 == this._index
                }
                isLast() {
                    return this._index == this._list.length - 1
                }
                setRandomizeAtWrapAround(t) {
                    return this._randomizeOnWrapAround = t, this
                }
                setWrapAround(t) {
                    return this._wrapAround = t, this
                }
                getListClone(t) {
                    return t ? n.ArrayUtils.shuffleArray(this._list) : this._list.concat()
                }
                increment() {
                    return this._index = this.wrapIndex(++this._index), this._index
                }
                decrement() {
                    return this._index = this.wrapIndex(--this._index), this._index
                }
                wrapIndex(t) {
                    return t >= this._list.length ? this._wrapAround ? (t = 0, this._randomizeOnWrapAround && (this._list = n.ArrayUtils.shuffleArray(this._list))) : t = this._list.length - 1 : t < 0 && (t = this._wrapAround ? this._list.length - 1 : 0), t
                }
            }
        },
        9315: function (t, e, i) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function (t, e, i, n) {
                void 0 === n && (n = i);
                var r = Object.getOwnPropertyDescriptor(e, i);
                r && !("get" in r ? !e.__esModule : r.writable || r.configurable) || (r = {
                    enumerable: !0,
                    get: function () {
                        return e[i]
                    }
                }), Object.defineProperty(t, n, r)
            } : function (t, e, i, n) {
                void 0 === n && (n = i), t[n] = e[i]
            }),
                r = this && this.__setModuleDefault || (Object.create ? function (t, e) {
                    Object.defineProperty(t, "default", {
                        enumerable: !0,
                        value: e
                    })
                } : function (t, e) {
                    t.default = e
                }),
                o = this && this.__importStar || function (t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
                    return r(e, t), e
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TimelineSprite = void 0;
            const s = o(i(3832)),
                a = i(6358);
            class l extends s.Sprite {
                get totalFrames() {
                    return this._textures.length
                }
                get totalDuration() {
                    return this._totalDuration
                }
                get frameDuration() {
                    return this._frameDuration
                }
                get currentFrame() {
                    const t = Math.floor(this.currentTweenFrame);
                    return Math.max(0, Math.min(t, this._textures.length - 1))
                }
                constructor(t, e = 30) {
                    super(t[0]), this._textures = t, this._sourceFPS = e, this._totalDuration = this._textures.length / this._sourceFPS, this._frameDuration = this._totalDuration / this._textures.length, this.currentTweenFrame = 0
                }
                getAnimation(t, e, i) {
                    1 === (t = null != t ? t : [0]).length && t.push(this._textures.length - 1);
                    const n = new a.TimelineLite;
                    n.add((() => this.setFrame(l.wrapIndex(this._textures.length, t[0]))));
                    for (let r = 1; r < t.length; r++) {
                        const o = l.wrapIndex(this._textures.length, t[r - 1]),
                            s = l.wrapIndex(this._textures.length, t[r]),
                            h = (Math.abs(o - s) + 1) * this._frameDuration;
                        n.add(new a.TweenLite(this, h, {
                            currentTweenFrame: s + (s >= o ? .99 : -.99),
                            ease: a.Linear.easeNone,
                            onUpdate: () => {
                                this.applyFrame(), e && e()
                            },
                            onComplete: r === t.length - 1 ? () => {
                                i && i()
                            } : void 0
                        }))
                    }
                    return n
                }
                static wrapIndex(t, e) {
                    if (t <= 0) throw new Error("Error: ArrayHelper.getValueInLoopRange(): length must bigger than zero!");
                    return e > t - 1 ? e % t : e < 0 ? t - Math.abs(e) % t : e
                }
                getAnimationAutoShowHide(t = !0, e = !0, i, n, r) {
                    const o = new a.TimelineLite;
                    return t && o.add((() => this.show())), o.add(this.getAnimation(i, n, (() => {
                        e && this.hide(), r && r()
                    }))), o
                }
                setFrame(t) {
                    this.currentTweenFrame = t, this.applyFrame()
                }
                applyFrame() {
                    this.texture = this._textures[this.currentFrame]
                }
                playLoop(t) {
                    this._loopAnimation && this._loopAnimation.isActive() || (this._loopAnimation = this.getAnimation([0], t, (() => this.playLoop(t))))
                }
                stopLoop() {
                    this._loopAnimation && this._loopAnimation.isActive() && (this._loopAnimation.pause(), this._loopAnimation.kill())
                }
                show() {
                    this.visible = !0
                }
                hide() {
                    this.visible = !1
                }
            }
            e.TimelineSprite = l
        },
        6418: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Timer = e.FlowState = void 0;
            const n = i(8246),
                r = i(8680),
                o = i(1410);
            var s;
            ! function (t) {
                t.IDLE = "IDLE", t.BET = "BET", t.BET_COMPLETED = "BET_COMPLETED", t.RESULT = "RESULT", t.WIN = "WIN"
            }(s = e.FlowState || (e.FlowState = {}));
            class a {
                static measureTimeAtStateStart(t, e) {
                    if (t == n.Mode.NORMAL) {
                        if (e == s.BET && (this._betStartDateTime = Date.now()), e == s.WIN) {
                            const t = o.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.minimumSpinTime,
                                e = Date.now() - this._betStartDateTime;
                            e < t ? this.roundStatsLogger.log(`%c Duration BET_START -> RESULT_END:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#AA0000; color:white;") : this.roundStatsLogger.log(`%c Duration BET_START -> RESULT_END:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#00AA00; color:white;")
                        }
                        if (e == s.BET_COMPLETED) {
                            const t = o.NolimitPromotionPlugin.apiPlugIn.gameClientConfiguration.minimumSpinTime,
                                e = Date.now() - this._betStartDateTime;
                            e < t ? this.roundStatsLogger.log(`%c Duration BET_START -> BET_COMPLETED:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#AA00AA; color:white;") : this.roundStatsLogger.log(`%c Duration BET_START -> BET_COMPLETED:  ${e} ms, (jurisdiction requirement: ${t})`, "background-color:#00AA00; color:white;")
                        }
                    }
                }
            }
            a.roundStatsLogger = r.Logger.createNamedLogger("Stats"), a._betStartDateTime = 0, e.Timer = a
        },
        460: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitAudioPlayer = void 0;
            const n = i(6212),
                r = i(8680),
                o = i(1766);
            class s { }
            s.MUSIC = "loops", s.EFFECT = "effects", s.KEYPAD = "keypad", e.NolimitAudioPlayer = class {
                get isLoaded() {
                    return this._isLoaded
                }
                get isLoading() {
                    return this._isLoading
                }
                get isLoadReady() {
                    return !!this._playCatalog
                }
                get catalogs() {
                    return this._playCatalog.catalogs
                }
                constructor() {
                    this.name = "AudioPlayer", this.FADE_TIME = 500, this._loopToBePlayed = [], this._loadingData = {
                        howlerPlayers: [],
                        configs: []
                    }, this._loggerEnabled = !1, this._isLoaded = !1, this._isLoading = !1, this._singelPlayers = {}, this._loopCache = []
                }
                getEffectDuration(t) {
                    return this.isLoaded ? this._singelPlayers.effects.duration(t) : 0
                }
                showLogs(t) {
                    this._loggerEnabled = t
                }
                soundLog(t, e) {
                    r.Logger.log("[SOUND" + (t ? "-" + t + "] : " : "] : ") + e)
                }
                createPlaylist(t) {
                    return t.then((t => {
                        this._playCatalog = {
                            catalogs: []
                        }, t.filter((t => !!t)).forEach((t => {
                            const e = {
                                categoryName: t.name,
                                soundList: {}
                            },
                                i = Object.keys(t.sprite);
                            this._loadingData.configs.push({
                                src: t.src,
                                loop: t.name === s.MUSIC,
                                sprite: t.sprite
                            });
                            for (let t = 0; t < i.length; t++) e.soundList[i[t]] = void 0;
                            this._playCatalog.catalogs.push(e)
                        }))
                    }))
                }
                startLoading() {
                    return this._isLoading = !0, new Promise((t => {
                        for (let t = 0; t < this._loadingData.configs.length; t++) this._loadingData.howlerPlayers.push(new o.Howl(this._loadingData.configs[t]));
                        t()
                    }))
                }
                checkLoadingState() {
                    for (let t = 0; t < this._loadingData.howlerPlayers.length; t++)
                        if ("loaded" !== this._loadingData.howlerPlayers[t].state()) return !1;
                    for (let t = 0; t < this.catalogs.length; t++) {
                        const e = this.getCategory(this.catalogs[t].categoryName),
                            i = this.getAllSoundInCatalog(e);
                        this.catalogs[t].categoryName == s.EFFECT && (this._singelPlayers.effects = new n.singelEffectsPlayer(this._loadingData.configs[t])), this.catalogs[t].categoryName == s.MUSIC && (this._singelPlayers.loops = new n.singelLoopPlayer(this._loadingData.configs[t]));
                        for (let r = 0; r < i.length; r++) {
                            const s = new o.Howl(this._loadingData.configs[t]);
                            e.soundList[i[r]] = new n.NolimitHowl(s, this._loadingData.configs[t]), e.soundList[i[r]].setSoundName(r)
                        }
                        this._loadingData.howlerPlayers[t].unload(), delete this._loadingData.howlerPlayers[t], delete this._loadingData.configs[t]
                    }
                    return this._loadingData = void 0, this._isLoading = !1, this._isLoaded = !0, !0
                }
                getCategory(t) {
                    let e = this.catalogs.find((e => e.categoryName === t));
                    if (!e) throw new Error("Trying to fetch sound from undefined soundFolder: " + t);
                    return e
                }
                getAllSoundInCatalog(t) {
                    return Object.keys(t.soundList)
                }
                getCategoryPlayer(t) {
                    const e = [],
                        i = Array.isArray(t) ? t : [t];
                    for (let t = 0; t < i.length; t++) {
                        const n = this.getCategory(i[t]),
                            r = this.getAllSoundInCatalog(n);
                        e.push(...r.map((t => n.soundList[t])))
                    }
                    return e
                }
                allPlayers() {
                    return this.getCategoryPlayer([s.KEYPAD, s.MUSIC, s.EFFECT])
                }
                getPlayerAtCategory(t, e) {
                    const i = Array.isArray(t) ? t : [t];
                    for (let t = 0; t < i.length; t++) {
                        let n = this.getCategory(i[t]);
                        if (-1 !== this.getAllSoundInCatalog(n).indexOf(e)) return n.soundList[e]
                    }
                }
                fetchSoundPlayer(t) {
                    for (let e = 0; e < this.catalogs.length; e++) {
                        let i = this.getCategory(this.catalogs[e].categoryName);
                        if (-1 !== this.getAllSoundInCatalog(i).indexOf(t)) return i.soundList[t]
                    }
                }
                getContext() {
                    return o.Howler.ctx
                }
                getMasterGain() {
                    return o.Howler.masterGain
                }
                setPause(t) {
                    this.isLoaded && (this.getCategoryPlayer([s.KEYPAD, s.MUSIC, s.EFFECT]).forEach((e => {
                        t ? e.pause() : e.resume()
                    })), this.onOldPause(t))
                }
                onOldPause(t) {
                    t ? (this._singelPlayers.loops.pause(), this._singelPlayers.effects.pause()) : (this._loopCache.length > 0 && (this._singelPlayers.loops.loop(this._loopCache), this._loopCache = []), this._singelPlayers.loops.resume(this.FADE_TIME), this._singelPlayers.effects.resume())
                }
                onHalt() {
                    this.setPause(!0), o.Howler.unload()
                }
                onSingleMusic(t) {
                    t ? (this._loopCache.length > 0 && (this._singelPlayers.loops.loop(this._loopCache), this._loopCache = []), this._singelPlayers.loops.resume(this.FADE_TIME)) : this._singelPlayers.loops.pause(this.FADE_TIME)
                }
                onSingleSfx(t) {
                    this._singelPlayers.effects.mute(t)
                }
                onMusic(t) {
                    this.isLoaded && (this._loggerEnabled && this.soundLog("MUSIC-MUTE", !t), this.onSingleMusic(t), this.getCategoryPlayer(s.MUSIC).forEach((e => {
                        if (null != this._loopToBePlayed && t) {
                            for (let t = 0; t < this._loopToBePlayed.length; t++)
                                if (e.isPlayerWithSound(this._loopToBePlayed[t].name)) {
                                    this._loggerEnabled && this.soundLog("MUSIC-PLAY", "Name: " + this._loopToBePlayed[t].name + ", Volume: " + this._loopToBePlayed[t].volume), e.fade(0, this._loopToBePlayed[t].volume, this.FADE_TIME);
                                    break
                                } e.mute(!t)
                        } else e.fadeToMute(!t, this.FADE_TIME)
                    })), null != this._loopToBePlayed && t && delete this._loopToBePlayed)
                }
                onSfx(t) {
                    this.isLoaded && (this._loggerEnabled && this.soundLog("SFX-MUTE", !t), this.onSingleSfx(!t), this.getCategoryPlayer([s.KEYPAD, s.EFFECT]).forEach((e => {
                        e.fadeToMute(!t, this.FADE_TIME)
                    })))
                }
                playEffect(t, e = 1) {
                    return r.Logger.deprecated("playEffect, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("PLAY-EFFECT", "Name: " + t + ", Amount: " + e), Promise.resolve(this._singelPlayers.effects.play(t, e))) : Promise.resolve("Not Loaded")
                }
                stopEffect(t, e = 0) {
                    return r.Logger.deprecated("stopEffect, use SlotGame.Sound.StopTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("STOP-EFFECT", "Name: " + t + ", FadeDurationMs: " + e), e <= 0 ? (this._singelPlayers.effects.stop(t), Promise.resolve(t)) : this.fadeEffect(t, 0, e).then((t => this.stopEffect(t, 0)))) : Promise.resolve("Not Loaded")
                }
                fadeEffect(t, e, i) {
                    return r.Logger.deprecated("fadeEffect, use SlotGame.Sound.FadeTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("FADE-EFFECT", "Name: " + t + ", ToVolume: " + e + ", DurationMS: " + i), this._singelPlayers.effects.fade(e, i, t)) : Promise.resolve("Not Loaded")
                }
                playAmbience(t, e, i) {
                    r.Logger.deprecated("playAmbience, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this._loopCache = Array.isArray(t) ? t : [t], this.isLoaded && (this._loggerEnabled && this.soundLog("AMBIENCE-PLAY", "Sounds: " + this._loopCache + ", FadeOutMS: " + e + ", FadeInMs: " + i), this._singelPlayers.loops.loop(this._loopCache, e, i), this._loopCache = [])
                }
                pauseAmbience(t = 0) {
                    return r.Logger.deprecated("pauseAmbience, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("AMBIENCE-PAUSE", "FadeOutDurationMs: " + t), this._singelPlayers.loops.pause(t)) : Promise.resolve("Not Loaded")
                }
                resumeAmbience(t = 0) {
                    return r.Logger.deprecated("resumeAmbience, use SlotGame.Sound.PlayTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("AMBIENCE-RESUME", "FadeInDurationMs: " + t), this._singelPlayers.loops.resume(t)) : Promise.resolve("Not Loaded")
                }
                fadeAmbience(t, e) {
                    return r.Logger.deprecated("fadeAmbience, use SlotGame.Sound.FadeTrack instead.", "0.4.3"), this.isLoaded ? (this._loggerEnabled && this.soundLog("AMBIENCE-FADE", "ToVolume: " + t + ", FadeDurationMs: " + e), this._singelPlayers.loops.fade(t, e)) : Promise.resolve("Not Loaded")
                }
                playTrack(t) {
                    if (this._loopToBePlayed) {
                        const e = null != t.volume ? t.volume : 1,
                            i = this._loopToBePlayed.findIndex((e => e.name == t.name)); - 1 == i ? this._loopToBePlayed.push({
                                name: t.name,
                                volume: e
                            }) : this._loopToBePlayed[i].volume = e
                    }
                    if (!this.isLoaded) return;
                    const e = this.getPlayerAtCategory([s.EFFECT, s.MUSIC], t.name);
                    return e && (this._loggerEnabled && this.soundLog("PLAY", "Name: " + t.name + ", Volume: " + (null != t.volume ? t.volume : 1) + ", Repeat: " + (null != t.repeat ? t.repeat : 0)), e.play(t.repeat, null != t.volume ? t.volume : 1)), e
                }
                stopTrack(t) {
                    if (this._loopToBePlayed && (this._loopToBePlayed = this._loopToBePlayed.filter((e => t != e.name))), !this.isLoaded) return;
                    const e = this.getPlayerAtCategory([s.EFFECT, s.MUSIC], t);
                    return e && (this._loggerEnabled && this.soundLog("STOP", "Name: " + t), e.stop()), e
                }
                fadeTrack(t) {
                    if (this._loopToBePlayed) {
                        const e = this._loopToBePlayed.findIndex((e => e.name == t.name));
                        e >= 0 && (this._loopToBePlayed[e].volume = null != t.to ? t.to : 1)
                    }
                    if (!this.isLoaded) return;
                    const e = this.getPlayerAtCategory([s.EFFECT, s.MUSIC], t.name);
                    return e && (this._loggerEnabled && this.soundLog("FADE", "Name: " + t.name + ", FromVolume: " + t.from + ", FromVolume: " + t.to + ", Duration: " + (t.duration ? t.duration : e.trackDuration())), e.fade(t.from, t.to, t.duration ? t.duration : e.trackDuration())), e
                }
                getSoundDuration(t) {
                    return this.isLoaded && this.getPlayerAtCategory([s.EFFECT, s.MUSIC], t) ? this.getPlayerAtCategory([s.EFFECT, s.MUSIC], t).trackDuration() : 0
                }
                playKeypadSound(t) {
                    if (!this.isLoaded || document.hidden) return;
                    const e = this.getPlayerAtCategory([s.KEYPAD], t);
                    return e && (this._loggerEnabled && this.soundLog("KEYPAD-PLAY", "Name: " + t), e.play(void 0, 1)), e
                }
                stopKeypadSound(t) {
                    if (!this.isLoaded || document.hidden) return;
                    const e = this.getPlayerAtCategory([s.KEYPAD], t);
                    return e && (this._loggerEnabled && this.soundLog("KEYPAD-STOP", "Name: " + t), e.stop()), e
                }
            }
        },
        6212: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitHowl = e.singelLoopPlayer = e.singelEffectsPlayer = e.HowlerStates = void 0;
            const n = i(1766);
            var r;
            (r = e.HowlerStates || (e.HowlerStates = {})).unloaded = "unloaded", r.loading = "loading", r.loaded = "loaded", e.singelEffectsPlayer = class {
                constructor(t) {
                    this.playing = {}, this.durations = {}, this.timesLeft = {}, this.paused = !1, this._player = new n.Howl(t);
                    for (let e in t.sprite) this.durations[e] = t.sprite[e][1]
                }
                play(t, e = 1) {
                    const i = this._player.play(t);
                    e > 1 && this._player.loop(!0, i), this.playing[t] && this.stop(t), this.playing[t] = i, this.timesLeft[i] = e, this._player.on("end", (e => {
                        this.timesLeft[e] = this.timesLeft[e] - 1, 1 === this.timesLeft[e] ? this._player.loop(!1, e) : this.timesLeft[e] < 1 && (delete this.playing[t], this._player.off("end", void 0, e))
                    }), i)
                }
                stop(t) {
                    t ? this.playing[t] && (this._player.off("end", void 0, this.playing[t]), this._player.stop(this.playing[t]), delete this.playing[t]) : Object.keys(this.playing).forEach((t => {
                        this.stop(t)
                    }))
                }
                pause() {
                    this.paused || (this.paused = !0, this._player.pause())
                }
                resume() {
                    if (this.paused) {
                        this.paused = !1;
                        for (const t in this.playing) this._player.play(this.playing[t])
                    }
                }
                duration(t) {
                    return this.durations[t]
                }
                volume(t) {
                    return this._player.volume(t)
                }
                fade(t, e, i) {
                    return new Promise((n => {
                        if (i && this.playing[i]) {
                            const r = this.playing[i];
                            this._player.once("fade", (() => n(i))), this._player.fade(this._player.volume(r), t, e, r)
                        } else n(i)
                    }))
                }
                mute(t) {
                    this._player.mute(t)
                }
                unload() {
                    return this._player.unload()
                }
            }, e.singelLoopPlayer = class {
                constructor(t) {
                    this.paused = !0, this.loopNames = [], this.currentLoopName = "", this.volume = 1, this._player = new n.Howl({
                        src: t.src,
                        sprite: t.sprite,
                        loop: !1
                    }), this._player.on("end", (() => this.playNext()))
                }
                loop(t, e = 0, i = e) {
                    if (this.loopNames = Array.isArray(t) ? t : [t], this.paused || this.loopNames[0] === this.currentLoopName) return Promise.resolve(0);
                    const n = this.currentLoopId;
                    return this.currentLoopName = this.loopNames[0], this.currentLoopId = this._player.play(this.currentLoopName), i > 0 && (this._player.volume(0, this.currentLoopId), this.fadeTo(this.currentLoopId, this.volume, i)), this.fadeTo(n, 0, e).then((t => (t && this._player.stop(t), Promise.resolve(t))))
                }
                pause(t = 0) {
                    return this.paused ? Promise.resolve() : (this.paused = !0, this.fadeTo(this.currentLoopId, 0, t).then((t => {
                        this.currentLoopId === t && this._player.pause(t)
                    })))
                }
                resume(t = 0) {
                    if (this.paused) {
                        if (this.paused = !1, this.currentLoopId && this.loopNames[0] === this.currentLoopName) return this._player.play(this.currentLoopId), this.fadeTo(this.currentLoopId, this.volume, t);
                        this.currentLoopId && this._player.stop(this.currentLoopId), this.loopNames && this.loopNames.length > 0 && (this.currentLoopName = this.loopNames[0], this.currentLoopId = this._player.play(this.currentLoopName), this.fadeTo(this.currentLoopId, this.volume, t))
                    }
                    return Promise.resolve()
                }
                fade(t, e = 0) {
                    return Number.isFinite(t) && t >= 0 && t <= 1 ? (this.volume = t, this.fadeTo(this.currentLoopId, this.volume, e)) : Promise.reject("Invalid volume: " + t)
                }
                fadeTo(t, e, i) {
                    return new Promise((n => {
                        if (t) {
                            if (!(i > 0 && this._player.volume(t) !== e)) return this._player.volume(e, t), n(t);
                            this._player.once("fade", (t => n(t))), this._player.fade(this._player.volume(t), e, i, t)
                        } else setTimeout(n, i)
                    }))
                }
                playNext() {
                    this.paused || (this.loopNames.push(this.loopNames.shift()), this.currentLoopName = this.loopNames[0], this.currentLoopId = this._player.play(this.currentLoopName), this._player.volume(this.volume, this.currentLoopId))
                }
                unload() {
                    return this._player.unload()
                }
            }, e.NolimitHowl = class {
                constructor(t, e) {
                    this._playIDs = [], this._soundName = "", this._repeatCount = 0, this._isPaused = !1, this._expectedVolume = 1, this._expectedMuteState = void 0, this._config = e, this._player = t
                }
                get config() {
                    return this._config
                }
                setSoundName(t = 0) {
                    this._soundName = Object.keys(this._config.sprite)[t], this.eventTriggers()
                }
                isPlayerWithSound(t) {
                    return this.soundName === t
                }
                eventTriggers() {
                    this.player.on("end", (() => this.cleanIDs()))
                }
                get soundName() {
                    return this._soundName
                }
                get triggerIDs() {
                    return this._playIDs
                }
                get lastTriggeredID() {
                    return this._playIDs[this.amountOfInstances - 1]
                }
                get amountOfInstances() {
                    return this._playIDs.length
                }
                get isEmpty() {
                    return 0 === this.amountOfInstances
                }
                get player() {
                    return this._player
                }
                get repeatCounter() {
                    return this._repeatCount
                }
                get isLooping() {
                    return this.player.loop() || this.repeatCounter > 0
                }
                get isPlaying() {
                    return this.player.playing()
                }
                setLoop(t) {
                    return this.player.loop(t)
                }
                play(t = 0, e = this.currentVolume(), i = 0) {
                    if (this._repeatCount = Math.max(0, t), this._expectedVolume = e, this.setVolume(this._expectedVolume), this.player.playing()) {
                        if (this.isLooping) this.player.play(this.lastTriggeredID);
                        else {
                            const t = this.player.play(this.soundName); - 1 == this._playIDs.indexOf(t) && this._playIDs.push(t)
                        }
                        return
                    }
                    const n = this.player.play(this.isEmpty ? this.soundName : this.lastTriggeredID); - 1 == this._playIDs.indexOf(n) && this._playIDs.push(n)
                }
                cleanIDs() {
                    if (this._repeatCount > 0) this.play(--this._repeatCount, this.currentVolume());
                    else if (!this.isEmpty) {
                        for (let t = 0; t < this.amountOfInstances; t++)
                            if (this.player.playing(this._playIDs[t])) return;
                        this.player.stop(), this._playIDs = []
                    }
                }
                resume() {
                    return !this.isEmpty && this._isPaused && (this.play(this._repeatCount, this._expectedVolume), this._isPaused = !1), this.soundName
                }
                pause() {
                    return !this.isEmpty && this.isPlaying && (this.player.pause(), this._isPaused = !0), this.soundName
                }
                stop() {
                    this._repeatCount = 0, this.player.stop(), this.cleanIDs()
                }
                isMuted() {
                    return this.player.mute()
                }
                mute(t) {
                    return this.player.mute(t), this._expectedMuteState = t, this.player
                }
                currentVolume() {
                    return this.player.volume()
                }
                setVolume(t) {
                    return this.player.volume(t)
                }
                fade(t = this.currentVolume(), e, i = 1) {
                    this.isEmpty && this.play(), this._expectedVolume = e, i <= 1 ? this.setVolume(this._expectedVolume) : (this.player.off("fade"), null != this._expectedMuteState && this.mute(this._expectedMuteState), this.player.fade(t, this._expectedVolume, i).once("fade", (() => {
                        this.setVolume(this._expectedVolume)
                    })))
                }
                fadeToMute(t, e = 1) {
                    this.player.off("fade"), this._expectedMuteState = t, !this.isEmpty && this.isPlaying ? this._expectedMuteState ? this.player.fade(this.currentVolume(), 0, e).once("fade", (() => {
                        this.mute(this._expectedMuteState)
                    })) : (this.mute(this._expectedMuteState), 0 == this._expectedVolume ? this.setVolume(this._expectedVolume) : this.player.fade(this.currentVolume(), this._expectedVolume, e)) : this.mute(this._expectedMuteState)
                }
                currentRate() {
                    return this.player.rate()
                }
                setRate(t) {
                    return this.player.rate(t)
                }
                idRate(t) {
                    this.player.rate(t, this.lastTriggeredID)
                }
                seek(t) {
                    return this.player.seek(t, this.lastTriggeredID)
                }
                trackDuration() {
                    return this._config.sprite[this.soundName][1]
                }
                currentState() {
                    return this.player.state()
                }
                load() {
                    this.player.load()
                }
                unload() {
                    this.player.unload()
                }
            }
        },
        1556: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitSlotAudio = void 0;
            const n = i(502),
                r = i(1740),
                o = i(7185),
                s = i(2820),
                a = i(8338),
                l = i(8680),
                h = i(460),
                u = i(877);
            class c {
                get AudioPlayer() {
                    return c._audioPlayer
                }
                get loading() {
                    return !!this.AudioPlayer && this.AudioPlayer.isLoading
                }
                get isLoaded() {
                    return !!this.AudioPlayer && this.AudioPlayer.isLoaded
                }
                get isLoading() {
                    return !!this.AudioPlayer && this.AudioPlayer.isLoading
                }
                constructor() {
                    this.name = "NolimitSlotAudio", this.muteSettingName = "mute", this._ignoreClick = !1, this.AudioPlayer || this.createAudioPlayer()
                }
                createAudioPlayer() {
                    c._audioPlayer = new h.NolimitAudioPlayer
                }
                get isEnabled() {
                    return !!c.apiPlugIn.settings.get(this.muteSettingName)
                }
                set isEnabled(t) {
                    c.apiPlugIn.settings.set(this.muteSettingName, t)
                }
                get isFirstOpened() {
                    return void 0 === c.apiPlugIn.settings.get(s.APISetting.SFX) || void 0 === c.apiPlugIn.settings.get(s.APISetting.MUSIC) || void 0 === c.apiPlugIn.settings.get(this.muteSettingName)
                }
                get isSettingsOff() {
                    return !c.apiPlugIn.settings.get(s.APISetting.SFX) && !c.apiPlugIn.settings.get(s.APISetting.MUSIC)
                }
                get isSettingsModified() {
                    return c.apiPlugIn.settings.get(s.APISetting.SFX) != c.apiPlugIn.settings.get(s.APISetting.MUSIC)
                }
                get sfxOn() {
                    return c.apiPlugIn.settings.get(s.APISetting.SFX)
                }
                get musicOn() {
                    return c.apiPlugIn.settings.get(s.APISetting.MUSIC)
                }
                get player() {
                    return this.AudioPlayer
                }
                addEventListeners() {
                    const t = c.apiPlugIn.events,
                        e = c.apiPlugIn.settings;
                    t.on(o.APIEvent.PAUSE, (t => this.eventTrigger(o.APIEvent.PAUSE, !0))), t.on(o.APIEvent.RESUME, (t => this.eventTrigger(o.APIEvent.RESUME, !1))), t.on(o.APIEvent.HALT, (t => this.eventTrigger(o.APIEvent.HALT, t))), t.on(o.APIEvent.HIDDEN, (t => this.eventTrigger(o.APIEvent.HIDDEN, t))), e.on(s.APISetting.SFX, (() => this.setInteractiveSettings(s.APISetting.SFX))), e.on(s.APISetting.MUSIC, (() => this.setInteractiveSettings(s.APISetting.MUSIC)))
                }
                eventTrigger(t, e) {
                    if (this.checkIsLoaded()) switch (t) {
                        case o.APIEvent.PAUSE:
                        case o.APIEvent.RESUME:
                        case o.APIEvent.HIDDEN:
                            this.isEnabled && this.AudioPlayer.setPause(!!e);
                            break;
                        case o.APIEvent.HALT:
                            this.AudioPlayer.onHalt();
                            break;
                        default:
                            throw new Error("Unkown Event Called: " + t)
                    }
                }
                checkIsLoaded() {
                    return this.AudioPlayer.isLoadReady ? (!this.isEnabled || this.isLoaded || this.isLoading || (l.Logger.logDev("SOUND: Start Loading"), this.load().then((() => {
                        this.tryStartSound()
                    }))), this.isLoaded) : this.AudioPlayer.isLoadReady
                }
                load() {
                    return this.AudioPlayer.startLoading().then((() => this.AudioPlayer))
                }
                tryStartSound() {
                    this.player.checkLoadingState() ? (this.loadTimeOutLoop = void 0, l.Logger.logDev("SOUND: Loaded"), c.apiPlugIn.settings.trigger(s.APISetting.SFX), c.apiPlugIn.settings.trigger(s.APISetting.MUSIC)) : (this.loadTimeOutLoop && clearTimeout(this.loadTimeOutLoop), this.loadTimeOutLoop = setTimeout((() => this.tryStartSound()), 200), l.Logger.logDev("SOUND: Checking if it's complete."))
                }
                setInteractiveSettings(t) {
                    this.updateSoundSetting() || (t == s.APISetting.SFX ? this.isEnabled ? this.AudioPlayer.onSfx(this.sfxOn) : this.AudioPlayer.onSfx(!1) : t == s.APISetting.MUSIC && (this.isEnabled ? this.AudioPlayer.onMusic(this.musicOn) : this.AudioPlayer.onMusic(!1)))
                }
                updateSoundSetting() {
                    return this._ignoreClick || (this.sfxOn || this.musicOn || (this.isEnabled = !1), this.isSettingsModified && (this.isEnabled = !0)), !this.checkIsLoaded()
                }
                setSoundSettings() {
                    const t = !!c.apiPlugIn.options.replay && !!c.apiPlugIn.options.replay.sound;
                    if (t && !this.isEnabled) return this.toggleMute(), void l.Logger.logDev("SOUND: isReplayWithSound: " + t);
                    const e = !!c.apiPlugIn.options.mute;
                    if (e && this.isEnabled) return this.toggleMute(), void l.Logger.logDev("SOUND: isMutedInOptions: " + e);
                    !(c.apiPlugIn.options.device === a.Device.MOBILE) && this.isFirstOpened && this.toggleMute(), this.isFirstOpened && (this.isEnabled = !(!c.apiPlugIn.settings.get(s.APISetting.SFX) && !c.apiPlugIn.settings.get(s.APISetting.MUSIC)))
                }
                isQuickMute() {
                    return !this.isEnabled
                }
                toggleQuickMute() {
                    return this.toggleMute(!1)
                }
                toggleMute(t = !0) {
                    return this.isEnabled = !this.isEnabled, this._ignoreClick = !0, t || !this.isSettingsModified ? (c.apiPlugIn.settings.set(s.APISetting.SFX, this.isEnabled), c.apiPlugIn.settings.set(s.APISetting.MUSIC, this.isEnabled)) : (c.apiPlugIn.settings.trigger(s.APISetting.SFX), c.apiPlugIn.settings.trigger(s.APISetting.MUSIC)), this._ignoreClick = !1, this.isEnabled
                }
                pause() {
                    this.eventTrigger(o.APIEvent.PAUSE, !0)
                }
                resume() {
                    this.eventTrigger(o.APIEvent.RESUME, !1)
                }
                init() {
                    return new Promise(((t, e) => {
                        for (let t of n.NolimitLauncher.plugins) (0, r.isApiPlugin)(t) && (c.apiPlugIn = t);
                        this.setSoundSettings(), this.addEventListeners(), t(this)
                    }))
                }
                getReady() {
                    return new Promise(((t, e) => {
                        this.getSoundUrl().then((i => {
                            u.get(i).json((e => {
                                this.AudioPlayer.createPlaylist(this.loadPlayer(e, i)).then((() => {
                                    this.updateSoundSetting(), t(this)
                                }))
                            })).catch(e)
                        })).catch(e)
                    }))
                }
                getReadyToStart() {
                    return Promise.resolve(this)
                }
                start() {
                    return Promise.resolve(this)
                }
                getSoundUrl() {
                    return new Promise(((t, e) => {
                        const i = c.apiPlugIn.resources.getConfig();
                        i ? t(i.staticRoot + c.AUDIO_JSON) : c.apiPlugIn.events.on(o.APIEvent.CONFIG, (() => {
                            const e = c.apiPlugIn.resources.getConfig();
                            t(e.staticRoot + c.AUDIO_JSON)
                        }))
                    }))
                }
                loadPlayer(t, e) {
                    return t = Array.isArray(t) ? t : [t], Promise.all(t.map((t => this.processSoundData(e, t))))
                }
                processSoundData(t, e) {
                    const i = this.getBaseUrl(t),
                        n = e[c.apiPlugIn.options.device] || e.src;
                    return e.src = n.map((t => `${i}/${t}`)), e
                }
                getBaseUrl(t) {
                    return t.substring(0, t.lastIndexOf("/"))
                }
                playKeypadEffect(t) {
                    this.player.playKeypadSound(t)
                }
            }
            c.AUDIO_JSON = "/resources/sounds/audio.json", e.NolimitSlotAudio = c
        },
        1115: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlotGame = void 0;
            const n = i(4267),
                r = i(502),
                o = i(1726),
                s = i(6946),
                a = i(1740),
                l = i(8778),
                h = i(8836),
                u = i(9785);
            class c {
                constructor() {
                    this.name = "SlotGame"
                }
                fetchPlugins() {
                    for (let t of r.NolimitLauncher.plugins) (0, o.isKeypadPlugin)(t) && (c.keypadPlugin = t), (0, s.isSoundPlugin)(t) && (c.sound = t.player), (0, a.isApiPlugin)(t) && (c.apiPlugin = t), (0, l.isJackpotPlugin)(t) && (c.jackpotPlugin = t), (0, h.isGamblePlugin)(t) && (c.gamblePlugin = t), (0, u.isAutoPlayPlugin)(t) && (c.autoPlayPlugin = t);
                    return null == c.keypadPlugin ? Promise.reject(new Error("SlotGame is missing KeypadPlugin")) : null == c.sound ? Promise.reject(new Error("SlotGame is missing SoundPlugin")) : null == c.apiPlugin ? Promise.reject(new Error("SlotGame is missing ApiPlugin")) : Promise.resolve()
                }
                getNoWinGameData() {
                    console.warn("GamePlugin.getNoWinData is not overridden in concrete game plugin, unable to soft reset")
                }
                init() {
                    return new Promise(((t, e) => {
                        this.fetchPlugins().catch((t => Promise.reject(t))), c.events = c.apiPlugin.eventSystemFactory.create(), t(this)
                    }))
                }
                getReady() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                getReadyToStart() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                start() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                getPaytable() {
                    const t = new n.TemplateLoader(c.apiPlugin.resources.getStaticRoot());
                    return t.add({
                        name: "Paytable",
                        url: "nolimit/screens/paytable.mustache"
                    }), t.load().then((t => {
                        for (let e of t)
                            if ("Paytable" == e.name && e.loadedData) return e.loadedData;
                        throw new Error("SlotGame could not load Paytable")
                    }))
                }
                getGameRules() {
                    const t = new n.TemplateLoader(c.apiPlugin.resources.getStaticRoot());
                    return t.add({
                        name: "Rules",
                        url: "nolimit/screens/rules.mustache"
                    }), t.load().then((t => {
                        for (let e of t)
                            if ("Rules" == e.name && e.loadedData) return e.loadedData;
                        throw new Error("SlotGame could not load Rules")
                    }))
                }
            }
            e.SlotGame = c
        },
        7732: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpineTween = void 0;
            const n = i(6358);
            class r extends n.TimelineLite {
                constructor(t, e, i, o = 0, s = 1) {
                    if (super(), null == i) return void r.clearAnimation(t, e);
                    const a = t.spineData.findAnimation(i);
                    if (!a) throw console.log(t), new Error(`No animation named ${i}`);
                    const l = 0 != o,
                        h = Math.max(a.duration, a.duration + a.duration * o),
                        u = new n.TweenLite(t, h, {});
                    this.add([u, () => r.setAnimation(t, e, a, l, s)]), o > 0 && this.add((() => r.stopLoop(t, e, a)))
                }
                static clearAnimation(t, e) {
                    t.state.setEmptyAnimation(e, 0)
                }
                static stopLoop(t, e, i) {
                    const n = t.state.getCurrent(e);
                    n.animation == i && (n.loop = !1)
                }
                static setAnimation(t, e, i, n, r) {
                    t.state.setAnimationWith(e, i, n).alpha = r
                }
            }
            e.SpineTween = r
        },
        379: (t, e) => {
            "use strict";
            var i, n, r;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AssetQualityLevel = e.SpriteSheetNameExtension = e.DefaultQualityExtension = void 0,
                function (t) {
                    t.LOW = "@0.25x.", t.MEDIUM = "@0.5x.", t.HIGH = "."
                }(i || (e.DefaultQualityExtension = i = {})),
                function (t) {
                    t.SPRITE_SHEET_SAME_LAYOUT = "_sheetSameLayout.", t.SPRITE_SHEET = "_sheet."
                }(n || (e.SpriteSheetNameExtension = n = {})),
                function (t) {
                    t[t.META = 0] = "META", t[t.LOW = 1] = "LOW", t[t.MEDIUM = 2] = "MEDIUM", t[t.HIGH = 3] = "HIGH"
                }(r || (e.AssetQualityLevel = r = {}))
        },
        343: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AssetLoader = e.AssetsQualitySetting = void 0;
            const n = i(8680),
                r = i(8338),
                o = i(9181),
                s = i(7185),
                a = i(379),
                l = i(3175),
                h = i(6629),
                u = i(6667),
                c = i(7598),
                d = i(6328);
            var p;
            ! function (t) {
                t[t.NONE = 0] = "NONE", t[t.LOW = 1] = "LOW", t[t.MEDIUM = 2] = "MEDIUM", t[t.HIGH = 3] = "HIGH"
            }(p || (e.AssetsQualitySetting = p = {})), e.AssetLoader = class {
                constructor(t, e) {
                    this._apiPlugin = t, this._apiPlugin.events.on(s.APIEvent.HALT, (() => this.halt())), this._baseUrl = e, this._events = this._apiPlugin.eventSystemFactory.create(), this.createLoader()
                }
                createLoader() {
                    this._loader = new PIXI.Loader(void 0, 1e4), this._textureParser = new l.TextureParser(this._loader), this._spineAssetParser = new h.SpineAssetParser(this._loader, this);
                    const t = this._loader._afterMiddleware[0],
                        e = (this._loader._afterMiddleware[1], this._loader._afterMiddleware[2]);
                    this._loader._afterMiddleware[3], this._loader._afterMiddleware[4], this._loader._afterMiddleware = [], this._loader._afterMiddleware.push(t), this._loader._afterMiddleware.push(e), this._loader.use(((t, e) => this._textureParser.parseResource(t, e))), this._loader.use(((t, e) => this._spineAssetParser.parseResource(t, e))), this._loader.onProgress.add(((t, e) => this.onLoaderProgress(t, e))), this._loader.onError.add(((t, e, i) => this.onLoaderError(t, e, i)))
                }
                getQualitySetting() {
                    switch (this._apiPlugin.options.quality) {
                        case "high":
                            return p.HIGH;
                        case "medium":
                            return p.MEDIUM;
                        case "low":
                            return p.LOW;
                        default:
                            return p.NONE
                    }
                }
                getDefaultQualities(t) {
                    const e = this.getQualitySetting();
                    if (!1 === this._apiPlugin.options.smartLoading || t) switch (e) {
                        case p.HIGH:
                            return [a.AssetQualityLevel.HIGH];
                        case p.MEDIUM:
                            return [a.AssetQualityLevel.MEDIUM];
                        case p.LOW:
                            return [a.AssetQualityLevel.LOW];
                        default:
                            return this._apiPlugin.options.device == r.Device.MOBILE ? [a.AssetQualityLevel.MEDIUM] : [a.AssetQualityLevel.HIGH]
                    }
                    switch (e) {
                        case p.HIGH:
                            return [a.AssetQualityLevel.MEDIUM, a.AssetQualityLevel.HIGH];
                        case p.MEDIUM:
                            return [a.AssetQualityLevel.LOW, a.AssetQualityLevel.MEDIUM];
                        case p.LOW:
                            return [a.AssetQualityLevel.LOW];
                        default:
                            return this._apiPlugin.options.device == r.Device.MOBILE ? [a.AssetQualityLevel.LOW, a.AssetQualityLevel.MEDIUM] : [a.AssetQualityLevel.MEDIUM, a.AssetQualityLevel.HIGH]
                    }
                }
                load(t) {
                    return new Promise(((e, i) => {
                        const n = d.AssetsConfig.getResourcesGroup(t);
                        for (let t of n) t && t.device && t.device !== this._apiPlugin.options.device && n.splice(n.indexOf(t), 1);
                        this.loadResourceGroup(t, n), this._events.on(c.AssetLoaderEvent.LEVEL_COMPLETE, (i => {
                            i.name == t && 1 == i.level && e({})
                        }))
                    }))
                }
                loadResourceGroup(t, e) {
                    if (this._loadLoopIndex = 0, this._totalAutoLoadLoops = 0, this._resourceGroup = t, null == e) return console.warn("AssetLoader.loadResourceGroup, assetGroups is null"), this._loadLoopIndex = 1, this.dispatchLoadLoopComplete(), void this.dispatchAllLoopsComplete();
                    this._assetsGroups = e;
                    for (let t of this._assetsGroups) null == t.autoLoad && (t.autoLoad = this.getDefaultQualities(t.forceSmartLoadingOff).concat()), t.autoLoad.unshift(a.AssetQualityLevel.META), this._totalAutoLoadLoops = this._totalAutoLoadLoops < t.autoLoad.length ? t.autoLoad.length : this._totalAutoLoadLoops, t.animations && this._textureParser.addAnimationRegister(t.animations);
                    this.autoLoadLevel()
                }
                addGroupToLoader(t) {
                    const e = t.autoLoad.shift();
                    if (null == e) return 0;
                    let i = 0;
                    for (let n of t.assets) {
                        let t = n.variants[e];
                        t && (this._loader.add(t.name, this._baseUrl + t.url), i++)
                    }
                    return i
                }
                autoLoadLevel() {
                    let t = 0;
                    for (let e = 0; e < this._assetsGroups.length; e++) t += this.addGroupToLoader(this._assetsGroups[e]);
                    t > 0 ? this._loader.load(((t, e) => this.onLevelLoaded(t, e))) : this.onLevelLoaded(this._loader, this._resources)
                }
                onLevelLoaded(t, e) {
                    if (t.reset(), this.dispatchLoadLoopComplete(), this._loadLoopIndex < this._totalAutoLoadLoops - 1) return this._loadLoopIndex++, void this.autoLoadLevel();
                    this.dispatchAllLoopsComplete()
                }
                dispatchAllLoopsComplete() {
                    n.Logger.logDev(`%cAssetLoader.dispatchAllLoopsComplete resourceGroup:${this._resourceGroup} , loadLoop: ${this._loadLoopIndex}`, "background:#99ea99;"), this._events.trigger(c.AssetLoaderEvent.ALL_LEVELS_COMPLETE, new c.AssetLoaderEvent(c.AssetLoaderEvent.ALL_LEVELS_COMPLETE, this._resourceGroup, this._loadLoopIndex))
                }
                dispatchLoadLoopComplete() {
                    n.Logger.logDev(`%cAssetLoader.dispatchLoadLoopComplete resourceGroup:${this._resourceGroup} , loadLoop: ${this._loadLoopIndex}`, "background:#ddffdd;"), this._resourceGroup === u.ResourcesGroupName.INTRO && (this._textureParser.ready = !0), this._events.trigger(c.AssetLoaderEvent.LEVEL_COMPLETE, new c.AssetLoaderEvent(c.AssetLoaderEvent.LEVEL_COMPLETE, this._resourceGroup, this._loadLoopIndex))
                }
                getTextures(t) {
                    return this._textureParser.getFrameTextures(t)
                }
                getSpineAsset(t) {
                    return this._spineAssetParser.getSpineAsset(t)
                }
                onLoaderProgress(t, e) {
                    this.dispatchProgress(t.progress)
                }
                dispatchProgress(t) {
                    this._events.trigger(c.AssetLoaderEvent.PROGRESS, new c.AssetLoaderEvent(c.AssetLoaderEvent.PROGRESS, this._resourceGroup, this._loadLoopIndex, t))
                }
                onLoaderError(t, e, i) {
                    n.Logger.logDev(t.message, e, i), this._apiPlugin.error.trigger(t.message, o.APIErrorCode.JAVASCRIPT)
                }
                halt() {
                    this._loader.destroy()
                }
            }
        },
        7598: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AssetLoaderEvent = void 0;
            class i {
                constructor(t, e, i, n) {
                    this.type = t, this.name = e, this.level = i, this.progress = n || 100
                }
            }
            e.AssetLoaderEvent = i, i.LEVEL_COMPLETE = "levelComplete", i.ALL_LEVELS_COMPLETE = "allLevelsComplete", i.PROGRESS = "progress"
        },
        6328: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AssetsConfig = void 0;
            const n = i(379),
                r = i(7962);
            class o {
                static addToAssetsConfig(t) {
                    for (let e in t) o._assetsConfig[e] ? o._assetsConfig[e] = o._assetsConfig[e].concat(t[e]) : o._assetsConfig[e] = t[e]
                }
                static get instance() {
                    return o._assetsConfig
                }
                static getResourcesGroup(t) {
                    return o._assetsConfig[t]
                }
            }
            e.AssetsConfig = o, o._defaultResources = {
                intro: [{
                    name: "defaultIntro",
                    autoLoad: [n.AssetQualityLevel.HIGH],
                    assets: [new r.TextureAsset("slotGameIntro0", "../node_modules/@nolimit/slot-game/resources/sheets/intro/intro0.json")],
                    animations: {
                        missingResource: "missing",
                        volatilityExtreme: "volatility_extreme",
                        volatilityHigh: "volatility_high",
                        volatilityMed: "volatility_medium",
                        xNudge: "x_nudge",
                        xWays: "x_ways"
                    }
                }],
                main: [{
                    name: "defaultMain",
                    assets: [new r.TextureAsset("slotGameMain0", "../node_modules/@nolimit/slot-game/resources/sheets/main/main0.json")],
                    animations: {
                        button: "ui/gameTweakerButton/button",
                        "button-disabled": "ui/gameTweakerButton/button-disabled"
                    }
                }]
            }, o._assetsConfig = {
                main: [],
                intro: []
            }
        },
        6667: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ResourcesGroupName = void 0,
                function (t) {
                    t.INTRO = "intro", t.MAIN = "main", t.FREESPIN = "freespin", t.BONUS = "bonus"
                }(i || (e.ResourcesGroupName = i = {}))
        },
        8964: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BitmapFontAsset = void 0;
            const n = i(379);
            e.BitmapFontAsset = class {
                constructor(t, e) {
                    this.name = t, this.variants = [], this.variants[n.AssetQualityLevel.META] = {
                        name: this.name,
                        url: e
                    }
                }
            }
        },
        4168: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpineAsset = void 0;
            const n = i(379);
            e.SpineAsset = class {
                constructor(t, e) {
                    this.name = t, this.variants = [], this.variants[n.AssetQualityLevel.META] = {
                        name: this.name,
                        url: e
                    }
                }
            }
        },
        7962: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TextureAsset = void 0;
            const n = i(379);
            class r {
                constructor(t, e, i = !0, o) {
                    this.name = t, this.variants = [], this._qualityExtensions = r.createQualityExtensions(o);
                    let s = r.getExtension(e);
                    const a = r.stripUrl(e, s);
                    "json" == s && (t += i ? n.SpriteSheetNameExtension.SPRITE_SHEET_SAME_LAYOUT : n.SpriteSheetNameExtension.SPRITE_SHEET), this.createVariants(t, a, s)
                }
                createVariants(t, e, i) {
                    this.variants[n.AssetQualityLevel.HIGH] = {
                        name: t,
                        url: e + this._qualityExtensions[n.AssetQualityLevel.HIGH] + i
                    }, this.variants[n.AssetQualityLevel.MEDIUM] = {
                        name: t,
                        url: e + this._qualityExtensions[n.AssetQualityLevel.MEDIUM] + i
                    }, this.variants[n.AssetQualityLevel.LOW] = {
                        name: t,
                        url: e + this._qualityExtensions[n.AssetQualityLevel.LOW] + i
                    }
                }
                static getExtension(t) {
                    let e = t.split(".").pop();
                    if (e) return e;
                    throw new Error("Asset url is not pointing to a valid file.")
                }
                static stripUrl(t, e) {
                    return t.slice(0, -(e.length + 1))
                }
                static createQualityExtensions(t) {
                    let e = [];
                    return e[n.AssetQualityLevel.HIGH] = t && t.high ? t.high : n.DefaultQualityExtension.HIGH, e[n.AssetQualityLevel.MEDIUM] = t && t.medium ? t.medium : n.DefaultQualityExtension.MEDIUM, e[n.AssetQualityLevel.LOW] = t && t.low ? t.low : n.DefaultQualityExtension.LOW, e
                }
            }
            e.TextureAsset = r
        },
        6629: (t, e) => {
            "use strict";

            function i(t) {
                return null != t.skins && Array.isArray(t.skins)
            }
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpineAssetParser = e.isSpineJson_3_8 = void 0, e.isSpineJson_3_8 = i;
            class n {
                constructor(t, e) {
                    this._loader = t, this._assetLoader = e, this._rawResource = {}, this._spineDataCache = {}
                }
                parseResource(t, e) {
                    if (!t.data || t.type !== PIXI.LoaderResource.TYPE.JSON || !t.data.bones) return e();
                    this._rawResource[t.name] = t, e()
                }
                getSpineAsset(t, e = /^\w+\//gi, i = "") {
                    if (this._spineDataCache[t]) return this._spineDataCache[t];
                    const r = this._rawResource[t],
                        o = r.data;
                    let s = n.getAllRegionNamesFromSpineData(o);
                    s = n.removeDuplicates(s);
                    const a = [];
                    for (let t of s) {
                        let n = {
                            regionName: t,
                            textureId: t.replace(e, i)
                        };
                        a.push(n)
                    }
                    const l = new PIXI.spine.core.TextureAtlas;
                    for (let t of a) l.addTexture(t.regionName, this._assetLoader.getTextures(t.textureId)[0]);
                    const h = new PIXI.spine.core.AtlasAttachmentLoader(l),
                        u = new PIXI.spine.core.SkeletonJson(h),
                        c = (r.metadata, r.metadata.spineSkeletonScale);
                    return c && (u.scale = c), this._spineDataCache[t] = u.readSkeletonData(r.data), this._spineDataCache[t]
                }
                static getAllRegionNamesFromSpineData(t) {
                    if (i(t)) {
                        let e = [];
                        return t.skins.forEach((t => {
                            const i = this.findTexturesInSkin(t.attachments);
                            e = e.concat(i)
                        })), e
                    } {
                        let e = [];
                        for (let i in t.skins) {
                            const n = t.skins[i],
                                r = this.findTexturesInSkin(n);
                            e = e.concat(r)
                        }
                        return e
                    }
                }
                static findTexturesInSkin(t) {
                    let e = [];
                    for (let i in t) {
                        const r = t[i];
                        for (let t in r) {
                            const i = r[t];
                            if (!i.type || "mesh" == i.type || "linkedmesh" == i.type)
                                if ("mesh" == i.type || "linkedmesh" == i.type || i.width && i.height) {
                                    let n;
                                    n = i.path ? i.path : i.name ? i.name : t, e.push(n)
                                } else {
                                    const t = n.findTexturesInSkin(i);
                                    e = e.concat(t)
                                }
                        }
                    }
                    return e
                }
                static removeDuplicates(t) {
                    const e = [];
                    for (let i = 0; i < t.length; i++) {
                        const n = t[i];
                        e.indexOf(n) < 0 && e.push(n)
                    }
                    return e
                }
            }
            e.SpineAssetParser = n
        },
        3175: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TextureParser = void 0;
            const n = i(379),
                r = i(8680);
            class o {
                constructor(t) {
                    this.ready = !1, this._loader = t, this._spriteSheetCache = {}, this._animationCache = {}, this._animationRegister = {}, this._oldBaseTextures = []
                }
                parseResource(t, e) {
                    t.type == PIXI.LoaderResource.TYPE.JSON && t.data.frames && this.processSpriteSheet(t), t.data && t.type === PIXI.LoaderResource.TYPE.IMAGE && this.processBaseTexture(t), e()
                }
                addAnimationRegister(t) {
                    for (let e in t) this._animationRegister[e] = t[e]
                }
                getFrameTextures(t) {
                    let e = t;
                    if (this._animationRegister[t] && (e = this._animationRegister[t]), PIXI.utils.TextureCache[e]) return [PIXI.utils.TextureCache[e]];
                    if (!this._animationCache[t]) {
                        let i = [];
                        for (let t in PIXI.utils.TextureCache) {
                            if (t.search("^" + e) < 0) continue;
                            let n = t.split(e).pop();
                            if (!n) continue;
                            let r = parseFloat(n);
                            isNaN(r) || i.push(t)
                        }
                        0 != i.length && (i = i.sort(), this._animationCache[t] = i)
                    }
                    if (this._animationCache[t]) {
                        let e = [];
                        for (let i of this._animationCache[t]) e.push(PIXI.utils.TextureCache[i]);
                        return e
                    }
                    if (this.ready) {
                        if ("missingResource" === t) throw new Error(`Error: TextureParser.getTexture(): [${t}] is not in texture cache, please check if you install slot-game correctly!`);
                        return r.Logger.logDev(`Error: TextureParser.getTexture(): [${t}] is not in texture cache`), this.getFrameTextures("missingResource")
                    }
                    throw new Error(`Error: TextureParser.getTexture(): [${t}] You cannot use texture before it's loaded!`)
                }
                processSpriteSheet(t) {
                    const e = t.name.search(n.SpriteSheetNameExtension.SPRITE_SHEET_SAME_LAYOUT) >= 0,
                        i = t.name.search(n.SpriteSheetNameExtension.SPRITE_SHEET);
                    if (i >= 0) {
                        let r = t.name.substring(0, i);
                        r += t.name.substring(i - 1 + n.SpriteSheetNameExtension.SPRITE_SHEET.length);
                        let o = t.data;
                        this._spriteSheetCache[r] && 0 == e && (o.dirty = !0), this._spriteSheetCache[r] = o;
                        const s = t.url.substring(0, t.url.lastIndexOf("/")) + "/";
                        let a = {
                            crossOrigin: t.crossOrigin,
                            loadType: PIXI.LoaderResource.LOAD_TYPE.IMAGE,
                            metadata: t.metadata.imageMetadata,
                            parentResource: t
                        };
                        this._loader.add(r, s + o.meta.image, a)
                    }
                }
                postProcessFrames(t) {
                    const e = t.name;
                    if (!this._spriteSheetCache[e]) return;
                    const i = this._spriteSheetCache[e];
                    let n = PIXI.utils.BaseTextureCache[e];
                    for (let t in i.frames) {
                        let e, r = n.resolution;
                        if (PIXI.utils.TextureCache[t]) e = PIXI.utils.TextureCache[t], e.baseTexture = n, 1 == i.dirty && o.updateTextureFrame(e, i.frames[t], r), e.updateUvs();
                        else {
                            const e = new PIXI.Texture(n);
                            o.updateTextureFrame(e, i.frames[t], r), PIXI.Texture.addToCache(e, t)
                        }
                    }
                }
                static updateTextureFrame(t, e, i) {
                    const n = e.frame;
                    n && (e.trimmed && (t.trim ? (t.trim.x = e.spriteSourceSize.x / i, t.trim.y = e.spriteSourceSize.y / i, t.trim.width = n.w / i, t.trim.height = n.h / i) : t.trim = new PIXI.Rectangle(e.spriteSourceSize.x / i, e.spriteSourceSize.y / i, n.w / i, n.h / i)), t.rotate = e.rotated ? 2 : 0, t.frame.x = n.x / i, t.frame.y = n.y / i, t.frame.width = e.rotated ? n.h / i : n.w / i, t.frame.height = e.rotated ? n.w / i : n.h / i, t.orig = new PIXI.Rectangle(0, 0, e.sourceSize.w / i, e.sourceSize.h / i)), t.updateUvs()
                }
                processBaseTexture(t) {
                    if (t.data && t.type === PIXI.LoaderResource.TYPE.IMAGE) {
                        const e = t.name;
                        if (PIXI.utils.BaseTextureCache[e]) {
                            const i = PIXI.BaseTexture.removeFromCache(e),
                                n = new PIXI.BaseTexture(t.data, {
                                    scaleMode: PIXI.settings.SCALE_MODE,
                                    resolution: PIXI.utils.getResolutionOfUrl(t.url)
                                });
                            n.resolution = PIXI.utils.getResolutionOfUrl(t.url), PIXI.utils.TextureCache[e].baseTexture = n, PIXI.BaseTexture.addToCache(n, e), this._oldBaseTextures.push(i), n.update()
                        } else {
                            let i = new PIXI.BaseTexture(t.data, {
                                scaleMode: PIXI.settings.SCALE_MODE,
                                resolution: PIXI.utils.getResolutionOfUrl(t.url)
                            });
                            i.resolution = PIXI.utils.getResolutionOfUrl(t.url), t.texture = new PIXI.Texture(i), PIXI.BaseTexture.addToCache(i, e), PIXI.Texture.addToCache(t.texture, e)
                        }
                        this.postProcessFrames(t)
                    }
                    this.destroyOldBaseTextures()
                }
                destroyOldBaseTextures() {
                    let t = this._oldBaseTextures.pop();
                    for (; t;) t.destroy(), t = this._oldBaseTextures.pop()
                }
            }
            e.TextureParser = o
        },
        2201: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FlowState = void 0,
                function (t) {
                    t.IDLE = "IDLE", t.BET = "BET", t.RESULT = "RESULT", t.WIN = "WIN"
                }(i || (e.FlowState = i = {}))
        },
        6038: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameFlowController = void 0;
            const n = i(2327),
                r = i(7185),
                o = i(1115),
                s = i(8943),
                a = i(493),
                l = i(8680),
                h = i(2201);
            e.GameFlowController = class {
                constructor(t, e) {
                    this._mode = n.GameMode.NORMAL, this._prevMode = this._mode, this._minimumGameRoundTimeInMs = 0, this._normalRoundCount = 0, this._accumulatedRoundTime = 0, this._apiPlugin = t, this._apiPlugin.events.on(r.APIEvent.STATE, (t => this.onApiState(t))), this._gameModeMap = new Map, this._model = e, this.flowStateLogger = l.Logger.createNamedLogger("FlowState"), this.roundStatsLogger = l.Logger.createNamedLogger("Stats")
                }
                start() {
                    this._minimumGameRoundTimeInMs = o.SlotGame.apiPlugin.gameClientConfiguration.minimumSpinTime, this._mode = this._model.data.nextMode, this.startFlowStatePresentation(h.FlowState.IDLE)
                }
                addGameModeFlowStatePresentationMap(t, e) {
                    this._gameModeMap.set(t, e)
                }
                calculatePaddingDuration(t) {
                    const e = 1e3 * t,
                        i = Date.now() - this._betStartDateTime,
                        n = (this._minimumGameRoundTimeInMs - i - e) / 1e3;
                    return Math.max(0, n)
                }
                getStateMap(t) {
                    const e = this._gameModeMap.get(t) || this._gameModeMap.get(n.GameMode.NORMAL);
                    if (null == e) throw new Error("You need at least one Game Mode Sequence, for GameMode.NORMAL");
                    return e
                }
                startFlowStatePresentation(t) {
                    if (null != this._currentPresentation) throw new Error(`Current presentation is not complete for state: ${t} mode: ${this._prevMode}`);
                    this._stateMap = this.getStateMap(this._mode), this._prevMode = this._mode, this.measureTimeAtStateStart(this._mode, t), this.flowStateLogger.log(`${this._mode}, ${t} start`);
                    const e = this._stateMap.get(t);
                    null != e ? (this._currentPresentation = e, this._currentPresentationController = new a.SkippableFlowStateController(t, (t => this.onFlowStateComplete(t)), (t => this.setSkippable(t))), this._currentPresentation.start(this._currentPresentationController)) : this.onFlowStateComplete(t)
                }
                setSkippable(t) {
                    var e, i;
                    const n = o.SlotGame.apiPlugin.slotStates.checkState(s.SlotState.STOPPING, s.SlotState.SKIPPED) && t,
                        a = o.SlotGame.apiPlugin.slotStates.checkState(s.SlotState.SKIPPABLE) && !t;
                    if (n && a) throw new Error("You cant enable and disable skippable at the same time");
                    n && (this.flowStateLogger.log(`${this._mode}, ${null === (e = this._currentPresentationController) || void 0 === e ? void 0 : e.state} enable skip`), o.SlotGame.apiPlugin.events.trigger(r.APIEvent.SKIPPABLE)), a && (this.flowStateLogger.log(`${this._mode}, ${null === (i = this._currentPresentationController) || void 0 === i ? void 0 : i.state} disable skip`), o.SlotGame.apiPlugin.events.trigger(r.APIEvent.SKIP))
                }
                onFlowStateComplete(t) {
                    switch (this.flowStateLogger.log(`${this._mode}, ${t} complete`), this._stateMap = void 0, this._currentPresentation = void 0, this._currentPresentationController = void 0, t) {
                        case h.FlowState.IDLE:
                            break;
                        case h.FlowState.BET:
                            o.SlotGame.jackpotPlugin && o.SlotGame.jackpotPlugin.isActive ? o.SlotGame.jackpotPlugin.addOnSpinCompleteCallback((() => {
                                this._apiPlugin.events.trigger(r.APIEvent.STARTED)
                            })) : this._apiPlugin.events.trigger(r.APIEvent.STARTED);
                            break;
                        case h.FlowState.RESULT:
                            this._apiPlugin.events.trigger(r.APIEvent.STOP);
                            break;
                        case h.FlowState.WIN:
                            this._apiPlugin.events.trigger(r.APIEvent.DONE), this._mode = this._model.data.nextMode, this._mode != n.GameMode.NORMAL ? this.startFlowStatePresentation(h.FlowState.IDLE) : (this._apiPlugin.events.trigger(r.APIEvent.FINISH), this._apiPlugin.slotStates.stateIsReady().then((() => {
                                this.startFlowStatePresentation(h.FlowState.IDLE)
                            })))
                    }
                }
                setMode(t) {
                    this._mode = t
                }
                skipFlowState(t) {
                    if (null == this._stateMap) throw new Error("Sequence is undefined, when skip");
                    null != this._currentPresentation && null != this._currentPresentationController && (this._currentPresentationController.finishCallback = () => this.onFlowStateSkipComplete(this._currentPresentationController.state), this._currentPresentationController.skip(), this.flowStateLogger.log(`${this._mode}, ${t} skip`))
                }
                onFlowStateSkipComplete(t) {
                    switch (this.flowStateLogger.log(`${this._mode}, ${t} skipped complete`), this._stateMap = void 0, this._currentPresentation = void 0, this._currentPresentationController = void 0, t) {
                        case h.FlowState.IDLE:
                            this.startFlowStatePresentation(h.FlowState.BET);
                            break;
                        case h.FlowState.BET:
                            this.startFlowStatePresentation(h.FlowState.RESULT);
                            break;
                        case h.FlowState.RESULT:
                            this.startFlowStatePresentation(h.FlowState.WIN);
                            break;
                        case h.FlowState.WIN:
                            this.onFlowStateComplete(h.FlowState.WIN)
                    }
                }
                onApiState(t) {
                    switch (t) {
                        case s.SlotState.STARTING:
                            null != this._stateMap ? this.skipFlowState(h.FlowState.IDLE) : this.startFlowStatePresentation(h.FlowState.BET);
                            break;
                        case s.SlotState.STOPPABLE:
                            this.startFlowStatePresentation(h.FlowState.RESULT);
                            break;
                        case s.SlotState.STOPPING:
                            null != this._stateMap ? this.skipFlowState(h.FlowState.RESULT) : this.startFlowStatePresentation(h.FlowState.WIN);
                            break;
                        case s.SlotState.SKIPPED:
                            null != this._stateMap && this.skipFlowState(h.FlowState.WIN);
                            break;
                        case s.SlotState.GAMBLE_DONE:
                            null != this._stateMap ? this.skipFlowState(h.FlowState.WIN) : this.startFlowStatePresentation(h.FlowState.WIN)
                    }
                }
                measureTimeAtStateStart(t, e) {
                    if (t == n.GameMode.NORMAL) {
                        if (e == h.FlowState.BET && (this._betStartDateTime = Date.now(), this._normalRoundCount += 1), e == h.FlowState.IDLE && this._normalRoundCount > 0) {
                            const t = Date.now() - this._betStartDateTime;
                            this._accumulatedRoundTime += t;
                            const e = this._accumulatedRoundTime / this._normalRoundCount;
                            this.roundStatsLogger.log(`%c Average:${e}  rounds:${this._normalRoundCount}`, "background-color:#0000AA; color:white;")
                        }
                        if (e == h.FlowState.WIN) {
                            const t = Date.now() - this._betStartDateTime;
                            t < this._minimumGameRoundTimeInMs ? this.roundStatsLogger.log(`%c Duration BET_START -> RESULT_END:  ${t} ms, (jurisdiction requirement: ${this._minimumGameRoundTimeInMs})`, "background-color:#AA0000; color:white;") : this.roundStatsLogger.log(`%c Duration BET_START -> RESULT_END:  ${t} ms, (jurisdiction requirement: ${this._minimumGameRoundTimeInMs})`, "background-color:#00AA00; color:white;")
                        }
                    }
                }
            }
        },
        2327: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameMode = void 0;
            class i { }
            e.GameMode = i, i.NORMAL = "NORMAL", i.RESPIN = "RESPIN", i.FREESPIN = "FREESPIN", i.FREESPIN_SUPER = "FREESPIN_SUPER", i.GAMBLE = "GAMBLE"
        },
        493: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SkippableFlowStateController = void 0, e.SkippableFlowStateController = class {
                get finishCallback() {
                    return this._finishCallback
                }
                set finishCallback(t) {
                    this._finishCallback = t
                }
                constructor(t, e, i) {
                    this.state = t, this.finishCallback = e, this._setSkippableCallback = i
                }
                finish() {
                    setTimeout((() => this.finishCallback(this.state)))
                }
                setSkipCallback(t) {
                    this._skipCallback = t, setTimeout((() => {
                        this._setSkippableCallback(null != this._skipCallback)
                    }))
                }
                skip() {
                    setTimeout((() => {
                        null != this._skipCallback && this._skipCallback()
                    }))
                }
            }
        },
        6496: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameModel = e.GameModelEvent = void 0;
            const n = i(7185),
                r = i(8680);
            var o;
            ! function (t) {
                t.INIT = "INIT", t.GAME = "GAME"
            }(o || (e.GameModelEvent = o = {})), e.GameModel = class {
                onInit(t) {
                    this.initData = t, this.data = t, this.logger.log("INIT DATA", t), this.events && this.events.trigger(o.INIT, t)
                }
                onGame(t) {
                    this.gameData = t, this.data = t, this.logger.log("GAME DATA", t), this.events && this.events.trigger(o.GAME, t)
                }
                constructor(t, e = !0) {
                    e && (this.events = t.eventSystemFactory.create()), this.logger = r.Logger.createNamedLogger("GameModel"), t.events.on(n.APIEvent.INIT, (t => this.onInit(t))), t.events.on(n.APIEvent.GAME, (t => this.onGame(t)))
                }
            }
        },
        6364: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ArrayHelper = void 0;
            const n = i(9529);
            e.ArrayHelper = class {
                static initArrayWithValues(t, e) {
                    const i = [];
                    for (let n = 0; n < t; n++) i.push(e(n));
                    return i
                }
                static getRandomValue(t) {
                    return t[n.MathHelper.clamp(Math.round(Math.random() * t.length), 0, t.length - 1)]
                }
                static arraySum(t) {
                    return t.reduce(((t, e) => t + e), 0)
                }
                static fetchArrTypeValue(t, e) {
                    return Array.isArray(t) ? t[e] : t
                }
                static countWithCondition(t, e) {
                    return t.filter((t => e(t))).length
                }
                static fetchLastValue(t) {
                    return t[t.length - 1]
                }
                static reviseIndexInLoopRange(t, e) {
                    if (t <= 0) throw new Error("Error: ArrayHelper.getValueInLoopRange(): length must bigger than zero!");
                    return e > t - 1 ? e % t : e < 0 ? t - Math.abs(e) % t : e
                }
                static removeFirstMatchElement(t, e) {
                    for (let i = 0; i < t.length; i++)
                        if (t[i] === e) return void t.splice(i, 1)
                }
                static indexOfArr(t, e) {
                    for (let e = 0; e < t.length; e++) {
                        const i = t.indexOf(t[e]);
                        if (i >= 0) return i
                    }
                    return -1
                }
                static removeFirstMatchElementWithCondition(t, e) {
                    for (let i = 0; i < t.length; i++)
                        if (e(t[i])) return void t.splice(i, 1)
                }
                static swapPositions(t, e, i) {
                    return [t[e], t[i]] = [t[i], t[e]]
                }
                static eachForEach(t, e) {
                    for (let i = 0; i < t.length; i++)
                        for (let n = 0; n < t[i].length; n++) e(t[i][n])
                }
                static countAmountOfIndexes(t, e = 0) {
                    if (Array.isArray(t))
                        for (let i = 0; i < t.length; i++) {
                            if (!Array.isArray(t[i])) return e + t.length;
                            e = this.countAmountOfIndexes(t[i], e)
                        }
                    return e
                }
                static shuffle(t) {
                    for (let e = t.length; e; e--) this.swapPositions(t, e - 1, Math.floor(Math.random() * e));
                    return t
                }
            }
        },
        9529: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.MathHelper = void 0;
            class i {
                static floorToDecimals(t, e) {
                    return Math.floor(t * Math.pow(10, e)) / Math.pow(10, e)
                }
                static ceilToDecimals(t, e) {
                    return Math.ceil(t * Math.pow(10, e)) / Math.pow(10, e)
                }
                static roundToDecimals(t, e) {
                    return Number(t.toFixed(e))
                }
                static randomNumberInRange(t, e, i = 0) {
                    let n = t + (e - t) * Math.random();
                    return Number(n.toFixed(i))
                }
                static randomIntInRange(t, e) {
                    return Math.floor(Math.random() * (e - t + 1) + t)
                }
                static clamp(t, e, i) {
                    return Math.min(Math.max(t, e), i)
                }
                static constrain(t, e, i) {
                    return Math.max(e, Math.min(t, i))
                }
                static isInRange(t, e, i) {
                    return t >= e && t <= i
                }
                static map(t, e, i, n, r) {
                    return (t - e) * (r - n) / (i - e) + n
                }
                static angleBetweenPoints(t, e) {
                    return Math.atan2(e.y - t.y, e.x - t.x)
                }
                static pointAdd(t, e) {
                    return "number" == typeof e ? new PIXI.Point(t.x + e, t.y + e) : new PIXI.Point(t.x + e.x, t.y + e.y)
                }
                static pointSub(t, e) {
                    return "number" == typeof e ? new PIXI.Point(t.x - e, t.y - e) : new PIXI.Point(t.x - e.x, t.y - e.y)
                }
                static pointMul(t, e) {
                    return "number" == typeof e ? new PIXI.Point(t.x * e, t.y * e) : new PIXI.Point(t.x * e.x, t.y * e.y)
                }
                static pointDiv(t, e) {
                    return "number" == typeof e ? new PIXI.Point(t.x / e, t.y / e) : new PIXI.Point(t.x / e.x, t.y / e.y)
                }
                static vectorMagnitude(t) {
                    return Math.sqrt(t.x * t.x + t.y * t.y)
                }
                static normalizeVector(t) {
                    const e = i.vectorMagnitude(t);
                    return e > 0 ? i.pointDiv(t, e) : new PIXI.Point
                }
                static pointAlongLine(t, e, i) {
                    let n = i;
                    return new PIXI.Point((1 - n) * t.x + n * e.x, (1 - n) * t.y + n * e.y)
                }
                static distanceBetweenPoints(t, e) {
                    return Math.sqrt((t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y))
                }
                static randomPosInRect(t, e) {
                    let n = new PIXI.Point(i.randomIntInRange(t.x, t.width + t.x), i.randomIntInRange(t.y, t.height + t.y));
                    if (e)
                        for (; e.contains(n.x, n.y);) n = new PIXI.Point(i.randomIntInRange(t.x, t.width + t.x), i.randomIntInRange(t.y, t.height + t.y));
                    return n
                }
                static DistanceByVTA(t, e, i) {
                    return t * e + i * Math.pow(e, 2) / 2
                }
                static accCalcByVDT(t, e, i) {
                    return 2 * (e - t * i) / Math.pow(i, 2)
                }
                static accCalcByVVD(t, e, i) {
                    return (Math.pow(t, 2) - Math.pow(e, 2)) / (2 * i)
                }
                static timeByVVA(t, e, i) {
                    return (t - e) / i
                }
                static frameToSeconds(t, e = 30) {
                    return t / e
                }
                static secondsToFrame(t, e = 30) {
                    return t * e
                }
                static normalizedRotation(t) {
                    return 2 * Math.PI / t
                }
                static degreeToAngle(t) {
                    return this.normalizedRotation(360 / t)
                }
            }
            e.MathHelper = i
        },
        7023: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SkinLoader = void 0;
            const n = i(2408),
                r = i(4514);
            class o {
                constructor() {
                    this._imgAssets = new Map, this._guideAssets = new Map, this._isLoaded = !1, this._defaultImgUrl = "/node_modules/@nolimit/slot-keypad/resources/default/icons/", this._defaultGuideUrl = "/node_modules/@nolimit/slot-keypad/resources/default/gui_guide_images/", this._loader = new n.ImgLoader(r.NolimitApplication.resourcePath), this._imgAssets.set(o.AUTO_PLAY_ON, this.makeImgUrl("keypad_icons/" + o.AUTO_PLAY_ON)), this._imgAssets.set(o.AUTO_PLAY_OFF, this.makeImgUrl("keypad_icons/" + o.AUTO_PLAY_OFF)), this._imgAssets.set(o.BACK, this.makeImgUrl("keypad_icons/" + o.BACK)), this._imgAssets.set(o.BET_LEVELS_BUTTON, this.makeImgUrl("keypad_icons/" + o.BET_LEVELS_BUTTON)), this._imgAssets.set(o.DEMO_ICON, this.makeImgUrl("keypad_icons/" + o.DEMO_ICON)), this._imgAssets.set(o.FAST_SPIN, this.makeImgUrl("keypad_icons/" + o.FAST_SPIN)), this._imgAssets.set(o.MENU, this.makeImgUrl("keypad_icons/" + o.MENU)), this._imgAssets.set(o.RING_LOADER, this.makeImgUrl("keypad_icons/" + o.RING_LOADER)), this._imgAssets.set(o.SOUND_ON, this.makeImgUrl("keypad_icons/" + o.SOUND_ON)), this._imgAssets.set(o.SOUND_OFF, this.makeImgUrl("keypad_icons/" + o.SOUND_OFF)), this._imgAssets.set(o.EXIT_LOBBY, this.makeImgUrl("menu_icons/" + o.EXIT_LOBBY)), this._imgAssets.set(o.HISTORY, this.makeImgUrl("menu_icons/" + o.HISTORY)), this._imgAssets.set(o.INFO, this.makeImgUrl("menu_icons/" + o.INFO)), this._imgAssets.set(o.SETTINGS, this.makeImgUrl("menu_icons/" + o.SETTINGS)), this._imgAssets.set(o.MENU_CLOSE, this.makeImgUrl("menu_icons/" + o.MENU_CLOSE)), this._imgAssets.set(o.SPIN_BUTTON_PLATE, this.makeImgUrl("spinbutton/" + o.SPIN_BUTTON_PLATE)), this._imgAssets.set(o.SPIN_ARROW, this.makeImgUrl("spinbutton/" + o.SPIN_ARROW)), this._imgAssets.set(o.SPIN_PLAY, this.makeImgUrl("spinbutton/" + o.SPIN_PLAY)), this._imgAssets.set(o.SPIN_SKIP, this.makeImgUrl("spinbutton/" + o.SPIN_SKIP)), this._imgAssets.set(o.SPIN_STOP, this.makeImgUrl("spinbutton/" + o.SPIN_STOP)), this._imgAssets.set(o.COLLECT_ICON, this.makeImgUrl("spinbutton/" + o.COLLECT_ICON)), this._imgAssets.set(o.BOOST_ICON, this.makeImgUrl("spinbutton/" + o.BOOST_ICON)), this._imgAssets.set(o.PROMO_BUTTON, this.makeImgUrl(o.PROMO_BUTTON)), this._imgAssets.set(o.LABEL_PLATE_22, this.makeImgUrl(o.LABEL_PLATE_22)), this._imgAssets.set(o.BUTTON_PLATE_20, this.makeImgUrl(o.BUTTON_PLATE_20)), this._imgAssets.set(o.BUTTON_STROKE_20, this.makeImgUrl(o.BUTTON_STROKE_20)), this._guideAssets.set(o.GUIDE_AUTO_PLAY_STOP_YELLOW, this.makeGuideUrl(o.GUIDE_AUTO_PLAY_STOP_YELLOW)), this._guideAssets.set(o.GUIDE_BOOSTED_BET, this.makeGuideUrl(o.GUIDE_BOOSTED_BET)), this._guideAssets.set(o.GUIDE_COLLECT_AND_SPIN, this.makeGuideUrl(o.GUIDE_COLLECT_AND_SPIN)), this._guideAssets.set(o.GUIDE_SPIN_BUTTON, this.makeGuideUrl(o.GUIDE_SPIN_BUTTON)), this._guideAssets.set(o.GUIDE_SPIN_BUTTON_X, this.makeGuideUrl(o.GUIDE_SPIN_BUTTON_X)), this._guideAssets.set(o.GUIDE_REPLAY, this.makeGuideUrl(o.GUIDE_REPLAY)), this._guideAssets.set(o.GUIDE_CHECKBOX, this.makeGuideUrl(o.GUIDE_CHECKBOX))
                }
                makeImgUrl(t) {
                    return this._defaultImgUrl + t + "@2x.png"
                }
                makeGuideUrl(t) {
                    return this._defaultGuideUrl + t + ".png"
                }
                overrideAssetByName(t, e) {
                    this._isLoaded ? console.warn("You need to override skin assets before loading.") : this._imgAssets.has(t) ? this._imgAssets.set(t, e) : console.warn("Trying to override source for non existing icon")
                }
                load() {
                    return this._imgAssets.forEach(((t, e) => {
                        this._loader.add(e, t)
                    })), this._loader.load().then((t => (this._isLoaded = t, t)))
                }
                getSkinTexture(t) {
                    return n.ImgLoader.getImgTexture(t)
                }
                static getTexture(t) {
                    return n.ImgLoader.getImgTexture(t)
                }
                getSkinData() {
                    const t = {};
                    return this._imgAssets.forEach(((e, i) => {
                        t[i] = e
                    })), this._guideAssets.forEach(((e, i) => {
                        t[i] = e
                    })), t
                }
            }
            o.AUTO_PLAY_ON = "autoPlayStop", o.AUTO_PLAY_OFF = "autoPlay", o.BACK = "back", o.BET_LEVELS_BUTTON = "bet", o.DEMO_ICON = "diamond", o.FAST_SPIN = "fastSpin", o.MENU = "menu", o.RING_LOADER = "ringLoader", o.SOUND_ON = "soundOn", o.SOUND_OFF = "soundOff", o.EXIT_LOBBY = "exitToLobby", o.HISTORY = "history", o.INFO = "info", o.SETTINGS = "settings", o.MENU_CLOSE = "menuClose", o.SPIN_BUTTON_PLATE = "spinBg", o.SPIN_ARROW = "spinArrow", o.SPIN_PLAY = "spinArrow", o.SPIN_SKIP = "spinX", o.SPIN_STOP = "spinX", o.COLLECT_ICON = "collectIcon", o.BOOST_ICON = "boostIcon", o.PROMO_BUTTON = "nolimitPromotions", o.LABEL_PLATE_22 = "labelPlate22", o.BUTTON_PLATE_20 = "buttonPlate20", o.BUTTON_STROKE_20 = "buttonStroke20", o.GUIDE_AUTO_PLAY_STOP_YELLOW = "autoPlayStopYellow", o.GUIDE_BOOSTED_BET = "boostedBet", o.GUIDE_COLLECT_AND_SPIN = "collectAndSpin", o.GUIDE_SPIN_BUTTON = "spinButton", o.GUIDE_SPIN_BUTTON_X = "spinButtonX", o.GUIDE_REPLAY = "replay", o.GUIDE_CHECKBOX = "checkBox", e.SkinLoader = o
        },
        8714: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlotKeypad = e.SettingsExtEventIDs = e.SettingPageIDs = e.KeypadValueIDs = e.KeypadButtonIDs = void 0;
            const n = i(1726),
                r = i(6869),
                o = i(6946),
                s = i(424),
                a = i(1740),
                l = i(9785),
                h = i(1305),
                u = i(4514),
                c = i(502),
                d = i(9959),
                p = i(6358),
                f = i(3934),
                g = i(2590),
                m = i(51),
                _ = i(9870),
                y = i(9756),
                S = i(7185),
                v = i(8943),
                b = i(4968),
                T = i(4495),
                P = i(2820),
                A = i(2111),
                I = i(4267),
                w = i(1653),
                E = i(318),
                C = i(8338),
                x = i(8680),
                B = i(3158),
                L = i(9933),
                O = i(5225),
                N = i(7023);
            var M, R, D, F;
            ! function (t) {
                t.FAST_SPIN = "FAST_SPIN", t.PROMO_BUTTON = "PROMO_BUTTON", t.DEMO = "DEMO", t.SOUND = "SOUND", t.AUTO_PLAY = "autoplay", t.SPIN = "spin", t.FULLSCREEN_SPIN = "FULLSCREEN_SPIN", t.MENU = "menu", t.BET_LEVEL = "bet-level", t.BET_LEVEL_PLUS = "plus", t.BET_LEVEL_MINUS = "minus", t.EXIT_REPLAY = "exitReplay"
            }(M = e.KeypadButtonIDs || (e.KeypadButtonIDs = {})), (F = e.KeypadValueIDs || (e.KeypadValueIDs = {})).BET = "BET", F.WIN = "WIN", F.BALANCE = "BALANCE", F.FREE_BETS_TOTAL_WIN = "FREE_BETS_TOTAL_WIN", F.TOTAL_COST = "TOTAL_COST",
                function (t) {
                    t.GAME_MENU = "gameMenuPage", t.INFO = "infoPage", t.SETTINGS = "settingsPage", t.BET_LEVEL = "betLevelPage", t.AUTOPLAY = "autoplayPage", t.HISTORY = "historyPage"
                }(R = e.SettingPageIDs || (e.SettingPageIDs = {})),
                function (t) {
                    t.SOUND_MASTER = "soundMaster", t.FAST_SPIN = "fastSpin", t.AUTOPLAY = "autoplay", t.OPEN_SETTINGS_SECTION = "openSettingsSection"
                }(D = e.SettingsExtEventIDs || (e.SettingsExtEventIDs = {}));
            class k {
                get showing() {
                    return this._view && this._view.visible
                }
                constructor() {
                    this.name = "SlotKeypad", this._balancePrecision = 2, this.skinLoader = new N.SkinLoader, k.skinLoader = this.skinLoader
                }
                fetchPlugins() {
                    for (let t of c.NolimitLauncher.plugins) (0, o.isSoundPlugin)(t) && (k.sound = t), (0, l.isAutoPlayPlugin)(t) && (k.autoplay = t), (0, a.isApiPlugin)(t) && (k.apiPlugIn = t, k.apiPlugIn.events.on(S.APIEvent.INIT, (t => this.onInitData()))), (0, s.isPromotionPlugin)(t) && (k.promoPlugin = t);
                    return null == k.sound ? Promise.reject(new Error("SlotKeypad is missing SoundPlugin")) : null == k.apiPlugIn ? Promise.reject(new Error("SlotKeypad is missing  ApiPlugin")) : null == k.autoplay ? Promise.reject(new Error("SlotKeypad is missing  AutoPlayPlugin")) : Promise.resolve()
                }
                destroy() {
                    this.events.shutdown(), k.sound = void 0, k.autoplay = void 0, k.apiPlugIn = void 0, k.promoPlugin = void 0, k.NO_DECIMALS_CUTOFF_POINT = void 0, k.svgLoader = void 0, k.skinLoader = void 0, k.VERSION = void 0
                }
                init() {
                    return new Promise(((t, e) => {
                        this.fetchPlugins().catch((t => Promise.reject(t))), this.events = k.apiPlugIn.eventSystemFactory.create(), t(this)
                    }))
                }
                getReady() {
                    const t = new A.FontLoader(u.NolimitApplication.resourcePath);
                    return t.add(w.OpenSans.ITALIC_600), t.add(w.OpenSans.NORMAL_300), t.add(w.OpenSans.NORMAL_400), t.add(w.OpenSans.NORMAL_700), Promise.all([this.skinLoader.load(), t.load()]).then((t => (k.apiPlugIn.settings.set(P.APISetting.DEVICE_HAS_ROUNDED_CORNERS, k.apiPlugIn.options.device == C.Device.MOBILE), this._view = new d.KeypadView(this), k.apiPlugIn.options.demo && k.apiPlugIn.options.token ? (this._demoView = new E.DemoView(this, k.apiPlugIn), this._demoView.load().then((t => {
                        this._view.betPanel.demoButton.enable(!0)
                    }))) : this.disableDemoButton(), this._betLevelsView = new f.BetLevelsDialogView(this, k.apiPlugIn), this._autoPlaySettingsView = new g.AutoPlayView(this, k.apiPlugIn), this._gameMenuView = new m.GameMenuDialogView(this, k.apiPlugIn), this.addEventListeners(), this._gameMenuView.preLoadHtmlPages().then((t => this)))))
                }
                getReadyToStart() {
                    return new Promise(((t, e) => {
                        this._view.betPanel.fastSpinButton.toggled = k.apiPlugIn.settings.get(P.APISetting.FAST_SPIN, !1), this._view.betPanel.promoButton.enable(!0), this._view.betPanel.betLevelButton.enable(!0), this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fastSpinButton.enable(!0), this._view.betPanel.autoplayButton.enable(!0), this._view.betPanel.menuButton.enable(!0), this._view.betPanel.soundButton.enable(!0), k.promoPlugin && k.promoPlugin.hasPromotions() || B.SlotKeypadUtils.disableElement(this._view.betPanel.promoButton), !1 === k.apiPlugIn.options.autoplay && (B.SlotKeypadUtils.disableElement(this._view.betPanel.autoplayButton), B.SlotKeypadUtils.disableElement(this._view.betPanel.fastSpinAutoPlaySeparator), this._view.betPanel.onResize()), k.apiPlugIn.gameClientConfiguration.isSet ? this.applyGameClientConfiguration() : k.apiPlugIn.events.on(S.APIEvent.GAME_CLIENT_CONFIGURATION_APPLIED, (() => this.applyGameClientConfiguration())), k.apiPlugIn.settings.set(P.APISetting.LEFT_HAND_MODE, !1), t(this)
                    }))
                }
                start() {
                    return new Promise(((t, e) => {
                        this._view.onOrientationChanged(), this._view.onResize(), this._view.alpha = 0, u.NolimitApplication.addLayer("Keypad", this._view), k.apiPlugIn.options.device != C.Device.DESKTOP || k.apiPlugIn.isReplay || (this._keyboardInput = new L.KeyboardInput(k.apiPlugIn, this)), p.TweenLite.to(this._view, .2, {
                            alpha: 1,
                            ease: p.Linear.easeNone,
                            onComplete: () => {
                                t(this)
                            }
                        })
                    }))
                }
                getKeypadGuide() {
                    const t = new I.TemplateLoader(k.apiPlugIn.resources.getStaticRoot());
                    return t.add({
                        name: "gui-guide",
                        url: "node_modules/@nolimit/slot-keypad/resources/default/templates/gui-guide.mustache"
                    }), t.load().then((t => {
                        for (let e of t)
                            if ("gui-guide" == e.name && e.loadedData) return e.loadedData;
                        throw new Error("SlotKeypad could not load gui-guide")
                    }))
                }
                applyGameClientConfiguration() {
                    k.apiPlugIn.gameClientConfiguration.fastSpinEnabled || (k.apiPlugIn.settings.set(P.APISetting.FAST_SPIN, !1), B.SlotKeypadUtils.disableElement(this._view.betPanel.fastSpinButton), B.SlotKeypadUtils.disableElement(this._view.betPanel.fastSpinAutoPlaySeparator), this._view.betPanel.onResize()), k.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayAllowed || (B.SlotKeypadUtils.disableElement(this._view.betPanel.autoplayButton), B.SlotKeypadUtils.disableElement(this._view.betPanel.fastSpinAutoPlaySeparator), this._view.betPanel.onResize())
                }
                setupMaxInactivityTimerForJurisdiction() {
                    k.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes && k.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes > 0 && this.createJurisdictionMaxInactivityInterval()
                }
                isMaxInactivityForJurisdictionApplied() {
                    return !!(k.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes && k.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes > 0)
                }
                createJurisdictionMaxInactivityInterval() {
                    if (this.isMaxInactivityForJurisdictionApplied()) {
                        const t = new Date;
                        let e = this._currentEndDate = new Date(t.getTime() + 6e4 * k.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes);
                        x.Logger.logDev("SlotKeypad - Inactivity, setting up max inactivity timer for jurisdiction: " + k.apiPlugIn.gameClientConfiguration.jurisdictionName), x.Logger.logDev("SlotKeypad - Inactivity Time in Minutes: " + k.apiPlugIn.gameClientConfiguration.maxInactivityInMinutes), x.Logger.logDev("SlotKeypad - Inactivity Start Date: " + t), x.Logger.logDev("SLotKeypad - Inactivity End Date: " + e), clearInterval(this._maxInactivityInterval);
                        let i = this._maxInactivityInterval = setInterval((function () {
                            let t = new Date,
                                n = e - t,
                                r = Math.round(n % 864e5 % 36e5 / 6e4);
                            x.Logger.logDev("SlotKeypad - Inactivity, minute countdown: " + r), r <= 0 && (clearInterval(i), x.Logger.logDev("SlotKeypad - Inactivity, time limit met, showing dialog at time: " + t), "mobile" === k.apiPlugIn.options.device ? k.apiPlugIn.dialog.showGameDialog({
                                message: k.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing."),
                                okButtonLabel: "OK",
                                onOkClick: () => {
                                    k.apiPlugIn.externalApi.trigger(T.APIExternalApiEvent.EXIT).or(history.back.bind(history))
                                }
                            }) : k.apiPlugIn.dialog.showNoCloseGameDialog({
                                message: k.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing.")
                            }))
                        }), 59e3)
                    }
                }
                forceCheckInactivity() {
                    if (this._currentEndDate && this._maxInactivityInterval) {
                        let t = new Date,
                            e = this._currentEndDate - t,
                            i = Math.round(e % 864e5 % 36e5 / 6e4);
                        x.Logger.logDev("SlotKeypad - Inactivity, force check on page visibility, time left on inactivity: " + i), i <= 0 && (clearInterval(this._maxInactivityInterval), x.Logger.logDev("SlotKeypad - Inactivity, time limit met, showing dialog at time: " + t), "mobile" === k.apiPlugIn.options.device ? k.apiPlugIn.dialog.showGameDialog({
                            message: k.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing."),
                            okButtonLabel: "OK",
                            onOkClick: () => {
                                k.apiPlugIn.externalApi.trigger(T.APIExternalApiEvent.EXIT).or(history.back.bind(history))
                            }
                        }) : k.apiPlugIn.dialog.showNoCloseGameDialog({
                            message: k.apiPlugIn.translations.translate("You have reached the maximum inactivity time and you have to restart the game to continue playing.")
                        }))
                    }
                }
                disableDemoButton() {
                    B.SlotKeypadUtils.disableElement(this._view.betPanel.demoButton)
                }
                addEventListeners() {
                    k.apiPlugIn.events.on(S.APIEvent.CURRENCY, (t => B.SlotKeypadUtils.doFontHack(t))), k.apiPlugIn.events.on(S.APIEvent.REFRESH, ((...t) => this.onRefresh(t))), k.apiPlugIn.events.on(S.APIEvent.BET, (t => this.onBet(t))), k.apiPlugIn.events.on(S.APIEvent.ACTION_SPINS_ROUND_COMPLETE, (() => this.updateBalance())), k.apiPlugIn.events.on(S.APIEvent.STATE, (t => this.onState(t))), k.apiPlugIn.events.on(S.APIEvent.FAST_SPIN, (t => this.onFastSpin(t))), k.apiPlugIn.events.on(S.APIEvent.AUTO_PLAY, (() => this.onAutoPlay())), k.apiPlugIn.events.on(S.APIEvent.BET_BOOST, (() => this.updateBet())), k.apiPlugIn.events.on(S.APIEvent.HALT, (() => this.onHalt())), k.apiPlugIn.events.on(S.APIEvent.PAUSE, (() => this.onPause(!0))), k.apiPlugIn.events.on(S.APIEvent.RESUME, (() => this.onPause(!1))), k.apiPlugIn.events.on(S.APIEvent.FREEZE, (() => this.onFreeze(!0))), k.apiPlugIn.events.on(S.APIEvent.UNFREEZE, (() => this.onFreeze(!1))), k.apiPlugIn.events.on(S.APIEvent.HIDDEN, (t => this.onHidden(t))), k.apiPlugIn.events.on(S.APIEvent.GAME, (t => this.onGameData(t))), k.apiPlugIn.settings.on(S.APIEvent.MUSIC, (t => this.onMusic(t))), k.apiPlugIn.settings.on(S.APIEvent.SFX, (t => this.onSfx(t))), k.apiPlugIn.events.on(S.APIEvent.SETTING_PAGE_CHANGE, (t => this.onSettingPageChange(t))), u.NolimitApplication.events.on(u.NolimitApplication.DIALOG_OPENED, (() => this.dialogOpened())), u.NolimitApplication.events.on(u.NolimitApplication.DIALOG_CLOSING, (() => this.dialogClosing())), u.NolimitApplication.apiPlugin.events.on(S.APIEvent.DIALOG, (t => this.onApiDialog(t))), u.NolimitApplication.apiPlugin.events.on(S.APIEvent.GUI_REFRESH, (t => this.onGuiRefresh(t))), k.apiPlugIn.freeBets.events.on(k.apiPlugIn.freeBets.FREE_BETS_START, (() => this.onFreeBetsStart())), k.apiPlugIn.freeBets.events.on(k.apiPlugIn.freeBets.FREE_BETS_START_FROM_ACTION_SPINS, (() => this.hideAllKeypadStuff())), k.apiPlugIn.freeBets.events.on(k.apiPlugIn.freeBets.FREE_BETS_END, (() => this.onFreeBetsEnd())), k.apiPlugIn.freeBets.events.on(k.apiPlugIn.freeBets.FREE_BETS_UPDATE, (() => this.onFreeBetsUpdate())), k.apiPlugIn.freeFeatureBet.events.on(k.apiPlugIn.freeFeatureBet.FREE_FEATURE_BET_START, (() => this.onFreeFeatureBetStart())), k.apiPlugIn.freeFeatureBet.events.on(k.apiPlugIn.freeFeatureBet.FREE_FEATURE_BET_END, (() => this.onFreeFeatureBetEnd()))
                }
                onGuiRefresh(t) {
                    k.apiPlugIn.slotStates.checkState(v.SlotState.READY) && (this.updateBet(), this.updateBalance(), this.updateSoundButton(), k.apiPlugIn.freeBets.hasFreeBets() && this.updateFreeBetsTotalWin(), null != (null == t ? void 0 : t.hideBalance) && (this._view.betPanel.balance.visible = !0 !== t.hideBalance))
                }
                hideAllKeypadStuff() {
                    this._view.visible = !1
                }
                onFreeFeatureBetStart() {
                    this._view.betPanel.promoButton.enable(!1), this._view.betPanel.promoButton.visible = !1, this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(_.SlotKeypadViewSettings.FREE_FEATURE_BET_COLOR), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.betLevelButton.hide(), this.updateBet()
                }
                onFreeFeatureBetEnd() {
                    this._view.betPanel.promoButton.enable(!0), this._view.betPanel.promoButton.visible = !0, this.setSpinButtonBetState(), this._view.betPanel.bet.setLabel(k.apiPlugIn.translations.translate("BET")), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(_.SlotKeypadViewSettings.NORMAL_COLOR)), this._view.betPanel.autoplayButton.enable(!0), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(_.SlotKeypadViewSettings.NORMAL_COLOR), this._view.betPanel.betLevelButton.show(), this._view.betPanel.betLevelButton.enable(!0), this.updateBet(), this._view.betPanel.onResize()
                }
                onFreeBetsUpdate() {
                    this._view.betPanel.bet.setLabel(k.apiPlugIn.freeBets.getBetHeader()), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(_.SlotKeypadViewSettings.FREE_BETS_COLOR)), this.updateFreeBetsTotalWin(!0)
                }
                onFreeBetsStart() {
                    this._view.betPanel.promoButton.enable(!1), this._view.betPanel.promoButton.visible = !1, this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(_.SlotKeypadViewSettings.FREE_BETS_COLOR), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.betLevelButton.hide(), this.updateBet(), this.updateFreeBetsTotalWin()
                }
                updateFreeBetsTotalWin(t = !1) {
                    let e = k.apiPlugIn.freeBets.getFormattedWin();
                    const i = k.apiPlugIn.freeBets.getCurrentWinnings();
                    null != e && t && (e = k.apiPlugIn.currency.format(i - this._currentRoundBalance)), null != e && i - this._currentRoundBalance > 0 ? (this._view.betPanel.freeBetsTotalWin.visible = !0, this._view.betPanel.freeBetsTotalWin.setValue(e), this._view.betPanel.onResize()) : (this._view.betPanel.freeBetsTotalWin.visible = !1, this._view.betPanel.freeBetsTotalWin.setValue(""), this._view.betPanel.onResize())
                }
                onFreeBetsEnd() {
                    this._view.betPanel.promoButton.enable(!0), this._view.betPanel.promoButton.visible = !0, this.setSpinButtonBetState(), this._view.betPanel.bet.setLabel(k.apiPlugIn.translations.translate("BET")), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(_.SlotKeypadViewSettings.NORMAL_COLOR)), this._view.betPanel.autoplayButton.spinsCounterLabel.setColor(_.SlotKeypadViewSettings.NORMAL_COLOR), this._view.betPanel.betLevelButton.show(), this._view.betPanel.betLevelButton.enable(!0), this._view.betPanel.freeBetsTotalWin.visible = !1, this._view.betPanel.freeBetsTotalWin.setValue("-1"), this.updateBet(), this._view.betPanel.onResize()
                }
                onApiDialog(t) { }
                onAutoPlay() {
                    !this._view.betPanel.autoplayButton.toggled && k.autoplay.isAutoplayRound && this.reportBackSettingChange("autoplay", !0), this._view.betPanel.autoplayButton.toggled = k.autoplay.isAutoplayRound, this._view.betPanel.autoplayButton.setCount(k.autoplay.rounds), k.autoplay.rounds <= 0 && this.reportBackSettingChange("autoplay", !1), this.setSpinButtonBetState(), k.autoplay.rounds <= 0 && this.reportBackSettingChange("autoplay", !1);
                    const t = k.apiPlugIn.slotStates.getState();
                    k.autoplay.isAutoplayRound || t == v.SlotState.READY || t == v.SlotState.FINISH || (this._view.betPanel.autoplayButton.enable(!1), this.reportBackSettingChange("autoplay", !1)), this._view.setStateVisibility()
                }
                onFastSpin(t) {
                    this._view.betPanel.fastSpinButton.toggled = t
                }
                clickSpin() {
                    this._view.betPanel.spinButton.clickButton()
                }
                buttonClick(t) {
                    x.Logger.logDev(`SlotKeypad.buttonClicked[${t.name}]`);
                    const e = this.cancelAutoPlay(t);
                    switch (t.name) {
                        case M.AUTO_PLAY:
                            e || this._autoPlaySettingsView.isOpen || (k.apiPlugIn.freeBets.hasFreeBets() ? k.autoplay.playFreeRoundsAutoplay() : (this._autoPlaySettingsView.open(), this.reportBackSettingPageChange(R.AUTOPLAY, !0)));
                            break;
                        case M.BET_LEVEL:
                            this._betLevelsView.open(), this.reportBackSettingPageChange(R.BET_LEVEL, !0);
                            break;
                        case M.FULLSCREEN_SPIN:
                            this.clickSpin();
                            break;
                        case M.SPIN:
                            this.onSpinButtonClicked();
                            break;
                        case M.MENU:
                            this._gameMenuView.open(), this.reportBackSettingPageChange(R.GAME_MENU, !0);
                            break;
                        case M.FAST_SPIN:
                            this.toggleFastSpin();
                            break;
                        case M.SOUND:
                            k.sound.toggleQuickMute();
                            break;
                        case M.PROMO_BUTTON:
                            k.promoPlugin.open();
                            break;
                        case M.DEMO:
                            this._demoView.open();
                            break;
                        case M.EXIT_REPLAY:
                            this.exitReplay()
                    }
                    this.onAnyInteraction()
                }
                onAnyInteraction() {
                    this.setupMaxInactivityTimerForJurisdiction()
                }
                cancelAutoPlay(t) {
                    if (k.autoplay.isAutoplayRound) {
                        const e = [M.AUTO_PLAY, M.MENU, M.BET_LEVEL_MINUS, M.BET_LEVEL_PLUS, M.BET_LEVEL];
                        for (let i of e)
                            if (i == t.name) return k.autoplay.cancelAutoPlay(), this.reportBackSettingChange(D.AUTOPLAY, !1), !0
                    }
                    return !1
                }
                static formatCurrencyWithDecimalCutoff(t) {
                    "string" == typeof t && (t = parseFloat(t));
                    const e = t < k.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
                    return k.apiPlugIn.currency.format(t, {
                        minimumPrecision: e
                    })
                }
                static formatCurrencyValueWithDecimalCutoff(t) {
                    "string" == typeof t && (t = parseFloat(t));
                    const e = t < k.NO_DECIMALS_CUTOFF_POINT || t % 1 != 0 ? 2 : 0;
                    return k.apiPlugIn.currency.formatValue(t, {
                        minimumPrecision: e
                    })
                }
                updateBet() {
                    let t = k.apiPlugIn.betLevel.getLevel();
                    k.apiPlugIn.freeBets.hasFreeBets() && (t = k.apiPlugIn.freeBets.getBet(), this._view.betPanel.bet.setLabel(k.apiPlugIn.freeBets.getBetHeader()), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(_.SlotKeypadViewSettings.FREE_BETS_COLOR))), k.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && (t = k.apiPlugIn.freeFeatureBet.getBet(), this._view.betPanel.bet.setLabel(k.apiPlugIn.freeFeatureBet.getBetHeader()), this._view.betPanel.bet.setColor(y.GuiUtils.getColorFromARGB(_.SlotKeypadViewSettings.FREE_FEATURE_BET_COLOR))), this.setBoostedBet(), this._view.betPanel.bet.setValue(k.formatCurrencyWithDecimalCutoff(t)), this.events.trigger(n.KeypadPluginEvents.DISPLAY_BET_UPDATE, t)
                }
                setBoostedBet() {
                    const t = k.apiPlugIn.betHandler.betBoost;
                    null != t ? (this._view.betPanel.totalCost.setValue(k.formatCurrencyWithDecimalCutoff(t.calculatedPrice)), this._view.betPanel.totalCost.visible || (this._view.betPanel.spinButton.spinState = r.SpinButtonState.BOOST, this.setSpinButtonBetState(), this._view.betPanel.totalCost.visible = !0, this._view.betPanel.onResize())) : this._view.betPanel.totalCost.visible && (this._view.betPanel.spinButton.spinState = r.SpinButtonState.SPIN, this.setSpinButtonBetState(), this._view.betPanel.totalCost.visible = !1, this._view.betPanel.onResize())
                }
                updateBalance() {
                    k.apiPlugIn.balance.getAmount();
                    const t = k.apiPlugIn.balance.getFormattedBalance(this._balancePrecision);
                    this._view.betPanel.balance.setValue(t), k.apiPlugIn.externalApi.trigger("balance", k.apiPlugIn.balance.toString())
                }
                newBetLevelSelected(t) {
                    const e = k.apiPlugIn.betLevel.getLevel();
                    k.apiPlugIn.betLevel.setLevel(t), this.updateBet(), this.events.trigger(n.KeypadPluginEvents.USER_BET_UPDATE, {
                        from: e,
                        to: k.apiPlugIn.betLevel.getLevel()
                    })
                }
                updateAutoplaySettings(t) {
                    k.autoplay.updateData(t)
                }
                reportBackSettingPageChange(t, e) {
                    k.apiPlugIn.events.trigger(S.APIEvent.SETTING_PAGE_CHANGE, {
                        name: t,
                        value: e
                    })
                }
                reportBackSettingChange(t, e) {
                    k.apiPlugIn.events.trigger(S.APIEvent.SETTING_CHANGE, {
                        name: t,
                        value: e
                    })
                }
                onSettingPageChange(t) {
                    t && t.page && t.section ? this.openGameSection(t.page, t.section, t.close || !1) : t && t.page && t.section
                }
                openGameSection(t, e, i = !1) {
                    if (i && this.reportBackSettingPageChange(t, !1), "gameMenu" === t)
                        if (i && this._gameMenuView.isOpen) this._gameMenuView.close();
                        else switch (e) {
                            case "history":
                            case "settings":
                            default:
                                break;
                            case "paytable":
                                this._gameMenuView.openAndGoTo(O.SettingSectionIDs.PAYTABLE);
                                break;
                            case "rules":
                                this._gameMenuView.openAndGoTo(O.SettingSectionIDs.RULES);
                                break;
                            case "guide":
                                this._gameMenuView.openAndGoTo(O.SettingSectionIDs.GUIDE)
                        }
                    "autoplayMenu" === t && this._autoPlaySettingsView, "betLevelMenu" === t && this._betLevelsView, this.reportBackSettingPageChange(t, !0)
                }
                onBet(t) {
                    t.type == b.APIBetType.GAMBLE_BET ? !0 !== t.playerInteraction.gambleCollected && this._view.betPanel.hideWin() : t.type !== b.APIBetType.ZERO_BET && this._view.betPanel.hideWin(), t.type === b.APIBetType.FEATURE_BET && 0 == k.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && this.updateBet(), 0 == k.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && this.updateBalance()
                }
                setSpinButtonBetState() {
                    null != k.apiPlugIn.betHandler.betBoost ? this._view.betPanel.spinButton.betState = h.BetState.BOOSTED_BET : k.autoplay.isAutoplayRound ? this._view.betPanel.spinButton.betState = h.BetState.AUTOPLAY : this._view.betPanel.zeroBetCounter.visible ? this._view.betPanel.spinButton.betState = h.BetState.ZERO_BET : this._view.betPanel.spinButton.betState = k.apiPlugIn.freeBets.hasFreeBets() ? h.BetState.FREE_BETS : h.BetState.NORMAL
                }
                onState(t) {
                    switch (this._view.betPanel.demoButton.enable(!1), t) {
                        case v.SlotState.RESTORE:
                            this.updateBalance(), this.updateBet(), this.setSpinButtonBetState(), this._view.setStateVisibility();
                            break;
                        case v.SlotState.READY:
                            this._currentRoundBalance = 0, this.setupMaxInactivityTimerForJurisdiction(), this.updateBalance(), this.updateBet(), this.setSpinButtonBetState(), null != k.apiPlugIn.betHandler.betBoost ? this._view.betPanel.spinButton.spinState = r.SpinButtonState.BOOST : this._view.betPanel.spinButton.spinState = r.SpinButtonState.SPIN, this._view.setStateVisibility(), this._view.betPanel.demoButton.enable(!0), this.reportBackSettingChange(S.APIEvent.AUDIO_MASTER_MUTED, !k.sound.isQuickMute());
                            break;
                        case v.SlotState.STARTING:
                            this.updateFreeBetsTotalWin(!0), this._view.setStateVisibility(), this._view.betPanel.spinButton.enable(!1), this._view.betPanel.promoButton.enable(!1), this._view.betPanel.menuButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.autoplayButton.enable(this._view.betPanel.autoplayButton.toggled);
                            break;
                        case v.SlotState.STOPPABLE:
                            k.apiPlugIn.gameClientConfiguration.fastSpinEnabled && (this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fullscreenSpinButton.enable(!0), this._view.betPanel.spinButton.spinState = r.SpinButtonState.STOP);
                            break;
                        case v.SlotState.STOPPING:
                            this._view.betPanel.spinButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1);
                            break;
                        case v.SlotState.SKIPPABLE:
                            this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fullscreenSpinButton.enable(!0), this._view.betPanel.spinButton.spinState = r.SpinButtonState.ABORT;
                            break;
                        case v.SlotState.SKIPPED:
                        case v.SlotState.DONE:
                            this._view.betPanel.spinButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1);
                            break;
                        case v.SlotState.FINISHING:
                            break;
                        case v.SlotState.FINISH:
                            this._currentRoundBalance = 0, this.updateBalance(), this._view.betPanel.spinButton.enable(!0), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.autoplayButton.enable(!0), this._view.betPanel.betLevelButton.enable(!0), this._view.betPanel.menuButton.enable(!0), this._view.betPanel.promoButton.enable(!0), this._view.setStateVisibility();
                            break;
                        case v.SlotState.SCREEN:
                            this._view.setStateVisibility(0);
                            break;
                        case v.SlotState.DIALOG:
                            this._view.setStateVisibility(.2, !0);
                            break;
                        case v.SlotState.GAMBLE:
                            this.setSpinButtonBetState(), this._view.betPanel.spinButton.spinState = r.SpinButtonState.GAMBLE, this._view.betPanel.spinButton.enable(!0), this._view.betPanel.promoButton.enable(!1), this._view.betPanel.menuButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.autoplayButton.enable(this._view.betPanel.autoplayButton.toggled), this._view.setStateVisibility();
                            break;
                        case v.SlotState.GAMBLING:
                            this._view.betPanel.spinButton.enable(!1);
                            break;
                        case v.SlotState.GAMBLE_COLLECT:
                            this._view.betPanel.spinButton.enable(!1), this._view.betPanel.promoButton.enable(!1), this._view.betPanel.menuButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1), this._view.betPanel.betLevelButton.enable(!1), this._view.betPanel.autoplayButton.enable(this._view.betPanel.autoplayButton.toggled)
                    }
                }
                onSpinButtonClicked() {
                    switch (k.apiPlugIn.slotStates.getState()) {
                        case v.SlotState.READY:
                            k.apiPlugIn.bet(), this._view.betPanel.spinButton.playClickedAnimation();
                            break;
                        case v.SlotState.STARTING:
                            break;
                        case v.SlotState.STOPPABLE:
                            k.apiPlugIn.events.trigger(S.APIEvent.STOP), this._view.betPanel.fullscreenSpinButton.playClickedAnimation();
                            break;
                        case v.SlotState.STOPPING:
                            break;
                        case v.SlotState.SKIPPABLE:
                            k.apiPlugIn.events.trigger(S.APIEvent.SKIP), this._view.betPanel.fullscreenSpinButton.playClickedAnimation();
                            break;
                        case v.SlotState.SKIPPED:
                            break;
                        case v.SlotState.GAMBLE:
                            k.apiPlugIn.bet(), this._view.betPanel.spinButton.playClickedAnimation();
                        case v.SlotState.DONE:
                        case v.SlotState.FINISHING:
                        case v.SlotState.SCREEN:
                    }
                }
                dialogOpened() { }
                dialogClosing() {
                    this._view.setStateVisibility(.18, !1, !0)
                }
                setWin(t, e, i, n) {
                    this._currentRoundBalance = t;
                    const r = k.apiPlugIn.currency.format(t);
                    if (null == i && (i = k.apiPlugIn.gameClientConfiguration.belowStakeWinRestriction && t <= this._playedBetValue), t <= 0) this._view.betPanel.hideWin(n ? 0 : .5).add((() => {
                        this._view.betPanel.win.setLabel(e ? k.apiPlugIn.translations.translate("TOTAL WIN") : k.apiPlugIn.translations.translate("WIN")), this._view.betPanel.win.setValue(r)
                    }));
                    else {
                        let t;
                        t = i ? "" : e ? k.apiPlugIn.translations.translate("TOTAL WIN") : k.apiPlugIn.translations.translate("WIN"), this._view.betPanel.win.setLabel(t), this._view.betPanel.win.setValue(r), this._view.betPanel.showWin()
                    }
                    this.updateBalance()
                }
                hide(t = 0) {
                    return this._view.hide(t)
                }
                show(t = 0) {
                    return this._view.visible = !0, this._view.show(t)
                }
                setZeroBetSpinCounter(t) {
                    t < 0 ? (this._view.betPanel.zeroBetCounter.hide(), this._view.betPanel.zeroBetCounter.setCount(t), this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.showSpinCounterLabel()) : (this._view.betPanel.zeroBetCounter.setCount(t), this._view.betPanel.zeroBetCounter.show(), this.setSpinButtonBetState(), this._view.betPanel.autoplayButton.hideSpinCounterLabel())
                }
                getBalanceBarHeight() {
                    return 35
                }
                getSpinButtonCenter() {
                    return this._view.betPanel.spinButtonCenter.clone()
                }
                disableQuickStop() {
                    k.apiPlugIn.slotStates.checkState(v.SlotState.STOPPABLE) && (this._view.betPanel.spinButton.enable(!1), this._view.betPanel.fullscreenSpinButton.enable(!1))
                }
                onRefresh(...t) {
                    k.apiPlugIn.slotStates.checkState(v.SlotState.READY) && (this.updateBalance(), this.updateBet()), this._betLevelsView.onRefresh()
                }
                exitToLobby() {
                    k.apiPlugIn.externalApi.trigger(T.APIExternalApiEvent.EXIT).or(history.back.bind(history))
                }
                exitReplay() {
                    k.apiPlugIn.externalApi.trigger(T.APIExternalApiEvent.EXIT_REPLAY)
                }
                toggleBoolSetting(t) {
                    const e = !k.apiPlugIn.settings.get(t, !1);
                    return k.apiPlugIn.settings.set(P.APISetting.FAST_SPIN, e), e
                }
                toggleFastSpin() {
                    const t = this.toggleBoolSetting(P.APISetting.FAST_SPIN);
                    k.apiPlugIn.events.trigger(S.APIEvent.FAST_SPIN, t), this.reportBackSettingChange("fastSpin", t)
                }
                onMusic(t) {
                    this.updateSoundButton()
                }
                onSfx(t) {
                    this.updateSoundButton()
                }
                updateSoundButton() {
                    k.sound.loading ? (this._view.betPanel.soundButton.toggled = !1, this._view.betPanel.soundButton.enable(!1), this._view.betPanel.soundButton.startLoadingAnimation(), this.reportBackSettingChange(S.APIEvent.AUDIO_MASTER_MUTED, k.sound.isQuickMute())) : (this._view.betPanel.soundButton.stopLoadingAnimation(), this._view.betPanel.soundButton.toggled = !k.sound.isQuickMute(), this._view.betPanel.soundButton.enable(!0), this.reportBackSettingChange(S.APIEvent.AUDIO_MASTER_MUTED, !k.sound.isQuickMute()))
                }
                onHidden(t) {
                    t || this.forceCheckInactivity(), this.updateSoundButton()
                }
                onGameData(t) {
                    this._playedBetValue = t.playedBetValue
                }
                onInitData() {
                    const t = k.apiPlugIn.freeBets.hasFreeBets() ? k.apiPlugIn.freeBets.getBet() : k.apiPlugIn.betLevel.getLevel();
                    this._playedBetValue = parseFloat(t)
                }
                onFreeze(t) {
                    t ? this._view.setStateVisibility(.2, !0) : this._view.setStateVisibility()
                }
                onPause(t) {
                    this.updateSoundButton(), t && this._view.setStateVisibility(.2, !0)
                }
                onHalt() {
                    this._view.halt()
                }
            }
            k.NO_DECIMALS_CUTOFF_POINT = 10, k.VERSION = i(452).i8, e.SlotKeypad = k
        },
        9870: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlotKeypadViewSettings = void 0;
            const n = i(3606);
            class r {
                static set instance(t) {
                    this._instance = t
                }
                static get instance() {
                    return null == this._instance && (this._instance = new r), this._instance
                }
                constructor() {
                    this.activePointerStateColors = new n.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), this.freeBetsPointerStateColors = new n.PointerStateColorSet(4286512896, 4286512896, 4286512896, 863960832), this.boostedBetsPointerStateColors = new n.PointerStateColorSet(4294950724, 4294950724, 4294950724, 872398660), this.normalNonEmphasisPointerStateColors = new n.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this.normalPointerStateColors = new n.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this.normalBackPlatePointerStateColors = new n.PointerStateColorSet(2566914048, 3137339392, 2281701376, 2566914048)
                }
            }
            r.NORMAL_COLOR = 4294967295, r.AUTOPLAY_COLOR = 4294966272, r.FREE_BETS_COLOR = 4286512896, r.FREE_FEATURE_BET_COLOR = 4286512896, r.BOOSTED_BET_COLOR = 4294950724, e.SlotKeypadViewSettings = r
        },
        9858: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.KeypadDefault = void 0;
            class i { }
            i.DEFAULT_LARGE_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 128, 70), i.DEFAULT_SMALL_BUTTON_SIZE = new PIXI.Rectangle(0, 0, 110, 60), i.DEFAULT_BET_LEVELS_ROW_MAX = 5, i.SCREEN_EDGE_MARGIN_TOP_LANDSCAPE = 40, i.SCREEN_EDGE_MARGIN_TOP = 40, i.SCREEN_EDGE_MARGIN_LEFT = 20, i.PAGE_LEFT_PADDING = 20, i.PAGE_HEADER_BOTTOM_MARGIN = 20, e.KeypadDefault = i
        },
        4526: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.KeypadTextStyles = void 0;
            const n = i(1653),
                r = i(5383),
                o = i(9870),
                s = i(9756),
                a = i(3663);
            class l { }
            l.DEFAULT_PORTRAIT_TEXT_SIZE = 20, l.DEFAULT_LANDSCAPE_TEXT_SIZE = 20, l.DEFAULT_DROP_SHADOW = {
                dropShadow: !0,
                dropShadowColor: 0,
                dropShadowAngle: 1.5707,
                dropShadowBlur: 4,
                dropShadowDistance: 2
            }, l.KEYPAD_STANDARD_LABEL = Object.assign(Object.assign(a.GuiDefaults.DEFAULT_LABEL_STYLE.clone(), l.DEFAULT_DROP_SHADOW), {
                fontWeight: r.FontWeight.NORMAL
            }), l.KEYPAD_STANDARD_VALUE = Object.assign(a.GuiDefaults.DEFAULT_LABEL_VALUE_STYLE.clone(), l.DEFAULT_DROP_SHADOW), l.FREE_BETS_WIN_LABEL = Object.assign(l.KEYPAD_STANDARD_LABEL.clone(), {
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR)
            }), l.FREE_BETS_WIN_VALUE = Object.assign(l.KEYPAD_STANDARD_VALUE.clone(), {
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR)
            }), l.TOTAL_COST_LABEL = Object.assign(l.KEYPAD_STANDARD_LABEL.clone(), {
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.BOOSTED_BET_COLOR)
            }), l.TOTAL_COST_VALUE = Object.assign(l.KEYPAD_STANDARD_VALUE.clone(), {
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.BOOSTED_BET_COLOR)
            }), l.WIN_LABEL = l.KEYPAD_STANDARD_LABEL.clone(), l.WIN_VALUE = Object.assign(l.KEYPAD_STANDARD_VALUE.clone(), {
                fontSize: 34,
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.AUTOPLAY_COLOR)
            }), l.DEFAULT_RADIO_BUTTON_LABEL = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 40,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.NORMAL
            }), l.DEFAULT_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), l.AUTO_PLAY_COUNTER_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 25,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), l.SPIN_BUTTON_FREE_BETS_NUMBER = new PIXI.TextStyle({
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR),
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 25,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), l.DEFAULT_DIALOG_HEADER = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 48,
                fontStyle: r.FontStyle.ITALIC,
                fontWeight: r.FontWeight.SEMI_BOLD,
                padding: 10
            }), l.DEFAULT_DIALOG_HEADER_EMPHASIS = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 40,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.BOLD
            }), l.BRAND_TEXT_THIN = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 17,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), l.BRAND_TEXT_THICK = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.BOLD
            }), l.CLOCK = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 14,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), l.GAME_NAME = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 14,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), l.FREE_BETS_DIALOG_HEADER = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 30,
                fontWeight: r.FontWeight.NORMAL
            }), l.FREE_BETS_DIALOG_MESSAGE = new PIXI.TextStyle({
                fill: s.GuiUtils.getColorFromARGB(o.SlotKeypadViewSettings.FREE_BETS_COLOR),
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 20,
                fontWeight: r.FontWeight.NORMAL,
                wordWrap: !0,
                wordWrapWidth: 660,
                align: "center"
            }), l.FREE_BETS_DIALOG_VALUE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 20,
                fontWeight: r.FontWeight.NORMAL
            }), e.KeypadTextStyles = l
        },
        9933: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.KeyboardInput = void 0;
            const n = i(2820),
                r = i(8714);
            e.KeyboardInput = class {
                constructor(t, e) {
                    this._boundEvents = !1, this.onKeyUp = t => {
                        var e;
                        if (" " === t.key) {
                            if (r.SlotKeypad.autoplay.isAutoplayRound || (null === (e = r.SlotKeypad.promoPlugin) || void 0 === e ? void 0 : e.isActionSpinRound)) return;
                            this._keypad.clickSpin()
                        }
                    }, this._api = t, this._keypad = e, this._api.settings.default(n.APISetting.USE_SPACE_TO_SPIN, !0), this._api.settings.on(n.APISetting.USE_SPACE_TO_SPIN, (() => this.update())), this.update()
                }
                update() {
                    const t = this._api.settings.get(n.APISetting.USE_SPACE_TO_SPIN);
                    t && !this._boundEvents && this.bindEvents(), !t && this._boundEvents && this.unbindEvents()
                }
                bindEvents() {
                    window.addEventListener("keyup", this.onKeyUp), this._boundEvents = !0
                }
                unbindEvents() {
                    window.removeEventListener("keyup", this.onKeyUp), this._boundEvents = !1
                }
            }
        },
        3988: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AnimationUtils = void 0;
            const n = i(6358);
            e.AnimationUtils = class {
                static hideObject(t = .5, e = !0) {
                    return new n.TimelineLite
                }
                static elementVisibilityAnimation(t, e, i, r, o = !0) {
                    const s = new n.TimelineLite;
                    return null != r && s.add((() => {
                        t.alpha = r
                    })), i ? (s.add((() => {
                        t.visible = !0
                    })), s.add(new n.TweenLite(t, e, {
                        alpha: 1,
                        ease: n.Linear.easeNone
                    }))) : (s.add(new n.TweenLite(t, e, {
                        alpha: 0,
                        ease: n.Linear.easeNone
                    })), o && s.add((() => {
                        t.visible = !1
                    }))), s
                }
            }
        },
        3158: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlotKeypadUtils = void 0;
            const n = i(4526);
            e.SlotKeypadUtils = class {
                static disableElement(t) {
                    t.parent && t.parent.removeChild(t)
                }
                static doFontHack(t) {
                    const e = [
                        [n.KeypadTextStyles.DEFAULT_RADIO_BUTTON_LABEL, "DEFAULT_RADIO_BUTTON_LABEL"],
                        [n.KeypadTextStyles.DEFAULT_LABEL_STYLE, "DEFAULT_LABEL_STYLE"],
                        [n.KeypadTextStyles.AUTO_PLAY_COUNTER_LABEL_STYLE, "AUTO_PLAY_COUNTER_LABEL_STYLE"],
                        [n.KeypadTextStyles.SPIN_BUTTON_FREE_BETS_NUMBER, "SPIN_BUTTON_FREE_BETS_NUMBER"],
                        [n.KeypadTextStyles.DEFAULT_DIALOG_HEADER, "DEFAULT_DIALOG_HEADER"],
                        [n.KeypadTextStyles.DEFAULT_DIALOG_HEADER_EMPHASIS, "DEFAULT_DIALOG_HEADER_EMPHASIS"],
                        [n.KeypadTextStyles.BRAND_TEXT_THIN, "BRAND_TEXT_THIN"],
                        [n.KeypadTextStyles.BRAND_TEXT_THICK, "BRAND_TEXT_THICK"],
                        [n.KeypadTextStyles.CLOCK, "CLOCK"],
                        [n.KeypadTextStyles.GAME_NAME, "GAME_NAME"],
                        [n.KeypadTextStyles.FREE_BETS_DIALOG_HEADER, "FREE_BETS_DIALOG_HEADER"],
                        [n.KeypadTextStyles.FREE_BETS_DIALOG_MESSAGE, "FREE_BETS_DIALOG_MESSAGE"],
                        [n.KeypadTextStyles.FREE_BETS_DIALOG_VALUE, "FREE_BETS_DIALOG_VALUE"]
                    ];
                    if (null != t.symbol) {
                        const i = document.createElement("div");
                        i.classList.add("currencyFontLoadHack"), i.style.position = "absolute", i.style.zIndex = "-1000";
                        const n = document.querySelector(".nolimit.container");
                        if (null == n) return;
                        n.append(i);
                        let r = 0;
                        for (let n of e) {
                            let e = "";
                            if ("string" == typeof n[0].fontFamily) e = n[0].fontFamily;
                            else
                                for (let t of n[0].fontFamily) e += t + ",";
                            const o = document.createElement("p");
                            o.style.position = "absolute", o.style.top = r + "px", o.style.fontFamily = e, o.style.fontWeight = n[0].fontWeight.toString(), o.style.fontSize = "20px", o.style.color = "#FFFFFF", o.innerText = t.symbol, r += 20, i.append(o)
                        }
                    }
                }
            }
        },
        9797: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetPanelView = void 0;
            const n = i(8714),
                r = i(6434),
                o = i(5991),
                s = i(9870),
                a = i(2974),
                l = i(4813),
                h = i(8760),
                u = i(4989),
                c = i(8143),
                d = i(2213),
                p = i(2178),
                f = i(4514),
                g = i(7427),
                m = i(6358),
                _ = i(2820),
                y = i(4468),
                S = i(7e3),
                v = i(1028),
                b = i(5431),
                T = i(4526),
                P = i(7023),
                A = i(9980);
            class I extends PIXI.Container {
                get totalCost() {
                    return this._totalCost
                }
                get permanentContainer() {
                    return this._permanentContainer
                }
                get freeBetsTotalWin() {
                    return this._freeBetsTotalWin
                }
                get staticContainer() {
                    return this._staticContainer
                }
                get dynamicContainer() {
                    return this._dynamicContainer
                }
                get demoButton() {
                    return this._demoButton
                }
                get soundButton() {
                    return this._soundButton
                }
                get promoButton() {
                    return this._promoButton
                }
                get zeroBetCounter() {
                    return this._zeroBetCounter
                }
                get fullscreenSpinButton() {
                    return this._fullscreenSpinButton
                }
                get betLevelButton() {
                    return this._betLevelButton
                }
                get menuButton() {
                    return this._menuButton
                }
                get spinButton() {
                    return this._spinButton
                }
                get spinSettingsGroup() {
                    return this._spinSettingsGroup
                }
                get fastSpinAutoPlaySeparator() {
                    return this._spinSettingsGroup.separator
                }
                get fastSpinButton() {
                    return this._fastSpinButton
                }
                get autoplayButton() {
                    return this._autoplayButton
                }
                get bet() {
                    return this._bet
                }
                get balance() {
                    return this._balance
                }
                get win() {
                    return this._win
                }
                constructor(t) {
                    super(), this.backgroundGradientMaxAlpha = .6, this._controller = t, this.name = "SlotKeypadView", this.initAnimations(), this.hideWin(0), n.SlotKeypad.apiPlugIn.settings.on(_.APISetting.LEFT_HAND_MODE, (() => this.onResize()))
                }
                onResize() {
                    const t = f.NolimitApplication.screenBounds;
                    this._backgroundGradient.position.set(t.left, t.bottom), this._backgroundGradient.width = t.width, this._backgroundGradient.height = 40, this._fullscreenSpinButton.position.set(t.left, t.top), this._fullscreenSpinButton.width = t.width, this._fullscreenSpinButton.height = t.height, this._spinSettingsGroup.resize();
                    const e = !0 === n.SlotKeypad.apiPlugIn.settings.get(_.APISetting.DEVICE_HAS_ROUNDED_CORNERS) ? 50 : 0,
                        i = 10;
                    let r = new PIXI.Point(t.center, t.bottom - 234),
                        o = t.bottom - 124,
                        s = new PIXI.Point;
                    if (f.NolimitApplication.isLandscape) this._win.position.set(t.center, t.bottom - 3), this._balance.position.set(t.right - i - e, t.bottom - 3), this._bet.position.set(t.left + i + e, t.bottom - 3), this._soundButton.position.set(t.left + i, o), this._betLevelButton.position.set(this._soundButton.x + this._soundButton.width + 20, o), this._menuButton.position.set(t.left + i, this._soundButton.y - this._soundButton.height - 20), this._promoButton.position.set(t.left + i, this._menuButton.y - this._promoButton.height - 30), r = new PIXI.Point(t.right - i - 100, t.bottom - 234), this._spinSettingsGroup.position.set(Math.floor(r.x - .5 * this._spinSettingsGroup.getWidth()), o), n.SlotKeypad.apiPlugIn.settings.get(_.APISetting.LEFT_HAND_MODE) && (r = new PIXI.Point(t.left + i + 100, t.bottom - 238)), s.set(43, 50);
                    else {
                        this._bet.position.set(t.left + i + e, t.bottom - 3), this._balance.position.set(t.right - i - e, t.bottom - 3), this._rightSeparator.position.set(t.right - i, this._balance.y - this._balance.height - 10 + 3), this._win.position.set(t.right - i, this._rightSeparator.y - 3), this._spinSettingsGroup.position.set(Math.floor(t.center - .5 * this._spinSettingsGroup.getWidth()), o), this._soundButton.position.set(t.left + i, o), this._betLevelButton.position.set(this._soundButton.x + this._soundButton.width + 20, o), this._promoButton.position.set(t.left + i, this._betLevelButton.y - this._promoButton.height - 30);
                        const n = r.y + 90;
                        this._menuButton.position.set(t.right - this._menuButton.width - i + 3, n - this._menuButton.height), this._nolimitBrandLabel.position.set(t.center, t.bottom - 3), s.set(0, 50)
                    }
                    if (this._freeBetsTotalWin.visible) {
                        this._freeBetsTotalWin.position.set(t.left + i + e, this._bet.y - this._freeBetsTotalWin.height - 3);
                        const n = [this._soundButton, this._betLevelButton, this._promoButton];
                        f.NolimitApplication.isLandscape && n.push(this._menuButton), v.GuiLayout.offset(n, 0, -this._freeBetsTotalWin.height)
                    }
                    if (this._totalCost.visible) {
                        this._totalCost.position.set(t.left + i + e, this._bet.y - this._totalCost.height - 3);
                        const n = [this._soundButton, this._betLevelButton, this._promoButton];
                        f.NolimitApplication.isLandscape && n.push(this._menuButton), v.GuiLayout.offset(n, 0, -this._totalCost.height)
                    }
                    this._demoButton.position.set(t.right - this._demoButton.width - i, t.top + 40), this._spinButton.position.set(r.x - 100, r.y - 90), this._zeroBetCounter.position.set(r.x - .5 * this._zeroBetCounter.width + s.x, r.y - .5 * this._zeroBetCounter.height + s.y), this.spinButtonCenter = r.clone()
                }
                onOrientationChanged() {
                    f.NolimitApplication.isLandscape ? (this._bet.setAnchor(0, 1), this._freeBetsTotalWin.setAnchor(0, 1), this._totalCost.setAnchor(0, 1), this._win.setAnchor(.5, 1), this._balance.setAnchor(1, 1), this._nolimitBrandLabel.pivot.set(.5 * this._nolimitBrandLabel.width, this._nolimitBrandLabel.height), this._staticContainer.removeChild(this._rightSeparator), this._staticContainer.removeChild(this._nolimitBrandLabel)) : (this._bet.setAnchor(0, 1), this._freeBetsTotalWin.setAnchor(0, 1), this._totalCost.setAnchor(0, 1), this._win.setAnchor(1, 1), this._balance.setAnchor(1, 1), this._rightSeparator.lineStyle(1, 16777215, .6), this._rightSeparator.lineTo(-150, 0), this._staticContainer.addChild(this._rightSeparator), this._staticContainer.addChild(this._nolimitBrandLabel))
                }
                createPermanentContainer() {
                    const t = new PIXI.Container;
                    t.name = "PermanentContainer";
                    const e = PIXI.BaseTexture.from("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAEACAYAAACOKzdSAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGRJREFUeNrs2bsNACAMQ0GD2H9mNoAuIuJSW+HFpuAzkowcauZS648OIN9ZAkMjBmNykqCxYPJBFnz4dQqQIDEIC4MNgwEkSGdaNxQ+yIKgocALJyfbjYmhjMFP8TuQBR22AAMAFikEyMCk4fEAAAAASUVORK5CYII=");
                    return this._backgroundGradient = new PIXI.Sprite(new PIXI.Texture(e)), this._backgroundGradient.anchor.set(0, 1), this._backgroundGradient.name = "BackgroundGradient", this._backgroundGradient.alpha = this.backgroundGradientMaxAlpha, this._balance = new l.LabeledValue(n.KeypadValueIDs.BALANCE, n.SlotKeypad.apiPlugIn.translations.translate("BALANCE"), -1, T.KeypadTextStyles.KEYPAD_STANDARD_LABEL, T.KeypadTextStyles.KEYPAD_STANDARD_VALUE), this._bet = new l.LabeledValue(n.KeypadValueIDs.BET, n.SlotKeypad.apiPlugIn.translations.translate("BET"), -1, T.KeypadTextStyles.KEYPAD_STANDARD_LABEL, T.KeypadTextStyles.KEYPAD_STANDARD_VALUE), this._totalCost = new l.LabeledValue(n.KeypadValueIDs.TOTAL_COST, n.SlotKeypad.apiPlugIn.translations.translate("TOTAL COST"), -1, T.KeypadTextStyles.TOTAL_COST_LABEL, T.KeypadTextStyles.TOTAL_COST_VALUE), this._totalCost.visible = !1, t.addChild(this._backgroundGradient), t.addChild(this._bet), t.addChild(this._balance), t.addChild(this._totalCost), t
                }
                createStaticContainer() {
                    const t = new PIXI.Container;
                    return t.name = "StaticContainer", this._rightSeparator = new PIXI.Graphics, this._rightSeparator.name = "_rightSeparator", this._nolimitBrandLabel = new d.NolimitBrandLabel, this._win = new y.WinLabel(n.KeypadValueIDs.WIN, n.SlotKeypad.apiPlugIn.translations.translate("WIN"), -1, T.KeypadTextStyles.WIN_LABEL, T.KeypadTextStyles.WIN_VALUE), this._zeroBetCounter = new g.ZeroBetCounter, this._fullscreenSpinButton = new p.FullscreenSpinButton(n.KeypadButtonIDs.FULLSCREEN_SPIN), this._fullscreenSpinButton.alpha = 0, this._fullscreenSpinButton.addClickCallback((() => this._controller.buttonClick(this._fullscreenSpinButton))), this._soundButton = new A.SoundButton(n.KeypadButtonIDs.SOUND), this._soundButton.addClickCallback((() => this._controller.buttonClick(this._soundButton))), this._soundButton.addClickCallback((() => this.playClickSound())), this._soundButton.toggled = !n.SlotKeypad.sound.isQuickMute(), this._freeBetsTotalWin = new l.LabeledValue(n.KeypadValueIDs.FREE_BETS_TOTAL_WIN, n.SlotKeypad.apiPlugIn.translations.translate("TOTAL WIN"), -1, T.KeypadTextStyles.FREE_BETS_WIN_LABEL, T.KeypadTextStyles.FREE_BETS_WIN_VALUE), this._freeBetsTotalWin.visible = !1, t.addChild(this._freeBetsTotalWin), t.addChild(this._win), t.addChild(this._zeroBetCounter), t.addChild(this._fullscreenSpinButton), t.addChild(this._soundButton), t
                }
                createDynamicContainer() {
                    const t = new PIXI.Container;
                    t.name = "DynamicContainer", this._spinButton = new r.SpinButton, this._spinButton.addClickCallback((() => this._controller.buttonClick(this._spinButton)));
                    let e, i, l = s.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone();
                    return s.SlotKeypadViewSettings.instance.activePointerStateColors.clone(), e = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.BET_LEVELS_BUTTON))), this._betLevelButton = new b.BetLevelButton(n.KeypadButtonIDs.BET_LEVEL, e, l), this._betLevelButton.addClickCallback((() => this._controller.buttonClick(this._betLevelButton))), this._betLevelButton.addClickCallback((() => this.playClickSound())), this._betLevelButton.toggled = !1, e = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.MENU_CLOSE))), i = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.MENU))), this._menuButton = new o.IconToggleButton(n.KeypadButtonIDs.MENU, e, l, i), this._menuButton.addClickCallback((() => this._controller.buttonClick(this._menuButton))), this._menuButton.addClickCallback((() => this.playClickSound())), this._menuButton.toggled = !1, e = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.PROMO_BUTTON))), i = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.PROMO_BUTTON))), this._promoButton = new o.IconToggleButton(n.KeypadButtonIDs.PROMO_BUTTON, e, l, i), this._promoButton.pivot.x = 60, this._promoButton.addClickCallback((() => this._controller.buttonClick(this._promoButton))), this._promoButton.addClickCallback((() => this.playClickSound())), e = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.DEMO_ICON))), i = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.DEMO_ICON))), this._demoButton = new o.IconToggleButton(n.KeypadButtonIDs.DEMO, e, l, i), this._demoButton.addClickCallback((() => this._controller.buttonClick(this._demoButton))), this._demoButton.addClickCallback((() => this.playClickSound())), t.addChild(this._spinButton), t.addChild(this._betLevelButton), t.addChild(this._menuButton), t.addChild(this._promoButton), t.addChild(this._demoButton), t
                }
                createSpinSettingsGroup() {
                    let t, e, i = s.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
                        r = s.SlotKeypadViewSettings.instance.activePointerStateColors.clone();
                    return t = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.FAST_SPIN))), this._fastSpinButton = new o.IconToggleButton(n.KeypadButtonIDs.FAST_SPIN, t, r, void 0, i), this._fastSpinButton.addClickCallback((() => this._controller.buttonClick(this._fastSpinButton))), this._fastSpinButton.addClickCallback((() => {
                        const t = this._fastSpinButton.toggled ? u.KeypadSound.FAST_SPIN_OFF : u.KeypadSound.FAST_SPIN_ON;
                        this.playClickSound(t)
                    })), this._fastSpinButton.toggled = !1, t = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.AUTO_PLAY_ON))), e = new a.PointerStateIconSet(new h.Icon(P.SkinLoader.getTexture(P.SkinLoader.AUTO_PLAY_OFF))), this._autoplayButton = new c.AutoplayButton(n.KeypadButtonIDs.AUTO_PLAY, t, r, e, i), this._autoplayButton.addClickCallback((() => this._controller.buttonClick(this._autoplayButton))), this._autoplayButton.addClickCallback((() => this.playClickSound())), this._autoplayButton.toggled = !1, new S.SpinSettingsGroup(this._fastSpinButton, this._autoplayButton)
                }
                initAnimations() {
                    this._permanentContainer = this.createPermanentContainer(), this._staticContainer = this.createStaticContainer(), this._dynamicContainer = this.createDynamicContainer(), this._spinSettingsGroup = this.createSpinSettingsGroup(), this.betLevelButton.addButtonSlave(this.bet), this.addChild(this._permanentContainer), this.addChild(this._staticContainer), this.addChild(this._dynamicContainer), this.addChild(this._spinSettingsGroup)
                }
                hideWin(t = .5) {
                    const e = new m.TimelineLite;
                    return e.add([new m.TweenLite(this._win, t, {
                        alpha: 0
                    }), new m.TweenLite(this._rightSeparator, t, {
                        alpha: 0
                    })], .1), e
                }
                showWin(t = .1) {
                    const e = new m.TimelineLite;
                    return e.add([new m.TweenLite(this._win, t, {
                        alpha: 1
                    }), new m.TweenLite(this._rightSeparator, t, {
                        alpha: 1
                    })]), e
                }
                playClickSound(t = u.KeypadSound.CLICK) {
                    n.SlotKeypad.sound.playKeypadEffect(t)
                }
            }
            e.BetPanelView = I
        },
        4989: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.KeypadSound = void 0, (i = e.KeypadSound || (e.KeypadSound = {})).NONE = "", i.CLICK = "click", i.DISABLED = "disabled", i.FAST_SPIN_OFF = "fast-spin-off", i.FAST_SPIN_ON = "fast-spin-on", i.SPIN_START = "spin-start", i.SPIN_STOP = "spin-stop"
        },
        9959: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.KeypadView = void 0;
            const n = i(8714),
                r = i(9797),
                o = i(6358),
                s = i(3988),
                a = i(8943),
                l = i(1309);
            class h extends PIXI.Container {
                get betPanel() {
                    return this._betPanel
                }
                constructor(t) {
                    super(), this._controller = t, this.initAnimations(), n.SlotKeypad.apiPlugIn.clock.events.on(n.SlotKeypad.apiPlugIn.clock.UPDATE, (() => this.onClockHandler(n.SlotKeypad.apiPlugIn.clock.UPDATE))), n.SlotKeypad.apiPlugIn.clock.events.on(n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE, (() => this.onClockHandler(n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE))), this.onClockHandler(n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE)
                }
                onResize() {
                    this._betPanel.onResize()
                }
                onOrientationChanged() {
                    this._betPanel.onOrientationChanged()
                }
                initAnimations() {
                    this.setupTopBar(), this._betPanel = new r.BetPanelView(this._controller), this.addChild(this._betPanel)
                }
                hide(t) {
                    return this.setStateVisibility(t, !0)
                }
                show(t) {
                    return this.setStateVisibility(t)
                }
                halt() {
                    this.createStateVisibilityAnimation(.1, !1, !1, !1)
                }
                setStateVisibility(t = .2, e = !1, i = !1) {
                    const r = n.SlotKeypad.apiPlugIn.slotStates.checkState(a.SlotState.READY, a.SlotState.FINISH, a.SlotState.GAMBLE) && !n.SlotKeypad.apiPlugIn.slotStates.checkState(a.SlotState.PAUSED),
                        o = n.SlotKeypad.apiPlugIn.slotStates.checkState(a.SlotState.DIALOG, a.SlotState.SCREEN, a.SlotState.PAUSED);
                    let s = r && !n.SlotKeypad.autoplay.isAutoplayRound && !n.SlotKeypad.apiPlugIn.isReplay,
                        l = (r || n.SlotKeypad.autoplay.isAutoplayRound) && !n.SlotKeypad.apiPlugIn.isReplay && !e,
                        h = !o && !e;
                    return o && i && (s = !0, l = !0, h = !0), this.createStateVisibilityAnimation(t, h, s, l)
                }
                createStateVisibilityAnimation(t, e, i, n) {
                    return null != this._stateVisibilityAnimation && (this._stateVisibilityAnimation.kill(), this._stateVisibilityAnimation = void 0), this._stateVisibilityAnimation = new o.TimelineLite, this._stateVisibilityAnimation.add([s.AnimationUtils.elementVisibilityAnimation(this.betPanel.staticContainer, t, e), s.AnimationUtils.elementVisibilityAnimation(this.betPanel.fastSpinButton, t, e), s.AnimationUtils.elementVisibilityAnimation(this.betPanel.dynamicContainer, t, i), s.AnimationUtils.elementVisibilityAnimation(this.betPanel.autoplayButton, t, n)]), this.betPanel.permanentContainer.interactiveChildren = i, this._stateVisibilityAnimation
                }
                onClockHandler(t) {
                    t == n.SlotKeypad.apiPlugIn.clock.UPDATE && this._clock.update(n.SlotKeypad.apiPlugIn.clock.formattedTime), t == n.SlotKeypad.apiPlugIn.clock.SETTING_UPDATE && (n.SlotKeypad.apiPlugIn.clock.shouldShow ? (this._clock.update(n.SlotKeypad.apiPlugIn.clock.formattedTime), this._clock.show()) : this._clock.hide())
                }
                setupTopBar() {
                    const t = document.querySelector(".nolimit.container"),
                        e = document.createElement("div");
                    e.classList.add("top-bar-left");
                    const i = document.createElement("div");
                    i.classList.add("top-bar-right"), this._clock = new l.HtmlTopLabel("clock", !0), this._playForFun = new l.HtmlTopLabel(".nolimit.container .fun"), this._gameName = new l.HtmlTopLabel(".nolimit.container #game-name-version"), this._netPosition = new l.HtmlTopLabel(".nolimit.container #net-position"), e.append(this._clock.element), e.append(this._playForFun.element), i.append(this._gameName.element), i.append(this._netPosition.element), t.append(e), t.append(i)
                }
            }
            e.KeypadView = h
        },
        5431: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetLevelButton = void 0;
            const n = i(5991);
            class r extends n.IconToggleButton {
                constructor(t, e, i, n, r) {
                    super(t, e, i, n, r), this._buttonSlaves = [], this.onSlaveClick = t => {
                        this.worldVisible && this.interactive && this.onClick(t)
                    }
                }
                addButtonSlave(t) {
                    t.on("pointertap", this.onSlaveClick), this._buttonSlaves.push(t)
                }
                enable(t) {
                    super.enable(t);
                    for (let e of this._buttonSlaves) e.interactive = t, e.buttonMode = t, e.hitArea = e.getLocalBounds()
                }
            }
            e.BetLevelButton = r
        },
        2213: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitBrandLabel = void 0;
            const n = i(1057),
                r = i(4526),
                o = i(1028);
            class s extends PIXI.Container {
                constructor() {
                    super();
                    const t = [];
                    t.push(new n.Label("NOLIMIT CITY", r.KeypadTextStyles.BRAND_TEXT_THICK)), o.GuiLayout.align(t);
                    for (let e of t) e.alpha = .3, this.addChild(e)
                }
            }
            e.NolimitBrandLabel = s
        },
        7e3: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpinSettingsGroup = void 0;
            const n = i(1028),
                r = i(6358);
            class o extends PIXI.Container {
                get separator() {
                    return this._separator
                }
                get autoPlayButton() {
                    return this._autoPlayButton
                }
                get fastSpinButton() {
                    return this._fastSpinButton
                }
                getWidth() {
                    const t = this._autoPlayButton.visible,
                        e = this._separator.visible,
                        i = this._fastSpinButton.visible;
                    this._autoPlayButton.visible = !0, this._separator.visible = !0, this._fastSpinButton.visible = !0;
                    const n = this.width;
                    return this._autoPlayButton.visible = t, this._separator.visible = e, this._fastSpinButton.visible = i, n
                }
                constructor(t, e) {
                    super(), this._autoPlayButton = e, this._separator = new PIXI.Graphics, this._fastSpinButton = t, this.addChild(this._autoPlayButton), this.addChild(this._separator), this.addChild(this._fastSpinButton), this._separator.clear(), this._separator.lineStyle(1, 16777215, .6), this._separator.lineTo(0, this._fastSpinButton.height), this.resize(), this.hideSeparator(0)
                }
                resize() {
                    n.GuiLayout.align(this.children, 18)
                }
                hideAutoPlay(t) {
                    const e = new r.TimelineLite;
                    return e.add([new r.TweenLite(this._autoPlayButton, t, {
                        alpha: 0,
                        ease: r.Linear.easeNone
                    }), this.hideSeparator(t)]), e.add((() => {
                        this._autoPlayButton.visible = !1
                    })), e
                }
                hideFastSpin(t) {
                    const e = new r.TimelineLite;
                    return e.add([new r.TweenLite(this._fastSpinButton, t, {
                        alpha: 0,
                        ease: r.Linear.easeNone
                    }), this.hideSeparator(t)]), e.add((() => {
                        this._fastSpinButton.visible = !1
                    })), e
                }
                showAutoPlay(t) {
                    const e = new r.TimelineLite;
                    return e.add((() => {
                        this._autoPlayButton.visible = !0
                    })), e.add([new r.TweenLite(this._autoPlayButton, t, {
                        alpha: 1,
                        ease: r.Linear.easeNone
                    }), () => {
                        this.showSeparator(t)
                    }]), e
                }
                showFastSpin(t) {
                    const e = new r.TimelineLite;
                    return e.add((() => {
                        this._fastSpinButton.visible = !0
                    })), e.add([new r.TweenLite(this._fastSpinButton, t, {
                        alpha: 1,
                        ease: r.Linear.easeNone
                    }), () => {
                        this.showSeparator(t)
                    }]), e
                }
                showSeparator(t) {
                    const e = new r.TimelineLite;
                    return this.shouldShowSeparator() && (e.add((() => {
                        this._separator.visible = !0
                    })), e.add([new r.TweenLite(this._separator, t, {
                        alpha: 1,
                        ease: r.Linear.easeNone
                    })])), e
                }
                hideSeparator(t) {
                    const e = new r.TimelineLite;
                    return e.add([new r.TweenLite(this._separator, t, {
                        alpha: 0,
                        ease: r.Linear.easeNone
                    })]), e.add((() => {
                        this._separator.visible = !1
                    })), e
                }
                shouldShowSeparator() {
                    return !(!this._autoPlayButton.visible || !this._fastSpinButton.visible)
                }
            }
            e.SpinSettingsGroup = o
        },
        4468: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.WinLabel = void 0;
            const n = i(4813),
                r = i(4514);
            class o extends n.LabeledValue {
                constructor(t, e, i, n, r) {
                    super(t, e, i, n, r), this.setAlignment(), this.setPivot()
                }
                setAlignment() {
                    r.NolimitApplication.isLandscape ? (this._label.position.set(0, this._value.height - this._label.height - 4), this._value.position.set(this._label.width + this._margin, 0)) : this._label.width > this._value.width ? (this._label.position.set(0, 0), this._value.position.set(this._label.width - this._value.width, this._label.height)) : (this._label.position.set(this._value.width - this._label.width, 0), this._value.position.set(0, this._label.height))
                }
                setPivot() {
                    this.pivot.set(this.width * this._anchorPoint.x, this.height * this._anchorPoint.y)
                }
            }
            e.WinLabel = o
        },
        7427: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ZeroBetCounter = void 0;
            const n = i(1057),
                r = i(7023),
                o = i(3663);
            class s extends PIXI.Container {
                constructor() {
                    super(), this.name = "ZeroBetCounter", this._backPlate = new PIXI.NineSlicePlane(r.SkinLoader.getTexture(r.SkinLoader.SPIN_BUTTON_PLATE), 40, 40, 40, 40), this._backPlate.width = 110, this._backPlate.height = 95, this._label = new n.Label("99", o.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE), this._label.anchor.set(.5, .5), this._label.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this.addChild(this._backPlate), this.addChild(this._label), this.hide()
                }
                setCount(t) {
                    this._label.text = "" + t
                }
                show() {
                    this.visible = !0
                }
                hide() {
                    this.visible = !1
                }
            }
            e.ZeroBetCounter = s
        },
        8143: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AutoplayButton = void 0;
            const n = i(5991),
                r = i(1057),
                o = i(4526),
                s = i(7023);
            class a extends n.IconToggleButton {
                get spinsCounterLabel() {
                    return this._spinsCounterLabel
                }
                get width() {
                    return this._icon.width
                }
                get height() {
                    return this._icon.height
                }
                constructor(t, e, i, n, a) {
                    super(t, e, i, n, a), this._spinsCounterLabel = new r.Label("-1", o.KeypadTextStyles.AUTO_PLAY_COUNTER_LABEL_STYLE), this._spinsCounterBackPlate = new PIXI.NineSlicePlane(s.SkinLoader.getTexture(s.SkinLoader.LABEL_PLATE_22), 22, 22, 22, 22), this._spinsCounterBackPlate.tint = 0, this._spinsCounterBackPlate.alpha = .4, this._spinsCounterLabel.addBackPlate(this._spinsCounterBackPlate, (() => this.updateSpinsCounterBackPlate())), this._spinsCounterLabel.anchor.set(.5, .5)
                }
                updateSpinsCounterBackPlate() {
                    const t = new r.Margin(0, 0);
                    this._spinsCounterBackPlate.width = 80, this._spinsCounterBackPlate.height = 46, this._spinsCounterBackPlate.pivot.set(.5 * this._spinsCounterBackPlate.width + t.left, .5 * this._spinsCounterBackPlate.height + t.top)
                }
                getIconColorSet() {
                    return this._colorSets.getItem(this.toggleState)
                }
                setCount(t) {
                    t > 0 ? (this._spinsCounterLabel.text = "" + t, this.addSubComponent(this._spinsCounterLabel, {
                        x: .5,
                        y: 0
                    }, {
                        x: 0,
                        y: -43
                    })) : this.removeChild(this._spinsCounterLabel)
                }
                hideSpinCounterLabel() {
                    this._spinsCounterLabel.visible = !1
                }
                showSpinCounterLabel() {
                    this._spinsCounterLabel.visible = !0
                }
            }
            e.AutoplayButton = a
        },
        2178: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FullscreenSpinButton = void 0;
            const n = i(1077),
                r = i(6358);
            class o extends n.GuiButton {
                constructor(t) {
                    super(t);
                    const e = new PIXI.Graphics;
                    e.beginFill(16777215, 1), e.drawRect(0, 0, 100, 100), e.endFill(), this.addChild(e)
                }
                playClickedAnimation() {
                    const t = new r.TimelineLite;
                    return t.add(new r.TweenLite(this, .1, {
                        alpha: .1,
                        ease: r.Linear.easeNone
                    })), t.add(new r.TweenLite(this, .2, {
                        alpha: 0,
                        ease: r.Power2.easeOut
                    })), t
                }
            }
            e.FullscreenSpinButton = o
        },
        6434: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpinButton = void 0;
            const n = i(1077),
                r = i(8714),
                o = i(956),
                s = i(2974),
                a = i(8760),
                l = i(9870),
                h = i(1305),
                u = i(6869),
                c = i(5233),
                d = i(9756),
                p = i(6358),
                f = i(4989),
                g = i(7023);
            class m extends n.GuiButton {
                get betState() {
                    return this._betState
                }
                set betState(t) {
                    this._betState = t, this.update()
                }
                get spinState() {
                    return this._spinState
                }
                set spinState(t) {
                    this._spinState = t, this.update()
                }
                constructor() {
                    super(r.KeypadButtonIDs.SPIN), this._betState = h.BetState.NORMAL, this._spinState = u.SpinButtonState.SPIN, this._backPlateColors = l.SlotKeypadViewSettings.instance.normalBackPlatePointerStateColors.clone(), this._outlineColor = new c.BetStateColorSet(l.SlotKeypadViewSettings.NORMAL_COLOR, l.SlotKeypadViewSettings.NORMAL_COLOR, l.SlotKeypadViewSettings.NORMAL_COLOR, l.SlotKeypadViewSettings.FREE_BETS_COLOR, l.SlotKeypadViewSettings.BOOSTED_BET_COLOR), this._icons = new u.SpinButtonStateSet(new s.PointerStateIconSet(new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.SPIN_ARROW))), new s.PointerStateIconSet(new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.SPIN_STOP))), new s.PointerStateIconSet(new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.SPIN_SKIP))), new s.PointerStateIconSet(new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.SPIN_PLAY))), new s.PointerStateIconSet(new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.SPIN_ARROW))), new s.PointerStateIconSet(new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.SPIN_ARROW)))), this._gambleIcon = new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.COLLECT_ICON)), this._boostIcon = new a.Icon(g.SkinLoader.getTexture(g.SkinLoader.BOOST_ICON));
                    const t = l.SlotKeypadViewSettings.instance.normalPointerStateColors.clone();
                    this._boostedColors = l.SlotKeypadViewSettings.instance.boostedBetsPointerStateColors.clone(), this._colorSets = new u.SpinButtonStateSet(t, t, t, t, t, this._boostedColors), this._soundSet = new u.SpinButtonStateSet(f.KeypadSound.SPIN_START, f.KeypadSound.SPIN_STOP, f.KeypadSound.SPIN_STOP, f.KeypadSound.NONE, f.KeypadSound.SPIN_START, f.KeypadSound.SPIN_START), this._backPlate = new PIXI.NineSlicePlane(g.SkinLoader.getTexture(g.SkinLoader.SPIN_BUTTON_PLATE), 40, 40, 40, 40), this._backPlate.width = 200, this._backPlate.height = 180, this.addChild(this._backPlate), this.addClickCallback((() => this.playSound())), this.update()
                }
                drawBackPlate(t, e) {
                    this._backPlate.tint = d.GuiUtils.getColorFromARGB(e)
                }
                playClickedAnimation() {
                    const t = new p.TimelineLite;
                    return t.set(this._icon, {
                        rotation: 0
                    }), t.set(this._icon.scale, {
                        x: 1,
                        y: 1
                    }), this._spinState == u.SpinButtonState.SPIN || this._spinState == u.SpinButtonState.GAMBLE || this._spinState == u.SpinButtonState.BOOST ? t.add(new p.TweenLite(this._icon, .25, {
                        rotation: 2 * Math.PI
                    })) : (t.add(new p.TweenLite(this._icon.scale, .05, {
                        x: .95,
                        y: .95,
                        ease: p.Linear.easeNone
                    })), t.add(new p.TweenLite(this._icon.scale, .05, {
                        x: 1,
                        y: 1
                    }))), t
                }
                setIcon() {
                    if (this._betState == h.BetState.ZERO_BET) return this._icon && (this._icon.visible = !1), void (this._backPlate.visible = !1);
                    const t = this._icons.getItem(this._spinState),
                        e = this._colorSets.getItem(this._spinState),
                        i = t.getItem(this.pointerState);
                    let n = e.getItem(this.pointerState);
                    this.betState == h.BetState.BOOSTED_BET && (n = this._boostedColors.getItem(this.pointerState)), i.setColor(n), i != this._icon && (this.addChild(i), this.removeChild(this._icon), this._icon = i), this._backPlate.visible = !0, this._icon.visible = !0, this._icon.anchor.set(.5, .5), this._icon.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this.setGambleIconViability(n), this.setBoostIconViability(n)
                }
                setGambleIconViability(t) {
                    this._spinState == u.SpinButtonState.GAMBLE ? (this._gambleIcon.visible = !0, this._gambleIcon.anchor.set(.5, .6), this._gambleIcon.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this._gambleIcon.setColor(t), this.addChild(this._gambleIcon)) : this.removeChild(this._gambleIcon)
                }
                setBoostIconViability(t) {
                    this._spinState == u.SpinButtonState.BOOST ? (this._boostIcon.visible = !0, this._boostIcon.anchor.set(.5, .6), this._boostIcon.position.set(.5 * this._backPlate.width, .5 * this._backPlate.height), this._boostIcon.setColor(t), this.addChild(this._boostIcon)) : this.removeChild(this._boostIcon)
                }
                onPointerStateUpdate(t) {
                    this.update()
                }
                update() {
                    this.drawBackPlate(this._backPlateColors.getItem(this.pointerState), this._outlineColor.getItem(this._betState)), this.setIcon()
                }
                playSound() {
                    const t = this._soundSet.getItem(this.spinState);
                    null != t && t != f.KeypadSound.NONE && r.SlotKeypad.sound.playKeypadEffect(t)
                }
                clickButton() {
                    this.pointerState != o.PointerState.DISABLED && this.onClick()
                }
            }
            e.SpinButton = m
        },
        1305: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetStateSet = e.BetState = void 0,
                function (t) {
                    t[t.NORMAL = 0] = "NORMAL", t[t.AUTOPLAY = 1] = "AUTOPLAY", t[t.ZERO_BET = 2] = "ZERO_BET", t[t.FREE_BETS = 3] = "FREE_BETS", t[t.BOOSTED_BET = 4] = "BOOSTED_BET", t[t.HIDDEN = 5] = "HIDDEN"
                }(i = e.BetState || (e.BetState = {}));
            class n {
                constructor(t, e, n, r, o, s) {
                    this[i.NORMAL] = t, this[i.AUTOPLAY] = e, this[i.ZERO_BET] = n, this[i.FREE_BETS] = r, this[i.BOOSTED_BET] = o, this[i.HIDDEN] = s
                }
                getItem(t) {
                    return this[t]
                }
                clone() {
                    return new n(this[i.NORMAL], this[i.AUTOPLAY], this[i.ZERO_BET], this[i.FREE_BETS], this[i.BOOSTED_BET], this[i.HIDDEN])
                }
            }
            e.BetStateSet = n, i.NORMAL, i.AUTOPLAY, i.ZERO_BET, i.FREE_BETS, i.BOOSTED_BET, i.HIDDEN
        },
        6869: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpinButtonStateSet = e.SpinButtonState = void 0,
                function (t) {
                    t[t.SPIN = 0] = "SPIN", t[t.STOP = 1] = "STOP", t[t.ABORT = 2] = "ABORT", t[t.COUNT = 3] = "COUNT", t[t.GAMBLE = 4] = "GAMBLE", t[t.BOOST = 5] = "BOOST"
                }(i = e.SpinButtonState || (e.SpinButtonState = {}));
            class n {
                constructor(t, e, n, r, o, s) {
                    this[i.SPIN] = t, this[i.STOP] = e, this[i.ABORT] = n, this[i.COUNT] = r, this[i.GAMBLE] = o, this[i.BOOST] = s
                }
                getItem(t) {
                    return this[t]
                }
                clone() {
                    return new n(this[i.SPIN], this[i.STOP], this[i.ABORT], this[i.COUNT], this[i.GAMBLE], this[i.BOOST])
                }
            }
            e.SpinButtonStateSet = n, i.SPIN, i.STOP, i.ABORT, i.COUNT, i.GAMBLE, i.BOOST
        },
        5233: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetStateColorSet = void 0;
            const n = i(1305);
            class r extends n.BetStateSet {
                constructor(t, e, i, n, r) {
                    super(t, e, i, n, r)
                }
                getItem(t) {
                    return null != this[t] ? this[t] : this[n.BetState.NORMAL]
                }
                clone() {
                    return super.clone()
                }
            }
            e.BetStateColorSet = r
        },
        2590: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AutoPlayView = void 0;
            const n = i(8714),
                r = i(1028),
                o = i(2056),
                s = i(647),
                a = i(4632),
                l = i(4781),
                h = i(9858),
                u = i(4514),
                c = i(4989),
                d = i(7185);
            class p extends o.DialogView {
                constructor(t, e) {
                    super(t, e, "AutoPlaySettings", !0)
                }
                init() {
                    super.init(), this._settingsPage = new a.AutoPlaySettingsPage(this, n.SlotKeypad.apiPlugIn.translations.translate("Autoplay settings")), this._settingsPage.name = "AutoPlaySettingsPage", this._roundsPage = new s.AutoPlayRoundsPage(this, n.SlotKeypad.apiPlugIn.translations.translate("Number of Rounds")), this._roundsPage.name = "NumberOfRoundsPage", this._sectionDivider = new PIXI.Graphics, this._content = new PIXI.Container, this._content.addChild(this._settingsPage), this._content.addChild(this._sectionDivider), this._content.addChild(this._roundsPage), this.addChild(this._content)
                }
                drawSectionDivider(t, e) {
                    this._sectionDivider.clear(), this._sectionDivider.lineStyle(1, 16777215, .6);
                    const i = h.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT;
                    this._sectionDivider.moveTo(i, 0), this._sectionDivider.lineTo(t.width - 2 * i, 0)
                }
                onResize() {
                    if (super.onResize(), !this.shouldResize()) return;
                    const t = (0, l.cloneScreenBounds)(u.NolimitApplication.screenBounds);
                    t.bottom -= this.bottomMargin, this.drawSectionDivider(t, u.NolimitApplication.isLandscape), this._settingsPage.onResize(t), this._roundsPage.onResize(t), r.GuiLayout.align([this._settingsPage, this._sectionDivider, this._roundsPage], 10, r.Align.LEFT, r.Direction.VERTICAL), this._content.position.set(t.left, t.top)
                }
                onInteraction(t, e) {
                    let i = !1,
                        r = !0;
                    const o = t.split("_")[0];
                    "maxSingleWin" == o && (this.autoPlaySettingsData.maxSingleWin = e, r = !1), "StopWhenBalanceIsLower" == o && (this.autoPlaySettingsData.minBalancePercent == e ? this.autoPlaySettingsData.minBalancePercent = void 0 : this.autoPlaySettingsData.minBalancePercent = e), "StopWhenBalanceIsHigher" == o && (this.autoPlaySettingsData.maxBalancePercent == e ? this.autoPlaySettingsData.maxBalancePercent = void 0 : this.autoPlaySettingsData.maxBalancePercent = e), "AutoPlayRoundsButton" == o && (this.autoPlaySettingsData.rounds = parseInt(e), i = !0), this._controller.updateAutoplaySettings(this.autoPlaySettingsData), this._settingsPage.updateValues(n.SlotKeypad.autoplay.settings), this._roundsPage.updateButtons(n.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRounds), r && n.SlotKeypad.sound.playKeypadEffect(c.KeypadSound.CLICK), i && this.close(!0)
                }
                open() {
                    super.open(), this.autoPlaySettingsData = n.SlotKeypad.autoplay.settings, this._settingsPage.updateValues(n.SlotKeypad.autoplay.settings), this._roundsPage.updateButtons(n.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRounds), this.onResize(), this._settingsPage.updateDomElement(!0)
                }
                close(t = !1) {
                    this._settingsPage.updateDomElement(!1), this.reportBackSettingPageClosed(), super.close()
                }
                reportBackSettingPageClosed() {
                    n.SlotKeypad.apiPlugIn.events.trigger(d.APIEvent.SETTING_PAGE_CHANGE, {
                        name: "gameMenu",
                        value: !1
                    })
                }
            }
            e.AutoPlayView = p
        },
        3934: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetLevelsDialogView = void 0;
            const n = i(8714),
                r = i(4550),
                o = i(2056),
                s = i(4514),
                a = i(4781),
                l = i(4989);
            class h extends o.DialogView {
                constructor(t, e) {
                    super(t, e, "BetLevels", !0)
                }
                init() {
                    super.init();
                    const t = this.api.options.hideCurrency ? "" : this.api.currency.getSymbol();
                    this._page = new r.BetLevelsPage(this, n.SlotKeypad.apiPlugIn.translations.translate("BET"), "" + t), this.addChild(this._page)
                }
                onResize() {
                    if (super.onResize(), !this.shouldResize()) return;
                    const t = (0, a.cloneScreenBounds)(s.NolimitApplication.screenBounds);
                    t.bottom -= this.bottomMargin, t.height -= this.bottomMargin, this._page.onResize(t), this._page.position.set(t.left, t.top)
                }
                onInteraction(t, e) {
                    n.SlotKeypad.sound.playKeypadEffect(l.KeypadSound.CLICK), this._controller.newBetLevelSelected(t), this.close()
                }
                onRefresh() {
                    this.isOpen && this._page.updateButtons()
                }
                open() {
                    super.open(), this._page.updateButtons(), this.onResize()
                }
                close() {
                    super.close()
                }
            }
            e.BetLevelsDialogView = h
        },
        318: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.DemoView = void 0;
            const n = i(2056),
                r = i(8714),
                o = i(4781),
                s = i(4514),
                a = i(5038),
                l = i(8943),
                h = i(4989);
            class u extends n.DialogView {
                constructor(t, e) {
                    super(t, e, "Demo", !0), this.storedOutcomes = [], this.outcomeQueue = [], this._client = e.communication.outcome.connect(e.options), e.log("Outcome ws connect"), this._client.on("error", (t => {
                        e.warn("Outcome ws error", t), this._controller.disableDemoButton()
                    })), this._client.on("close", (() => {
                        e.log("Outcome ws close")
                    })), this._client.on("message", (t => {
                        e.log("Outcome ws message", t), this.storedOutcomes = t
                    }))
                }
                load() {
                    return this.api.resources.loadJson("outcome.json").then((t => {
                        this.outcomeJson = t
                    }))
                }
                init() {
                    super.init(), this._page = new a.DemoPage(this, r.SlotKeypad.apiPlugIn.translations.translate("DEMO"), ""), this.addChild(this._page)
                }
                tryToSpin() {
                    const t = this.api.slotStates.checkState(l.SlotState.READY);
                    this.storedOutcomes.length > 0 && t && this._controller.clickSpin()
                }
                onInteraction(t, e) {
                    r.SlotKeypad.sound.playKeypadEffect(h.KeypadSound.CLICK), t == u.GO_BUTTON ? this.outcomeQueue.length > 0 && (this.sendOutcomesToServer(this.outcomeQueue), this.clearQueue(), this.close()) : t == u.CLEAR_OUTCOME_SETTER_BUTTON ? this._client.clear() : t == u.CLEAR_BUTTON ? (this.clearQueue(), this._page.updateButtons()) : this.addToQueue(this.outcomeJson.demo[e])
                }
                sendOutcomesToServer(t) {
                    for (let e of t)
                        for (let t of e.outcomes) "string" == typeof t ? this._client.addFlag(t) : this._client.addReels(t)
                }
                addToQueue(t) {
                    this.outcomeQueue.push(t), this._page.updateQueue()
                }
                clearQueue() {
                    this.outcomeQueue = [], this._page.updateQueue()
                }
                onResize() {
                    if (super.onResize(), !this.shouldResize()) return;
                    const t = (0, o.cloneScreenBounds)(s.NolimitApplication.screenBounds);
                    t.bottom -= this.bottomMargin, t.height -= this.bottomMargin, this._page.onResize(t), this._page.position.set(t.left, t.top)
                }
                open() {
                    super.open(), this._page.updateButtons(), this._page.updateQueue(), this.onResize()
                }
                close() {
                    super.close()
                }
            }
            u.GO_BUTTON = "GO_BUTTON", u.CLEAR_BUTTON = "CLEAR_BUTTON", u.CLEAR_OUTCOME_SETTER_BUTTON = "CLEAR_OUTCOME_SETTER_BUTTON", e.DemoView = u
        },
        2056: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.DialogView = void 0;
            const n = i(8714),
                r = i(4781),
                o = i(4514),
                s = i(9870),
                a = i(5991),
                l = i(2974),
                h = i(8760),
                u = i(9858),
                c = i(4989),
                d = i(3158),
                p = i(7023);
            class f extends PIXI.Container {
                get isOpen() {
                    return this._isOpen
                }
                constructor(t, e, i, n = !1) {
                    super(), this._init = !1, this._isOpen = !1, this.bottomMargin = 0, this.name = i, this.api = e, this._controller = t, this._shouldHaveCloseButton = n, this.bottomMargin = this._controller.getBalanceBarHeight()
                }
                onInteraction(t, e) { }
                init() {
                    this._backPlate = new PIXI.Graphics, this._backPlate.name = "backplate", this.addChild(this._backPlate);
                    const t = s.SlotKeypadViewSettings.instance.normalPointerStateColors.clone(),
                        e = new l.PointerStateIconSet(new h.Icon(p.SkinLoader.getTexture(p.SkinLoader.MENU_CLOSE)));
                    this.closeButton = new a.IconToggleButton("CLOSE", e, t, e), this.closeButton.addClickCallback((() => this.close())), this.closeButton.enable(!0), this.addChild(this.closeButton), this._shouldHaveCloseButton || d.SlotKeypadUtils.disableElement(this.closeButton), this._bottomSeparator = new PIXI.Graphics, this._bottomSeparator.name = "_bottomSeparator", this.addChild(this._bottomSeparator)
                }
                drawBackPlate(t) {
                    this._backPlate.clear(), this._backPlate.beginFill(0, .1), this._backPlate.drawRect(0, 0, t.width, t.height), this._backPlate.position.set(t.left, t.top)
                }
                drawBottomSeparator(t) {
                    this._bottomSeparator.clear(), this._bottomSeparator.lineStyle(2, 16777215, .6), this._bottomSeparator.moveTo(0, 0), this._bottomSeparator.lineTo(t.width, 0), this._bottomSeparator.position.set(t.left, t.bottom + 1)
                }
                close() {
                    n.SlotKeypad.sound.playKeypadEffect(c.KeypadSound.CLICK), o.NolimitApplication.removeDialog(this), this._isOpen = !1
                }
                open() {
                    this._init || (this.init(), this._init = !0), this._isOpen = !0, o.NolimitApplication.addDialog(this, !0)
                }
                shouldResize() {
                    return this._init && this._isOpen
                }
                onResize() {
                    if (this.shouldResize()) {
                        const t = (0, r.cloneScreenBounds)(o.NolimitApplication.screenBounds);
                        t.bottom -= this.bottomMargin, this.closeButton.position.set(t.right - this.closeButton.width - u.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, t.top - 11 + (o.NolimitApplication.isLandscape ? u.KeypadDefault.SCREEN_EDGE_MARGIN_TOP_LANDSCAPE : u.KeypadDefault.SCREEN_EDGE_MARGIN_TOP)), this.drawBackPlate(t), this.drawBottomSeparator(t)
                    }
                }
            }
            e.DialogView = f
        },
        51: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameMenuDialogView = e.MenuButtonIDs = void 0;
            const n = i(4989),
                r = i(2056),
                o = i(8714),
                s = i(4514),
                a = i(4781),
                l = i(2306),
                h = i(5225),
                u = i(2540),
                c = i(1007),
                d = i(7185);
            var p;
            ! function (t) {
                t.EXIT_TO_LOBBY = "EXIT_TO_LOBBY", t.HISTORY = "HISTORY", t.INFO = "INFO", t.SETTINGS = "SETTINGS", t.CLOSE = "CLOSE"
            }(p = e.MenuButtonIDs || (e.MenuButtonIDs = {}));
            class f extends r.DialogView {
                openAndGoTo(t) {
                    this._isOpen || (t === h.SettingSectionIDs.GUIDE || t === h.SettingSectionIDs.RULES || t === h.SettingSectionIDs.PAYTABLE) && (this.open(), this._infoPage.goToSection(t))
                }
                constructor(t, e) {
                    super(t, e, "GameMenu", !1), this._htmlScreenContainer = f.getScreensContainer(), this._screenSystem = o.SlotKeypad.apiPlugIn.screenSystem.create(this._htmlScreenContainer), this.init(), this._init = !0
                }
                init() {
                    super.init(), this._menuBar = new c.GameMenuNavigationBar(this), this.addChild(this._menuBar), this._gameSettingsPage = new u.GameSettingsPage(p.SETTINGS, this, o.SlotKeypad.apiPlugIn.translations.translate("Game settings")), this._infoPage = new h.InfoPage(this._htmlScreenContainer, this._screenSystem, p.INFO, this), this._historyPage = new l.HistoryPage(this._htmlScreenContainer, this._screenSystem, p.HISTORY, this, o.SlotKeypad.apiPlugIn.translations.translate("Game history"))
                }
                preLoadHtmlPages() {
                    const t = [];
                    return t.push(this._historyPage.load()), t.push(this._infoPage.load()), Promise.all(t)
                }
                onResize() {
                    if (super.onResize(), !this.shouldResize()) return;
                    const t = (0, a.cloneScreenBounds)(s.NolimitApplication.screenBounds);
                    t.bottom -= this.bottomMargin, t.height -= this.bottomMargin, this._menuBar.onResize(t), s.NolimitApplication.isLandscape ? (t.right -= this._menuBar.width, t.width -= this._menuBar.width) : (t.bottom -= this._menuBar.height, t.height -= this._menuBar.height), this._gameSettingsPage.position.set(t.left, t.top), this._gameSettingsPage.onResize(t), this._historyPage.position.set(t.left, t.top), this._historyPage.onResize(t), this._infoPage.position.set(t.left, t.top), this._infoPage.onResize(t)
                }
                onInteraction(t, e) {
                    switch (o.SlotKeypad.sound.playKeypadEffect(n.KeypadSound.CLICK), t) {
                        case p.EXIT_TO_LOBBY:
                            this._controller.exitToLobby();
                            break;
                        case p.HISTORY:
                            this.setActivePage(this._historyPage), this.reportBackSettingPageChange(o.SettingPageIDs.HISTORY, !0);
                            break;
                        case p.INFO:
                            this.setActivePage(this._infoPage), this.reportBackSettingPageChange(o.SettingPageIDs.INFO, !0);
                            break;
                        case p.SETTINGS:
                            this.setActivePage(this._gameSettingsPage), this.reportBackSettingPageChange(o.SettingPageIDs.SETTINGS, !0);
                            break;
                        case p.CLOSE:
                            this.close()
                    }
                    this.updateButtons()
                }
                open() {
                    super.open(), this.onResize(), this.setActivePage(this._infoPage), this.updateButtons()
                }
                close() {
                    this.setActivePage(null), this.reportBackSettingPageClosed(), super.close()
                }
                reportBackSettingPageChange(t, e) {
                    o.SlotKeypad.apiPlugIn.externalApi.trigger(d.APIEvent.SETTING_PAGE_CHANGE, {
                        name: t,
                        value: e
                    })
                }
                reportBackSettingPageClosed() {
                    o.SlotKeypad.apiPlugIn.externalApi.trigger(d.APIEvent.SETTING_PAGE_CHANGE, {
                        name: "gameMenu",
                        value: !1
                    })
                }
                setActivePage(t) {
                    if (null == t) return this._activePage.deactivate(), void (this._htmlScreenContainer.style.display = "none");
                    t != this._activePage ? (this._activePage && (this.removeChild(this._activePage), this._activePage.deactivate()), t.activate(), this.addChild(t), this._activePage = t) : "HISTORY" !== this._activePage.name && this._activePage.activate()
                }
                updateButtons() {
                    this._menuBar.updateButtons(this._activePage.name)
                }
                static getScreensContainer() {
                    let t = document.querySelector(".nolimit.container.screensFrameContainer");
                    if (null == t) {
                        const e = document.querySelector(".nolimit.container");
                        null == e ? o.SlotKeypad.apiPlugIn.error.trigger("Can't find container element: .nolimit.container") : (t = document.createElement("div"), t.classList.add("screensFrameContainer"), t.style.display = "none", t.style.position = "absolute", t.style.width = "100%", t.style.height = "100%", t.style.top = "0px", t.style.left = "0pxe", e.appendChild(t))
                    }
                    return t
                }
            }
            e.GameMenuDialogView = f
        },
        1007: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameMenuNavigationBar = void 0;
            const n = i(9870),
                r = i(8714),
                o = i(3158),
                s = i(51),
                a = i(2974),
                l = i(8760),
                h = i(5991),
                u = i(8338),
                c = i(1028),
                d = i(4514),
                p = i(7023);
            class f extends PIXI.Container {
                constructor(t) {
                    super(), this.name = "GameMenuNavigationBar", this._parentView = t, this.createMenuBar()
                }
                drawMenuBackPlate(t) {
                    this._backPlate.clear(), this._backPlate.beginFill(0, .2), d.NolimitApplication.isLandscape ? (this._backPlate.drawRect(2, 0, 109, t.height), this._backPlate.endFill(), this._backPlate.lineStyle(2, 16777215, .6), this._backPlate.moveTo(1, 0), this._backPlate.lineTo(1, t.height)) : (this._backPlate.drawRect(0, 2, t.width, 109), this._backPlate.endFill(), this._backPlate.lineStyle(2, 16777215, .6), this._backPlate.moveTo(0, 1), this._backPlate.lineTo(t.width, 1))
                }
                drawSeparators() {
                    this._exitSeparator.clear(), this._exitSeparator.lineStyle(.6, 16777215), this._closeButtonSeparator.clear(), this._closeButtonSeparator.lineStyle(.6, 16777215), d.NolimitApplication.isLandscape ? (this._exitSeparator.lineTo(70, 0), this._closeButtonSeparator.lineTo(70, 0)) : (this._exitSeparator.lineTo(0, 70), this._closeButtonSeparator.lineTo(0, 70))
                }
                onResize(t) {
                    this.drawMenuBackPlate(t), this.drawSeparators(), d.NolimitApplication.isLandscape ? (c.GuiLayout.align(this._navigationSection.children, 30, c.Align.CENTER, c.Direction.VERTICAL), c.GuiLayout.align(this._exitLobbySection.children, 21, c.Align.CENTER, c.Direction.VERTICAL), c.GuiLayout.align(this._closeButtonSection.children, 6, c.Align.CENTER, c.Direction.VERTICAL), this._exitLobbySection.pivot.set(.5 * this._exitLobbySection.width, 0), this._closeButtonSection.pivot.set(.5 * this._closeButtonSection.width, this._closeButtonSection.height), this._navigationSection.pivot.set(.5 * this._navigationSection.width, this._navigationSection.height), this._exitLobbySection.position.y = 40, this._closeButtonSection.position.y = t.height - 5, this._navigationSection.position.y = this._closeButtonSection.y - this._closeButtonSection.height - 40, this._exitLobbySection.position.x = .5 * this._backPlate.width, this._closeButtonSection.position.x = .5 * this._backPlate.width, this._navigationSection.position.x = .5 * this._backPlate.width, this.pivot.set(this.width, 0), this.position.set(t.right, t.top)) : (c.GuiLayout.align(this._navigationSection.children, 30, c.Align.CENTER, c.Direction.HORIZONTAL), c.GuiLayout.align(this._exitLobbySection.children, 21, c.Align.CENTER, c.Direction.HORIZONTAL), c.GuiLayout.align(this._closeButtonSection.children, 6, c.Align.CENTER, c.Direction.HORIZONTAL), this._exitLobbySection.pivot.set(0, .5 * this._exitLobbySection.height), this._closeButtonSection.pivot.set(this._closeButtonSection.width, .5 * this._closeButtonSection.height), this._navigationSection.pivot.set(this._navigationSection.width, .5 * this._navigationSection.height), this._exitLobbySection.position.x = 20, this._closeButtonSection.position.x = t.width - 5, this._navigationSection.position.x = this._closeButtonSection.x - this._closeButtonSection.width - 40, this._exitLobbySection.position.y = .5 * this._backPlate.height, this._closeButtonSection.position.y = .5 * this._backPlate.height, this._navigationSection.position.y = .5 * this._backPlate.height, this.pivot.set(0, this.height), this.position.set(t.left, t.bottom))
                }
                onOrientationChanged() { }
                createMenuBar() {
                    this._backPlate = new PIXI.Graphics, this._backPlate.beginFill(16711680, .6), this._backPlate.drawRect(0, 2, 109, 109), this._backPlate.endFill(), this._backPlate.lineStyle(2, 16777215, .6), this._backPlate.moveTo(0, 1), this._backPlate.lineTo(109, 1), this._buttons = [];
                    let t, e = n.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
                        i = n.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone();
                    t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.EXIT_LOBBY))), this._exitLobbyButton = new h.IconToggleButton(s.MenuButtonIDs.EXIT_TO_LOBBY, t, e, void 0, i), this._exitLobbyButton.addClickCallback((() => this._parentView.onInteraction(this._exitLobbyButton.name, this._exitLobbyButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.HISTORY))), this._historyButton = new h.IconToggleButton(s.MenuButtonIDs.HISTORY, t, e, void 0, i), this._historyButton.addClickCallback((() => this._parentView.onInteraction(this._historyButton.name, this._historyButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.INFO))), this._infoButton = new h.IconToggleButton(s.MenuButtonIDs.INFO, t, e, void 0, i), this._infoButton.addClickCallback((() => this._parentView.onInteraction(this._infoButton.name, this._infoButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.SETTINGS))), this._settingButton = new h.IconToggleButton(s.MenuButtonIDs.SETTINGS, t, e, void 0, i), this._settingButton.addClickCallback((() => this._parentView.onInteraction(this._settingButton.name, this._settingButton.name))), t = new a.PointerStateIconSet(new l.Icon(p.SkinLoader.getTexture(p.SkinLoader.MENU_CLOSE))), this._closeButton = new h.IconToggleButton(s.MenuButtonIDs.CLOSE, t, e, void 0, i), this._closeButton.addClickCallback((() => this._parentView.onInteraction(this._closeButton.name, this._closeButton.name))), this._buttons.push(this._exitLobbyButton), this._buttons.push(this._historyButton), this._buttons.push(this._infoButton), this._buttons.push(this._settingButton), this._buttons.push(this._closeButton), this._exitLobbySection = new PIXI.Container, this._exitSeparator = new PIXI.Graphics, this._exitLobbySection.addChild(this._exitLobbyButton), this._exitLobbySection.addChild(this._exitSeparator), this._navigationSection = new PIXI.Container, this._navigationSection.addChild(this._historyButton), this._navigationSection.addChild(this._infoButton), this._navigationSection.addChild(this._settingButton), this._closeButtonSection = new PIXI.Container, this._closeButtonSeparator = new PIXI.Graphics, this._closeButtonSection.addChild(this._closeButtonSeparator), this._closeButtonSection.addChild(this._closeButton), this.addChild(this._backPlate), this.addChild(this._exitLobbySection), this.addChild(this._navigationSection), this.addChild(this._closeButtonSection);
                    for (let t of this._buttons) t.enable(!0);
                    r.SlotKeypad.apiPlugIn.options.device === u.Device.DESKTOP ? r.SlotKeypad.apiPlugIn.options.showExitButtonDesktop || o.SlotKeypadUtils.disableElement(this._exitLobbySection) : r.SlotKeypad.apiPlugIn.options.hideExitButton && o.SlotKeypadUtils.disableElement(this._exitLobbySection)
                }
                updateButtons(t) {
                    for (let e of this._buttons) e.toggled = t === e.name
                }
            }
            e.GameMenuNavigationBar = f
        },
        5518: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PageHeader = void 0;
            const n = i(4526),
                r = i(9870),
                o = i(1057),
                s = i(1028);
            class a extends PIXI.Container {
                constructor(t, e) {
                    super(), this._headerWhite = new o.Label(t, n.KeypadTextStyles.DEFAULT_DIALOG_HEADER), this._headerYellow = new o.Label(e, n.KeypadTextStyles.DEFAULT_DIALOG_HEADER), this._headerYellow.setColor(r.SlotKeypadViewSettings.AUTOPLAY_COLOR), this._separator = new PIXI.Graphics, this._textContainer = new PIXI.Container, this._textContainer.addChild(this._headerWhite, this._headerYellow), s.GuiLayout.align([this._headerWhite, this._headerYellow], 10, s.Align.TOP, s.Direction.HORIZONTAL), this.addChild(this._textContainer, this._separator)
                }
                resize(t) {
                    this._separator.clear(), this._separator.lineStyle(1, 16777215, .5), this._separator.moveTo(0, 0), this._separator.lineTo(t - 11, 0), this._separator.position.set(0, 89), this._textContainer.width > t - 80 && this._textContainer.scale.set((t - 80) / this._textContainer.width)
                }
            }
            e.PageHeader = a
        },
        647: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AutoPlayRoundsPage = void 0;
            const n = i(1395),
                r = i(9870),
                o = i(9858),
                s = i(1028),
                a = i(8714),
                l = i(8130),
                h = i(3663);
            class u extends n.BasePage {
                constructor(t, e) {
                    super("autoplayRounds", t, e)
                }
                createContent() {
                    const t = super.createContent();
                    return this._buttonContainer = new PIXI.Container, this._buttonContainer.name = "buttons", this._buttons = [], t.addChild(this._buttonContainer), t
                }
                createButton(t) {
                    let e = r.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
                        i = r.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
                        n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
                    const s = new l.LabelButton("AutoPlayRoundsButton_" + t.toString(), t.toString(), n, i, e);
                    return s.value = t, s.addClickCallback((() => this._parentView.onInteraction(s.name, s.value))), s.setSize(o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.width, o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.height), s.enable(!1), s.toggled = !1, this._buttons.push(s), this._buttonContainer.addChild(s), s
                }
                onResize(t) {
                    this.header.position.set(o.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 0), this.content.position.set(0, this.header.y + this.header.height + 10), this.onResizeContent(t)
                }
                onResizeContent(t) {
                    const e = t.width - 2 * o.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT,
                        i = o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.width + 15;
                    let n = Math.floor(e / i);
                    i * (n + 1) - 15 <= e && (n += 1);
                    const r = n,
                        a = Math.ceil(this._buttons.length / r),
                        l = this._buttons.concat();
                    for (let t = 0; t < a; t++) {
                        const e = l.length < r ? l : l.splice(0, r);
                        s.GuiLayout.align(e, 15, s.Align.TOP, s.Direction.HORIZONTAL), s.GuiLayout.offset(e, o.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, (o.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE.height + 15) * t)
                    }
                }
                updateButtons(t) {
                    let e = !0;
                    a.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && (e = null != a.SlotKeypad.autoplay.settings.minBalancePercent);
                    for (let i = 0; i < t.length; i++) {
                        const n = t[i];
                        this._buttons[i] ? (this._buttons[i].value = n.toString(), this._buttons[i].name = "AutoPlayRoundsButton_" + n.toString(), this._buttons[i].label.text = n.toString()) : this.createButton(n), this._buttons[i].enable(e)
                    }
                    const i = this._buttons.splice(t.length);
                    for (let t of i) this._buttonContainer.removeChild(t)
                }
            }
            e.AutoPlayRoundsPage = u
        },
        4632: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AutoPlaySettingsPage = void 0;
            const n = i(1028),
                r = i(1395),
                o = i(1057),
                s = i(7618),
                a = i(9870),
                l = i(9858),
                h = i(9756),
                u = i(8714),
                c = i(3663),
                d = i(8130);
            class p extends r.BasePage {
                constructor(t, e) {
                    super("autoplaySettings", t, e), this._addLimitMustBeSet = !1
                }
                updateDomElement(t) {
                    t ? this._stopWhenExceedInput.addDom() : this._stopWhenExceedInput.removeDom()
                }
                createContent() {
                    const t = super.createContent(),
                        e = u.SlotKeypad.apiPlugIn.translations.translate("Stop when single win exceeds");
                    this._stopWhenExceedWin = this.createStopWhenExceedWin(e), this._stopWhenExceedWin.name = "stopWhenExceedContainer", this._stopWhenBalanceIsLowerButtons = [];
                    const i = u.SlotKeypad.apiPlugIn.translations.translate("Stop before the balance is lower than"),
                        r = u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit ? h.GuiUtils.getColorFromARGB(a.SlotKeypadViewSettings.AUTOPLAY_COLOR) : h.GuiUtils.getColorFromARGB(a.SlotKeypadViewSettings.NORMAL_COLOR),
                        o = this.createStopWhenBalance(i, "StopWhenBalanceIsLower", ["0%", "50%", "75%"], [0, .5, .75], this._stopWhenBalanceIsLowerButtons, r, !0);
                    this._stopWhenBalanceIsLower = o.container, this._calculatedMinBalance = o.calculatedValueLabel, this._stopWhenBalanceIsLower.name = "stopWhenBalanceIsLower", this._stopWhenBalanceIsHigherButtons = [];
                    const s = u.SlotKeypad.apiPlugIn.translations.translate("Stop when the balance is higher than"),
                        l = this.createStopWhenBalance(s, "StopWhenBalanceIsHigher", ["150%", "200%", "500%"], [1.5, 2, 5], this._stopWhenBalanceIsHigherButtons);
                    return this._stopWhenBalanceIsHigher = l.container, this._calculatedMaxBalance = l.calculatedValueLabel, this._stopWhenBalanceIsHigher.name = "stopWhenBalanceIsHigher", t.addChild(this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher), n.GuiLayout.align([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 20, n.Align.LEFT, n.Direction.VERTICAL), t
                }
                onResizeContent(t) {
                    if (super.onResizeContent(t), this._stopWhenBalanceIsLower.width + this._stopWhenBalanceIsHigher.width + 20 + 2 * l.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT < t.width) {
                        n.GuiLayout.align([this._stopWhenExceedWin, this._stopWhenBalanceIsLower], 20, n.Align.LEFT, n.Direction.VERTICAL);
                        const t = this._stopWhenBalanceIsLower.y + 20;
                        n.GuiLayout.align([this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 40, n.Align.TOP, n.Direction.HORIZONTAL), n.GuiLayout.offset([this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 0, t), n.GuiLayout.offset([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], l.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 20)
                    } else n.GuiLayout.align([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], 20, n.Align.LEFT, n.Direction.VERTICAL), n.GuiLayout.offset([this._stopWhenExceedWin, this._stopWhenBalanceIsLower, this._stopWhenBalanceIsHigher], l.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 20)
                }
                createLossLimitMustBeSet(t) {
                    const e = new PIXI.Container;
                    let i = c.GuiDefaults.DEFAULT_LABEL_STYLE.clone();
                    i.fontSize = 16;
                    const r = new o.Label(t, i);
                    return e.addChild(r), n.GuiLayout.align([r], 10, 0, n.Direction.VERTICAL), e
                }
                createStopWhenExceedWin(t) {
                    const e = this._parentView.api.options.hideCurrency ? "" : this._parentView.api.currency.getSymbol(),
                        i = new PIXI.Container,
                        r = new o.Label(t),
                        a = new PIXI.Container,
                        l = new s.TextInput("maxSingleWin", ((t, e) => this._parentView.onInteraction(t, e)), 330, c.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE);
                    l.setDomParent(u.SlotKeypad.apiPlugIn.getGameElement());
                    const h = new o.Label(e, c.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE);
                    return n.GuiLayout.align([l, h], 10, .5), a.addChild(l, h), this._stopWhenExceedInput = l, i.addChild(r, a), n.GuiLayout.align([r, a], 10, 0, n.Direction.VERTICAL), i
                }
                createStopWhenBalance(t, e, i, r, s, d = a.SlotKeypadViewSettings.NORMAL_COLOR, p = !1) {
                    const f = new PIXI.Container;
                    let g = c.GuiDefaults.DEFAULT_LABEL_STYLE.clone();
                    g.fill = h.GuiUtils.getColorFromARGB(d);
                    const m = new o.Label(t, g),
                        _ = this.createButtons(l.KeypadDefault.DEFAULT_SMALL_BUTTON_SIZE, e, i, r, s);
                    g = c.GuiDefaults.DEFAULT_LABEL_STYLE.clone(), g.fill = h.GuiUtils.getColorFromARGB(a.SlotKeypadViewSettings.AUTOPLAY_COLOR);
                    const y = new o.Label("-1 CUR", g);
                    if (u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && p) {
                        const t = u.SlotKeypad.apiPlugIn.translations.translate("Loss limit needs to be set to activate autoplay.");
                        this._lossLimitMustBeSet = this.createLossLimitMustBeSet(t), this._lossLimitMustBeSet.name = "lossLimitMustBeSet"
                    }
                    return n.GuiLayout.align(_.children, 15), n.GuiLayout.align(u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && p ? [m, _, y, this._lossLimitMustBeSet] : [m, _, y], 10, n.Align.LEFT, n.Direction.VERTICAL), f.addChild(m), f.addChild(_), u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && p && (f.addChild(this._lossLimitMustBeSet), n.GuiLayout.modifyMargin(this._lossLimitMustBeSet, -15, n.Direction.VERTICAL, _), this._addLimitMustBeSet = p, this._buttons = _), f.addChild(y), {
                        container: f,
                        calculatedValueLabel: y
                    }
                }
                createButtons(t, e, i, n, r) {
                    const o = new PIXI.Container;
                    let s = a.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
                        l = a.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
                        h = c.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
                    for (let a = 0; a < n.length; a++) {
                        const u = n[a],
                            c = i[a],
                            p = new d.LabelButton(e + "_" + c, c, h, l, s);
                        p.value = u, p.addClickCallback((() => this._parentView.onInteraction(p.name, p.value))), p.setSize(t.width, t.height), p.enable(!0), p.toggled = !1, r.push(p), o.addChild(p)
                    }
                    return o
                }
                updateValues(t) {
                    t.maxSingleWin ? this._stopWhenExceedInput.setElementValue(t.maxSingleWin) : this._stopWhenExceedInput.setElementValue(-1);
                    for (let e of this._stopWhenBalanceIsLowerButtons) e.toggled = e.value == t.minBalancePercent, t.minBalancePercentText ? (this._calculatedMinBalance.text = t.minBalancePercentText, this._calculatedMinBalance.alpha = 1, u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && (this._lossLimitMustBeSet.alpha = 0)) : (this._calculatedMinBalance.text = "-1 CUR", u.SlotKeypad.apiPlugIn.gameClientConfiguration.autoPlaySettings.autoplayRequiresStopLossLimit && (this._lossLimitMustBeSet.alpha = 1), this._calculatedMinBalance.alpha = 0);
                    for (let e of this._stopWhenBalanceIsHigherButtons) e.toggled = e.value == t.maxBalancePercent, t.maxBalancePercentText ? (this._calculatedMaxBalance.text = t.maxBalancePercentText, this._calculatedMaxBalance.alpha = 1) : (this._calculatedMaxBalance.text = "-1 CUR", this._calculatedMaxBalance.alpha = 0)
                }
            }
            e.AutoPlaySettingsPage = p
        },
        1395: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BasePage = void 0;
            const n = i(9858),
                r = i(4514),
                o = i(5518),
                s = i(3158);
            class a extends PIXI.Container {
                constructor(t, e, i = "", n = "", r = 600) {
                    super(), this.name = t, this._parentView = e, this.header = new o.PageHeader(i, n), this.content = this.createContent(), this.content.name = "content", this.addChild(this.header), this.addChild(this.content)
                }
                removeHeader() {
                    s.SlotKeypadUtils.disableElement(this.header)
                }
                onResize(t) {
                    const e = r.NolimitApplication.isLandscape ? n.KeypadDefault.SCREEN_EDGE_MARGIN_TOP_LANDSCAPE : n.KeypadDefault.SCREEN_EDGE_MARGIN_TOP;
                    this.header.position.set(n.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, e), this.header.resize(t.width - 2 * n.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT), this.onResizeContent(t)
                }
                getHeaderBottom() {
                    return this.header.parent != this ? 0 : this.header.y + this.header.height
                }
                activate() { }
                deactivate() { }
                onResizeContent(t) {
                    const e = this.getHeaderBottom();
                    this.content.position.set(0, e + 0)
                }
                createContent() {
                    return new PIXI.Container
                }
            }
            e.BasePage = a
        },
        4550: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetLevelsPage = void 0;
            const n = i(1395),
                r = i(1028),
                o = i(9870),
                s = i(9858),
                a = i(8714),
                l = i(8130),
                h = i(3663);
            class u extends n.BasePage {
                constructor(t, e, i) {
                    super("Betlevels", t, e, i)
                }
                createContent() {
                    const t = super.createContent();
                    return this._buttonContainer = new PIXI.Container, this._buttonContainer.name = "buttons", this._buttons = this.createButtons(this._buttonContainer), t.addChild(this._buttonContainer), t
                }
                createButtons(t) {
                    const e = this._parentView.api.betLevel.getAvailableLevels(),
                        i = this._parentView.api.betLevel.getUnavailableLevels(),
                        n = e.concat(i),
                        s = (this._parentView.api.translations.translate(this._parentView.api.betLevel.getMessage()), []);
                    let u = o.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
                        c = o.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
                        d = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
                    for (let e of n) {
                        const i = a.SlotKeypad.formatCurrencyValueWithDecimalCutoff(e);
                        d.fontSize = 40;
                        const n = new l.LabelButton(e, i, d, c, u);
                        n.addClickCallback((() => this._parentView.onInteraction(n.name, n.value))), n.enable(!0), n.resizeButtonToLabelWithMargin(10, 15, 10, 15), s.push(n), t.addChild(n)
                    }
                    this._largestButtonSize = r.GuiLayout.getLargestSize(s);
                    for (let t of s) t.setSize(this._largestButtonSize.x, this._largestButtonSize.y);
                    return s
                }
                onResize(t) {
                    super.onResize(t);
                    const e = 15;
                    let i = Math.floor(t.width / (this._largestButtonSize.x + e));
                    const n = Math.min(i, s.KeypadDefault.DEFAULT_BET_LEVELS_ROW_MAX),
                        o = Math.ceil(this._buttons.length / n),
                        a = this._buttons.concat();
                    for (let t = 0; t < o; t++) {
                        const i = a.length < n,
                            o = i ? a : a.splice(0, n);
                        if (r.GuiLayout.align(o, e, r.Align.TOP, r.Direction.HORIZONTAL), i) {
                            const i = this._largestButtonSize.x * o.length + e * (o.length - 1),
                                s = .5 * (this._largestButtonSize.x * n + e * (n - 1) - i);
                            r.GuiLayout.offset(o, s, (this._largestButtonSize.y + e) * t)
                        } else r.GuiLayout.offset(o, 0, (this._largestButtonSize.y + e) * t)
                    }
                    this.content.position.x = .5 * (t.width - this.content.width), this.content.position.y += 20
                }
                updateButtons() {
                    const t = this._parentView.api.betLevel.getUnavailableLevels(),
                        e = this._parentView.api.betLevel.getLevel();
                    for (let i of this._buttons) i.toggled = i.name == e, t.indexOf(i.name) >= 0 ? i.enable(!1) : i.enable(!0)
                }
            }
            e.BetLevelsPage = u
        },
        5038: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.DemoPage = void 0;
            const n = i(1395),
                r = i(9870),
                o = i(1028),
                s = i(318),
                a = i(1057),
                l = i(8130),
                h = i(3663);
            class u extends n.BasePage {
                constructor(t, e, i) {
                    super("Demo", t, e, i)
                }
                createContent() {
                    const t = super.createContent();
                    this._buttonContainer = new PIXI.Container, this._buttonContainer.name = "buttons", this._buttons = this.createButtons(this._buttonContainer), this._outcomeQueueContainer = new PIXI.Container;
                    let e = r.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
                        i = r.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
                        n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
                    return this._goButton = new l.LabelButton(s.DemoView.GO_BUTTON, "ADD TO OS", n, i, e), this._goButton.addClickCallback((() => this._parentView.onInteraction(this._goButton.name, void 0))), this._goButton.resizeButtonToLabelWithMargin(20, 30, 20, 30), this._goButton.enable(!1), this._clearOutcomeSetterButton = new l.LabelButton(s.DemoView.CLEAR_OUTCOME_SETTER_BUTTON, "CLEAR OS", n, i, e), this._clearOutcomeSetterButton.addClickCallback((() => this._parentView.onInteraction(this._clearOutcomeSetterButton.name, void 0))), this._clearOutcomeSetterButton.resizeButtonToLabelWithMargin(20, 30, 20, 30), this._clearOutcomeSetterButton.enable(!0), this._mainButtonContainer = new PIXI.Container, this._mainButtonContainer.addChild(this._goButton, this._clearOutcomeSetterButton), o.GuiLayout.align([this._goButton, this._clearOutcomeSetterButton], 10), this._mainButtonContainer.pivot.set(.5 * this._mainButtonContainer.width, 0), n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone(), n.fontSize = 14, this._clearButton = new l.LabelButton(s.DemoView.CLEAR_BUTTON, "CLEAR", n, i, e), this._clearButton.addClickCallback((() => this._parentView.onInteraction(this._clearButton.name, void 0))), this._clearButton.resizeButtonToLabelWithMargin(10, 15, 10, 15), this._clearButton.enable(!0), n = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone(), n.fontSize = 12, this._queueLabel = new a.Label("Queue:"), this._queue = new a.Label("..."), this._queueLabel.position.set(0, 0), this._clearButton.position.set(this._queueLabel.width + 10, .5 * -Math.abs(this._queueLabel.height - this._clearButton.height)), this._queue.position.set(10, this._queueLabel.y + this._queueLabel.height + 10), this._outcomeQueueContainer.addChild(this._queueLabel), this._outcomeQueueContainer.addChild(this._clearButton), this._outcomeQueueContainer.addChild(this._queue), t.addChild(this._buttonContainer), this.addChild(this._outcomeQueueContainer), this.addChild(this._mainButtonContainer), t
                }
                createButtons(t) {
                    const e = [];
                    let i = r.SlotKeypadViewSettings.instance.normalNonEmphasisPointerStateColors.clone(),
                        n = r.SlotKeypadViewSettings.instance.activePointerStateColors.clone(),
                        s = h.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE.clone();
                    s.fontSize = 20;
                    const a = this._parentView.outcomeJson;
                    for (let r = 0; r < a.demo.length; r++) {
                        let o = a.demo[r];
                        const h = new l.LabelButton(o.name, o.name, s, n, i);
                        h.value = r, h.addClickCallback((() => this._parentView.onInteraction(h.name, h.value))), h.resizeButtonToLabelWithMargin(10, 15, 10, 15), h.enable(!0), e.push(h), t.addChild(h)
                    }
                    this._largestButtonSize = o.GuiLayout.getLargestSize(e);
                    for (let t of e) t.setSize(this._largestButtonSize.x, this._largestButtonSize.y);
                    return e
                }
                onResize(t) {
                    super.onResize(t);
                    const e = 15,
                        i = Math.floor(t.width / (this._largestButtonSize.x + e)),
                        n = Math.ceil(this._buttons.length / i),
                        r = this._buttons.concat();
                    for (let t = 0; t < n; t++) {
                        const n = r.length < i,
                            s = n ? r : r.splice(0, i);
                        if (o.GuiLayout.align(s, e, o.Align.TOP, o.Direction.HORIZONTAL), n) {
                            const n = this._largestButtonSize.x * s.length + e * (s.length - 1),
                                r = .5 * (this._largestButtonSize.x * i + e * (i - 1) - n);
                            o.GuiLayout.offset(s, r, (this._largestButtonSize.y + e) * t + 20)
                        } else o.GuiLayout.offset(s, 0, (this._largestButtonSize.y + e) * t + 20)
                    }
                    this.content.position.x = .5 * (t.width - this.content.width), this._outcomeQueueContainer.position.set(10, this.content.y + this.content.height + 50), this._mainButtonContainer.position.set(.5 * t.width, t.height - 40 - this._mainButtonContainer.height)
                }
                updateButtons() {
                    for (let t of this._buttons) t.toggled = !1;
                    this._clearOutcomeSetterButton.toggled = !1, this._goButton.toggled = !1, this._clearButton.toggled = !1
                }
                updateQueue() {
                    let t = "";
                    const e = this._parentView.outcomeQueue;
                    for (let i of e) t += i.name + "\n";
                    this._queue.text = t, this._goButton.enable(e.length > 0)
                }
            }
            e.DemoPage = u
        },
        2540: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameSettingsPage = void 0;
            const n = i(1395),
                r = i(1028),
                o = i(8714),
                s = i(9858),
                a = i(2820),
                l = i(3128),
                h = i(2588),
                u = i(8338);
            class c extends n.BasePage {
                constructor(t, e, i) {
                    super(t, e, i)
                }
                createContent() {
                    const t = new l.GUIScrollContainer(720, 720, !1);
                    this._buttons = [], this._soundSettingsContainer = this.createButtonGroup([{
                        id: a.APISetting.MUSIC,
                        label: "Music"
                    }, {
                        id: a.APISetting.SFX,
                        label: "Sound effects"
                    }]), o.SlotKeypad.apiPlugIn.options.device == u.Device.DESKTOP ? this._generalSettingsContainer = this.createButtonGroup([{
                        id: a.APISetting.CLOCK,
                        label: "Show clock"
                    }, {
                        id: a.APISetting.USE_SPACE_TO_SPIN,
                        label: "Use spacebar to spin"
                    }]) : this._generalSettingsContainer = this.createButtonGroup([{
                        id: a.APISetting.CLOCK,
                        label: "Show clock"
                    }]), this._separator = new PIXI.Graphics;
                    const e = new PIXI.Container;
                    return e.addChild(this._soundSettingsContainer, this._separator, this._generalSettingsContainer), t.addContent(e), t
                }
                drawSeparator(t, e) {
                    this._separator.clear(), this._separator.lineStyle(1, 16777215, .6), e ? (this._separator.moveTo(0, 0), this._separator.lineTo(0, t)) : (this._separator.moveTo(0, 0), this._separator.lineTo(t, 0))
                }
                onResize(t) {
                    super.onResize(t), this.drawSeparator(t.width - 2 * s.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, !1), r.GuiLayout.align([this._soundSettingsContainer, this._separator, this._generalSettingsContainer], 30, r.Align.LEFT, r.Direction.VERTICAL), r.GuiLayout.offset([this._soundSettingsContainer, this._separator, this._generalSettingsContainer], s.KeypadDefault.SCREEN_EDGE_MARGIN_LEFT, 20), this.content.resize(t.width, t.height - this.content.position.y)
                }
                buttonClickCallback(t) {
                    const e = !o.SlotKeypad.apiPlugIn.settings.get(t.name, !1);
                    o.SlotKeypad.apiPlugIn.settings.set(t.name, e), t.toggled = e
                }
                createButtonGroup(t, e = 0) {
                    const i = new PIXI.Container;
                    for (let e of t) {
                        const t = new h.RadioButton(e.id, o.SlotKeypad.apiPlugIn.translations.translate(e.label));
                        t.addClickCallback((() => this.buttonClickCallback(t))), t.enable(!0), t.toggled = o.SlotKeypad.apiPlugIn.settings.get(t.name, !1), i.addChild(t), this._buttons.push(t)
                    }
                    if (this.layoutButtonGroup(i), e > 0) {
                        const t = new PIXI.Graphics;
                        t.beginFill(0, 1), t.drawRect(0, 0, e, 2), i.addChild(t)
                    }
                    return i
                }
                layoutButtonGroup(t) {
                    r.GuiLayout.align(t.children, 50, r.Align.LEFT, r.Direction.VERTICAL), r.GuiLayout.offset(t.children, 10, 0)
                }
                activate() {
                    for (let t of this._buttons) t.toggled = o.SlotKeypad.apiPlugIn.settings.get(t.name, !1), t.name == a.APISetting.CLOCK && (t.enable(o.SlotKeypad.apiPlugIn.gameClientConfiguration.clockSettings.allowSetting), o.SlotKeypad.apiPlugIn.gameClientConfiguration.clockSettings.allowSetting || (this._generalSettingsContainer.removeChild(t), this.layoutButtonGroup(this._generalSettingsContainer)))
                }
            }
            e.GameSettingsPage = c
        },
        2306: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.HistoryPage = void 0;
            const n = i(8714),
                r = i(8565),
                o = i(6331),
                s = i(51),
                a = i(4267),
                l = i(7464);
            class h extends o.HtmlBasePage {
                constructor(t, e, i, n, r) {
                    super(t, e, i, n, r)
                }
                load() {
                    const t = new a.TemplateLoader(n.SlotKeypad.apiPlugIn.resources.getStaticRoot());
                    return t.add({
                        name: s.MenuButtonIDs.HISTORY,
                        url: "node_modules/@nolimit/slot-keypad/resources/default/templates/history.mustache"
                    }), t.load().then((t => this.addLoadedScreenTemplates(t))).then((() => this.init()))
                }
                activate() {
                    super.activate(), this.update(), this.screen.show()
                }
                deactivate() {
                    this.screen.hide(), this.calendarController.resetView(), super.deactivate()
                }
                init() {
                    super.init(), r.Settings.defaultLocale = n.SlotKeypad.apiPlugIn.options.language, this.calendarController = new l.CalendarController(this.screen)
                }
                static makeElement(t, e) {
                    const i = document.createElement(t);
                    return e && (i.innerHTML = e), i
                }
                static scrollTo(t, e, i) {
                    if (i <= 0) return;
                    const n = (e - t.scrollTop) / i * 10;
                    setTimeout((function () {
                        t.scrollTop = t.scrollTop + n, t.scrollTop !== e && h.scrollTo(t, e, i - 10)
                    }), 10)
                }
                onResize(t) {
                    this.calendarController.resize(t), super.onResize(t)
                }
                update() {
                    this.calendarController.update()
                }
            }
            e.HistoryPage = h
        },
        6331: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.HtmlBasePage = void 0;
            const n = i(4781),
                r = i(1395),
                o = i(4514),
                s = i(8714);
            class a extends r.BasePage {
                get screen() {
                    if (null != this._screen) return this._screen;
                    const t = this._screenSystem.get(this.name);
                    if (null == t) throw new Error(`Missing screen: ${this.name}`);
                    return this._screen = t, this._screen
                }
                constructor(t, e, i, n, r) {
                    super(i, n, r), this._active = !1, this._parentDiv = t, this._screenSystem = e
                }
                activate() {
                    this._active = !0, this._parentDiv.style.display = "block", this.resizeHtml(this._htmlBounds)
                }
                deactivate() {
                    this._active = !1, this._parentDiv.style.display = "none"
                }
                onResize(t) {
                    super.onResize(t), this._htmlBounds = (0, n.cloneScreenBounds)(t), this._htmlBounds.height -= this.content.y, this._htmlBounds.top = this.content.y, this.resizeHtml(this._htmlBounds)
                }
                resizeHtml(t) {
                    this._active && (this._screen && (this.screen.element.style.fontSize = 20 * o.NolimitApplication.globalScale + "px"), this._parentDiv.style.width = t.width * o.NolimitApplication.globalScale + "px", this._parentDiv.style.height = t.height * o.NolimitApplication.globalScale + "px", this._parentDiv.style.top = t.top * o.NolimitApplication.globalScale + "px")
                }
                init() { }
                load() {
                    return Promise.resolve()
                }
                addLoadedScreenTemplates(t) {
                    const e = [];
                    for (let i of t)
                        if (i.loadedData) {
                            let t = s.SlotKeypad.apiPlugIn.translations.render(i.loadedData);
                            t = t.replace(/<html /i, `<html data-device="${s.SlotKeypad.apiPlugIn.options.device}" data-agent="${navigator.userAgent}" `), e.push(this._screenSystem.add(i.name, t).then((t => t.classList.add("screen"))))
                        } return Promise.all(e)
                }
            }
            e.HtmlBasePage = a
        },
        5225: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.InfoPage = e.SettingSectionIDs = void 0;
            const n = i(6331),
                r = i(8714),
                o = i(57),
                s = i(8836),
                a = i(502),
                l = i(4267),
                h = i(2757),
                u = i(51);
            var c;
            ! function (t) {
                t.GUIDE = "guide", t.RULES = "rules", t.PAYTABLE = "paytable"
            }(c = e.SettingSectionIDs || (e.SettingSectionIDs = {}));
            class d extends n.HtmlBasePage {
                constructor(t, e, i, n, r) {
                    super(t, e, i, n, r), this.removeHeader()
                }
                goToSection(t) {
                    let e;
                    switch (t) {
                        case c.GUIDE:
                            e = this.screen.find(".gui-guide")[0];
                            break;
                        case c.RULES:
                            e = this.screen.find(".rules")[0];
                            break;
                        case c.PAYTABLE:
                            e = this.screen.find(".paytable")[0]
                    }
                    e.scrollIntoView()
                }
                activate() {
                    super.activate(), r.SlotKeypad.apiPlugIn.payoutMultiplier.updateScreen(this.screen), r.SlotKeypad.apiPlugIn.gameClientConfiguration.updateScreen(this.screen), r.SlotKeypad.apiPlugIn.maximumWinCap.updateScreen(this.screen), r.SlotKeypad.apiPlugIn.rtp.updateScreen(this.screen), r.SlotKeypad.apiPlugIn.gameInfo.updateScreen(this.screen), this.updatePromoPanel(), this.updateGamble(), this.updateBoost(), this.screen.show()
                }
                deactivate() {
                    super.deactivate(), this.screen.hide()
                }
                load() {
                    const t = new l.TemplateLoader(r.SlotKeypad.apiPlugIn.resources.getStaticRoot());
                    return t.add({
                        name: u.MenuButtonIDs.INFO,
                        url: "node_modules/@nolimit/slot-keypad/resources/default/templates/game-info.mustache"
                    }), t.load().then((t => this.addLoadedScreenTemplates(t))).then((() => this.assembleInfoPage()))
                }
                assembleInfoPage() {
                    const t = [],
                        e = this.prepareDataForHTMLInfo();
                    for (let i of a.NolimitLauncher.plugins) null != i.getGameRules && ((0, o.isGamePlugin)(i) ? t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e, "game")))) : (0, s.isGamblePlugin)(i) ? t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e, "gamble")))) : t.push(i.getGameRules().then((t => this.addHtmlToInfoSection(t, "rules", e))))), i.getKeypadGuide && (e.skin = r.SlotKeypad.skinLoader.getSkinData(), t.push(i.getKeypadGuide().then((t => this.addHtmlToInfoSection(t, "gui-guide", e))))), (0, o.isGamePlugin)(i) && t.push(i.getPaytable().then((t => this.addHtmlToInfoSection(t, "paytable", e))));
                    return Promise.all(t)
                }
                updateBoost() {
                    const t = r.SlotKeypad.apiPlugIn.bonusFeatures;
                    t.hasAnyType(t.allTypesByCategory[h.GameFeatureCategory.BOOSTED_BET]) || this.screen.find(".boostedBet").forEach((t => t.style.display = "none"))
                }
                updateGamble() {
                    for (let t of a.NolimitLauncher.plugins)
                        if ((0, s.isGamblePlugin)(t)) return;
                    this.screen.find(".gamble").forEach((t => t.style.display = "none"))
                }
                updatePromoPanel() {
                    if (r.SlotKeypad.promoPlugin && r.SlotKeypad.promoPlugin.hasPromotions()) {
                        const t = this.screen.find("tr.noLimitBonus")[0];
                        if (null == t) return;
                        const e = r.SlotKeypad.apiPlugIn.bonusFeatures.allTypesByCategory[h.GameFeatureCategory.BONUS_BUY],
                            i = r.SlotKeypad.apiPlugIn.bonusFeatures.getFeatureDataByTypes(e);
                        for (let e of i) {
                            const i = t.querySelector("th #" + e.name);
                            null != i && (i.innerHTML = r.SlotKeypad.apiPlugIn.translations.render('<p id="{{name}}">{{#tr}}Bonus can be bought for {{price}} times bet, maximum possible bet is {{maxBet}}.{{/tr}}</p>', {
                                name: e.name,
                                maxBet: r.SlotKeypad.apiPlugIn.currency.format(e.getMaxBet()),
                                price: e.price
                            }))
                        }
                    } else this.screen.find("tr.promoPanel").forEach((t => t.style.display = "none"))
                }
                addHtmlToInfoSection(t, e, i, n = void 0) {
                    return new Promise(((o, s) => {
                        const a = this.screen.find("#" + e)[0];
                        if (a)
                            if (null != n) {
                                const e = this.screen.find("#" + n)[0];
                                e && (e.innerHTML = r.SlotKeypad.apiPlugIn.translations.render(t, i))
                            } else {
                                let e = document.createElement("div");
                                a.append(e), e.innerHTML = r.SlotKeypad.apiPlugIn.translations.render(t, i)
                            } o()
                    }))
                }
                prepareDataForHTMLInfo() {
                    const t = r.SlotKeypad.apiPlugIn.gameClientConfiguration,
                        e = t.showMinBet,
                        i = t.showMaxBet,
                        n = r.SlotKeypad.apiPlugIn.betLevel.getAvailableLevels(),
                        o = r.SlotKeypad.apiPlugIn.betLevel.getUnavailableLevels(),
                        s = !!(r.SlotKeypad.apiPlugIn.options && r.SlotKeypad.apiPlugIn.options.game && r.SlotKeypad.apiPlugIn.options.game.indexOf("DX1") > -1);
                    let a = "",
                        l = "",
                        h = 0;
                    return e && (a = n.length > 0 ? r.SlotKeypad.apiPlugIn.currency.format(+n[0]) : r.SlotKeypad.apiPlugIn.currency.format(+o[0])), i && (h = o.length > 0 ? +o[o.length - 1] : +n[n.length - 1], r.SlotKeypad.apiPlugIn.bonusFeatures.availableNames.size && r.SlotKeypad.apiPlugIn.bonusFeatures.availableNames.forEach((t => {
                        const e = r.SlotKeypad.apiPlugIn.bonusFeatures.getFeatureDataByName(t);
                        if (e) {
                            const t = e.price * e.getMaxBet();
                            h = Math.max(h, t)
                        }
                    })), l = r.SlotKeypad.apiPlugIn.currency.format(h)), {
                        dx1: s,
                        fastSpinEnabled: t.fastSpinEnabled,
                        replaceSlotsInGameRules: t.replaceSlotsInGameRules,
                        showGameVersionInGuiGuide: t.showGameVersionInGuiGuide,
                        gameVersion: t.gameVersion,
                        showGameClientBuiltDate: t.showGameClientBuiltDate,
                        gameVersionDate: t.gameVersionDate,
                        showMinBet: e,
                        minBet: a,
                        showMaxBet: i,
                        maxBet: l,
                        showServerVersion: t.showServerVersion,
                        serverVersion: t.serverVersion,
                        showNearMissGfx: t.showNearMissGfx,
                        showBaseGameHighestWinInRules: t.showBaseGameHighestWinInRules,
                        replaceWincapInfo: t.replaceWincapInfo,
                        showOnlyMaxRTPForRange: t.showOnlyMaxRTPForRange
                    }
                }
            }
            e.InfoPage = d
        },
        7464: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.CalendarController = e.GameHistorySortType = e.GameHistorySortHeader = void 0;
            const n = i(8565),
                r = i(8714),
                o = i(2306),
                s = i(4514);
            var a, l;
            ! function (t) {
                t.TIME = "TIME", t.BET = "BET", t.WIN = "WIN"
            }(a = e.GameHistorySortHeader || (e.GameHistorySortHeader = {})),
                function (t) {
                    t.ASC = "ASC", t.DESC = "DESC"
                }(l = e.GameHistorySortType || (e.GameHistorySortType = {})), e.CalendarController = class {
                    constructor(t) {
                        this.onDaySelectNew = t => {
                            const e = t.target,
                                i = this.menuDiv.querySelector(".history");
                            o.HistoryPage.scrollTo(i, 0, 50), setTimeout((() => {
                                this.backToSearchBtn.classList.add("animate"), this.calendarContainer.classList.add("animate"), this.resultContainer.classList.add("animate")
                            }), 100);
                            const n = e.dataset.date;
                            this.clearResult(), this.currentSort = {
                                date: n,
                                head: a.TIME,
                                type: l.DESC,
                                page: 1
                            }, this.loadPage(this.currentSort)
                        }, this.screen = t, this.selectedMonth = n.DateTime.local(), this.menuDiv = this.screen.find("#gameHistoryContainer")[0], this.calendarContainer = this.menuDiv.querySelector(".calendar-container"), this.calendarTimeContainer = this.menuDiv.querySelector(".calendar-time-container"), this.calendarTimeContainer.style.display = "none", this.calendarTime = this.calendarTimeContainer.querySelector(".calendar-time"), this.monthHeader = this.calendarContainer.querySelector(".month .header"), this.calendarDays = this.calendarContainer.querySelector(".days"), this.prevMonthBtn = this.calendarContainer.querySelector(".month .prev"), this.nextMonthBtn = this.calendarContainer.querySelector(".month .next"), this.prevMonthBtn.addEventListener("click", (t => this.changeMonth(t))), this.nextMonthBtn.addEventListener("click", (t => this.changeMonth(t))), this.loadingCalendarIcon = this.calendarContainer.querySelector(".loading"), this.backToSearchBtn = this.menuDiv.querySelector(".back-to-search-btn"), this.resultContainer = this.menuDiv.querySelector(".result-container"), this.resultInfo = this.resultContainer.querySelector(".result-info"), this.resultInfoDate = this.resultInfo.querySelector(".date"), this.resultDiv = this.resultContainer.querySelector(".result"), this.resultHead = this.resultContainer.querySelector(".result table thead"), this.resultBody = this.resultContainer.querySelector(".result table tbody"), this.sortTimeBtn = this.resultContainer.querySelector(".result table thead .sort .sortTime"), this.sortTimeBtn.addEventListener("click", (() => {
                            this.onSort(a.TIME)
                        })), this.sortWinBtn = this.resultContainer.querySelector(".result table thead .sort .sortWin"), this.sortWinBtn.addEventListener("click", (() => {
                            this.onSort(a.WIN)
                        })), this.amounts = this.resultInfo.querySelectorAll("tr.amount th"), this.loadMoreBtn = this.resultContainer.querySelector(".result .loadMore"), this.loadMoreBtn.addEventListener("click", (() => {
                            this.currentSort.page += 1, this.loadPage(this.currentSort)
                        })), this.loadingIcon = this.resultContainer.querySelector(".result .loading"), this.backToSearchBtn = this.screen.find(".back-to-search-btn")[0], this.backToSearchBtn.addEventListener("click", (() => {
                            this.resetView()
                        }))
                    }
                    goBackToCalendarView() {
                        this.backToSearchBtn.classList.remove("animate"), this.calendarContainer.classList.remove("animate"), this.resultContainer.classList.remove("animate"), this.clearResult()
                    }
                    resetView() {
                        const t = this.screen.find(".history")[0];
                        o.HistoryPage.scrollTo(t, 0, 50), setTimeout((() => {
                            this.goBackToCalendarView()
                        }), 100)
                    }
                    onSort(t) {
                        t != this.currentSort.head && (this.clearResult(), this.currentSort.head = t, this.currentSort.page = 1, this.loadPage(this.currentSort))
                    }
                    changeMonth(t) {
                        const e = t.target;
                        e.classList.contains("disabled") || (e.classList.contains("prev") ? this.selectedMonth = this.selectedMonth.minus({
                            month: 1
                        }) : e.classList.contains("next") && (this.selectedMonth = this.selectedMonth.plus({
                            month: 1
                        })), this.update())
                    }
                    update(t = this.selectedMonth) {
                        this.monthHeader.textContent = t.toLocaleString({
                            month: "long",
                            year: "numeric"
                        }).toUpperCase(), this.prevMonthBtn.classList.add("disabled"), this.nextMonthBtn.classList.add("disabled");
                        const e = n.DateTime.local(),
                            i = e.minus({
                                year: 1
                            });
                        this.calendarDays.innerHTML = "", this.loadingCalendarIcon.style.display = "inline-block", r.SlotKeypad.apiPlugIn.communication.history.daysNoHour(t.year, t.month).then((n => {
                            this.generateCalendarDays(t, n), this.loadingCalendarIcon.style.display = "none", i.hasSame(t, "year") && i.hasSame(t, "month") ? this.prevMonthBtn.classList.add("disabled") : this.prevMonthBtn.classList.remove("disabled"), e.hasSame(t, "year") && e.hasSame(t, "month") ? this.nextMonthBtn.classList.add("disabled") : this.nextMonthBtn.classList.remove("disabled")
                        })).catch(console.error)
                    }
                    generateCalendarDays(t, e) {
                        const i = n.DateTime.local(),
                            r = t.startOf("month");
                        for (let t = 2 - r.weekday; t <= r.daysInMonth; t++) {
                            const n = document.createElement("li");
                            if (t > 0) {
                                n.textContent = t.toString();
                                const o = r.plus({
                                    days: t - 1
                                }),
                                    s = o.toISODate();
                                e[s] && (n.classList.add("played"), n.addEventListener("click", this.onDaySelectNew), n.dataset.date = s, n.dataset.hours = e[s].join(",")), i.hasSame(o, "day") && n.classList.add("today")
                            }
                            this.calendarDays.appendChild(n)
                        }
                    }
                    clearResult() {
                        this.totalBet = 0, this.totalWin = 0, this.resultBody.innerHTML = ""
                    }
                    loadPage(t) {
                        this.loadingIcon.style.display = "inline-block", this.loadMoreBtn.style.display = "none", t.head == a.TIME ? (this.sortTimeBtn.querySelector(".down").style.display = "inline", this.sortTimeBtn.querySelector(".right").style.display = "none", this.sortWinBtn.querySelector(".down").style.display = "none", this.sortWinBtn.querySelector(".right").style.display = "inline") : (this.sortTimeBtn.querySelector(".down").style.display = "none", this.sortTimeBtn.querySelector(".right").style.display = "inline", this.sortWinBtn.querySelector(".down").style.display = "inline", this.sortWinBtn.querySelector(".right").style.display = "none"), r.SlotKeypad.apiPlugIn.communication.history.roundsPaginated(t.date, t.head, t.type, t.page).then((e => {
                            this.addRoundsToResult(t, e), e.length < 100 ? this.loadMoreBtn.style.display = "none" : this.loadMoreBtn.style.display = "inline-block", this.loadingIcon.style.display = "none"
                        })).catch(console.error)
                    }
                    addRoundsToResult(t, e) {
                        for (let t of e) this.resultBody.appendChild(this.generateRoundTableRow(t));
                        const i = 100 * t.page - 100 + e.length;
                        this.resultInfoDate.textContent = `${t.date} (${r.SlotKeypad.apiPlugIn.translations.translate("Round")} 1-${i})`;
                        const n = this.totalWin - this.totalBet;
                        this.amounts[0].textContent = s.NolimitApplication.apiPlugin.currency.formatValue(this.totalBet), this.amounts[1].textContent = s.NolimitApplication.apiPlugin.currency.formatValue(this.totalWin), this.amounts[2].textContent = s.NolimitApplication.apiPlugin.currency.formatValue(n)
                    }
                    generateRoundTableRow(t) {
                        this.totalBet += t.totalBet, this.totalWin += t.totalWin;
                        const e = o.HistoryPage.makeElement("tr");
                        let i = s.NolimitApplication.apiPlugin.currency.formatValue(t.totalBet);
                        t.promoName && (e.classList.add("freebets"), i = `0.00 (${s.NolimitApplication.apiPlugin.currency.formatValue(t.totalFreeBet || 0)})`);
                        const n = t.startTime.split(" ")[1],
                            a = o.HistoryPage.makeElement("td", n);
                        if (t.actionSpin) {
                            const t = r.SlotKeypad.apiPlugIn.resources.getStaticRoot() + "/node_modules/@nolimit/slot-keypad/resources/default/templates/actionSpinsIcon.svg",
                                e = document.createElement("img");
                            e.src = t, e.style.marginLeft = "0.5em", e.style.height = "1em", a.append(e)
                        }
                        if ("FEATURE_BET" == t.requestType && "BOOSTED_BET" !== t.requestInformation) {
                            const t = r.SlotKeypad.apiPlugIn.resources.getStaticRoot() + "/node_modules/@nolimit/slot-keypad/resources/default/templates/nolimitBonusIcon.svg",
                                e = document.createElement("img");
                            e.src = t, e.style.marginLeft = "0.5em", e.style.height = "1em", a.append(e)
                        }
                        e.appendChild(a), e.appendChild(o.HistoryPage.makeElement("td", i)), e.appendChild(o.HistoryPage.makeElement("td", s.NolimitApplication.apiPlugin.currency.formatValue(t.totalWin)));
                        const l = 0 == t.balanceAfter ? "-" : s.NolimitApplication.apiPlugin.currency.formatValue(t.balanceAfter);
                        e.appendChild(o.HistoryPage.makeElement("td", l));
                        const h = document.createElement("td");
                        return h.classList.add("right"), h.classList.add("replay"), h.innerHTML = '<a target="_blank"></a>', h.querySelector("a").addEventListener("click", (e => {
                            r.SlotKeypad.apiPlugIn.openReplay(t.gameRoundId), e.preventDefault()
                        })), e.appendChild(h), e
                    }
                    resize(t) { }
                }
        },
        1309: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.HtmlTopLabel = void 0, e.HtmlTopLabel = class {
                get element() {
                    return this._element
                }
                constructor(t, e = !1) {
                    if (e) this._element = document.createElement("div"), this._element.innerText = "", this._element.id = t;
                    else {
                        const e = document.querySelector(t);
                        this._element = null != e ? e : new HTMLElement
                    }
                    this._element.classList.add("top-bar-item")
                }
                update(t) {
                    this._element.innerText = t
                }
                show() {
                    this._element.style.display = "block"
                }
                hide() {
                    this._element.style.display = "none"
                }
            }
        },
        4514: function (t, e, i) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function (t, e, i, n) {
                void 0 === n && (n = i);
                var r = Object.getOwnPropertyDescriptor(e, i);
                r && !("get" in r ? !e.__esModule : r.writable || r.configurable) || (r = {
                    enumerable: !0,
                    get: function () {
                        return e[i]
                    }
                }), Object.defineProperty(t, n, r)
            } : function (t, e, i, n) {
                void 0 === n && (n = i), t[n] = e[i]
            }),
                r = this && this.__setModuleDefault || (Object.create ? function (t, e) {
                    Object.defineProperty(t, "default", {
                        enumerable: !0,
                        value: e
                    })
                } : function (t, e) {
                    t.default = e
                }),
                o = this && this.__importStar || function (t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
                    return r(e, t), e
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitApplication = void 0;
            const s = i(5698);
            Promise.resolve().then((() => o(i(3832))));
            const a = o(i(3832)),
                l = i(7148),
                h = i(7185),
                u = i(8338),
                c = i(5654),
                d = i(502),
                p = i(1740),
                f = i(8943),
                g = i(8680),
                m = i(2817),
                _ = i(6358),
                y = i(9949);
            class S {
                static get hasOpenDialog() {
                    return S._instance._hasOpenDialog
                }
                static get resourcePath() {
                    let t = "";
                    const e = document.getElementsByTagName("script");
                    for (let i = 0; i < e.length; i++) {
                        const n = e[i].src;
                        if (/\/game\.js$/.test(n)) {
                            t = n.substr(0, n.length - 8);
                            break
                        }
                    }
                    return t
                }
                static get pixiLoader() {
                    return S._instance._pixiApp.loader
                }
                static get pixiApp() {
                    return S._instance._pixiApp
                }
                static get globalScale() {
                    return S._instance._globalScale
                }
                get frame() {
                    return {
                        width: 720,
                        height: 720
                    }
                }
                get stage() {
                    return this._internalStage
                }
                constructor() {
                    this.name = "NolimitApplication", this._paused = !1, this._globalScale = 1, this.placement = {
                        x: .5,
                        y: .5
                    }, this._layers = {}, this.onWebGLContextLost = t => {
                        g.Logger.logDev(t.type, t), S.apiPlugin.events.trigger("error", {
                            code: -1005,
                            message: "Graphics init failed"
                        })
                    }, this.animate = () => {
                        this._pixiApp.render()
                    }
                }
                fetchPlugins() {
                    for (let t of d.NolimitLauncher.plugins) (0, p.isApiPlugin)(t) && (S.apiPlugin = t);
                    return null == S.apiPlugin ? Promise.reject(new Error("NolimitApplication is missing  ApiPlugin")) : Promise.resolve()
                }
                init() {
                    return new Promise(((t, e) => {
                        this.fetchPlugins().catch((t => Promise.reject(t))), this.addEventListeners(), S.events = y.create(), this._gameElement = S.apiPlugin.getGameElement(), this.nolimitContainer = document.querySelector(".nolimit.container");
                        let i = S.apiPlugin.isReplay ? d.NolimitLauncher.instance.settings.maxResolutionReplay : d.NolimitLauncher.instance.settings.maxResolution;
                        i = Math.min(i, 2), S.resolution = Math.min(Math.max(window.devicePixelRatio, 1), i);
                        try {
                            this._pixiApp = new a.Application({
                                autoStart: !1,
                                width: 1280,
                                height: 720,
                                autoDensity: !1,
                                antialias: !1,
                                resolution: S.resolution,
                                sharedTicker: !1,
                                backgroundColor: 0
                            })
                        } catch (t) {
                            S.apiPlugin.error.trigger(S.apiPlugin.translations.translate("Your device or browser doesnt support WebGL. Please check that WebGL is supported and activated."))
                        }
                        this._internalStage = new a.Container, this._internalStage.name = "Stage", this._pixiApp.stage.addChild(this._internalStage), this._dialogLayer = new a.Container, this._dialogLayer.name = "Dialog", this._pixiApp.stage.addChild(this._dialogLayer), this._keypadLayer = new a.Container, this._keypadLayer.name = "Keypad", this._pixiApp.stage.addChild(this._keypadLayer), this._gameElement.appendChild(this._pixiApp.renderer.view), this._pixiApp.renderer.view.addEventListener("webglcontextlost", this.onWebGLContextLost, !1), S.svgLoader = new c.SvgLoader(S.resourcePath, S.resolution), S._instance = this, this._freezeBlur = new l.PerformanceFreezeBlur(this._internalStage), t(this)
                    }))
                }
                destroyRenderer() {
                    s.GSAPCompatabilityWrapper.pauseGlobalTimeline(), this._pixiApp.renderer.view.parentNode.removeChild(this._pixiApp.renderer.view), S.pixiApp.renderer.destroy()
                }
                reInitRenderer() {
                    S.resolution = Math.min(Math.max(window.devicePixelRatio, 1), 2);
                    try {
                        this._pixiApp = new a.Application({
                            autoStart: !1,
                            width: 1280,
                            height: 720,
                            autoDensity: !1,
                            antialias: !1,
                            resolution: S.resolution,
                            sharedTicker: !1,
                            backgroundColor: 0
                        })
                    } catch (t) {
                        S.apiPlugin.error.trigger(S.apiPlugin.translations.translate("Your device or browser doesnt support WebGL. Please check that WebGL is supported and activated."))
                    }
                    s.GSAPCompatabilityWrapper.resumeGlobalTimeline(), S.apiPlugin.events.trigger(h.APIEvent.RE_INIT_RENDERER_DONE), this._pixiApp.stage.addChild(this._internalStage), this._pixiApp.stage.addChild(this._dialogLayer), this._pixiApp.stage.addChild(this._keypadLayer), this._gameElement.appendChild(this._pixiApp.renderer.view), this._pixiApp.renderer.view.addEventListener("webglcontextlost", this.onWebGLContextLost, !1), this.resize(), m.ViewPort.triggerResize()
                }
                getReady() {
                    return new Promise(((t, e) => {
                        this.resize(), s.GSAPCompatabilityWrapper.initTicker(this.animate), t(this)
                    }))
                }
                getReadyToStart() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                start() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                destroy() {
                    m.ViewPort.shutDown(), s.GSAPCompatabilityWrapper.removeTicker(this.animate), this._pixiApp.destroy(!0, {
                        children: !0,
                        texture: !0,
                        baseTexture: !0
                    }), console.log("NolimitApp destroy")
                }
                addEventListeners() {
                    S.apiPlugin.events.on(h.APIEvent.CONFIG, (t => {
                        const e = t.size.width / t.size.height;
                        S.apiPlugin.options.device == u.Device.DESKTOP && m.ViewPort.confineToRatio(this.nolimitContainer, e), m.ViewPort.onResize(((e, i) => {
                            const n = Math.min(e / this.frame.width, i / this.frame.height);
                            this._globalScale = n, null != this.nolimitContainer && (this.nolimitContainer.style.fontSize = 10 * n + "px");
                            let r = t.size.width,
                                o = t.size.height;
                            if (e >= t.size.width && i >= t.size.height) {
                                const t = e >= i;
                                if (r = o * (Math.max(e, i) / Math.min(e, i)), !t) {
                                    const t = r;
                                    r = o, o = t
                                }
                            } else r = e, o = i;
                            this._pixiApp.renderer.resize(r, o), this._pixiApp.view.style.width = e + "px", this._pixiApp.view.style.height = i + "px", this.resize()
                        })), m.ViewPort.triggerResize()
                    })), S.apiPlugin.events.on(h.APIEvent.HALT, (() => {
                        m.ViewPort.shutDown();
                        const t = this.addBlur();
                        t.add((() => {
                            s.GSAPCompatabilityWrapper.removeTicker(this.animate)
                        })), t.add((() => {
                            this._pixiApp.destroy()
                        }), 1)
                    })), S.apiPlugin.events.on(h.APIEvent.PAUSE, (() => this.onPause(!0))), S.apiPlugin.events.on(h.APIEvent.RESUME, (() => this.onPause(!1))), S.apiPlugin.events.on(h.APIEvent.DESTROY_RENDERER, (() => this.destroyRenderer())), S.apiPlugin.events.on(h.APIEvent.RE_INIT_RENDERER, (() => this.reInitRenderer())), S.apiPlugin.events.on(h.APIEvent.DIALOG, (t => this.onApiDialog(t))), S.apiPlugin.events.on(h.APIEvent.FREEZE, (t => this.onFreeze(t))), S.apiPlugin.events.on(h.APIEvent.UNFREEZE, (() => this.onUnFreeze()))
                }
                onFreeze(t = !1) {
                    this.addBlur(!0), t && s.GSAPCompatabilityWrapper.pauseGlobalTimeline()
                }
                onUnFreeze() {
                    this.removeBlur(), s.GSAPCompatabilityWrapper.isGlobalTimelinePaused() && s.GSAPCompatabilityWrapper.resumeGlobalTimeline()
                }
                onApiDialog(t) {
                    "open" == t ? this.addBlur(!0) : this.removeBlur()
                }
                addBlur(t = !1) {
                    return S._instance._freezeBlur.freeze(.22, t)
                }
                removeBlur() {
                    return S._instance._freezeBlur.unfreeze(.22)
                }
                onPause(t) {
                    this._pauseTl && this._pauseTl.isActive() && this._pauseTl.progress(1), this._pauseTl = new _.TimelineLite, t && !this._paused ? (this._paused = !0, this._hasOpenDialog || this._pauseTl.add(S._instance._freezeBlur.freeze()), this._pauseTl.add((() => {
                        s.GSAPCompatabilityWrapper.pauseGlobalTimeline()
                    }), "+=0.5")) : !t && this._paused && (this._paused = !1, s.GSAPCompatabilityWrapper.resumeGlobalTimeline(), this._hasOpenDialog || this._pauseTl.add(S._instance._freezeBlur.unfreeze()))
                }
                orientationChanged() {
                    for (let t in this._layers) {
                        const e = this._layers[t];
                        null != e.onOrientationChanged && e.onOrientationChanged()
                    }
                }
                resizeLayers() {
                    for (let t in this._layers) {
                        const e = this._layers[t];
                        null != e.onResize && e.onResize()
                    }
                }
                static resize() {
                    S._instance.resize()
                }
                resize() {
                    const t = this._pixiApp.renderer.screen.width,
                        e = this._pixiApp.renderer.screen.height,
                        i = this.setOrientation(t >= e);
                    let n = Math.min(t / this.frame.width, e / this.frame.height),
                        r = (e - this.frame.height * n) * this.placement.y,
                        o = (t - this.frame.width * n) * this.placement.x;
                    S.screenBounds = {
                        top: Math.round(-r / n),
                        left: Math.round(-o / n),
                        right: Math.round(o / n) + this.frame.width,
                        bottom: Math.round(r / n) + this.frame.height,
                        center: .5 * this.frame.width,
                        width: Math.round(t / n),
                        height: Math.round(e / n),
                        scale: n
                    }, this._pixiApp.stage.scale.set(n, n), this._pixiApp.stage.position.set(Math.round(o), Math.round(r)), i && this.orientationChanged(), this.resizeLayers(), null != this._currentDialog && this._currentDialog.onResize && this._currentDialog.onResize(), this._freezeBlur.onResize(), i && this._freezeBlur.onOrientationChanged(), S.events.trigger(S.RESIZE)
                }
                setOrientation(t) {
                    return S.isLandscape != t && (S.isLandscape = t, !0)
                }
                static addLayerAt(t, e, i = 0) {
                    S._instance._layers[t] = e, e.name = t, S._instance.stage.addChildAt(e, i), "Keypad" == t && S._instance._keypadLayer.addChildAt(e, i)
                }
                static addLayer(t, e) {
                    S._instance._layers[t] = e, e.name = t, S._instance.stage.addChild(e), "Keypad" == t && S._instance._keypadLayer.addChild(e)
                }
                static removeLayer(t) {
                    if (S._instance._layers[t]) {
                        const e = S._instance.stage.removeChild(S._instance._layers[t]);
                        return "Keypad" == t && S._instance._keypadLayer.removeChild(S._instance._layers[t]), delete S._instance._layers[t], e
                    }
                }
                static getLayerByName(t) {
                    return S._instance._layers[t]
                }
                static addDialog(t, e = !1) {
                    S.apiPlugin.dialog.lock("PIXIDialog"), S._instance._currentDialog != t ? S.apiPlugin.slotStates.checkState(f.SlotState.READY) ? null == S._instance._currentDialog ? (S.apiPlugin.events.trigger(h.APIEvent.SCREEN, "open"), e && S._instance._freezeBlur.freeze(), S._instance._currentDialog = t, S.events.trigger(S.DIALOG_OPENED), S._instance._dialogLayer.addChild(t), S._instance._hasOpenDialog = !0) : g.Logger.warn("Dialog error: There is already a screen") : g.Logger.warn("Dialog error: game state is not READY") : g.Logger.warn("Dialog: Doubel trigger dialog. May be due to performance slowdown.")
                }
                static removeDialog(t, e = !0) {
                    t != S._instance._currentDialog && S.apiPlugin.error.trigger("Dialog error: trying to remove dialog that is not current dialog");
                    const i = new _.TimelineLite({
                        onStart: () => {
                            S.events.trigger(S.DIALOG_CLOSING)
                        },
                        onComplete: () => {
                            S._instance._hasOpenDialog = !1, S.apiPlugin.dialog.unlock("PIXIDialog"), S.apiPlugin.events.trigger(h.APIEvent.SCREEN, "close"), S.events.trigger(S.DIALOG_CLOSED)
                        }
                    });
                    i.add((() => {
                        S._instance._currentDialog = null, S._instance._dialogLayer.removeChild(t)
                    })), S._instance._freezeBlur.isFrozen && e && i.add(S._instance._freezeBlur.unfreeze(), 0)
                }
                static minimizeDialog(t) {
                    t != S._instance._currentDialog && S.apiPlugin.error.trigger("Dialog error: trying to remove dialog that is not current dialog");
                    const e = new _.TimelineLite({
                        onStart: () => {
                            S.events.trigger(S.DIALOG_MINIMIZING)
                        },
                        onComplete: () => {
                            S._instance._hasOpenDialog = !1, S.apiPlugin.dialog.unlock("PIXIDialog")
                        }
                    });
                    e.add((() => {
                        S._instance._currentDialog = null, S._instance._dialogLayer.removeChild(t)
                    })), S._instance._freezeBlur.isFrozen && e.add(S._instance._freezeBlur.unfreeze(), 0)
                }
            }
            S.DIALOG_OPENED = "dialogOpened", S.DIALOG_CLOSED = "dialogClosed", S.DIALOG_CLOSING = "dialogClosing", S.DIALOG_MINIMIZING = "dialogMinimizing", S.RESIZE = "resize", e.NolimitApplication = S
        },
        502: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitLauncher = e.LauncherSettings = void 0;
            const n = i(4514),
                r = i(8163),
                o = i(1069),
                s = i(1190),
                a = i(8647),
                l = i(8680);
            class h {
                constructor() {
                    this.log = l.LogLevel.DEV, this.maxResolution = 2, this.maxResolutionReplay = 2
                }
            }
            e.LauncherSettings = h;
            class u {
                static get instance() {
                    return null == this._instance && (this._instance = new u), this._instance
                }
                static get defaultResourcePath() {
                    return "/node_modules/@nolimit/slot-launcher/resources/default/"
                }
                constructor() {
                    this.settings = new h, this.logger = new l.NamedLogger("NolimitLauncher"), this.logger.level = this.settings.log, u.plugins = [], u.apiPlugin = new o.NolimitApiPlugin, u.plugins.push(u.apiPlugin), u.plugins.push(new n.NolimitApplication), u.plugins.push(new r.NolimitAutoPlayPlugin), u.plugins.push(new s.AnalyticsIntegrationPlugin), u.plugins.push(new a.GuiPlugin)
                }
                destroy() {
                    for (let t = 0; t < u.plugins.length; t++)
                        if ("NolimitApplication" == u.plugins[t].name) {
                            const e = u.plugins[t];
                            e.destroy && e.destroy(), u.plugins.splice(t, 1);
                            break
                        } for (; u.plugins.length > 0;) {
                            let t = u.plugins.pop();
                            (null == t ? void 0 : t.destroy) && t.destroy()
                        }
                    u.plugins = [], null != this._destructionCallback && this._destructionCallback(), u._instance = void 0
                }
                static destroy() {
                    u._instance && u._instance.destroy()
                }
                setDestructionCallback(t) {
                    this._destructionCallback = t
                }
                removePlugin(t) {
                    for (let e = 0; e < u.plugins.length; e++)
                        if (t == u.plugins[e]) return void u.plugins.splice(e, 1)
                }
                launch(t) {
                    u.plugins = u.plugins.concat(t), this._allPluginNames = [];
                    const e = [];
                    for (let t of u.plugins) this._allPluginNames.push(t.name), e.push(t.init().then((t => this.logValue(t, "loaded"))));
                    this.resetPromisesLeft("init"), Promise.all(e).then((t => this.onLoaded(t)), (t => this.onFail(t)))
                }
                onLoaded(t) {
                    if (null != this._loadError) return;
                    this.logger.log("initComplete");
                    const e = [];
                    for (let i of t) e.push(i.getReady().then((t => this.logValue(t, "ready"))));
                    this.resetPromisesLeft("getReady"), Promise.all(e).then((t => this.onReady(t)), (t => this.onFail(t)))
                }
                onReady(t) {
                    if (null != this._loadError) return;
                    this.logger.log("getReadyComplete");
                    const e = [];
                    for (let i of t) e.push(i.getReadyToStart().then((t => this.logValue(t, "onReadyToStart"))));
                    this.resetPromisesLeft("getReadyToStart"), Promise.all(e).then((t => this.onReadyToStart(t)), (t => this.onFail(t)))
                }
                onReadyToStart(t) {
                    if (null != this._loadError) return;
                    this.logger.log("getReadyToStartComplete");
                    const e = [];
                    for (let i of t) e.push(i.start().then((t => this.logValue(t, "start"))));
                    this.resetPromisesLeft("start"), Promise.all(e).then((t => this.onStart(t)), (t => this.onFail(t)))
                }
                onStart(t) {
                    null == this._loadError && (u.started = !0, this.logger.log("startComplete"), u.apiPlugin.startGame())
                }
                onFail(t) {
                    this._loadError = t, console.log(t), u.apiPlugin.error.trigger(t.message, t.code)
                }
                logValue(t, e) {
                    return this.settings.log != l.LogLevel.NONE && (this._promisesLeft.pluginsLeft.splice(this._promisesLeft.pluginsLeft.indexOf(t.name), 1), this.logger.log(`Plugins left in phase (${this._promisesLeft.phase}): `, this._promisesLeft.pluginsLeft)), t
                }
                resetPromisesLeft(t) {
                    this._promisesLeft = {
                        phase: t,
                        pluginsLeft: this._allPluginNames.concat()
                    }
                }
            }
            u.started = !1, e.NolimitLauncher = u
        },
        1487: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TimelineSprite = void 0;
            const n = i(6358);
            class r extends PIXI.Sprite {
                get totalFrames() {
                    return this._textures.length
                }
                get totalDuration() {
                    return this._totalDuration
                }
                get frameDuration() {
                    return this._frameDuration
                }
                get currentFrame() {
                    const t = Math.floor(this.currentTweenFrame);
                    return Math.max(0, Math.min(t, this._textures.length - 1))
                }
                constructor(t, e = 30) {
                    super(t[0]), this._textures = t, this._sourceFPS = e, this._totalDuration = this._textures.length / this._sourceFPS, this._frameDuration = this._totalDuration / this._textures.length, this.currentTweenFrame = 0
                }
                getAnimation(t, e, i) {
                    1 === (t = null != t ? t : [0]).length && t.push(this._textures.length - 1);
                    const o = new n.TimelineLite;
                    o.add((() => this.setFrame(r.wrapIndex(this._textures.length, t[0]))));
                    for (let s = 1; s < t.length; s++) {
                        const a = r.wrapIndex(this._textures.length, t[s - 1]),
                            l = r.wrapIndex(this._textures.length, t[s]),
                            h = (Math.abs(a - l) + 1) * this._frameDuration;
                        o.add(new n.TweenLite(this, h, {
                            duration: h,
                            currentTweenFrame: l + (l >= a ? .99 : -.99),
                            ease: n.Linear.easeNone,
                            onUpdate: () => {
                                this.applyFrame(), e && e()
                            },
                            onComplete: s === t.length - 1 ? () => {
                                i && i()
                            } : void 0
                        }))
                    }
                    return o
                }
                static wrapIndex(t, e) {
                    if (t <= 0) throw new Error("Error: ArrayHelper.getValueInLoopRange(): length must bigger than zero!");
                    return e > t - 1 ? e % t : e < 0 ? t - Math.abs(e) % t : e
                }
                getAnimationAutoShowHide(t = !0, e = !0, i, r, o) {
                    const s = new n.TimelineLite;
                    return t && s.add((() => this.show())), s.add(this.getAnimation(i, r, (() => {
                        e && this.hide(), o && o()
                    }))), s
                }
                setFrame(t) {
                    this.currentTweenFrame = t, this.applyFrame()
                }
                applyFrame() {
                    this.texture = this._textures[this.currentFrame]
                }
                playLoop(t) {
                    this._loopAnimation && this._loopAnimation.isActive() || (this._loopAnimation = this.getAnimation([0], t, (() => this.playLoop(t))))
                }
                stopLoop() {
                    this._loopAnimation && this._loopAnimation.isActive() && (this._loopAnimation.pause(), this._loopAnimation.kill())
                }
                show() {
                    this.visible = !0
                }
                hide() {
                    this.visible = !1
                }
            }
            e.TimelineSprite = r
        },
        7241: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NLCStaticText = void 0;
            const n = i(4514),
                r = i(3832);
            class o extends PIXI.Sprite {
                constructor(t, e) {
                    super(o.renderTextToTexture(new PIXI.Text(t, e))), this.roundPixels = !0
                }
                static renderTextToTexture(t) {
                    const e = t.style.padding ? t.style.padding : 0,
                        i = PIXI.RenderTexture.create({
                            width: t.width + 2 * e,
                            height: t.height + 2 * e,
                            resolution: n.NolimitApplication.resolution
                        });
                    return t.position.set(e, e), n.NolimitApplication.pixiApp.renderer.render(t, i), i.trim = new r.Rectangle(-e, -e, t.width + 2 * e, t.height + 2 * e), i.orig = new r.Rectangle(e, e, t.width, t.height), i.updateUvs(), t.destroy({
                        children: !0,
                        texture: !0,
                        baseTexture: !0
                    }), i
                }
            }
            e.NLCStaticText = o
        },
        155: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NLCText = void 0;
            const n = i(7241);
            class r extends n.NLCStaticText {
                get text() {
                    return this._text
                }
                set text(t) {
                    this._text = t, this.remakeTexture()
                }
                constructor(t, e) {
                    super(t, e), this._text = t, this._style = null != e ? e : new PIXI.TextStyle
                }
                getStyleClone() {
                    return this._style.clone()
                }
                setStyle(t) {
                    this._style = t, this.remakeTexture()
                }
                remakeTexture() {
                    this.texture = n.NLCStaticText.renderTextToTexture(new PIXI.Text(this._text, this._style))
                }
            }
            e.NLCText = r
        },
        4781: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.cloneScreenBounds = void 0, e.cloneScreenBounds = function (t) {
                return {
                    top: t.top,
                    left: t.left,
                    bottom: t.bottom,
                    right: t.right,
                    center: t.center,
                    width: t.width,
                    height: t.height,
                    scale: t.scale
                }
            }
        },
        7148: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PerformanceFreezeBlur = void 0;
            const n = i(6358),
                r = i(4514);
            class o {
                get isFrozen() {
                    return this._isFrozen
                }
                constructor(t) {
                    this._isFrozen = !1, this._hasInit = !1, this._gameStage = t
                }
                init() {
                    this._resolution = .05, this._app = r.NolimitApplication.pixiApp, this._freezeTexture = PIXI.RenderTexture.create({
                        width: this._app.renderer.screen.width,
                        height: this._app.renderer.screen.height,
                        resolution: r.NolimitApplication.resolution,
                        scaleMode: PIXI.SCALE_MODES.LINEAR
                    }), this._freezeSprite = new PIXI.Sprite(this._freezeTexture), this._freezeSprite.name = "freezeSprite", this._blurTexture = PIXI.RenderTexture.create({
                        width: this._app.renderer.screen.width,
                        height: this._app.renderer.screen.height,
                        resolution: this._resolution,
                        scaleMode: PIXI.SCALE_MODES.LINEAR
                    }), this._blurSprite = new PIXI.Sprite(this._blurTexture), this._blurFilter = new PIXI.filters.BlurFilter, this._blurFilter.autoFit = !1, this._blurFilter.blur = 60, this._blurFilter.padding = 0, this._blurSprite.filters = [this._blurFilter], this._hasInit = !0
                }
                freeze(t = .22, e = !1) {
                    if (this._isFrozen) return new n.TimelineLite;
                    this._hasInit || this.init(), null != this._animation && this._animation.isActive() && (this._animation.progress(1, !1), delete this._animation), this.renderTextures(), this.resize();
                    const i = new n.TimelineLite;
                    return i.add((() => {
                        e && (r.NolimitApplication.pixiApp.stage.interactiveChildren = !1), this._isFrozen = !0, this._freezeSprite.alpha = 0, r.NolimitApplication.pixiApp.stage.addChildAt(this._freezeSprite, 0), r.NolimitApplication.pixiApp.stage.addChildAt(this._gameStage, 0)
                    })), i.add(new n.TweenLite(this._freezeSprite, t, {
                        alpha: 1
                    })), i.add((() => {
                        r.NolimitApplication.pixiApp.stage.removeChild(this._gameStage), delete this._animation
                    })), this._animation = i, i
                }
                unfreeze(t = .22) {
                    if (!this._isFrozen) return new n.TimelineLite;
                    null != this._animation && this._animation.isActive() && (this._animation.progress(1, !1), delete this._animation);
                    const e = new n.TimelineLite({
                        onComplete: () => {
                            r.NolimitApplication.pixiApp.stage.removeChild(this._freezeSprite), r.NolimitApplication.pixiApp.stage.interactiveChildren = !0, delete this._animation, this._isFrozen = !1
                        }
                    });
                    return e.add((() => {
                        r.NolimitApplication.pixiApp.stage.addChildAt(this._gameStage, 0)
                    })), e.add(new n.TweenLite(this._freezeSprite, t, {
                        alpha: 0
                    })), e
                }
                renderTextures() {
                    this._freezeSprite.scale.set(1, 1), this._freezeTexture.resize(r.NolimitApplication.screenBounds.width, r.NolimitApplication.screenBounds.height), this._blurTexture.resize(r.NolimitApplication.screenBounds.width + 200, r.NolimitApplication.screenBounds.height + 200), r.NolimitApplication.pixiApp.renderer.render(this._gameStage, this._blurTexture, !0, o.getStageMatrix()), this._blurSprite.render(r.NolimitApplication.pixiApp.renderer), r.NolimitApplication.pixiApp.renderer.render(this._blurSprite, this._freezeTexture, !0)
                }
                static getStageMatrix() {
                    const t = new PIXI.Matrix;
                    return t.translate(-r.NolimitApplication.screenBounds.left, -r.NolimitApplication.screenBounds.top), t
                }
                resize() {
                    this._freezeSprite.position.set(r.NolimitApplication.screenBounds.left, r.NolimitApplication.screenBounds.top), this._freezeSprite.width = r.NolimitApplication.screenBounds.width, this._freezeSprite.height = r.NolimitApplication.screenBounds.height
                }
                onOrientationChanged() {
                    this._isFrozen && this.renderTextures()
                }
                onResize() {
                    this._hasInit && this.resize()
                }
            }
            e.PerformanceFreezeBlur = o
        },
        1077: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiButton = void 0;
            const n = i(956),
                r = i(8680);
            class o extends PIXI.Container {
                get pointerState() {
                    return this._pointerState
                }
                constructor(t, e) {
                    super(), this._boundEvents = !1, this.debug = !1, this.onPointerTap = t => {
                        t.stopPropagation(), this.onClick(t)
                    }, this.onPointerDown = t => {
                        t.stopPropagation(), this.setPointerState(n.PointerState.DOWN)
                    }, this.onPointerOver = t => {
                        this.setPointerState(n.PointerState.OVER)
                    }, this.onPointerUp = t => {
                        this.setPointerState(n.PointerState.IDLE)
                    }, this.onPointerUpOutside = t => {
                        this.setPointerState(n.PointerState.IDLE)
                    }, this.onPointerOut = t => {
                        this.setPointerState(n.PointerState.IDLE)
                    }, this.name = t, this._clickCallbacks = [], null != e && this.addClickCallback(e), this._callbackSets = []
                }
                bindEvents() {
                    this.on("pointertap", this.onPointerTap), this.on("pointerdown", this.onPointerDown), this.on("pointerover", this.onPointerOver), this.on("pointerup", this.onPointerUp), this.on("pointerupoutside", this.onPointerUpOutside), this.on("pointerout", this.onPointerOut)
                }
                enable(t) {
                    this._boundEvents || (this.bindEvents(), this._boundEvents = !0), this.interactive = t, this.buttonMode = t, this.setPointerState(t ? n.PointerState.IDLE : n.PointerState.DISABLED)
                }
                addClickCallback(t) {
                    this._clickCallbacks.push(t)
                }
                addCallbackSet(t) {
                    this._callbackSets.push(t)
                }
                setPointerState(t) {
                    if (this._pointerState !== t) {
                        this._pointerState = t, this.onPointerStateUpdate(t);
                        for (let e of this._callbackSets) null != e[t] && e[t]();
                        this.debug && r.Logger.logDev(`[${this.name}].pointerState: ${n.PointerState[this.pointerState]}`)
                    }
                }
                onClick(t) {
                    for (let t of this._clickCallbacks) t();
                    this.debug && r.Logger.logDev(`[${this.name}].onClick`), t && t.stopPropagation()
                }
                onPointerStateUpdate(t) { }
            }
            e.GuiButton = o
        },
        393: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiToggleButton = void 0;
            const n = i(1077),
                r = i(3815);
            class o extends n.GuiButton {
                get toggled() {
                    return this.toggleState === r.ToggleState.ON
                }
                set toggled(t) {
                    this.toggleState = t ? r.ToggleState.ON : r.ToggleState.OFF
                }
                get toggleState() {
                    return this._toggleState
                }
                set toggleState(t) {
                    this._toggleState = t, this._toggleCallback(this._toggleState)
                }
                constructor(t, e) {
                    super(t), this._toggleCallback = e
                }
            }
            e.GuiToggleButton = o
        },
        8853: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.IconButton = void 0;
            const n = i(1077);
            class r extends n.GuiButton {
                constructor(t, e, i, n) {
                    super(t, n), this.onPointerStateUpdate = t => {
                        this.setIcon()
                    }, this._iconSet = e, this._colorSet = i
                }
                setIcon() {
                    const t = this._iconSet.getItem(this.pointerState),
                        e = this._colorSet.getItem(this.pointerState);
                    t.setColor(e), t != this._icon && (this.addChild(t), this.removeChild(this._icon), this._icon = t)
                }
            }
            e.IconButton = r
        },
        5991: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.IconToggleButton = void 0;
            const n = i(393),
                r = i(3815);
            class o extends n.GuiToggleButton {
                constructor(t, e, i, n, o) {
                    super(t, (() => this.toggleCallback())), this.onPointerStateUpdate = t => {
                        this.setIcon()
                    }, this._iconSets = new r.ToggleStateSet(e, n), this._colorSets = new r.ToggleStateSet(i, o)
                }
                getIconSet() {
                    return this._iconSets.getItem(this.toggleState)
                }
                getIconColorSet() {
                    return this._colorSets.getItem(this.toggleState)
                }
                setIcon() {
                    const t = this.getIconSet(),
                        e = this.getIconColorSet(),
                        i = t.getItem(this.pointerState),
                        n = e.getItem(this.pointerState);
                    i.setColor(n), i != this._icon && (this.addChild(i), this.removeChild(this._icon), this._icon = i)
                }
                addSubComponent(t, e, i) {
                    this.addChild(t), this._icon || this.setIcon(), t.position.set(this._icon.width * e.x + i.x, this._icon.height * e.y + i.y)
                }
                removeSubComponent(t) {
                    this.removeChild(t)
                }
                toggleCallback() {
                    this.setIcon()
                }
                hide() {
                    this.visible = !1
                }
                show() {
                    this.visible = !0
                }
            }
            e.IconToggleButton = o
        },
        8130: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.LabelButton = e.createDefaultButtonStroke = e.createDefaultButtonBackPlate = void 0;
            const n = i(393),
                r = i(1057),
                o = i(3815),
                s = i(3606),
                a = i(5654),
                l = i(9756),
                h = i(9834),
                u = i(3663);

            function c() {
                const t = new PIXI.NineSlicePlane(a.SvgLoader.getSvgTexture(h.GuiDefaultTextures.PLATE_BASE_20), 20, 20, 20, 20);
                return t.tint = 0, t.alpha = .15, t
            }

            function d() {
                const t = new PIXI.NineSlicePlane(a.SvgLoader.getSvgTexture(h.GuiDefaultTextures.PLATE_STROKE_20), 20, 20, 20, 20);
                return t.tint = 16777215, t.alpha = .6, t
            }
            e.createDefaultButtonBackPlate = c, e.createDefaultButtonStroke = d;
            class p extends n.GuiToggleButton {
                get backplate() {
                    return this._backplate
                }
                set backplate(t) {
                    this._backplate = t
                }
                get stroke() {
                    return this._stroke
                }
                set stroke(t) {
                    this._stroke = t
                }
                get label() {
                    return this._label
                }
                constructor(t, e = "", i, n, a, l, h) {
                    super(t, (() => this.toggleCallback())), i = i || u.GuiDefaults.DEFAULT_BUTTON_LABEL_STYLE, n = n || new s.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208), a = a || new s.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231), this._colorSets = new o.ToggleStateSet(n, a), this.value = void 0, this._label = new r.Label(e, i), this._backplate = l || c(), this._stroke = h || d(), this.addChild(this._backplate), this.addChild(this._stroke), this.addChild(this._label)
                }
                setSize(t, e) {
                    this._backplate.width = t, this._backplate.height = e, this._stroke.width = t, this._stroke.height = e, this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e)
                }
                resizeButtonToLabelWithMargin(t = 0, e = 0, i = 0, n = 0) {
                    this.setSize(this._label.width + n + e, this._label.height + t + i), this._label.anchor.set(0, 0), this._label.position.set(n, t)
                }
                setColors() {
                    const t = this._colorSets.getItem(this.toggleState).getItem(this.pointerState);
                    this._label.setColor(t), this._backplate.alpha = .15 * (1 - this.toggleState), this._stroke.tint = l.GuiUtils.getColorFromARGB(t), this._stroke.alpha = l.GuiUtils.getAlphaFromARGB(t), this._stroke.alpha *= this.toggled ? 1 : .6
                }
                toggleCallback() {
                    this.setColors()
                }
                onPointerStateUpdate(t) {
                    this.setColors()
                }
            }
            e.LabelButton = p
        },
        8592: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ContinueButton = void 0;
            const n = i(4514),
                r = i(3663),
                o = i(5654),
                s = i(9834),
                a = i(1077),
                l = i(1057),
                h = i(3606),
                u = i(9756);
            class c extends a.GuiButton {
                constructor(t) {
                    super(t || "continues_button"), this.onPointerStateUpdate = t => {
                        const e = u.GuiUtils.getAlphaFromARGB(this._colors.getItem(t));
                        this.alpha = e
                    }, t = t || n.NolimitApplication.apiPlugin.translations.translate("CONTINUE"), this._label = new l.Label(t, r.GuiDefaults.DEFAULT_CONTINUE_BUTTON_LABEL_STYLE), this._backplate = c.createBackPlate(), this._stroke = c.createButtonStroke(), this._colors = new h.PointerStateColorSet(4278190080, void 0, void 0, 2147483648), this.addChild(this._backplate), this.addChild(this._stroke), this.addChild(this._label), this.resizeButtonToLabelWithMargin(18, 30, 18, 30)
                }
                setSize(t, e) {
                    this._backplate.width = t, this._backplate.height = e, this._stroke.width = t, this._stroke.height = e, this._label.anchor.set(.5, .5), this._label.position.set(.5 * t, .5 * e)
                }
                resizeButtonToLabelWithMargin(t = 0, e = 0, i = 0, n = 0) {
                    this.setSize(this._label.width + n + e, this._label.height + t + i), this._label.anchor.set(0, 0), this._label.position.set(n, t)
                }
                static createBackPlate() {
                    const t = new PIXI.NineSlicePlane(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.PLATE_BASE_9), 9, 9, 9, 9);
                    return t.tint = 0, t.alpha = .4, t
                }
                static createButtonStroke() {
                    const t = new PIXI.NineSlicePlane(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.PLATE_STROKE_9), 9, 9, 9, 9);
                    return t.tint = 16777215, t.alpha = 1, t
                }
            }
            e.ContinueButton = c
        },
        2588: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.RadioButton = void 0;
            const n = i(5991),
                r = i(5654),
                o = i(9834),
                s = i(2974),
                a = i(8760),
                l = i(3606),
                h = i(1057),
                u = i(3663);
            class c extends n.IconToggleButton {
                constructor(t, e) {
                    const i = new l.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208),
                        n = new l.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231),
                        c = r.SvgLoader.getSvgTexture(o.GuiDefaultTextures.CHECK_BOX).clone();
                    c.rotate = 12;
                    const d = new s.PointerStateIconSet(new a.Icon(r.SvgLoader.getSvgTexture(o.GuiDefaultTextures.CHECK_BOX)));
                    if (super(t, new s.PointerStateIconSet(new a.Icon(c.clone())), i, d, n), null != e) {
                        const t = new h.Label(e, u.GuiDefaults.DEFAULT_RADIO_BUTTON_LABEL);
                        t.anchor.set(0, .5), this.addSubComponent(t, {
                            x: 1,
                            y: .5
                        }, {
                            x: 20,
                            y: 0
                        })
                    }
                }
            }
            e.RadioButton = c
        },
        9980: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SoundButton = void 0;
            const n = i(5991),
                r = i(2974),
                o = i(3606),
                s = i(6358),
                a = i(8760),
                l = i(9834),
                h = i(2408);
            class u extends n.IconToggleButton {
                constructor(t) {
                    const e = new o.PointerStateColorSet(4294966272, 4294966272, 4294966272, 872414208),
                        i = new o.PointerStateColorSet(4294967295, 4294967295, 4294967295, 872415231);
                    super(t, new r.PointerStateIconSet(new a.Icon(h.ImgLoader.getImgTexture(l.GuiDefaultTextures.SOUND_ON))), e, new r.PointerStateIconSet(new a.Icon(h.ImgLoader.getImgTexture(l.GuiDefaultTextures.SOUND_OFF))), i), this._loadingRing = new PIXI.Sprite(h.ImgLoader.getImgTexture(l.GuiDefaultTextures.SOUND_RING)), this._loadingRing.anchor.set(.5, .5), this._loadingRing.position.set(.5 * this._loadingRing.width, .5 * this._loadingRing.height)
                }
                startLoadingAnimation(t) {
                    null == this._tl && (this._tl = null != t ? new s.TimelineMax({
                        repeat: -1,
                        onRepeat: () => {
                            t()
                        }
                    }) : new s.TimelineMax({
                        repeat: -1
                    }), this.addChild(this._loadingRing), this._tl.add(new s.TweenLite(this._loadingRing, 1, {
                        rotation: 2 * Math.PI,
                        ease: s.Linear.easeNone
                    })))
                }
                stopLoadingAnimation() {
                    null != this._tl && (this._tl.pause(), this._tl.kill(), this.removeChild(this._loadingRing), this._tl = void 0)
                }
            }
            e.SoundButton = u
        },
        956: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PointerStateSet = e.PointerState = void 0,
                function (t) {
                    t[t.IDLE = 0] = "IDLE", t[t.DOWN = 1] = "DOWN", t[t.OVER = 2] = "OVER", t[t.DISABLED = 3] = "DISABLED"
                }(i = e.PointerState || (e.PointerState = {}));
            class n {
                constructor(t, e, n, r) {
                    this[i.IDLE] = t, this[i.DOWN] = e, this[i.OVER] = n, this[i.DISABLED] = r
                }
                getItem(t) {
                    return this[t]
                }
                clone() {
                    return new n(this[i.IDLE], this[i.DOWN], this[i.OVER], this[i.DISABLED])
                }
            }
            e.PointerStateSet = n, i.IDLE, i.DOWN, i.OVER, i.DISABLED
        },
        3815: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ToggleStateSet = e.ToggleState = void 0,
                function (t) {
                    t[t.OFF = 0] = "OFF", t[t.ON = 1] = "ON"
                }(i = e.ToggleState || (e.ToggleState = {}));
            class n {
                constructor(t, e) {
                    this[i.ON] = t, this[i.OFF] = e
                }
                getItem(t) {
                    return null != this[t] ? this[t] : this[i.ON]
                }
                clone() {
                    return new n(this[i.ON], this[i.OFF])
                }
            }
            e.ToggleStateSet = n, i.OFF, i.ON
        },
        3606: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PointerStateColorSet = void 0;
            const n = i(956);
            class r extends n.PointerStateSet {
                constructor(t, e, i, n) {
                    super(t, e, i, n)
                }
                getItem(t) {
                    return null != this[t] ? this[t] : this[n.PointerState.IDLE]
                }
                clone() {
                    return super.clone()
                }
            }
            e.PointerStateColorSet = r
        },
        2974: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PointerStateIconSet = void 0;
            const n = i(956);
            class r extends n.PointerStateSet {
                constructor(t, e, i, n) {
                    super(t, e, i, n)
                }
                getItem(t) {
                    return null != this[t] ? this[t] : this[n.PointerState.IDLE]
                }
            }
            e.PointerStateIconSet = r
        },
        9834: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiDefaultTextures = void 0;
            const n = i(2408);
            class r {
                static makeAssetPath(t) {
                    return "/node_modules/@nolimit/slot-launcher/resources/default/gui/" + t
                }
                static getImgConfigs() {
                    return [new n.ImgAssetConfig(r.SOUND_RING), new n.ImgAssetConfig(r.SOUND_OFF), new n.ImgAssetConfig(r.SOUND_ON), new n.ImgAssetConfig(r.CHECK_BOX), new n.ImgAssetConfig(r.PLATE_BASE_9), new n.ImgAssetConfig(r.PLATE_STROKE_9), new n.ImgAssetConfig(r.PLATE_BASE_20), new n.ImgAssetConfig(r.PLATE_STROKE_20), new n.ImgAssetConfig(r.BULLET_SMALL), new n.ImgAssetConfig(r.BULLET_LARGE), new n.ImgAssetConfig(r.NAV_ARROW), new n.ImgAssetConfig(r.VOL_INSANE), new n.ImgAssetConfig(r.VOL_EXTREME), new n.ImgAssetConfig(r.VOL_HIGH), new n.ImgAssetConfig(r.VOL_MEDIUM), new n.ImgAssetConfig(r.X_NUDGE), new n.ImgAssetConfig(r.X_WAYS), new n.ImgAssetConfig(r.X_WAYS_INFECTIOUS), new n.ImgAssetConfig(r.X_PAYS), new n.ImgAssetConfig(r.X_BOMB), new n.ImgAssetConfig(r.X_SPLIT), new n.ImgAssetConfig(r.X_SIZE), new n.ImgAssetConfig(r.X_BET), new n.ImgAssetConfig(r.X_CLUSTER), new n.ImgAssetConfig(r.X_MOUNT), new n.ImgAssetConfig(r.X_CAP), new n.ImgAssetConfig(r.X_BIZARRE), new n.ImgAssetConfig(r.X_ZONE), new n.ImgAssetConfig(r.SNOW_FLAKE), new n.ImgAssetConfig(r.RATED_R)]
                }
            }
            r.CHECK_BOX = r.makeAssetPath("checkBox@2x.png"), r.SOUND_RING = r.makeAssetPath("ringLoader@2x.png"), r.SOUND_OFF = r.makeAssetPath("soundOff@2x.png"), r.SOUND_ON = r.makeAssetPath("soundOn@2x.png"), r.PLATE_BASE_9 = r.makeAssetPath("plateBase9@2x.png"), r.PLATE_STROKE_9 = r.makeAssetPath("plateStroke9@2x.png"), r.PLATE_BASE_20 = r.makeAssetPath("plateBase20@2x.png"), r.PLATE_STROKE_20 = r.makeAssetPath("plateStroke20@2x.png"), r.BULLET_SMALL = r.makeAssetPath("bulletSmall@2x.png"), r.BULLET_LARGE = r.makeAssetPath("bulletLarge@2x.png"), r.NAV_ARROW = r.makeAssetPath("navArrow@2x.png"), r.VOL_INSANE = r.makeAssetPath("volInsane@2x.png"), r.VOL_EXTREME = r.makeAssetPath("volExtreme@2x.png"), r.VOL_HIGH = r.makeAssetPath("volHigh@2x.png"), r.VOL_MEDIUM = r.makeAssetPath("volMedium@2x.png"), r.X_NUDGE = r.makeAssetPath("xNudge@2x.png"), r.X_WAYS = r.makeAssetPath("xWays@2x.png"), r.X_WAYS_INFECTIOUS = r.makeAssetPath("xWaysInfectious@2x.png"), r.X_PAYS = r.makeAssetPath("xPays@2x.png"), r.X_BOMB = r.makeAssetPath("xBomb@2x.png"), r.X_SPLIT = r.makeAssetPath("xSplit@2x.png"), r.X_SIZE = r.makeAssetPath("xSize@2x.png"), r.X_BET = r.makeAssetPath("xBet@2x.png"), r.X_CLUSTER = r.makeAssetPath("xCluster@2x.png"), r.X_MOUNT = r.makeAssetPath("xMount@2x.png"), r.X_CAP = r.makeAssetPath("xCap@2x.png"), r.X_BIZARRE = r.makeAssetPath("xBizarre@2x.png"), r.X_ZONE = r.makeAssetPath("xZone@2x.png"), r.SNOW_FLAKE = r.makeAssetPath("censoredSnowFlake@2x.png"), r.RATED_R = r.makeAssetPath("ratedR.png"), e.GuiDefaultTextures = r
        },
        3663: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiDefaults = void 0;
            const n = i(1653),
                r = i(5383);
            class o { }
            o.DEFAULT_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), o.DEFAULT_LABEL_STYLE_SMALL = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 16,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), o.DEFAULT_LABEL_VALUE_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 20,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.BOLD
            }), o.INTRO_PAGE_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 28,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.NORMAL,
                wordWrap: !0,
                wordWrapWidth: 340,
                breakWords: !0
            }), o.DEFAULT_CONTINUE_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 34,
                fontStyle: r.FontStyle.ITALIC,
                fontWeight: r.FontWeight.EXTRA_BOLD,
                padding: 10
            }), o.DEFAULT_BUTTON_LABEL_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.LIGHT
            }), o.DEFAULT_RADIO_BUTTON_LABEL = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: n.OpenSans.FAMILY,
                fontSize: 34,
                fontStyle: r.FontStyle.NORMAL,
                fontWeight: r.FontWeight.NORMAL
            }), e.GuiDefaults = o
        },
        8760: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Icon = void 0;
            const n = i(3832),
                r = i(9756);
            class o extends n.Sprite {
                constructor(t) {
                    super(t)
                }
                setColor(t) {
                    this.tint = r.GuiUtils.getColorFromARGB(t), this.alpha = r.GuiUtils.getAlphaFromARGB(t)
                }
            }
            e.Icon = o
        },
        7618: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TextInput = void 0;
            const n = i(9756),
                r = i(4514);
            class o extends PIXI.Container {
                constructor(t, e, i, n = o.DEFAULT_STYLE, s = "number") {
                    super(), this._elementInDom = !1, this._value = 0, this._lastInput = "", this.hasAddedDeFocusListener = !1, this.logData = [], this.onBlur = () => {
                        this.log("onBlur");
                        const t = parseFloat(this._inputElement.value.replace(",", ".").replace(/[$]/, ""));
                        isNaN(t) || t <= 0 ? (this._inputElement.value = "", this._onInputChangedCallback(this.name, void 0)) : this._onInputChangedCallback(this.name, t), this.removeDeFocusListener()
                    }, this.deFocusElement = t => {
                        this.log("onDeFocusElement"), document.activeElement !== this._inputElement && (this.log("Do Blur!"), this._inputElement.blur(), this.onBlur())
                    }, this.name = t, this._onInputChangedCallback = e, this._inputWidth = i, this._inputType = s, this._inputTextStyle = n, this.createDOM(), r.NolimitApplication.events.on(r.NolimitApplication.RESIZE, (() => this.resize()))
                }
                get visible() {
                    return !this._inputElement || "block" == this._inputElement.style.display
                }
                set visible(t) {
                    this._inputElement && (this._inputElement.style.display = t ? "block" : "none")
                }
                get alpha() {
                    return 1 | parseFloat(this._inputElement.style.opacity)
                }
                set alpha(t) {
                    this._inputElement && (this._inputElement.style.opacity = t.toString())
                }
                getCss() {
                    return ".pixiTextInput input {\n            box-shadow:none;\n        }\n\n        .pixiTextInput input:focus {\n            box-shadow:none !important;\n        }\n\n        .pixiTextInput input:invalid {\n            box-shadow:none !important;\n        }"
                }
                log(t) {
                    for (this.logData.push(t); this.logData.length > 15;) this.logData.shift();
                    this._debugElement.innerHTML = this.logData.join("<br>")
                }
                createDOM() {
                    this._deFocusElement = document.createElement("div"), this._deFocusElement.style.position = "absolute", this._deFocusElement.style.top = "0px", this._deFocusElement.style.left = "0px", this._deFocusElement.style.width = "100%", this._deFocusElement.style.height = "100%", this._deFocusElement.style.backgroundColor = "rgba(0,0,0,0.4)", this._deFocusElement.hidden = !0, this._debugElement = document.createElement("p"), this._debugElement.textContent = "DEBUG", this._debugElement.style.position = "absolute", this._debugElement.style.top = "110px", this._debugElement.style.width = "97%", this._debugElement.style.fontSize = "2em", this._debugElement.style.color = "white", this._debugElement.style.textAlign = "right", this._debugElement.hidden = !0, this._inputElement = document.createElement("input"), this._inputElement.type = this._inputType, this._inputElement.classList.add("pixiTextInput"), this._inputElement.min = "0", this._inputElement.style.opacity = "1", this._inputElement.style.position = "absolute", this._inputElement.style.transformOrigin = "0 0", this._inputElement.style.lineHeight = "1", this._inputElement.style.backgroundColor = "transparent", this._inputElement.style.border = "1px solid", this._inputElement.style.borderRadius = "5px", this._inputElement.style.borderColor = "rgba(255,255,255,0.4)", this._inputElement.style.boxShadow = "none", this._inputElement.style.boxShadow = "none";
                    const t = document.createElement("style");
                    t.appendChild(document.createTextNode(this.getCss())), document.head.append(t), this.addEventListener(this._inputElement), this._inputElement.style.outline = "none", this._inputElement.style.color = "string" == typeof this._inputTextStyle.fill ? this._inputTextStyle.fill : "#ffffff", this._inputElement.style.fontFamily = "string" == typeof this._inputTextStyle.fontFamily ? this._inputTextStyle.fontFamily : this._inputTextStyle.fontFamily[0], this._inputElement.style.fontSize = this._inputTextStyle.fontSize + "px", this._inputElement.style.fontStyle = this._inputTextStyle.fontStyle, this._inputElement.style.fontWeight = this._inputTextStyle.fontWeight + "px", this._inputElement.style.width = this._inputWidth + "px", this._inputElement.style.padding = "4px", this._inputElement.style.textAlign = "right";
                    let e = this.getDOMInputBounds();
                    this._gfx = new PIXI.Graphics, this._gfx.beginFill(16711680, 1), this._gfx.drawRect(0, 0, e.width, e.height), this._gfx.endFill(), this._gfx.alpha = 0, this.addChild(this._gfx)
                }
                addEventListener(t) {
                    t.addEventListener("focus", (() => {
                        this.log("onFocus"), t.style.borderColor = "rgba(255,255,255,0.6)", t.style.color = "string" == typeof this._inputTextStyle.fill ? this._inputTextStyle.fill : "#ffffff", this.addDeFocusListener()
                    })), t.addEventListener("blur", (() => {
                        this.onBlur()
                    })), t.addEventListener("focusout", (() => {
                        this.onBlur()
                    })), t.addEventListener("keydown", (t => {
                        const e = t.keyCode,
                            i = !0 === t.ctrlKey || !0 === t.metaKey;
                        t.shiftKey || t.altKey ? t.preventDefault() : [46, 8, 9, 27, 13, 110, 188, 190].includes(e) || i || e >= 35 && e <= 39 || (e < 48 || e > 57) && (e < 96 || e > 105) && (t.preventDefault(), t.stopPropagation())
                    }))
                }
                addDeFocusListener() {
                    this.log("addDeFocusListener"), this.hasAddedDeFocusListener || (window.document.body.addEventListener("click", this.deFocusElement), this._deFocusElement.style.cursor = "pointer", this._deFocusElement.hidden = !1, this.hasAddedDeFocusListener = !0)
                }
                removeDeFocusListener() {
                    this.log("removeDeFocusListener"), window.document.body.removeEventListener("click", this.deFocusElement), this._deFocusElement.style.cursor = "default", this._deFocusElement.hidden = !0, this.hasAddedDeFocusListener = !1
                }
                getDOMInputBounds() {
                    let t = !1;
                    this._elementInDom || (document.body.appendChild(this._inputElement), t = !0);
                    let e = this._inputElement.style.transform,
                        i = this._inputElement.style.display;
                    this._inputElement.style.transform = "", this._inputElement.style.display = "block";
                    let n = this._inputElement.getBoundingClientRect();
                    return this._inputElement.style.transform = e, this._inputElement.style.display = i, t && document.body.removeChild(this._inputElement), n
                }
                setDomParent(t) {
                    this._domParent = t
                }
                addDom() {
                    this._domParent ? (this._domParent.appendChild(this._deFocusElement), this._domParent.appendChild(this._debugElement), this._domParent.appendChild(this._inputElement)) : (document.body.appendChild(this._deFocusElement), document.body.appendChild(this._debugElement), document.body.appendChild(this._inputElement)), this.visible = !0, this._elementInDom = !0, this.resize()
                }
                removeDom() {
                    this._domParent ? (this._domParent.removeChild(this._deFocusElement), this._domParent.removeChild(this._debugElement), this._domParent.removeChild(this._inputElement)) : (document.body.removeChild(this._deFocusElement), document.body.removeChild(this._debugElement), document.body.removeChild(this._inputElement)), this._elementInDom = !1
                }
                get valueString() {
                    return this._value < 0 ? "" : this._value.toString()
                }
                get value() {
                    return this._value
                }
                set value(t) {
                    isNaN(t) || (this._value = t)
                }
                setElementValue(t) {
                    this.value = t, this._inputElement.value = this.valueString, this.value > 0 ? (this._inputElement.style.borderColor = "rgba(255,255,0,0.4)", this._inputElement.style.color = "#ffff00") : (this._inputElement.style.borderColor = "rgba(255,255,255,0.4)", this._inputElement.style.color = "string" == typeof this._inputTextStyle.fill ? this._inputTextStyle.fill : "#ffffff")
                }
                resize() {
                    if (!this._elementInDom) return;
                    this.toGlobal(this.position), this._inputElement.style.top = "0px", this._inputElement.style.left = "0px";
                    const t = this.worldTransform.clone();
                    t.scale(r.NolimitApplication.globalScale / r.NolimitApplication.pixiApp.stage.scale.x, r.NolimitApplication.globalScale / r.NolimitApplication.pixiApp.stage.scale.y), this._inputElement.style.transform = n.GuiUtils.pixiMatrixToCSSMatrix(t)
                }
            }
            o.DEFAULT_STYLE = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: "Open Sans",
                fontSize: 20,
                fontStyle: "normal",
                fontWeight: "300"
            }), e.TextInput = o
        },
        1057: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Label = e.Margin = void 0;
            const n = i(9756),
                r = i(3663),
                o = i(155);
            e.Margin = class {
                constructor(t, e, i, n) {
                    this.top = t, this.right = e || this.top, this.bottom = i || this.top, this.left = n || this.right
                }
            };
            class s extends PIXI.Container {
                get width() {
                    return this._label.width
                }
                get height() {
                    return this._label.height
                }
                get tint() {
                    return this._label.tint
                }
                set tint(t) {
                    this._label.tint = t
                }
                constructor(t, e = r.GuiDefaults.DEFAULT_LABEL_STYLE) {
                    super(), this._label = new o.NLCText(t, e.clone()), this.name = "Label[" + t + "]", this.anchor = new PIXI.ObservablePoint(((...t) => this.onAnchorUpdate(t)), this), this.addChild(this._label)
                }
                setColor(t) {
                    const e = this._label.getStyleClone();
                    e.fill = n.GuiUtils.getColorFromARGB(t), this._label.setStyle(e), this.alpha = n.GuiUtils.getAlphaFromARGB(t)
                }
                addBackPlate(t, e) {
                    this._backPlateUpdateCallback = e, this.addChild(t), this.addChild(this._label), this.updateBackPlate()
                }
                set text(t) {
                    this._label.text = t, this.updateBackPlate()
                }
                get text() {
                    return this._label.text
                }
                getStyleClone() {
                    return this._label.getStyleClone()
                }
                setStyle(t) {
                    this._label.setStyle(t)
                }
                onAnchorUpdate(t) {
                    this._label.anchor.set(this.anchor.x, this.anchor.y), this.updateBackPlate()
                }
                updateBackPlate() {
                    this._backPlateUpdateCallback && this._backPlateUpdateCallback()
                }
            }
            e.Label = s
        },
        4813: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.LabeledValue = void 0;
            const n = i(1057),
                r = i(3663);
            class o extends PIXI.Container {
                get label() {
                    return this._label
                }
                get value() {
                    return this._value
                }
                constructor(t, e, i, o = r.GuiDefaults.DEFAULT_LABEL_STYLE, s = r.GuiDefaults.DEFAULT_LABEL_VALUE_STYLE) {
                    super(), this._margin = 10, this._anchorPoint = new PIXI.Point(0, 0), this.name = t, this._label = new n.Label(e, o), this._value = new n.Label(i.toString(), s), this.addChild(this._label), this.addChild(this._value), this.setAlignment()
                }
                setTextSize(t) {
                    const e = this._label.getStyleClone();
                    e.fontSize = t;
                    const i = this._value.getStyleClone();
                    i.fontSize = t, this._label.setStyle(e), this._value.setStyle(i), this.setAlignment(), this.setPivot()
                }
                setAlignment() {
                    this._label.position.set(0, 0), this._value.position.set(this._label.width + this._margin, 0)
                }
                setColor(t) {
                    this._label.tint = t, this._value.tint = t
                }
                setValue(t) {
                    this._value.text = t, this.setAlignment(), this.setPivot()
                }
                setLabel(t) {
                    this._label.text = t, this.setAlignment(), this.setPivot()
                }
                setPivot() {
                    this.pivot.set(this.width * this._anchorPoint.x, this.height * this._anchorPoint.y)
                }
                setAnchor(t, e) {
                    this._anchorPoint = new PIXI.Point(t, e), this.setAlignment(), this.setPivot()
                }
            }
            e.LabeledValue = o
        },
        8647: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiPlugin = void 0;
            const n = i(4514),
                r = i(1653),
                o = i(2111),
                s = i(9834),
                a = i(2408);
            e.GuiPlugin = class {
                constructor() {
                    this.name = "GuiPlugin"
                }
                init() {
                    const t = new o.FontLoader(n.NolimitApplication.resourcePath);
                    t.add(r.OpenSans.NORMAL_300), t.add(r.OpenSans.NORMAL_400), t.add(r.OpenSans.NORMAL_700), t.add(r.OpenSans.ITALIC_700), t.add(r.OpenSans.ITALIC_800);
                    const e = new a.ImgLoader(n.NolimitApplication.resourcePath);
                    for (let t of s.GuiDefaultTextures.getImgConfigs()) e.add(t.name, t.url);
                    return Promise.all([e.load(), t.load()]).then((t => Promise.resolve(this)))
                }
                getReady() {
                    return Promise.resolve(this)
                }
                getReadyToStart() {
                    return Promise.resolve(this)
                }
                start() {
                    return Promise.resolve(this)
                }
            }
        },
        3128: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GUIScrollContainer = void 0;
            const n = i(7002),
                r = i(5269),
                o = i(4274);
            class s extends PIXI.Container {
                constructor(t, e, i = !0, s = !0, a = !1, l) {
                    super(), this.scrollEnabled = !0, this.setScrollDelta = (t, e = 0, i = 0) => {
                        this.scrollEnabled && (this.setActiveScroller(t), this.checkAllowedDirections(e, i), this.setScrollTarget(t, this._scrollTarget.x + e, this._scrollTarget.y + i))
                    }, this.setScrollTarget = (t, e, i) => {
                        null != e && this._hasScroll.x && this._directionAllowed.x && (this._scrollTarget.x = e), null != i && this._hasScroll.y && this._directionAllowed.y && (this._scrollTarget.y = i), this.animate()
                    }, this._defaultAllowedDirections = {
                        x: i,
                        y: s
                    }, this._hasScroll = {
                        x: !1,
                        y: !1
                    }, this._directionAllowed = {
                        x: !0,
                        y: !0
                    }, this._maskContentSizeDiff = new PIXI.Point, this._scrollTarget = new PIXI.Point, this._maskSize = {
                        width: t,
                        height: e
                    }, this._scrollMask = new PIXI.Graphics, this._scrollMask.name = "GuiScrollerMask", this._content = new r.Scroller(this);
                    const h = {
                        color: (null == l ? void 0 : l.color) || 16777215,
                        thickness: (null == l ? void 0 : l.thickness) || 7.5
                    };
                    this._scrollBarVertical = new o.ScrollBar(this, !0, !a, h);
                    const u = {
                        color: (null == l ? void 0 : l.color) || 16777215,
                        thickness: (null == l ? void 0 : l.thickness) || 5
                    };
                    this._scrollBarHorizontal = new o.ScrollBar(this, !1, !0, u), this._mouseScrollEvent = new n.MouseScroller(this), this.addChild(this._scrollMask), this.addChild(this._content), this.addChild(this._scrollBarVertical), this.addChild(this._scrollBarHorizontal), this.mask = this._scrollMask, this.drawMask(), this._scrollBarVertical.position.x = this._maskSize.width, this._scrollBarHorizontal.position.y = this._maskSize.height
                }
                reAddMouseHoverListener() {
                    this._mouseScrollEvent.reAddHoverListener()
                }
                resize(t, e) {
                    this._maskSize = {
                        width: t,
                        height: e
                    }, this.drawMask(), this._scrollBarVertical.position.x = this._maskSize.width, this._scrollBarHorizontal.position.y = this._maskSize.height, this.updateContent()
                }
                addContent(t) {
                    this._content.addChild(t), this.updateContent()
                }
                removeContent(t) {
                    this._content.removeChild(t), this.updateContent()
                }
                removeAllContent() {
                    this._content.removeChildren(), this.updateContent()
                }
                updateContent() {
                    this.updateHitArea(), this.checkNeedsScroll()
                }
                drawMask() {
                    this._scrollMask.clear(), this._scrollMask.beginFill(16711680), this._scrollMask.drawRect(0, 0, this._maskSize.width, this._maskSize.height), this._scrollMask.endFill()
                }
                checkNeedsScroll() {
                    const t = this._content.getLocalBounds();
                    this._maskContentSizeDiff = new PIXI.Point(t.right - this._maskSize.width, t.bottom - this._maskSize.height);
                    const e = this._maskContentSizeDiff.x > 0,
                        i = this._maskContentSizeDiff.y > 0;
                    this._scrollBarHorizontal.setBarScale(this._scrollMask.width, t.right), this._scrollBarVertical.setBarScale(this._scrollMask.height, t.bottom), this._hasScroll.x != e && this.setScrollTarget(this, 0, void 0), this._hasScroll.y != i && this.setScrollTarget(this, void 0, 0), this._hasScroll.x = e, this._hasScroll.y = i, this._hasScroll.x && this._scrollBarHorizontal.resize(this._scrollMask.width, t.right), this._hasScroll.y && this._scrollBarVertical.resize(this._scrollMask.height, t.bottom), this._scrollBarHorizontal.enable(this._hasScroll.x && this._defaultAllowedDirections.x), this._scrollBarVertical.enable(this._hasScroll.y && this._defaultAllowedDirections.y), this._content.enable(this._hasScroll.x && this._defaultAllowedDirections.x || this._hasScroll.y && this._defaultAllowedDirections.y), this._mouseScrollEvent.enable(this._hasScroll.x && this._defaultAllowedDirections.x || this._hasScroll.y && this._defaultAllowedDirections.y)
                }
                updateHitArea() {
                    this._content.hitArea = new PIXI.Rectangle(-this._content.x, -this._content.y, this._maskSize.width, this._maskSize.height)
                }
                clamp(t, e, i) {
                    return Math.max(e, Math.min(t, i))
                }
                animate() {
                    this._scrollTarget.x = this.clamp(this._scrollTarget.x, -Math.abs(this._maskContentSizeDiff.x), 0), this._scrollTarget.y = this.clamp(this._scrollTarget.y, -Math.abs(this._maskContentSizeDiff.y), 0), this._content.setScrollPosition(this._scrollTarget).eventCallback("onComplete", (() => this.updateHitArea())), this._scrollBarVertical.setScrollPosition(this._scrollTarget), this._scrollBarHorizontal.setScrollPosition(this._scrollTarget)
                }
                setActiveScroller(t) {
                    this._activeScroller != t && (this._content.abort(), this._directionAllowed.x = this._defaultAllowedDirections.x, this._directionAllowed.y = this._defaultAllowedDirections.y), this._activeScroller = t, this._activeScroller == this._mouseScrollEvent && (this._directionAllowed.x = this._defaultAllowedDirections.x, this._directionAllowed.y = this._defaultAllowedDirections.y)
                }
                checkAllowedDirections(t, e) {
                    this._directionAllowed.x && this._directionAllowed.y && (Math.abs(e) > Math.abs(t) ? (this._directionAllowed.y = !0, this._directionAllowed.x = !this._hasScroll.y) : (this._directionAllowed.y = !this._hasScroll.x, this._directionAllowed.x = !0))
                }
            }
            e.GUIScrollContainer = s
        },
        7002: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.MouseScroller = void 0;
            var i = PIXI.InteractionEvent;
            e.MouseScroller = class {
                constructor(t) {
                    this.onMouseScrollLocal = t => {
                        const e = t;
                        e.preventDefault(), void 0 !== e.deltaX ? this._delta.set(e.deltaX, e.deltaY) : this._delta.set(1 == e.axis ? 60 * e.detail : 0, 2 == e.axis ? 60 * e.detail : 0), this._scrollContainer.setScrollDelta(this, -this._delta.x, -this._delta.y)
                    }, this.onHover = t => {
                        this._bound || (document.addEventListener("mousewheel", this.onMouseScrollLocal, {
                            once: !1,
                            passive: !1
                        }), document.addEventListener("DOMMouseScroll", this.onMouseScrollLocal, {
                            once: !1,
                            passive: !1
                        }), this._bound = !0)
                    }, this.onMouseOut = t => {
                        this._bound && (document.removeEventListener("mousewheel", this.onMouseScrollLocal), document.removeEventListener("DOMMouseScroll", this.onMouseScrollLocal), this._bound = !1)
                    }, this.name = "MouseScroller", this._scrollContainer = t, this._delta = new PIXI.Point, this._bound = !1
                }
                reAddHoverListener() {
                    this.onHover(new i)
                }
                enable(t) {
                    t ? this.startEvent() : this.stopEvent(), this._enabled = t
                }
                stopEvent() {
                    this._bound && (document.removeEventListener("mousewheel", this.onMouseScrollLocal), document.removeEventListener("DOMMouseScroll", this.onMouseScrollLocal), this._bound = !1), this._enabled && (this._scrollContainer.removeListener("mouseover", this.onHover), this._scrollContainer.removeListener("mouseout", this.onMouseOut))
                }
                startEvent() {
                    this._enabled || (this._scrollContainer.on("mouseover", this.onHover), this._scrollContainer.on("mouseout", this.onMouseOut), this._scrollContainer.interactive = !0)
                }
            }
        },
        4274: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ScrollBar = void 0;
            const n = i(5269),
                r = i(6358);
            class o extends n.Scroller {
                constructor(t, e, i, n) {
                    super(t), this._useFadeTween = !0, this.name = "ScrollBar" + (e ? "Vertical" : "Horizontal"), this._vertical = e, this._margin = new PIXI.Point(5, 5), this._useFadeTween = i, this._gfx = new PIXI.Graphics, this._scrollConfig = n, this.addChild(this._gfx)
                }
                setBarScale(t, e) {
                    this._barScale = t / e
                }
                resize(t, e) {
                    this._barScale = t / e;
                    const i = this._barScale * t;
                    let n, r = this._scrollConfig.thickness;
                    this._gfx.clear(), this._vertical ? (n = new PIXI.Rectangle(-6 * r, this._margin.y, 6 * r, i - 2 * this._margin.y), this._gfx.beginFill(this._scrollConfig.color, 1), this._gfx.drawRoundedRect(-(r + this._margin.x), this._margin.y, r, i - 2 * this._margin.y, 5)) : (n = new PIXI.Rectangle(this._margin.x, -6 * r, i - 2 * this._margin.x, 6 * r), this._gfx.beginFill(this._scrollConfig.color, 1), this._gfx.drawRect(this._margin.x, -(r + this._margin.y), i - 2 * this._margin.x, r)), this.hitArea = n, this._gfx.endFill()
                }
                setScrollPosition(t) {
                    return this.alpha = 1, this._fadeTween && this._fadeTween.kill(), this._useFadeTween && (this._fadeTween = r.TweenLite.to(this, .2, {
                        duration: .2,
                        alpha: .4,
                        delay: 1
                    })), this._scrollTween && this._scrollTween.kill(), this._vertical ? this._scrollTween = r.TweenLite.to(this.position, .2, {
                        duration: .2,
                        y: -t.y * this._barScale,
                        ease: r.Power2.easeOut
                    }) : this._scrollTween = r.TweenLite.to(this.position, .2, {
                        duration: .2,
                        x: -t.x * this._barScale,
                        ease: r.Power2.easeOut
                    }), this._scrollTween
                }
                start() {
                    super.start(), this.visible = this._enabled
                }
                stop() {
                    super.stop(), this.visible = this._enabled
                }
                calculateDelta(t, e) {
                    let i = 0,
                        n = 0;
                    return this._vertical ? n = (t.y - e.y) / -this._barScale : i = (t.x - e.x) / -this._barScale, new PIXI.Point(i, n)
                }
            }
            e.ScrollBar = o
        },
        5269: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Scroller = void 0;
            const n = i(6358);
            class r extends PIXI.Container {
                constructor(t) {
                    super(), this._enabled = !1, this.onDragStart = t => {
                        this.data = t.data, this._prevScrollTarget = this.data.getLocalPosition(this.parent), this.setScrollDelta(this._prevScrollTarget, !0), this.on("pointermove", this.onDragMove)
                    }, this.onDragMove = t => {
                        if (this.data) {
                            const t = this.data.getLocalPosition(this.parent);
                            this.setScrollDelta(t)
                        }
                    }, this.onDragEnd = t => {
                        if (this.data) {
                            const t = this.data.getLocalPosition(this.parent);
                            this.slideToStop(), this.setScrollDelta(t)
                        }
                        this.data = void 0, this._prevScrollTarget = void 0, this.removeListener("pointermove", this.onDragMove)
                    }, this.name = "ScrollContent", this._speed = new PIXI.Point(0, 0), this._timestamp = 0, this._scrollContainer = t, this.enable(!1), this.setScrollPosition(new PIXI.Point(0, 0))
                }
                enable(t) {
                    t ? this.start() : this.stop()
                }
                start() {
                    this._enabled || (this._enabled = !0, this.interactive = !0, this.buttonMode = !0, this.on("pointerdown", this.onDragStart), this.on("pointerup", this.onDragEnd), this.on("pointerupoutside", this.onDragEnd))
                }
                stop() {
                    this.interactive = !1, this.buttonMode = !1, this.removeListener("pointerdown", this.onDragStart), this.removeListener("pointerup", this.onDragEnd), this.removeListener("pointerupoutside", this.onDragEnd), this._enabled = !1
                }
                setScrollDelta(t, e = !1) {
                    const i = e ? void 0 : this,
                        n = this.calculateDelta(t, this._prevScrollTarget);
                    this._scrollContainer.setScrollDelta(i, n.x, n.y), this._prevScrollTarget = t
                }
                slideToStop() {
                    Math.abs(this._speed.x) < 2 && Math.abs(this._speed.y) < 2 || (this._slideTween = new n.TweenLite(this._speed, 2, {
                        x: 0,
                        y: 0,
                        ease: n.Power2.easeOut,
                        onUpdate: () => {
                            this._scrollContainer.setScrollDelta(this, this._speed.x, this._speed.y)
                        },
                        onComplete: () => {
                            this._scrollContainer.setScrollDelta(void 0, this._speed.x, this._speed.y)
                        }
                    }))
                }
                setScrollPosition(t) {
                    return null == this._slideTween && this.calcSpeed(t), n.TweenLite.to(this.position, .2, {
                        x: t.x,
                        y: t.y,
                        ease: n.Power2.easeOut
                    })
                }
                abort() {
                    this._slideTween && (this._slideTween.kill(), this._slideTween = void 0, this._speed.set(0, 0))
                }
                calcSpeed(t) {
                    const e = Date.now(),
                        i = e - this._timestamp;
                    let n = new PIXI.Point(Math.abs(this.position.x) - Math.abs(t.x), Math.abs(this.position.y) - Math.abs(t.y));
                    this._speed.set(Math.round(n.x / i), Math.round(n.y / i)), this._timestamp = e
                }
                calculateDelta(t, e) {
                    return new PIXI.Point(t.x - e.x, t.y - e.y)
                }
            }
            e.Scroller = r
        },
        1028: (t, e) => {
            "use strict";
            var i, n;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiLayout = e.Direction = e.Align = void 0, (n = e.Align || (e.Align = {}))[n.LEFT = 0] = "LEFT", n[n.TOP = 0] = "TOP", n[n.CENTER = .5] = "CENTER", n[n.RIGHT = 1] = "RIGHT", n[n.BOTTOM = 1] = "BOTTOM",
                function (t) {
                    t[t.VERTICAL = 0] = "VERTICAL", t[t.HORIZONTAL = 1] = "HORIZONTAL"
                }(i = e.Direction || (e.Direction = {}));
            class r {
                static justify(t, e, n, o) {
                    n = null != n ? n : 0, o = null != o ? o : i.HORIZONTAL;
                    let s = 0;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e].getLocalBounds();
                        o == i.VERTICAL ? s += n.bottom : s += n.right
                    }
                    const a = (e - s) / (t.length - 1);
                    r.align(t, a, n, o)
                }
                static align(t, e, n, r) {
                    e = null != e ? e : 0, n = null != n ? n : 0, r = null != r ? r : i.HORIZONTAL;
                    let o = 0,
                        s = 0;
                    for (let n = 0; n < t.length; n++) {
                        const a = t[n],
                            l = a.getLocalBounds();
                        r == i.VERTICAL ? (a.position.y = o, o += l.bottom + e, s = l.right > s ? l.right : s) : (a.position.x = o, o += l.right + e, s = l.bottom > s ? l.bottom : s)
                    }
                    for (let e of t) {
                        const t = e.getLocalBounds();
                        r == i.VERTICAL ? e.position.x = (s - t.right) * n : e.position.y = (s - t.bottom) * n
                    }
                }
                static modifyMargin(t, e, n, r) {
                    e = null != e ? e : 0, n = null != n ? n : i.HORIZONTAL;
                    let o = 0;
                    const s = t.getLocalBounds();
                    let a, l, h = 0,
                        u = 0;
                    r && (a = r.getLocalBounds(), l = r.getGlobalPosition(), h = a.bottom + l.y, u = a.right + l.x), n == i.VERTICAL ? (o = r ? h : 0, o += s.bottom + e, t.position.y = o) : (o = r ? u : 0, o += s.right + e, t.position.x = o)
                }
                static getLargestSize(t) {
                    const e = new PIXI.Point(0, 0);
                    for (let i of t) {
                        const t = i.getBounds();
                        e.x = t.right > e.x ? t.right : e.x, e.y = t.bottom > e.y ? t.bottom : e.y
                    }
                    return e
                }
                static gridLayout(t, e) {
                    let i = 0,
                        n = 0;
                    for (let e of t) {
                        const t = e.getBounds();
                        i = t.width > i ? t.width : i, n = t.height > n ? t.height : n
                    }
                    const r = Math.floor(e / i);
                    for (let e = 0; e < t.length; e++) {
                        const o = t[e];
                        o.x = Math.floor(e % r) * i, o.y = Math.floor(e / r) * n
                    }
                }
                static offset(t, e = 0, i = 0) {
                    for (let n of t) n.x += e, n.y += i
                }
            }
            e.GuiLayout = r
        },
        9756: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GuiUtils = void 0, e.GuiUtils = class {
                static getAlphaFromARGB(t) {
                    return (t >> 24 & 255) / 255
                }
                static getColorFromARGB(t) {
                    return 16777215 & t
                }
                static getARGB(t, e = 1) {
                    return 255 * e << 24 | t
                }
                static pixiMatrixToCSSMatrix(t) {
                    return "matrix(" + [t.a, t.b, t.c, t.d, t.tx, t.ty].join(",") + ")"
                }
                static getDOMRelativeWorldTransform(t, e, i) {
                    let n = e.worldTransform.clone();
                    return n.scale(t.resolution, t.resolution), n.scale(i.width / t.width, i.height / t.height), n
                }
            }
        },
        8162: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlideShow = void 0;
            const n = i(6358),
                r = i(2974),
                o = i(8760),
                s = i(5654),
                a = i(9834),
                l = i(3606),
                h = i(9756),
                u = i(1028),
                c = i(8853),
                d = i(6659);
            var p;
            ! function (t) {
                t[t.LEFT = -1] = "LEFT", t[t.NONE = 0] = "NONE", t[t.RIGHT = 1] = "RIGHT"
            }(p || (p = {}));
            class f extends PIXI.Container {
                get slidePixelsPerSecond() {
                    return this._slidePixelsPerSecond
                }
                set slidePixelsPerSecond(t) {
                    this._slidePixelsPerSecond = t
                }
                get pageFlipDelay() {
                    return this._pageFlipDelay
                }
                set pageFlipDelay(t) {
                    this._pageFlipDelay = t
                }
                get isSinglePaged() {
                    return !!this._pages && 1 == this._pages.length
                }
                constructor(t, e, i, n) {
                    super(), this._pageAnimations = [], this._slideDistance = 0, this._pageFlipDelay = f.DEFAULT_PAGE_FLIP_DELAY, this._slidePixelsPerSecond = 4e3, this._currentIndex = -1, this._colors = n, this._slideShowBackground = this.createSlideShowBackground(n.backgroundColor, n.backgroundAlpha), this._borderTop = e, this._borderBottom = i, this._borderBottom.position.y = this._slideShowBackground.height, this.setupPages(t), this.createNavigation(), this.addChild(this._slideShowBackground, this._pageContainer, this._borderTop, this._borderBottom, this._navButtonsContainer, this._navBulletsContainer)
                }
                createNavigation() {
                    if (this._pageContainer.position.set(0, 195), this.isSinglePaged) this._navButtonsContainer = new PIXI.Container, this._navBulletsContainer = new PIXI.Container;
                    else {
                        this._navBulletsContainer = this.createNavBullets(this._pages.length), this._navBulletsContainer.name = "_navBulletsContainer", this._navButtonsContainer = this.createNavButtons();
                        const t = .5 * this._navBulletsContainer.width + 15;
                        this._navButtons[0].position.set(-t, .5 * this._navBulletsContainer.height), this._navButtons[1].position.set(t, .5 * this._navBulletsContainer.height), this._navButtonsContainer.name = "_navButtonsContainer", this._navBulletsContainer.position.set(0, 410), this._navButtonsContainer.position.set(0, 410)
                    }
                }
                createSlideShowBackground(t = 0, e = .4) {
                    const i = new PIXI.Container,
                        n = new PIXI.Sprite(PIXI.Texture.WHITE);
                    return n.width = 1680, n.height = 390, n.anchor.set(.5, 0), n.tint = t, n.alpha = e, i.addChild(n), i
                }
                changeWidth(t) {
                    this._slideDistance = .5 * t + 360
                }
                resize() {
                    for (let t of this._pages) t.resize()
                }
                startDrag() {
                    null != this._scheduledFlip && this._scheduledFlip.isActive() && this._scheduledFlip.pause()
                }
                endDrag() {
                    null != this._scheduledFlip && this._scheduledFlip.paused() && this._scheduledFlip.resume()
                }
                start() {
                    this.isSinglePaged ? this.showSinglePage() : this.navToIndex(0)
                }
                stop() {
                    for (let t of this._pages) t.enable(!1);
                    this._scheduledFlip && this._scheduledFlip.kill(), this._currentPageSwitchAnimation && this._currentPageSwitchAnimation.isActive() && (this._currentPageSwitchAnimation.progress(1), this._currentPageSwitchAnimation.kill())
                }
                showSinglePage() {
                    this._pages[0].position.set(0, 0), this._pages[0].alpha = 1, this._pages[0].visible = !0
                }
                scheduleNextAutoFlip() {
                    this._scheduledFlip && this._scheduledFlip.kill(), this._scheduledFlip = new n.TweenLite(this, this._pageFlipDelay, {
                        onComplete: () => {
                            this.next()
                        }
                    })
                }
                next() {
                    this.navToIndex(this._currentIndex + 1, p.LEFT)
                }
                prev() {
                    this.navToIndex(this._currentIndex - 1, p.RIGHT)
                }
                navToIndex(t, e = p.NONE) {
                    let i = t % this._pages.length;
                    i < 0 && (i += this._pages.length), this.switchToPage(i, e);
                    for (let t of this._navBullets) t.button.toggled = t.index == i, t.button.enable(t.index != i);
                    this._currentIndex = i, this.scheduleNextAutoFlip()
                }
                switchToPage(t, e) {
                    const i = new n.TimelineLite;
                    this._currentIndex >= 0 && this._pages[this._currentIndex].enable(!1), this._pages[t].enable(!1), this._currentIndex >= 0 && i.add(this.createTransitionAnimation(this._currentIndex, this._pageBackgrounds[this._currentIndex], !1, e)), i.add(this.createTransitionAnimation(t, this._pageBackgrounds[t], !0, e), 0), i.add((() => {
                        this._pages[t].enable(!0)
                    })), this._currentPageSwitchAnimation && this._currentPageSwitchAnimation.isActive() && (this._currentPageSwitchAnimation.progress(1), this._currentPageSwitchAnimation.kill()), this._currentPageSwitchAnimation = i
                }
                createTransitionAnimation(t, e, i, r) {
                    const o = this._pages[t],
                        s = this._slideDistance * r;
                    let a = Math.max(Math.abs(s) - Math.abs(o.position.x), 0) / this._slidePixelsPerSecond;
                    a = 0 == s ? .2 : a;
                    const l = new n.TimelineLite;
                    return i ? (l.add((() => {
                        o.position.x = -s, o.visible = !0, e.visible = !0, e.alpha = 0, this._pageBackgroundContainer.addChild(e)
                    })), l.add([new n.TweenLite(e, a, {
                        alpha: 1,
                        ease: n.Linear.easeNone
                    }), new n.TweenLite(o, a, {
                        alpha: 1,
                        ease: n.Linear.easeNone
                    }), new n.TweenLite(o.position, a, {
                        x: 0
                    })])) : (l.add([new n.TweenLite(e, a, {
                        alpha: 0,
                        ease: n.Linear.easeNone
                    }), new n.TweenLite(o, a, {
                        alpha: 0,
                        ease: n.Linear.easeNone
                    }), new n.TweenLite(o.position, a, {
                        x: s
                    })]), l.eventCallback("onComplete", (() => {
                        o.visible = !1, e.visible = !1, o.position.x = 0, e.alpha = 0
                    }))), l
                }
                createNavBullets(t) {
                    const e = new PIXI.Container;
                    this._navBullets = [];
                    for (let i = 0; i < t; i++) {
                        const t = new d.SlideShowBullet(i, (t => this.navToIndex(i)), this._colors.bulletColor);
                        this._navBullets.push(e.addChild(t))
                    }
                    return u.GuiLayout.align(this._navBullets, 10, u.Align.CENTER, u.Direction.HORIZONTAL), e.pivot.set(.5 * e.width, 0), e
                }
                createNavButtons() {
                    const t = new PIXI.Container,
                        e = s.SvgLoader.getSvgTexture(a.GuiDefaultTextures.NAV_ARROW).clone();
                    e.rotate = 12;
                    const i = new r.PointerStateIconSet(new o.Icon(e)),
                        n = new l.PointerStateColorSet(h.GuiUtils.getARGB(this._colors.bulletColor, 1), h.GuiUtils.getARGB(this._colors.bulletColor, .25)),
                        u = new c.IconButton("navPrev", i, n);
                    u.addClickCallback((() => this.prev())), u.enable(!0), u.pivot.set(u.width, .5 * u.height);
                    const d = s.SvgLoader.getSvgTexture(a.GuiDefaultTextures.NAV_ARROW),
                        p = new r.PointerStateIconSet(new o.Icon(d)),
                        f = new l.PointerStateColorSet(h.GuiUtils.getARGB(this._colors.bulletColor, 1), h.GuiUtils.getARGB(this._colors.bulletColor, .25)),
                        g = new c.IconButton("navPrev", p, f);
                    return g.addClickCallback((() => this.next())), g.enable(!0), g.pivot.set(0, .5 * g.height), this._navButtons = [u, g], t.addChild(u, g), t
                }
                setupPages(t) {
                    this._pages = t, this._pageBackgroundContainer = new PIXI.Container, this._pageBackgroundContainer.name = "_pageBackgroundContainer", this._pageBackgrounds = [], this._pageContainer = new PIXI.Container, this._pageContainer.name = "_pageContainer", this._pageContainer.addChild(this._pageBackgroundContainer);
                    for (let e of t) {
                        e.visible = !1, e.alpha = 0, this.isSinglePaged || e.setSwipeCallbacks((() => this.startDrag()), (() => this.endDrag()), (() => this.prev()), (() => this.next())), this._pageContainer.addChild(e);
                        const t = this.createPageBackground(e);
                        this._pageBackgrounds.push(t), this._pageBackgroundContainer.addChild(t)
                    }
                }
                createPageBackground(t) {
                    const e = new PIXI.Sprite(PIXI.Texture.WHITE);
                    return null != t.backgroundColor ? (e.anchor.set(.5, .5), e.width = 1680, e.height = 390, e.visible = !1, e.alpha = 0, e.tint = t.backgroundColor) : e.texture = PIXI.Texture.EMPTY, e
                }
            }
            f.DEFAULT_PAGE_FLIP_DELAY = 10, e.SlideShow = f
        },
        6659: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlideShowBullet = void 0;
            const n = i(5991),
                r = i(2974),
                o = i(8760),
                s = i(5654),
                a = i(9834),
                l = i(3606),
                h = i(9756);
            class u extends PIXI.Container {
                constructor(t, e, i = 16777215) {
                    super();
                    const u = new r.PointerStateIconSet(new o.Icon(s.SvgLoader.getSvgTexture(a.GuiDefaultTextures.BULLET_LARGE))),
                        c = new r.PointerStateIconSet(new o.Icon(s.SvgLoader.getSvgTexture(a.GuiDefaultTextures.BULLET_SMALL))),
                        d = new l.PointerStateColorSet(h.GuiUtils.getARGB(i, 1));
                    this.index = t, this.button = new n.IconToggleButton(`navBullet[${t}]`, u, d, c), this.button.addClickCallback(e), this.button.enable(!0), this.addChild(this.button)
                }
            }
            e.SlideShowBullet = u
        },
        2960: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlideShowPage = void 0;
            const n = i(3663),
                r = i(6358),
                o = i(155);
            class s extends PIXI.Container {
                constructor(t, e, i, r = !0) {
                    if (super(), this._snapBackDistance = 360, this.onDragStart = t => {
                        this.data = t.data, this._startPos = new PIXI.Point(this.position.x, this.position.y), this._prevScrollTarget = this.data.getLocalPosition(this.parent), this.setScrollDelta(this._prevScrollTarget), this.on("pointermove", this.onDragMove), this._startDragCallback && this._startDragCallback()
                    }, this.onDragMove = t => {
                        if (this.data) {
                            const t = this.data.getLocalPosition(this.parent);
                            this.setScrollDelta(t), Math.abs(this.position.x) - Math.abs(this._startPos.x) > this._snapBackDistance && this.onDragEnd()
                        }
                    }, this.onDragEnd = t => {
                        if (this.data) {
                            const t = this.data.getLocalPosition(this.parent);
                            this.setScrollDelta(t), this.snap()
                        }
                        this.data = void 0, this._prevScrollTarget = void 0, this.removeListener("pointermove", this.onDragMove), this._endDragCallback && this._endDragCallback()
                    }, this.backgroundColor = i, null != t) {
                        const e = new PIXI.Sprite(t);
                        e.anchor.x = r ? 1 : 0, e.anchor.y = .5, e.position.x = r ? -10 : 10, this.addChild(e)
                    }
                    if (null != e) {
                        const t = new o.NLCText(e, n.GuiDefaults.INTRO_PAGE_TEXT);
                        t.anchor.x = r ? 0 : 1, t.anchor.y = .5, t.position.x = r ? 10 : -10, this.addChild(t)
                    }
                    this.hitArea = new PIXI.Rectangle(-840, -195, 1680, 390)
                }
                resize() { }
                setSwipeCallbacks(t, e, i, n) {
                    this._startDragCallback = t, this._endDragCallback = e, this._prevCallback = i, this._nextCallback = n
                }
                enable(t) {
                    t ? this.start() : this.stop()
                }
                start() {
                    this._enabled || (this._enabled = !0, this.interactive = !0, this.buttonMode = !0, this.on("pointerdown", this.onDragStart), this.on("pointerup", this.onDragEnd), this.on("pointerupoutside", this.onDragEnd))
                }
                stop() {
                    this.interactive = !1, this.buttonMode = !1, this.removeListener("pointerdown", this.onDragStart), this.removeListener("pointerup", this.onDragEnd), this.removeListener("pointerupoutside", this.onDragEnd), this._enabled = !1
                }
                setScrollDelta(t) {
                    const e = this.calculateDelta(t, this._prevScrollTarget);
                    this.position.x += e.x, this._prevScrollTarget = t
                }
                calculateDelta(t, e) {
                    return new PIXI.Point(t.x - e.x, t.y - e.y)
                }
                snap() {
                    Math.abs(this.position.x) - Math.abs(this._startPos.x) <= this._snapBackDistance ? new r.TweenLite(this.position, .2, {
                        x: this._startPos.x,
                        y: this._startPos.y
                    }) : this.position.x > this._startPos.x ? this._prevCallback && this._prevCallback() : this._nextCallback && this._nextCallback()
                }
            }
            e.SlideShowPage = s
        },
        4968: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.APIBetType = void 0, (i = e.APIBetType || (e.APIBetType = {})).NORMAL_BET = "normalBet", i.FREE_BET = "freeBet", i.ZERO_BET = "zeroBet", i.GAMBLE_BET = "gambleBet", i.PICK_AND_CLICK_BET = "pickAndClickBet", i.FEATURE_BET = "featureBet"
        },
        9181: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.APIErrorCode = void 0, (i = e.APIErrorCode || (e.APIErrorCode = {}))[i.UNKNOWN = 0] = "UNKNOWN", i[i.JAVASCRIPT = -1001] = "JAVASCRIPT", i[i.PROMISE = -1002] = "PROMISE", i[i.COMMUNICATION = -1003] = "COMMUNICATION", i[i.REPLAY = -1004] = "REPLAY", i[i.GRAPHICS = -1005] = "GRAPHICS", i[i.PLUGIN_LAUNCH = -1007] = "PLUGIN_LAUNCH", i[i.FORBIDDEN = 403] = "FORBIDDEN", i[i.BAD_GATEWAY = 502] = "BAD_GATEWAY", i[i.SESSION_TIMEOUT = 1007] = "SESSION_TIMEOUT", i[i.INSUFFICIENT_FUNDS = 1025] = "INSUFFICIENT_FUNDS", i[i.RESPONSIBLE_GAMING_EXCEEDED = 1026] = "RESPONSIBLE_GAMING_EXCEEDED", i[i.RESPONSIBLE_GAMING_BLOCK = 1030] = "RESPONSIBLE_GAMING_BLOCK", i[i.OPERATOR_ERROR = 1050] = "OPERATOR_ERROR", i[i.OPERATOR_ERROR_NON_FATAL = 1051] = "OPERATOR_ERROR_NON_FATAL", i[i.FRONT_CLIENT_NOT_VALID = 13004] = "FRONT_CLIENT_NOT_VALID", i[i.FRONT_CLIENT_NOT_ACTIVE = 13005] = "FRONT_CLIENT_NOT_ACTIVE", i[i.COUNTRY_BLOCKED = 13043] = "COUNTRY_BLOCKED"
        },
        7185: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.APIEvent = void 0, (i = e.APIEvent || (e.APIEvent = {})).REPLAY_END = "replayEnd", i.DESTROY_RENDERER = "detroyRenderer", i.RE_INIT_RENDERER = "reInitRenderer", i.RE_INIT_RENDERER_DONE = "reInitRendererDone", i.DIALOG = "dialog", i.REALITY_CHECK = "realityCheck", i.MINIMUM_SPIN_TIME = "minSpinTime", i.PENDING_WIN = "pendingWin", i.BET = "bet", i.BALANCE = "balance", i.BET_BOOST = "betBoost", i.BROKE = "broke", i.SET_BALANCE_ID = "setBalanceId", i.BUSY = "busy", i.IDLE = "idle", i.CURRENCY = "currency", i.MESSAGES = "messages", i.WIN = "win", i.GUI_REFRESH = "guiRefresh", i.REFRESH = "refresh", i.TICK = "tick", i.UPDATE_FREE_SPINS = "updateFreeSpins", i.IS_OPEN_GAME_ROUND = "isOpenGameRound", i.FREE_BETS = "freeBets", i.FREE_FEATURE_BETS = "featureBets", i.STATE = "state", i.AUTO_PLAY = "autoplay", i.CONFIG = "config", i.CURRENT_BET = "currentBet", i.FAST_SPIN = "fastspin", i.FEATURE_BET_LEVELS = "featureBetLevels", i.ALLOWED_GAME_FEATURES = "allowedGameFeatures", i.GAME_INFO = "gameInfo", i.GAME_CLIENT_CONFIGURATION = "gameClientConfiguration", i.GAME_CLIENT_CONFIGURATION_APPLIED = "gameClientConfigurationApplied", i.INIT = "init", i.GAME = "game", i.READY = "ready", i.START = "start", i.STARTED = "started", i.STOP = "stop", i.SKIPPABLE = "skippable", i.FINISHING = "finishing", i.DONE = "done", i.FINISH = "finish", i.SKIP = "skip", i.SCREEN = "screen", i.GAMBLE = "gamble", i.GAMBLING = "gambling", i.GAMBLE_DONE = "gambleDone", i.REMAINING_FREE_SPINS = "remainingFreeSpins", i.JACKPOT = "jackpot", i.HOLD = "hold", i.PAUSE = "pause", i.RESUME = "resume", i.HIDDEN = "hidden", i.HALT = "halt", i.MUSIC = "music", i.SFX = "sfx", i.SETTING_CHANGE = "settingChange", i.SETTING_PAGE_CHANGE = "settingPageChange", i.AUDIO_MASTER_MUTED = "soundMaster", i.SOFT_RESET = "softReset", i.FREEZE = "freeze", i.UNFREEZE = "unfreeze", i.ACTION_SPINS_BET = "actionSpinsBet", i.ACTION_SPINS_ROUND_COMPLETE = "actionSpinsRoundComplete", i.ACTION_SPINS_IS_ACTIVE = "actionSpinsActive", i.REPLAY_BASE_URL = "replayBaseUrl", i.SERVER_VERSION = "serverVersion"
        },
        4495: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.APIExternalApiEvent = void 0, (i = e.APIExternalApiEvent || (e.APIExternalApiEvent = {})).EXIT = "exit", i.EXIT_REPLAY = "exit-replay"
        },
        8338: (t, e) => {
            "use strict";
            var i, n;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Device = e.Mute = void 0, (n = e.Mute || (e.Mute = {})).MUTED = "muted", n.UN_MUTED = "un-muted", (i = e.Device || (e.Device = {})).MOBILE = "mobile", i.DESKTOP = "desktop"
        },
        2820: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.APISetting = void 0, (i = e.APISetting || (e.APISetting = {})).LEFT_HAND_MODE = "leftHanded", i.CLOCK = "clock", i.MUSIC = "music", i.SFX = "sfx", i.FAST_SPIN = "fastspin", i.DEVICE_HAS_ROUNDED_CORNERS = "deviceHasRoundedCorners", i.USE_SPACE_TO_SPIN = "useSpaceToSpin", i.BALANCE_ID = "balanceId"
        },
        2111: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FontLoader = void 0;
            const n = i(8296);
            e.FontLoader = class {
                constructor(t) {
                    this._baseUrl = t, this._assetsToLoad = []
                }
                add(t) {
                    this._assetsToLoad.push(t)
                }
                load() {
                    return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve(!0)
                }
                loadInternal(t) {
                    const e = [];
                    for (let i of t) e.push(n.FontCache.addFontFace(i, this._baseUrl));
                    return Promise.all(e).then((t => this.loadComplete(t)))
                }
                loadComplete(t) {
                    return this._assetsToLoad = [], Promise.resolve(!0)
                }
            }
        },
        2408: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ImgLoader = e.ImgAssetConfig = void 0, e.ImgAssetConfig = class {
                constructor(t) {
                    this.name = t, this.url = t
                }
            }, e.ImgLoader = class {
                constructor(t) {
                    this._internalLoader = new PIXI.Loader(t, 1e4), this._assetsToLoad = []
                }
                add(t, e) {
                    this._assetsToLoad.push({
                        name: t,
                        url: e
                    })
                }
                load() {
                    return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve(!0)
                }
                loadInternal(t) {
                    return new Promise(((e, i) => {
                        for (let e of t) this._internalLoader.add(e.name, e.url, {
                            crossOrigin: "*"
                        });
                        this._internalLoader.load(), this._internalLoader.onError.add((() => {
                            i("error loading")
                        })), this._internalLoader.onComplete.add((() => {
                            e(!0)
                        }))
                    }))
                }
                getImgTexture(t) {
                    if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture");
                    return PIXI.utils.TextureCache[t]
                }
                static getImgTexture(t) {
                    if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture");
                    return PIXI.utils.TextureCache[t]
                }
            }
        },
        8379: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SvgAsset = void 0;
            const n = i(4514);
            e.SvgAsset = class {
                constructor(t, e, i) {
                    this._name = t, this._url = e, this._resolution = i.scale, this._svgResource = new PIXI.resources.SVGResource(e, i)
                }
                load() {
                    return new Promise(((t, e) => {
                        this._svgResource.load().then((e => {
                            const i = new PIXI.BaseTexture(e, {
                                resolution: this._resolution
                            }),
                                r = new PIXI.Texture(i),
                                o = new PIXI.Sprite(r),
                                s = PIXI.RenderTexture.create({
                                    width: r.width,
                                    height: r.height
                                });
                            n.NolimitApplication.pixiApp.renderer.render(o, s), PIXI.Texture.addToCache(s, this._name), e.source instanceof HTMLCanvasElement && r.destroy(!0), t(s)
                        }))
                    }))
                }
            }
        },
        5654: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SvgLoader = e.SvgAssetConfig = void 0;
            const n = i(8379);
            e.SvgAssetConfig = class {
                constructor(t, e, i) {
                    this.url = t, this.name = t, this.height = e, this.width = i
                }
            }, e.SvgLoader = class {
                constructor(t, e) {
                    this._baseUrl = t, this._resolution = e, this._assetsToLoad = []
                }
                add(t, e, i, r) {
                    const o = {
                        scale: this._resolution,
                        width: i ? i * this._resolution : void 0,
                        height: r ? r * this._resolution : void 0,
                        autoLoad: !1
                    };
                    this._assetsToLoad.push(new n.SvgAsset(t, this._baseUrl + e, o))
                }
                load() {
                    return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve(!0)
                }
                loadInternal(t) {
                    const e = [];
                    for (let i of t) e.push(i.load());
                    return Promise.all(e).then((t => this.loadComplete(t)))
                }
                loadComplete(t) {
                    return this._assetsToLoad = [], Promise.resolve(!0)
                }
                getSvgTexture(t) {
                    if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture: " + t);
                    return PIXI.utils.TextureCache[t]
                }
                static getSvgTexture(t) {
                    if (!PIXI.utils.TextureCache[t]) throw new Error("Missing texture: " + t);
                    return PIXI.utils.TextureCache[t]
                }
            }
        },
        4267: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TemplateLoader = void 0, e.TemplateLoader = class {
                constructor(t) {
                    this._baseUrl = t, this._assetsToLoad = [], this._loader = new PIXI.Loader(t, 1e4)
                }
                add(t) {
                    this._assetsToLoad.push(t)
                }
                load(t) {
                    if (t)
                        for (let e of t) this.add(e);
                    return this._assetsToLoad.length > 0 ? this.loadInternal(this._assetsToLoad) : Promise.resolve([])
                }
                loadInternal(t) {
                    return new Promise(((e, i) => {
                        for (let e of t) this._loader.add(e.name, e.url, {
                            crossOrigin: "*"
                        });
                        this._loader.onError.add(((t, e, i) => {
                            throw e.destroy(), t
                        })), this._loader.onComplete.add(((t, i) => {
                            for (let t of this._assetsToLoad) t.loadedData = null != i[t.name] ? i[t.name].data : void 0;
                            e(this._assetsToLoad)
                        })), this._loader.load()
                    }))
                }
            }
        },
        8296: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FontCache = void 0;
            const n = i(502),
                r = i(7347);
            class o {
                static get styleElement() {
                    return null == this._styleElement && (this._styleElement = document.createElement("style"), document.head.append(this._styleElement)), this._styleElement
                }
                static get instance() {
                    return null == this._instance && (this._instance = new o), this._instance
                }
                constructor() { }
                static addFontFace(t, e) {
                    if (!o.instance.isFontAdded(t)) {
                        const i = document.createElement("style"),
                            n = o.instance.createStyleString(t, e);
                        i.appendChild(document.createTextNode(n)), document.head.appendChild(i), o.addedFonts.push(o.createSummery(t))
                    }
                    return new r(t.family, {
                        weight: t.weight,
                        style: t.style
                    }).load(null, 1e4).catch((t => {
                        n.NolimitLauncher.apiPlugin.warn(t)
                    }))
                }
                isFontAdded(t) {
                    return o.addedFonts.indexOf(o.createSummery(t)) >= 0
                }
                static createSummery(t) {
                    return `${t.family},${t.weight},${t.style}`
                }
                createStyleString(t, e) {
                    let i = t.weight;
                    return isNaN(parseInt(t.weight)) && (i = parseInt(t.weight)), `\n@font-face {\n    font-family: '${t.family}';\n    src: url('${e + t.url}') format('woff');\n    font-weight: ${i};\n    font-style: ${t.style};\n}`
                }
            }
            o.addedFonts = [], e.FontCache = o
        },
        5383: (t, e) => {
            "use strict";
            var i, n, r;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FontType = e.FontStyle = e.FontWeight = void 0, (r = e.FontWeight || (e.FontWeight = {})).THIN = "100", r.EXTRA_LIGHT = "200", r.ULTRA_LIGHT = "200", r.LIGHT = "300", r.NORMAL = "400", r.REGULAR = "400", r.MEDIUM = "500", r.SEMI_BOLD = "600", r.DEMI_BOLD = "600", r.BOLD = "700", r.EXTRA_BOLD = "800", r.ULTRA_BOLD = "800", r.BLACK = "900", r.HEAVY = "900", (n = e.FontStyle || (e.FontStyle = {})).NORMAL = "normal", n.ITALIC = "italic", n.OBLIQUE = "oblique", (i = e.FontType || (e.FontType = {})).EOT = "embedded-opentype", i.WOFF2 = "woff2", i.WOFF = "woff", i.TTF = "truetype", i.SVG = "svg", i.OTF = "opentype"
        },
        1653: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.OpenSans = void 0;
            const n = i(5383);
            class r { }
            r.FAMILY = "Open Sans", r.BASE_URL = "/node_modules/@nolimit/slot-launcher/resources/default/fonts/opensans/", r.NORMAL_300 = {
                family: r.FAMILY,
                weight: n.FontWeight.LIGHT,
                style: n.FontStyle.NORMAL,
                url: r.BASE_URL + "OpenSans-Light-webfont.woff"
            }, r.ITALIC_300 = {
                family: r.FAMILY,
                weight: n.FontWeight.LIGHT,
                style: n.FontStyle.ITALIC,
                url: r.BASE_URL + "OpenSans-LightItalic-webfont.woff"
            }, r.NORMAL_400 = {
                family: r.FAMILY,
                weight: n.FontWeight.REGULAR,
                style: n.FontStyle.NORMAL,
                url: r.BASE_URL + "OpenSans-Regular-webfont.woff"
            }, r.ITALIC_400 = {
                family: r.FAMILY,
                weight: n.FontWeight.REGULAR,
                style: n.FontStyle.ITALIC,
                url: r.BASE_URL + "OpenSans-Italic-webfont.woff"
            }, r.NORMAL_600 = {
                family: r.FAMILY,
                weight: n.FontWeight.SEMI_BOLD,
                style: n.FontStyle.NORMAL,
                url: r.BASE_URL + "OpenSans-Semibold-webfont.woff"
            }, r.ITALIC_600 = {
                family: r.FAMILY,
                weight: n.FontWeight.SEMI_BOLD,
                style: n.FontStyle.ITALIC,
                url: r.BASE_URL + "OpenSans-SemiboldItalic-webfont.woff"
            }, r.NORMAL_700 = {
                family: r.FAMILY,
                weight: n.FontWeight.BOLD,
                style: n.FontStyle.NORMAL,
                url: r.BASE_URL + "OpenSans-Bold-webfont.woff"
            }, r.ITALIC_700 = {
                family: r.FAMILY,
                weight: n.FontWeight.BOLD,
                style: n.FontStyle.ITALIC,
                url: r.BASE_URL + "OpenSans-BoldItalic-webfont.woff"
            }, r.NORMAL_800 = {
                family: r.FAMILY,
                weight: n.FontWeight.EXTRA_BOLD,
                style: n.FontStyle.NORMAL,
                url: r.BASE_URL + "OpenSans-ExtraBold-webfont.woff"
            }, r.ITALIC_800 = {
                family: r.FAMILY,
                weight: n.FontWeight.EXTRA_BOLD,
                style: n.FontStyle.ITALIC,
                url: r.BASE_URL + "OpenSans-ExtraBoldItalic-webfont.woff"
            }, e.OpenSans = r
        },
        1740: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isApiPlugin = void 0, e.isApiPlugin = function (t) {
                return void 0 !== t.bet
            }
        },
        9785: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isAutoPlayPlugin = void 0, e.isAutoPlayPlugin = function (t) {
                return void 0 !== t.updateData && void 0 !== t.cancelAutoPlay
            }
        },
        8836: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isGamblePlugin = void 0, e.isGamblePlugin = function (t) {
                return void 0 !== t.hasGamble && void 0 !== t.startGamble
            }
        },
        57: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isGamePlugin = void 0, e.isGamePlugin = function (t) {
                return void 0 !== t.getPaytable
            }
        },
        8778: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isJackpotPlugin = e.JackpotPluginEvents = void 0;
            class i { }
            i.SPIN_COMPLETE = "jackpotSpinComplete", e.JackpotPluginEvents = i, e.isJackpotPlugin = function (t) {
                return void 0 !== t.addOnSpinCompleteCallback && void 0 !== t.isActive
            }
        },
        1726: (t, e) => {
            "use strict";
            var i;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isKeypadPlugin = e.KeypadPluginEvents = void 0, (i = e.KeypadPluginEvents || (e.KeypadPluginEvents = {})).DISPLAY_BET_UPDATE = "KeypadPlugin_displayBetUpdate", i.USER_BET_UPDATE = "KeypadPlugin_userBetUpdate", e.isKeypadPlugin = function (t) {
                return void 0 !== t.setWin && void 0 !== t.setZeroBetSpinCounter
            }
        },
        424: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isPromotionPlugin = void 0, e.isPromotionPlugin = function (t) {
                return void 0 !== t.open && void 0 !== t.close
            }
        },
        6946: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isSoundPlugin = void 0, e.isSoundPlugin = function (t) {
                return void 0 !== t.isLoaded && void 0 !== t.player
            }
        },
        5409: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BonusFeatureHandler = void 0;
            const n = i(7185),
                r = i(2757),
                o = i(8680);
            class s {
                get availableNames() {
                    return this._availableNames
                }
                get availableTypes() {
                    return this._availableTypes
                }
                get notAllowedFeatures() {
                    return this._nowAllowedFeatures
                }
                constructor(t) {
                    this.featureBetLevelsChangeCallbacks = [], this._allowedGameFeatures = [], this.allTypesByCategory = {
                        [r.GameFeatureCategory.BONUS_BUY]: ["FREESPIN", "FEATURE_BUY"],
                        [r.GameFeatureCategory.BOOSTED_BET]: ["BOOSTED_BET_X_ROWS", "BOOSTED_BET_LOCKED_REELS"]
                    }, this._bonusFeatureData = [], this._nowAllowedFeatures = [], this._hasInit = !1, this.hasInitCallbacks = [], this.onInit = t => {
                        if (t.featureBuyTimesBetValue) {
                            for (let e of t.featureBuyTimesBetValue) this._bonusFeatureData.push(new r.BonusFeatureData(e));
                            this.updateFeatureBetLevels()
                        }
                        this._hasInit = !0;
                        for (let t of this.hasInitCallbacks) t();
                        this.hasInitCallbacks = [], this.checkAllowedFeatures();
                        for (let t of this._bonusFeatureData) t.betLevels.length && (this._availableTypes.add(t.type), this._availableNames.add(t.name));
                        this._api.events.on(n.APIEvent.FEATURE_BET_LEVELS, this.onFeatureBetLevels)
                    }, this.onFeatureBetLevels = t => {
                        let e = s.isFeatureBetLevelsChanged(this._inputFeatureBetLevels, t);
                        if (this._inputFeatureBetLevels = t, e) {
                            this.updateFeatureBetLevels();
                            for (let t of this.featureBetLevelsChangeCallbacks) t(this._inputFeatureBetLevels)
                        }
                    }, this._api = t, this._availableTypes = new Set, this._availableNames = new Set, this._api.events.once(n.APIEvent.ALLOWED_GAME_FEATURES, (t => {
                        this._allowedGameFeatures = Array.isArray(t) ? t : t.allowedGameFeatures, this.checkAllowedFeatures()
                    })), this._api.events.once(n.APIEvent.FEATURE_BET_LEVELS, (t => {
                        this._inputFeatureBetLevels = t
                    })), this._api.events.on(n.APIEvent.INIT, this.onInit)
                }
                checkAllowedFeatures() {
                    for (let t = this._bonusFeatureData.length - 1; t >= 0; t--) {
                        const e = this._bonusFeatureData[t];
                        if (this._allowedGameFeatures.indexOf(e.name) < 0) {
                            const e = this._bonusFeatureData.splice(t, 1)[0];
                            this._nowAllowedFeatures.push(e)
                        }
                    }
                }
                updateFeatureBetLevels() {
                    for (let t of this._bonusFeatureData) t.updateBetLevels(this._inputFeatureBetLevels);
                    o.Logger.logDev("[BonusFeatureHandler] updateFeatureBetLevels :", this._bonusFeatureData)
                }
                addOnFeatureBetLevelsChangeCallback(t) {
                    this.featureBetLevelsChangeCallbacks.push(t)
                }
                static isFeatureBetLevelsChanged(t = {}, e = {}) {
                    const i = Object.keys(e);
                    if (Object.keys(t).length == i.length) {
                        for (let n = 0; n < i.length; n++)
                            if (s.getMaxFromArray(e[i[n]]) != s.getMaxFromArray(t[i[n]])) return !0;
                        return !1
                    }
                    return !0
                }
                static getMaxFromArray(t) {
                    let e = Number.MIN_VALUE;
                    for (let i = 0; i < t.length; i++) e = Math.max(e, +t[i]);
                    return e
                }
                getFeatureDataByTypes(t) {
                    let e = [];
                    for (let i of t) e = e.concat(this.getFeatureDataByType(i));
                    return e
                }
                getFeatureDataByType(t) {
                    let e = [];
                    for (let i of this._bonusFeatureData) i.type === t && e.push(i);
                    return e
                }
                getFeatureDataByNames(t) {
                    let e = [];
                    for (let i of t) e = e.concat(this.getFeatureDataByName(i));
                    return e
                }
                getFeatureDataByName(t) {
                    for (let e of this._bonusFeatureData)
                        if (e.name === t) return e
                }
                hasAnyType(t) {
                    return this.findAnyInSet(this.availableTypes, t)
                }
                hasAnyName(t) {
                    return this.findAnyInSet(this.availableNames, t)
                }
                findAnyInSet(t, e) {
                    let i = !1;
                    for (let n of e)
                        if (i = t.has(n), i) return i;
                    return i
                }
                hasInit() {
                    return this._hasInit ? Promise.resolve(!0) : new Promise(((t, e) => {
                        this.hasInitCallbacks.push((() => {
                            t(!0)
                        }))
                    }))
                }
            }
            e.BonusFeatureHandler = s
        },
        2757: (t, e) => {
            "use strict";
            var i, n;
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameFeatureNames = e.GameFeatureCategory = e.BonusFeatureData = void 0, e.BonusFeatureData = class {
                constructor(t) {
                    this.name = t.name, this.type = t.type, this.price = t.price, this.betLevels = []
                }
                updateBetLevels(t) {
                    for (let e in t) e == this.name && (this.betLevels = t[e])
                }
                getMaxBet() {
                    let t = Number.MIN_VALUE;
                    for (let e = 0; e < this.betLevels.length; e++) t = Math.max(t, +this.betLevels[e]);
                    return t
                }
            }, (n = e.GameFeatureCategory || (e.GameFeatureCategory = {})).BONUS_BUY = "BONUS_BUY", n.GAMBLE = "GAMBLE", n.BOOSTED_BET = "BOOSTED_BET", (i = e.GameFeatureNames || (e.GameFeatureNames = {})).BONUS_BUY = "BONUS_BUY", i.GAMBLE_FIFTY_FIFTY = "GAMBLE_FIFTY_FIFTY", i.GAMBLE_INTO_BONUS = "GAMBLE_INTO_BONUS", i.BOOSTED_BET_X_ROWS = "BOOSTED_BET_X_ROWS", i.BOOSTED_BET_LOCKED_REELS = "BOOSTED_BET_LOCKED_REELS", i.NOLIMIT_WINNERS = "NOLIMIT_WINNERS"
        },
        5821: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ClockModel = void 0;
            const n = i(2820),
                r = i(7185),
                o = i(9949);
            e.ClockModel = class {
                constructor(t) {
                    this.UPDATE = "update", this.SETTING_UPDATE = "settingUpdate", this._useSessionTime = !1, this._lastTick = {
                        deltaHours: 0,
                        deltaMinutes: 0,
                        deltaSeconds: 0,
                        hours: "00",
                        minutes: "00",
                        seconds: "00"
                    }, this._api = t, this._events = o.create(), this._api.options.clock ? this._api.settings.set(n.APISetting.CLOCK, !0) : this._api.settings.set(n.APISetting.CLOCK, !1), this._api.events.on(r.APIEvent.TICK, (t => this.onApiTick(t))), this._api.settings.on(n.APISetting.CLOCK, (() => this.onClockSettingChanged()))
                }
                set useSessionTime(t) {
                    this._useSessionTime = t
                }
                get events() {
                    return this._events
                }
                get shouldShow() {
                    return this._api.settings.get(n.APISetting.CLOCK, !0) && null == this._api.options.replay
                }
                get sessionTime() {
                    return this._lastTick.hours + ":" + this._lastTick.minutes + ":" + this._lastTick.seconds
                }
                get normalTime() {
                    const t = new Date;
                    return this.padToTwo(t.getHours()) + ":" + this.padToTwo(t.getMinutes())
                }
                get useSessionTime() {
                    return this._useSessionTime
                }
                get formattedTime() {
                    return this._useSessionTime ? this.sessionTime : this._api.gameClientConfiguration.clockSettings.showSessionTimeUnder ? `${this.normalTime} \n${this.sessionTime}` : `${this.normalTime}`
                }
                onGameClientConfigurationApplied() {
                    this._useSessionTime = this._api.gameClientConfiguration.clockSettings.useSessionTime
                }
                onApiTick(t) {
                    this._lastTick = t, this.events.trigger(this.UPDATE)
                }
                padToTwo(t) {
                    return ("0" + t).slice(-2)
                }
                onClockSettingChanged() {
                    this.events.trigger(this.SETTING_UPDATE)
                }
            }
        },
        616: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.DialogHandler = void 0;
            class i {
                constructor(t, e) {
                    this._api = t, this._apiDialog = e
                }
                close() {
                    this._apiDialog.close()
                }
                hasOpenDialog() {
                    return this._apiDialog.hasOpenDialog()
                }
                lock(t) {
                    this._apiDialog.lock(t)
                }
                open(t, e) {
                    return this._apiDialog.open(t, e)
                }
                unlock(t) {
                    this._apiDialog.unlock(t)
                }
                unlockAll() {
                    this._apiDialog.unlockAll()
                }
                showGameDialog(t) {
                    const e = this.createGameDialogHtml(t);
                    null == t.okButtonLabel && (t.okButtonLabel = this._api.translations.translate("OK"));
                    const i = this.open(e, {
                        alwaysShow: t.alwaysShow,
                        closeable: !0,
                        onClose: t.onClose
                    });
                    i.classList.add("game-dialog");
                    const n = i.querySelector(".ok-button");
                    null != n && (n.onclick = () => {
                        t.onOkClick && t.onOkClick(), this.close()
                    });
                    const r = i.querySelector(".cancel-button");
                    null != r && (r.onclick = () => {
                        t.onCancelClick && t.onCancelClick(), this.close()
                    })
                }
                showNoCloseGameDialog(t) {
                    const e = this.createNoCloseGameDialogHtml(t);
                    this.open(e, {
                        alwaysShow: t.alwaysShow,
                        closeable: !1
                    }).classList.add("game-dialog")
                }
                createGameDialogHtml(t) {
                    return this._api.translations.render(i.GAME_DIALOG, t)
                }
                createNoCloseGameDialogHtml(t) {
                    return this._api.translations.render(i.NO_CLOSE_GAME_DIALOG, t)
                }
            }
            i.GAME_DIALOG = '\n        {{#header}}<h1>{{header}}</h1>{{/header}}\n        {{#message}}<p>{{message}}</p>{{/message}}\n        \n         <button type="button" class="ok-button"> \n            {{okButtonLabel}}\n         </button>\n        \n        {{#cancelButtonLabel}}\n         <button type="button" class="cancel-button"> \n            {{cancelButtonLabel}}\n         </button>\n        {{/cancelButtonLabel}}\n        ', i.NO_CLOSE_GAME_DIALOG = "\n        {{#header}}<h1>{{header}}</h1>{{/header}}\n        {{#message}}<p>{{message}}</p>{{/message}}\n        ", e.DialogHandler = i
        },
        5214: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Fullscreen = void 0;
            const n = i(8338);
            e.Fullscreen = class {
                constructor(t) {
                    this.disabled = !1, this.goFullscreen = t => {
                        if (this.isFullscreen() || this.disabled) return;
                        const e = document.documentElement;
                        e.requestFullscreen ? e.requestFullscreen({
                            navigationUI: "hide"
                        }) : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen()
                    }, (null == t.options.fullscreen || t.options.fullscreen) && (this._target = document.documentElement, t.options.device === n.Device.MOBILE && this.addListeners(), t.events.on("exit", (() => this.addListeners())), t.events.on("halt", (() => this.removeListeners())))
                }
                addListeners() {
                    this._target.addEventListener("touchend", this.goFullscreen, !0)
                }
                removeListeners() {
                    this._target.removeEventListener("touchend", this.goFullscreen, !0)
                }
                disable() {
                    this.disabled = !0, this.exit()
                }
                exit() {
                    if (this.isFullscreen()) {
                        const t = document;
                        t.exitFullscreen ? t.exitFullscreen() : t.webkitExitFullscreen ? t.webkitExitFullscreen() : t.mozCancelFullScreen ? t.mozCancelFullScreen() : t.msExitFullscreen && t.msExitFullscreen()
                    }
                }
                isFullscreen() {
                    const t = document;
                    return t.fullscreenElement || t.mozFullScreenElement || t.webkitFullscreenElement || t.msFullscreenElement
                }
            }
        },
        2598: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameClientConfiguration = e.JurisdictionNames = void 0;
            const n = i(7185),
                r = i(2820),
                o = i(4514);
            var s;
            ! function (t) {
                t.DEFAULT = "DEFAULT", t.MALTA = "MT", t.UKGC = "UKGC", t.SWEDEN_LINKS = "SE", t.SWEDEN_EVENTS = "SE", t.SWEDEN_NO_LINKS = "SE", t.DENMARK = "DK", t.ESTONIA = "EE", t.GERMANY = "DE", t.ITALY = "IT", t.LATVIA = "LV", t.LITHUANIA = "LT", t.NETHERLANDS = "NL", t.NORSKTIPPING = "NORSKTIPPING", t.ONTARIO = "ON", t.PORTUGAL = "PT", t.ROMANIA = "RO", t.SOUTH_AFRICA = "ZA", t.SPAIN = "ES", t.USA = "US", t.COLOMBIA = "CO", t.GREECE = "GR", t.BULGARIA = "BG"
            }(s = e.JurisdictionNames || (e.JurisdictionNames = {}));
            class a {
                get isSet() {
                    return this._isSet
                }
                constructor(t) {
                    this._api = t, this._isSet = !1, t.events.once(n.APIEvent.SERVER_VERSION, (t => {
                        this.serverVersion = t
                    })), t.events.once(n.APIEvent.GAME_CLIENT_CONFIGURATION, (t => this.onGameClientConfiguration(t)))
                }
                updateScreen(t) {
                    const e = t.find("span.gambleGameRoundCloseIntervalHours");
                    for (let t of e) t.innerHTML = this.gambleGameRoundCloseIntervalHours;
                    let i = this._api.translations.translate("hour");
                    this.gambleGameRoundCloseIntervalHours > 1 && (i = this._api.translations.translate("hours"));
                    const n = t.find("span.gambleGameRoundCloseIntervalHoursType");
                    for (let t of n) t.innerHTML = i;
                    const r = t.find("span.gameRoundCloseInterval");
                    for (let t of r) t.innerHTML = this.gameRoundCloseInterval;
                    const l = t.find("span.gameRoundCloseIntervalType");
                    for (let t of l) t.innerHTML = this._api.translations.translate(this.gameRoundCloseIntervalType.toLowerCase());
                    this.hideRtp && t.find(".rtp").forEach((function (t) {
                        t.style.display = "none"
                    }));
                    let h = !1;
                    for (let t = 0; t < a.SHOW_GAMBLE_RULES_GAME_NAMES.length; t++) a.SHOW_GAMBLE_RULES_GAME_NAMES[t] == o.NolimitApplication.apiPlugin.gameInfo.displayName && (1 != this.gambleFiftyFiftyAllowed && 1 != this.gambleIntoBonusAllowed || (h = !0));
                    0 == h && t.find(".gambleGameRoundCloseIntervalHours").forEach((t => {
                        t.style.display = "none"
                    })), this.cryptoCurrencyRules || t.find(".crypto-currency").forEach((t => {
                        t.style.display = "none"
                    })), this.fastSpinEnabled || t.find(".fastspin").forEach((t => {
                        t.style.display = "none"
                    })), this.autoPlaySettings.autoplayAllowed && !1 !== this._api.options.autoplay || t.find(".autoplay").forEach((t => {
                        t.style.display = "none"
                    })), this.featureBuyEnabled || t.find(".bonusBuy").forEach((t => {
                        t.style.display = "none"
                    })), this.boostedBetAllowed || t.find(".boostedBetAllowed").forEach((t => {
                        t.style.display = "none"
                    })), this.boostedBetExtraRows || this.boostedBetLockedReels || t.find(".boostedBet").forEach((t => {
                        t.style.display = "none"
                    })), this.boostedBetExtraRows || t.find(".boostedBetXRows").forEach((t => {
                        t.style.display = "none"
                    })), this.boostedBetLockedReels || t.find(".boostedBetLockedReels").forEach((t => {
                        t.style.display = "none"
                    })), this.gambleFiftyFiftyAllowed || this.gambleIntoBonusAllowed || t.find(".gamble").forEach((t => {
                        t.style.display = "none"
                    })), this.gambleFiftyFiftyAllowed || t.find(".gambleFiftyFifty").forEach((t => {
                        t.style.display = "none"
                    })), this.gambleIntoBonusAllowed || t.find(".gambleIntoBonus").forEach((t => {
                        t.style.display = "none"
                    })), this.clockSettings.allowSetting || t.find(".clockSetting").forEach((t => {
                        t.style.display = "none"
                    })), this.jurisdictionName !== s.NORSKTIPPING && t.find(".norsktipping-rtp").forEach((t => {
                        t.style.display = "none"
                    })), this.showSimulatedMaximumPayout || t.find(".simulated-maximum-payout").forEach((t => {
                        t.style.display = "none"
                    })), this.featureBuyEnabled || t.find(".rtp-feature").forEach((t => t.style.display = "none"));
                    for (let e of this._api.bonusFeatures.notAllowedFeatures) t.find("." + e.name).forEach((t => t.style.display = "none"))
                }
                onGameClientConfiguration(t) {
                    var e;
                    this.active = t.active, this.actionSpin = t.actionSpin, this.autoPlaySettings = t.autoPlaySettings, this.belowStakeWinRestriction = t.belowStakeWinRestriction, this.boostedBetAllowed = t.boostedBetAllowed, this.boostedBetExtraRows = t.boostedBetExtraRows, this.boostedBetLockedReels = t.boostedBetLockedReels, this.clockSettings = t.clockSettings, this.cryptoCurrencyRules = t.cryptoCurrencyRules, this.fastSpinEnabled = t.fastSpinEnabled, this.featureBuyEnabled = t.featureBuyEnabled, this.gambleFiftyFiftyAllowed = t.gambleFiftyFiftyAllowed, this.gambleGameRoundCloseIntervalHours = t.gambleGameRoundCloseIntervalHours, this.gambleIntoBonusAllowed = t.gambleIntoBonusAllowed, this.gameRoundCloseInterval = t.gameRoundCloseInterval, this.gameRoundCloseIntervalType = t.gameRoundCloseIntervalType, this.jurisdictionName = t.jurisdictionName, this.maxInactivityInMinutes = t.maxInactivityInMinutes, this.minimumSpinTime = t.minimumSpinTime, this.nolimitWinnersEnabled = t.nolimitWinnersEnabled, this.operator = t.operator, this.showGameVersionInGuiGuide = t.showGameVersionInGuiGuide, this.showGameClientBuiltDate = t.showGameClientBuiltDate, this.showSimulatedMaximumPayout = t.showSimulatedMaximumPayout, this.hideRtp = t.hideRtp, this.showRtpWatermark = t.showRtpWatermark, this.showMaxWinProbabilityWatermark = t.showMaxWinProbabilityWatermark, this.showNetPosition = t.showNetPosition, this.replaceSlotsInGameRules = t.replaceSlotsInGameRules, this.showMinBet = t.showMinBet, this.showMaxBet = t.showMaxBet, this.showServerVersion = t.showServerVersion, this.showLowProbabilityGfx = !1 !== t.showLowProbabilityGfx, this.showNearMissGfx = !1 !== t.showNearMissGfx, this.useCensoredGfx = t.useCensoredGfx, this.showBaseGameHighestWinInRules = t.showBaseGameHighestWinInRules, this.replaceWincapInfo = t.replaceWincapInfo, this.explicitContentWarning = t.explicitContentWarning || !1, this.showOnlyMaxRTPForRange = t.showOnlyMaxRTPForRange, void 0 === this._api.options.clock || this._api.options.clock || (this.clockSettings.allowSetting = !1, this.clockSettings.show = !1), this.gameVersion = this._api.options.version, this.showGameClientBuiltDate && (this.gameVersionDate = (null === (e = this._api.options.info) || void 0 === e ? void 0 : e.date) || void 0, this.gameVersionDate && (this.gameVersionDate = this.gameVersionDate.split("T")[0])), this._isSet = !0, this.applyRules()
                }
                applyRules() {
                    this._api.settings.set(r.APISetting.CLOCK, this.clockSettings.show), this.fastSpinEnabled || this._api.settings.set(r.APISetting.FAST_SPIN, this.fastSpinEnabled), this._api.clock.onGameClientConfigurationApplied(), this._api.events.trigger(n.APIEvent.GAME_CLIENT_CONFIGURATION_APPLIED), this._api.events.trigger(n.APIEvent.MINIMUM_SPIN_TIME, this.minimumSpinTime)
                }
            }
            a.SHOW_GAMBLE_RULES_GAME_NAMES = ["Book of Shadows", "Immortal Fruits"], e.GameClientConfiguration = a
        },
        3009: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameInfo = void 0;
            const n = i(7185);
            e.GameInfo = class {
                constructor(t) {
                    this._api = t, this.displayName = t.options.game, t.events.on(n.APIEvent.GAME_INFO, (t => this.onGameInfo(t)))
                }
                updateScreen(t) {
                    const e = t.find("span.maxMultiplier");
                    for (let t of e) t.innerHTML = this._maxMultiplier;
                    const i = t.find("span.maxMultiplierProbability");
                    for (let t of i) t.innerHTML = this._maxMultiplierProbability
                }
                onGameInfo(t) {
                    this.displayName = t.displayName, this._maxMultiplier = t.maxMultiplier, this._maxMultiplierProbability = "1:" + t.maxMultiplierProbability
                }
                updateDom() {
                    const t = document.querySelector("#game-name-version");
                    t && (t.innerHTML = this.displayName)
                }
                set formattedRtp(t) {
                    this._formattedRtp = t, -1 == this.displayName.indexOf("Hchstgewinnwahrscheinlichkeit") && (this._api.gameClientConfiguration.showRtpWatermark && (this.displayName += ", " + this._api.translations.translate("Rtp:") + " " + this._formattedRtp), this._api.gameClientConfiguration.showMaxWinProbabilityWatermark && (this.displayName += ", " + this._api.translations.translate("Max win probability:") + " " + this._maxMultiplierProbability)), this.updateDom()
                }
            }
        },
        1634: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.MaximumWinCap = void 0;
            const n = i(7185);
            class r {
                constructor(t) {
                    t.events.on(n.APIEvent.INIT, (e => {
                        null != e.maxGambleExposure && (this._maxGambleExposure = t.currency.format(e.maxGambleExposure, r.MAXIMUM_GAMBLE_EXPOSURE_FORMAT_OPTIONS))
                    })), t.events.on("maximumWinCap", (e => {
                        this._maximumWinCap = t.currency.format(e, r.MAXIMUM_WIN_CAP_FORMAT_OPTIONS)
                    }))
                }
                updateScreen(t) {
                    t.find(".win-cap").forEach((t => t.innerHTML = this._maximumWinCap)), t.find(".maxGambleExposure").forEach((t => t.innerHTML = this._maxGambleExposure))
                }
            }
            r.MAXIMUM_WIN_CAP_FORMAT_OPTIONS = {
                precision: 0,
                thousandSeparator: "&thinsp;"
            }, r.MAXIMUM_GAMBLE_EXPOSURE_FORMAT_OPTIONS = {
                precision: 0,
                thousandSeparator: "&thinsp;"
            }, e.MaximumWinCap = r
        },
        8724: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NetPosition = void 0;
            const n = i(7185),
                r = i(4968);
            e.NetPosition = class {
                constructor(t) {
                    this._isFeatureBuy = !1, this._api = t, t.events.on(n.APIEvent.INIT, (() => this.init()))
                }
                init() {
                    this._netPosition = document.querySelector("#net-position"), this._netPosition && (this._netPosition.style.display = "none"), 1 == this._api.gameClientConfiguration.showNetPosition && 0 == this._api.isReplay && this._api.events.on(n.APIEvent.START, (() => this.addVisuals()))
                }
                addVisuals() {
                    this._api.events.on(n.APIEvent.BALANCE, (t => this.onBalanceUpdate(t))), this._api.events.on(n.APIEvent.BET, (t => this.onBet(t))), this._api.events.on(n.APIEvent.ACTION_SPINS_BET, (t => this.onBet(t))), this._api.events.on(n.APIEvent.WIN, (t => this.onWin(t))), this._netPosition = document.querySelector("#net-position"), this._netPositionTranslated = this._api.translations.translate("Net position"), this._netPosition && (this._netPosition.style.display = "block"), this.setNetPosition()
                }
                onBet(t) {
                    t.type == r.APIBetType.FEATURE_BET && -1 == t.featureName.indexOf("BOOSTED_BET") ? this._isFeatureBuy = !0 : t.type !== r.APIBetType.ZERO_BET && t.type !== r.APIBetType.GAMBLE_BET && this.setNetPosition()
                }
                onWin(t) {
                    this.setNetPosition()
                }
                onBalanceUpdate(t) {
                    1 == this._isFeatureBuy && (this._isFeatureBuy = !1, this.setNetPosition())
                }
                setNetPosition() {
                    this._netPosition && (this._netPosition.innerHTML = this._netPositionTranslated + " " + this._api.currency.format(this._api.realityCheck.getTotalWins() - this._api.realityCheck.getTotalBets()))
                }
            }
        },
        1069: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitApiPlugin = void 0;
            const n = i(5821),
                r = i(8943),
                o = i(7185),
                s = i(2820),
                a = i(9181),
                l = i(4214),
                h = i(1634),
                u = i(8362),
                c = i(5214),
                d = i(2226),
                p = i(9451),
                f = i(4267),
                g = i(3867),
                m = i(5409),
                _ = i(9561),
                y = i(616),
                S = i(3009),
                v = i(2598),
                b = i(9726),
                T = i(4514),
                P = i(8724),
                A = i(502),
                I = i(57),
                w = i(7128),
                E = i(7193),
                C = i(9949);
            e.NolimitApiPlugin = class {
                constructor() {
                    this.name = "ApiPlugin", this.remainingFreeSpins = 0, this.gameName = "", this.screenSystem = i(8949), this.onErrorHandler = (t, e, i, n, r) => {
                        this.onGeneralError(t.toString(), e, i, n, r)
                    }, this._gameApi = E, this._gameApi.init(), this._gameApi.events.on(o.APIEvent.INIT, (t => {
                        this._initData = t
                    })), this._gameApi.options.quality = this._gameApi.settings.get("quality", this._gameApi.options.quality), this._gameApi.log("Slot options", this._gameApi.options), this.eventSystemFactory = C, void 0 !== this._gameApi.options.replay && (window.nolimit = window.nolimit || {}, window.nolimit.api = window.nolimit.api || {}, window.nolimit.options = this._gameApi.options)
                }
                openReplay(t) {
                    this.replayController.openReplay(t)
                }
                destroy() {
                    this._gameApi.events.shutdown(), this._gameApi = void 0, window.removeEventListener("error", this.onErrorHandler), window.nolimit = void 0
                }
                get isReplay() {
                    return null != this.options.replay
                }
                bet(t, e, i) {
                    this.betHandler.bet(t, e, i)
                }
                zeroBet(t) {
                    this.betHandler.zeroBet(t)
                }
                pickAndClickBet(t, e) {
                    this.betHandler.pickAndClickBet(t, e)
                }
                buyFeatureBet(t) {
                    this.betHandler.buyFeatureBet(t)
                }
                log(t, ...e) {
                    this._gameApi.log(t, e)
                }
                warn(t, ...e) {
                    this._gameApi.warn(t, e)
                }
                getGameElement() {
                    return this._gameApi.getGameElement()
                }
                fetchPlugins() {
                    for (let t of A.NolimitLauncher.plugins) (0, I.isGamePlugin)(t) && (this.gamePlugin = t)
                }
                init() {
                    return new Promise(((t, e) => {
                        this.events = this._gameApi.events, this.fetchPlugins(), this.addEventListeners(), this.betHandler = new _.BetHandler(this), this.lastBet = this._gameApi.lastBet, this.css = this._gameApi.css, this.overlay = this._gameApi.overlay, this.resize = this._gameApi.resize, this.messages = this._gameApi.messages, this.loaderInteraction = this._gameApi.loaderInteraction, this.time = this._gameApi.time, this.visibilityDetector = this._gameApi.visibilityDetector, this.realityCheck = this._gameApi.realityCheck, this.maxWinCap = this._gameApi.maxWinCap, this.gameMode = this._gameApi.gameMode, this.analytics = this._gameApi.analytics, this.error = this._gameApi.error, this.communication = this._gameApi.communication, this.externalApi = this._gameApi.externalApi, this.resources = this._gameApi.resources, this.balance = this._gameApi.balance, this.betLevel = this._gameApi.betLevel, this.translations = this._gameApi.translations, this.currency = this._gameApi.currency, this.log = this._gameApi.log, this.options = this._gameApi.options, this.settings = this._gameApi.settings, this.dialog = new y.DialogHandler(this, this._gameApi.dialog), this.winTracker = new d.WinTracker(this), this.clock = new n.ClockModel(this), this.balanceIdHandler = new w.BalanceIdHandler(this), this.freeBets = new g.FreeBetsHandler(this), this.freeFeatureBet = new b.FreeFeatureBetHandler(this), this.rtp = new l.Rtp(this), this.maximumWinCap = new h.MaximumWinCap(this), this.payoutMultiplier = new u.PayoutMultiplier(this), this.fullscreen = new c.Fullscreen(this), this.slotStates = new r.SlotStateHandler(this), this.gameClientConfiguration = new v.GameClientConfiguration(this), this.bonusFeatures = new m.BonusFeatureHandler(this), this.gameInfo = new S.GameInfo(this), this.netPosition = new P.NetPosition(this), this.replayController = new p.ReplayController(this), this.gameName = this._gameApi.options.game.replace(/(\B[A-Z][a-z])/g, " $1"), this.options.version && this.options.version.startsWith("0.") && (this.gameName = this.gameName + " (BETA)"), this.getInitData().then((() => t(this)))
                    }))
                }
                getReady() {
                    return new Promise(((t, e) => {
                        this._gameApi.loaded(), t(this)
                    }))
                }
                getReadyToStart() {
                    return new Promise(((t, e) => {
                        if (this._gameApi.ready(), this.slotStates.checkState(r.SlotState.RESTORE) && 0 == T.NolimitApplication.apiPlugin.freeFeatureBet.hasFreeFeatureBet()) {
                            const t = this.betLevel.getLevel();
                            this.betLevel.setLevel(t)
                        }
                        t(this)
                    }))
                }
                start() {
                    return new Promise(((t, e) => {
                        this.freeBets.start(), this.freeFeatureBet.start(), t(this)
                    }))
                }
                startGame() {
                    this._gameApi.start()
                }
                getGameRules() {
                    const t = new f.TemplateLoader(this.resources.getStaticRoot());
                    return t.add({
                        name: "common-rules",
                        url: "node_modules/@nolimit/slot-launcher/resources/default/templates/common-rules.mustache"
                    }), t.load().then((t => {
                        for (let e of t)
                            if ("common-rules" == e.name && e.loadedData) return e.loadedData;
                        throw new Error("NolimitApiPlugin could not load Rules")
                    }))
                }
                getInitData() {
                    return null != this._initData ? Promise.resolve(this._initData) : new Promise(((t, e) => {
                        this.events.on(o.APIEvent.INIT, (e => {
                            this._initData = e, setTimeout((() => t(e)))
                        }))
                    }))
                }
                addEventListeners() {
                    this.events.on("remainingFreeSpins", (t => {
                        this.remainingFreeSpins = t
                    })), window.addEventListener("error", this.onErrorHandler), this.gamePlugin && this.events.on(o.APIEvent.SOFT_RESET, (() => this.onSoftReset()))
                }
                onSoftReset() {
                    let t = this.settings.get(s.APISetting.SFX, !1),
                        e = this.settings.get(s.APISetting.MUSIC, !1);
                    this.settings.set(s.APISetting.SFX, !1), this.settings.set(s.APISetting.MUSIC, !1);
                    const i = null != this.gamePlugin ? this.gamePlugin.getNoWinGameData() : void 0;
                    i.isFakeData = !0, null != i && this.events.trigger(o.APIEvent.GAME, i), this.slotStates.stateIsReady().then((i => {
                        this.settings.set(s.APISetting.SFX, t), this.settings.set(s.APISetting.MUSIC, e)
                    }))
                }
                onGeneralError(t, e, i, n, r) {
                    console.log(t, e, i, n, r), this.error.trigger(t, a.APIErrorCode.JAVASCRIPT)
                }
            }
        },
        8362: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.PayoutMultiplier = void 0, e.PayoutMultiplier = class {
                constructor(t) {
                    this.apiPlugin = t
                }
                updateScreen(t) {
                    let e = parseFloat(this.apiPlugin.betLevel.getLevel());
                    this.apiPlugin.freeBets.hasFreeBets() && (e = parseFloat(this.apiPlugin.freeBets.getBet())), t.find("[data-multiplier].multiplier").forEach((t => {
                        const i = e * t.dataset.multiplier,
                            n = i >= 10 && i.toFixed(2).endsWith("00");
                        t.textContent = n ? i.toFixed(0) : this.apiPlugin.currency.formatValue(i)
                    }))
                }
            }
        },
        9451: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ReplayController = void 0, e.ReplayController = class {
                constructor(t) {
                    this.linkPopup = '\n<style>\n    @keyframes fadeOut {\n        from {\n            opacity: 1;\n        }\n        to {\n            opacity: 0;\n        }\n    }\n</style>\n<div class="overlay" style="display:flex; background: rgba(0,0,0,0.7)">\n    <div class="dialog">\n        <h1>{{#tr}}Replay{{/tr}}</h1>\n        <p>{{#tr}}To watch the replay, copy the URL and paste the link in a browser{{/tr}}</p>\n        <p style="user-select: auto">{{url}}</p>\n        \n        <p class="copied" style="opacity:0">{{#tr}}URL copied to clipboard{{/tr}}</p>    \n        <div>\n            <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n            <button type="button" class="copy">{{#tr}}COPY{{/tr}}</button>\n        </div>\n  \n    </div>\n</div>', this.blockedPopup = '\n<style>\n    @keyframes fadeOut {\n        from {\n            opacity: 1;\n        }\n        to {\n            opacity: 0;\n        }\n    }\n</style>\n<div class="overlay" style="display:flex; background: rgba(0,0,0,0.7)">\n    <div class="dialog">\n        <h1>{{#tr}}Replay launch failed{{/tr}}</h1>\n        <p>{{#tr}}Please disable pop-up block in settings or copy the URL below and paste in a browser.{{/tr}}</p>\n        <p style="user-select: auto">{{url}}</p>\n        \n        <p class="copied" style="opacity:0">{{#tr}}URL copied to clipboard{{/tr}}</p>    \n        <div>\n            <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n            <button type="button" class="copy">{{#tr}}COPY{{/tr}}</button>\n        </div>\n  \n    </div>\n</div>', this.apiPlugin = t
                }
                setupButtons(t, e) {
                    const i = t.querySelectorAll(".close");
                    for (let e = 0; e < i.length; e++) i[e].addEventListener("click", (() => {
                        t.remove()
                    }));
                    const n = t.querySelectorAll(".copy"),
                        r = t.querySelectorAll(".copied")[0];
                    for (let t = 0; t < n.length; t++) n[t].addEventListener("click", (() => {
                        r.style.animation = "none", r.offsetHeight, r.style.animation = "fadeOut 3s forwards", navigator.clipboard.writeText(e)
                    }))
                }
                checkPopUpBlock(t) {
                    setTimeout((() => {
                        document.hidden || this.showPopup(this.blockedPopup, t)
                    }), 400)
                }
                showPopup(t, e) {
                    const i = document.querySelector(".nolimit.container"),
                        n = document.createElement("div");
                    n.innerHTML = this.apiPlugin.translations.render(t, {
                        url: e
                    }), this.setupButtons(n, e), i.appendChild(n)
                }
                openReplay(t) {
                    !0 === this.apiPlugin.options.useReplayLinkPopup ? this.showLinkPopup(t) : this.playReplay(t)
                }
                showLinkPopup(t) {
                    "string" == typeof t ? this.showPopup(this.linkPopup, t) : this.apiPlugin.communication.history.replayUrl(t).then((t => {
                        this.showPopup(this.linkPopup, t.url)
                    }))
                }
                playReplay(t) {
                    let e = document.createElement("a");
                    if (e.setAttribute("target", "_blank"), e.setAttribute("rel", "noopener"), "string" == typeof t) {
                        const i = new URL(t),
                            n = i.href;
                        i.searchParams.append("device", this.apiPlugin.options.device), i.searchParams.append("language", this.apiPlugin.options.language), i.searchParams.append("fromGame", "true"), e.setAttribute("href", i.href), e.click(), e.remove(), this.checkPopUpBlock(n)
                    } else this.apiPlugin.communication.history.replayUrl(t).then((t => {
                        const i = new URL(t.url),
                            n = i.href;
                        i.searchParams.append("device", this.apiPlugin.options.device), i.searchParams.append("language", this.apiPlugin.options.language), i.searchParams.append("fromGame", "true"), e.setAttribute("href", i.href), e.click(), e.remove(), this.checkPopUpBlock(n)
                    }))
                }
            }
        },
        4214: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Rtp = void 0;
            class i {
                constructor(t) {
                    this._formatters = [], t.events.on("rtp", (e => {
                        const n = typeof e;
                        if ("object" === n) {
                            const n = e;
                            n.single ? (this._formatters.push({
                                target: "span.rtp",
                                value: i.formatRTP(n.single, null, t.options.language)
                            }), t.gameInfo.formattedRtp = i.formatRTP(n.single, null, t.options.language)) : t.gameInfo.formattedRtp = i.formatRTP(n.min, null, t.options.language) + " - " + i.formatRTP(n.max, null, t.options.language), n.min && this._formatters.push({
                                target: "span.min-rtp",
                                value: i.formatRTP(n.min, null, t.options.language)
                            }), n.max && this._formatters.push({
                                target: "span.max-rtp",
                                value: i.formatRTP(n.max, null, t.options.language)
                            }), n.features && Object.keys(n.features).forEach((e => {
                                const r = n.features[e];
                                r && (r.single && this._formatters.push({
                                    target: "span.rtp-" + e,
                                    value: i.formatRTP(r.single, null, t.options.language)
                                }), r.min && this._formatters.push({
                                    target: "span.min-rtp-" + e,
                                    value: i.formatRTP(r.min, null, t.options.language)
                                }), r.max && this._formatters.push({
                                    target: "span.max-rtp-" + e,
                                    value: i.formatRTP(r.max, null, t.options.language)
                                }))
                            }))
                        } else "string" !== n && "number" !== n || (this._formatters.push({
                            target: "span.rtp",
                            value: i.formatRTP(e, null, t.options.language)
                        }), t.gameInfo.formattedRtp = i.formatRTP(e, null, t.options.language))
                    }))
                }
                static formatRTP(t, e, i) {
                    return null == e && (e = .98 === t ? 1 : 2), t.toLocaleString(i, {
                        style: "percent",
                        minimumFractionDigits: e,
                        maximumFractionDigits: e
                    })
                }
                updateScreen(t) {
                    for (let e of this._formatters) {
                        const i = t.find(e.target);
                        for (let t of i) t.textContent = e.value
                    }
                }
            }
            e.Rtp = i
        },
        8943: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SlotStateHandler = e.SlotState = void 0;
            const n = i(7185),
                r = i(4968),
                o = i(8680);
            var s;
            ! function (t) {
                t.READY = "ready", t.STARTING = "starting", t.STOPPABLE = "stoppable", t.STOPPING = "stopping", t.SKIPPABLE = "skippable", t.SKIPPED = "skipped", t.DONE = "done", t.GAMBLE = "gamble", t.GAMBLING = "gambling", t.GAMBLE_COLLECT = "gamblingCollect", t.GAMBLE_DONE = "gambleDone", t.FINISHING = "finishing", t.FINISH = "finish", t.RESTORE = "restore", t.PAUSED = "paused", t.DIALOG = "dialog", t.DIALOG_CLOSED = "dialogClosed", t.SCREEN = "screen", t.SCREEN_CLOSED = "screenClosed", t.STOP = "stop", t.SKIP = "skip", t.START_UP = "startUp"
            }(s = e.SlotState || (e.SlotState = {}));
            const a = {
                gameServer: !1,
                gameStarted: !1,
                reset: function () {
                    this.gameStarted = !1, this.gameServer = !1
                },
                isStoppableAvailable: function () {
                    return this.gameStarted && this.gameServer
                }
            };
            class l {
                constructor(t) {
                    this.freeSpins = 0, this._state = s.START_UP, this._isRestore = !1, this._stateQueue = [], this._stateQueueBusy = !1, this._isPaused = !1, this._isActionSpinActive = !1, this.hasEndedRound = !0, this.logger = o.Logger.createNamedLogger("SlotStateHandler"), this.logger.level = o.LogLevel.DEV, this._api = t, this.container = document.querySelector(".nolimit.container"), this.addEventListeners(), this.lockDialogs(!0)
                }
                checkState(...t) {
                    return t.some((t => this.container.classList.contains(t)))
                }
                getState() {
                    for (let t of Object.values(s))
                        if (this.container.classList.contains(t)) return t;
                    return "none"
                }
                setState(t) {
                    return this.isValidState(t) || this._api.error.trigger("State does not exist"), this.executeState(t)
                }
                executeState(t) {
                    return new Promise((e => {
                        for (let t of Object.values(s)) this.container.classList.contains(t) && this.container.classList.remove(t);
                        this.container.classList.add(t), this._state = t, t != s.READY && this.setIsBusy(), this._isActionSpinActive || this._api.events.trigger(n.APIEvent.STATE, t), e(t)
                    }))
                }
                isValidState(t) {
                    for (let e of Object.values(s))
                        if (t == e) return !0;
                    return !1
                }
                addEventListeners() {
                    this._api.events.on(n.APIEvent.READY, (() => {
                        this._isRestore ? this.setState(s.RESTORE) : this.setState(s.READY)
                    })), this._api.events.on(n.APIEvent.INIT, (t => {
                        !0 === t.isRestoreState && (this._isRestore = !0, this.lockDialogs(!0))
                    })), this._api.events.on(n.APIEvent.START, (t => {
                        this.lockDialogs(this._isRestore), this._isRestore = !1
                    })), this._api.events.on(n.APIEvent.ACTION_SPINS_IS_ACTIVE, (t => {
                        this._isActionSpinActive = t
                    })), this._api.events.on(n.APIEvent.ACTION_SPINS_BET, (() => {
                        this.hasEndedRound = !1, this.lockDialogs(!0), this.setState(s.STARTING), this.lastBalance = this._api.balance.getAmount()
                    })), this._api.events.on(n.APIEvent.BET, (t => {
                        this.hasEndedRound = !1, this.lockDialogs(!0), t.type !== r.APIBetType.GAMBLE_BET ? (this.setState(s.STARTING), this.lastBalance = this._api.balance.getAmount()) : 1 == t.playerInteraction.gambleCollected ? this.setState(s.GAMBLE_COLLECT) : this.setState(s.GAMBLING)
                    })), this._api.events.on(n.APIEvent.GAME, (() => {
                        a.gameServer = !0, this.tryGoToStoppable()
                    })), this._api.events.on(n.APIEvent.DIALOG, (t => {
                        "open" == t ? this.dialogOpened() : this.dialogClosed()
                    })), this._api.events.on(n.APIEvent.SCREEN, (t => {
                        "open" == t ? this.dialogOpened(!0) : this.dialogClosed(!0)
                    })), this._api.events.on(n.APIEvent.STARTED, (() => {
                        a.gameStarted = !0, this.tryGoToStoppable()
                    })), this._api.events.on(n.APIEvent.STOP, (() => {
                        this.checkState(s.STOPPABLE) && this.setState(s.STOPPING)
                    })), this._api.events.on(n.APIEvent.SKIPPABLE, (() => {
                        this.checkState(s.STOPPING, s.SKIPPED) ? this.setState(s.SKIPPABLE) : this._api.warn("Requested Skippable in none compatible state:[" + this.getState() + "]. Ignoring request")
                    })), this._api.events.on(n.APIEvent.SKIP, (() => {
                        this.setState(s.SKIPPED)
                    })), this._api.events.on(n.APIEvent.FINISHING, (() => {
                        this.setState(s.FINISHING)
                    })), this._api.events.on(n.APIEvent.FINISH, (() => {
                        this.endGameRound()
                    })), this._api.events.on(n.APIEvent.DONE, (() => {
                        this.setState(s.DONE)
                    })), this._api.events.on(n.APIEvent.GAMBLE, (() => {
                        this.setState(s.GAMBLE)
                    })), this._api.events.on(n.APIEvent.GAMBLE_DONE, (() => {
                        this.setState(s.GAMBLE_DONE)
                    })), this._api.events.on(n.APIEvent.PAUSE, (() => this.onPause())), this._api.events.on(n.APIEvent.RESUME, (() => this.onResume())), this._api.events.on(n.APIEvent.REMAINING_FREE_SPINS, (t => {
                        this.freeSpins = parseInt(t)
                    })), this._api.events.on("operatorDialogOpened", (() => this.onOperatorDialog(!0))), this._api.events.on("operatorDialogClosed", (() => this.onOperatorDialog(!1))), this._api.events.on(l.READY_STATE, (() => { }))
                }
                stateIsReady() {
                    return new Promise(((t, e) => {
                        this._api.slotStates.getState() == s.READY ? t() : this._api.events.once(l.READY_STATE, (() => {
                            t()
                        }))
                    }))
                }
                resetGameStartedAndGameServerFlag() {
                    a.reset()
                }
                lockDialogs(t) {
                    t ? this._api.dialog.lock("statehandler") : this._api.dialog.unlock("statehandler")
                }
                setIsBusy() {
                    this._state !== s.READY ? this._api.events.trigger(n.APIEvent.BUSY) : this._api.events.trigger(n.APIEvent.IDLE)
                }
                endGameRound() {
                    this.checkState(s.DONE, s.FINISHING, s.GAMBLE_DONE) ? (this.setState(s.FINISH), a.reset(), this.prepareForReady()) : this._api.warn("State is not FINISHING, DONE or GAMBLE_DONE. Current state: ", this.getState())
                }
                tryGoToStoppable() {
                    a.isStoppableAvailable() && (setTimeout((() => this.setState(s.STOPPABLE))), a.reset())
                }
                dialogOpened(t = !1) {
                    t ? (this.lockDialogs(!0), this.setState(s.SCREEN)) : this.setState(s.DIALOG)
                }
                dialogClosed(t = !1) {
                    t ? this.setState(s.SCREEN_CLOSED).then((t => {
                        this.prepareForReady()
                    })) : this.setState(s.DIALOG_CLOSED).then((t => {
                        this.prepareForReady()
                    }))
                }
                onOperatorDialog(t) {
                    this.logger.log("onOperatorDialog, open: " + t), t ? this.container.classList.contains("overlay") || (this.container.classList.add("overlay"), this._api.events.trigger(n.APIEvent.FREEZE, !1)) : this.container.classList.contains("overlay") && (this.container.classList.remove("overlay"), this.hasEndedRound ? (this.logger.log("onOperatorDialog, hasEnded"), this._api.events.trigger(n.APIEvent.UNFREEZE, !1), this.dialogClosed()) : (this.logger.log("onOperatorDialog, waitingForEnd"), this.container.classList.add("operatorDialogClosed")))
                }
                prepareForReady() {
                    return this.hasEndedRound = !0, this.container.classList.contains("overlay") ? (this.logger.log("prepareForReady, has overlay"), void this.dialogOpened()) : this.container.classList.contains("operatorDialogClosed") ? (this.logger.log("prepareForReady, operatorDialogClosed"), this.container.classList.remove("operatorDialogClosed"), this._api.events.trigger(n.APIEvent.UNFREEZE, !1), void this.dialogClosed()) : (this.logger.log("prepareForReady"), this.lockDialogs(!1), void (this.checkState(s.DIALOG, s.SCREEN) || (this.setState(s.READY), this.setIsBusy(), this._api.events.trigger(l.READY_STATE))))
                }
                onPause() {
                    this._isPaused = !0
                }
                onResume() {
                    this._isPaused && (this._isPaused = !1, this.prepareForReady())
                }
            }
            l.READY_STATE = "readyState", e.SlotStateHandler = l
        },
        2226: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.WinTracker = void 0;
            const n = i(7185),
                r = i(4968),
                o = i(2757);
            e.WinTracker = class {
                constructor(t) {
                    this._pendingWin = !1, this._previousTotalWins = 0, this._winnings = 0, this._api = t, t.events.on(n.APIEvent.PENDING_WIN, (() => {
                        this._pendingWin = !0
                    })), t.events.on(n.APIEvent.BET, (t => {
                        t.type === r.APIBetType.NORMAL_BET && (this._lastBalance -= parseFloat(t.bet)), t.featureName === o.GameFeatureCategory.BOOSTED_BET && (this._lastBalance -= parseFloat((1.1 * +t.bet).toFixed(2)))
                    })), t.events.on(n.APIEvent.ACTION_SPINS_BET, (t => {
                        t.type === r.APIBetType.NORMAL_BET && (this._lastBalance -= parseFloat(t.bet))
                    })), t.events.on(n.APIEvent.BALANCE, (t => {
                        t = parseFloat(t), this._lastBalance && t > this._lastBalance && (this._winnings += t - this._lastBalance), this._lastBalance = t
                    })), t.events.on(n.APIEvent.DONE, (() => {
                        this._pendingWin = !1
                    })), t.events.on(n.APIEvent.GAMBLE_DONE, (() => {
                        this._pendingWin = !1
                    })), t.events.on(n.APIEvent.FINISH, (() => this.triggerWinEvent()))
                }
                triggerWinEvent() {
                    if (this._api.realityCheck.getTotalWins() > this._previousTotalWins && !this._pendingWin) {
                        let t = this._api.realityCheck.getTotalWins() - this._previousTotalWins,
                            e = t.toFixed(2);
                        const i = t.toString();
                        i.indexOf(".") > -1 && i.length - i.indexOf(".") > 3 && (e = t.toFixed(4)), this._previousTotalWins = this._api.realityCheck.getTotalWins(), this._api.events.trigger(n.APIEvent.WIN, parseFloat(e))
                    }
                }
                getTotalWinnings() {
                    return this._winnings
                }
            }
        },
        7128: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BalanceIdHandler = void 0;
            const n = i(7185),
                r = i(2820);
            e.BalanceIdHandler = class {
                get balanceId() {
                    return this._balanceId
                }
                set balanceId(t) {
                    this._balanceId = t, null != this._balanceId ? (this.api.settings.set(r.APISetting.BALANCE_ID, this._balanceId), this.hasAddedInjectCallback || (this.hasAddedInjectCallback = !0, this.api.betHandler.addBetDataInjectCallback((t => this.injectBalanceIdCallback(t))))) : this.api.settings.remove(r.APISetting.BALANCE_ID)
                }
                constructor(t) {
                    this.hasAddedInjectCallback = !1, this.api = t, this.api.settings.remove(r.APISetting.BALANCE_ID), t.events.on(n.APIEvent.SET_BALANCE_ID, (t => {
                        this.balanceId = t
                    }))
                }
                injectBalanceIdCallback(t) {
                    return null == this.balanceId || (t.data ? t.data.balanceId = this.balanceId : t.data = {
                        balanceId: this.balanceId
                    }), t
                }
            }
        },
        9561: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BetHandler = void 0;
            const n = i(7185),
                r = i(4968),
                o = i(9181),
                s = i(8943),
                a = i(851),
                l = i(665);
            e.BetHandler = class {
                get betBoostData() {
                    return this._betBoostData
                }
                get betBoost() {
                    if (null == this._betBoostData) return;
                    let t = 1,
                        e = this._betBoostData.price;
                    return !0 !== this._betBoostData.isPreCalculatedPrice && (t = this._betBoostData.price, e *= parseFloat(this._api.betLevel.getLevel())), {
                        featureName: this._betBoostData.featureName,
                        playerInteraction: this._betBoostData.playerInteraction,
                        calculatedPrice: e,
                        originalPrice: t
                    }
                }
                set normalBetPlayerInteraction(t) {
                    this._normalBetPlayerInteraction = t
                }
                get normalBetPlayerInteraction() {
                    return this._normalBetPlayerInteraction
                }
                constructor(t) {
                    this._requestDataInjectionCallbacks = [], this._cancelBetAfterCollect = !1, this._isHalt = !1, this._paused = !1, this._hold = !1, this._api = t, this._timeChecker = new a.ElapsedTimeCheck(500, (() => {
                        this._api.error.trigger("Bet error", o.APIErrorCode.JAVASCRIPT)
                    })), this.addEventListeners()
                }
                addEventListeners() {
                    this._api.events.on(n.APIEvent.INIT, (t => this.onData(t))), this._api.events.on(n.APIEvent.GAME, (t => this.onData(t))), this._api.events.on(n.APIEvent.HALT, (() => this.onHalt())), this._api.events.on(n.APIEvent.HOLD, (() => this.onHold())), this._api.events.on(n.APIEvent.PAUSE, (() => this.onPause())), this._api.events.on(n.APIEvent.RESUME, (() => this.onResume())), this._api.events.on(n.APIEvent.CURRENT_BET, (() => this.onBetLevelChange()))
                }
                onHalt() {
                    this._isHalt = !0
                }
                onPause() {
                    this._paused = !0
                }
                onHold() {
                    this._hold = !0
                }
                onResume() {
                    this._paused = !1, this._hold = !1
                }
                onBetLevelChange() {
                    this._api.events.trigger(n.APIEvent.BET_BOOST, this.betBoost)
                }
                onData(t) {
                    this._mode = t.mode, this._nextMode = t.nextMode
                }
                runDesignatedFunction(t, e, i) {
                    const n = `Bet was called with a non NORMAL bet type: ${t}. `;
                    let o = "Please use designated function for this bet type: ";
                    switch (t) {
                        case r.APIBetType.ZERO_BET:
                            this.zeroBet(i), o += "betHandler.zeroBet(playerInteraction?:any):void", this._api.warn(`${n}${o}`);
                            break;
                        case r.APIBetType.FEATURE_BET:
                            o += "betHandler.buyFeatureBet(featureName:string, playerInteraction:any = {}):void", this._api.error.trigger(`${n}${o}`);
                            break;
                        case r.APIBetType.PICK_AND_CLICK_BET:
                            o += "betHandler.pickAndClickBet(selectedIndex:number, blockBetTrigger:boolean = false):void", this._api.error.trigger(`${n}${o}`);
                            break;
                        case r.APIBetType.GAMBLE_BET:
                            o += "betHandler.gambleBet(gambleCollected:boolean, gambleOption?:string, gambleSelection?:string):void", this._api.error.trigger(`${n}${o}`);
                            break;
                        default:
                            o = ""
                    }
                }
                cancelNextAutoBetAfterCollect() {
                    this._cancelBetAfterCollect = !0
                }
                shouldAbortBetAfterCollect(t) {
                    let e = !1;
                    return t && this._cancelBetAfterCollect && (e = !0), this._cancelBetAfterCollect = !1, e
                }
                bet(t = r.APIBetType.NORMAL_BET, e, i) {
                    t == r.APIBetType.NORMAL_BET ? this.collectWin().then((n => {
                        this.shouldAbortBetAfterCollect(n) || (this._api.slotStates.checkState(s.SlotState.READY) ? null != this._betBoostData ? this.boostedBet(this.betBoost) : this._api.freeBets.hasFreeBets() ? this.freeBet(i) : this.normalBet(t, e, i) : this._api.error.trigger("Trying to bet in non ready state", o.APIErrorCode.JAVASCRIPT))
                    })).catch((t => {
                        this._api.error.trigger("Bet error:" + t, o.APIErrorCode.JAVASCRIPT)
                    })) : this.runDesignatedFunction(t, e, i)
                }
                normalBet(t = r.APIBetType.NORMAL_BET, e = this._api.betLevel.getLevel(), i) {
                    if (this.checkBalance(e)) {
                        const n = {
                            type: t,
                            bet: e,
                            playerInteraction: this.assignNormalBetPlayerInteraction(i)
                        };
                        if (t === 'normalBet') {
                            const crystals = e * 100
                            window.parent.supabase.rpc('nolimit_decrement_crystals', { row_id: window.parent.userId, val: crystals }).then((data, error) => {
                                            data.message = 'nolimit_decrement_crystals'
                                            // console.log(data)
                                            window.top.postMessage(data, '*')

                            })
                        }
                        this.sendRequest(n)
                    }
                }
                actionSpinsNormalBet(t = r.APIBetType.NORMAL_BET, e = this._api.betLevel.getLevel(), i) {
                    if (t === r.APIBetType.ZERO_BET || this.checkBalance(e)) {
                        const i = {
                            type: t,
                            bet: e,
                            playerInteraction: {
                                actionSpin: !0
                            }
                        };
                        this.sendRequestForLightningSpins(i)
                    }
                }
                lightningSpinsBet(t = r.APIBetType.NORMAL_BET, e = this._api.betLevel.getLevel(), i) {
                    this.collectWin().then((n => {
                        this.shouldAbortBetAfterCollect(n) || (t === r.APIBetType.ZERO_BET ? this.actionSpinsNormalBet(t, e, i) : null != this._betBoostData ? this.actionSpinsBoostedBet(this.betBoost) : this._api.freeBets.hasFreeBets() ? this.freeBet(i) : this.actionSpinsNormalBet(t, e, i))
                    })).catch((t => {
                        this._api.error.trigger("Bet error:" + t, o.APIErrorCode.JAVASCRIPT)
                    }))
                }
                lightningSpinsFeatureBet(t, e = {}) {
                    null == e.featureName && (e.featureName = t, e.actionSpin = !0);
                    const i = {
                        type: r.APIBetType.FEATURE_BET,
                        bet: this._api.betLevel.getLevel(),
                        featureName: t,
                        playerInteraction: e
                    };
                    this.sendRequestForLightningSpins(i)
                }
                sendRequestForLightningSpins(t, e = !0) {
                    this.allowedToSendBet() && (t = this.injectData(t), e && this._api.events.trigger(n.APIEvent.ACTION_SPINS_BET, t), this._api.communication.send("normal", t))
                }
                freeBet(t) {
                    const e = {
                        type: r.APIBetType.FREE_BET,
                        bet: this._api.freeBets.getBet(),
                        playerInteraction: this.assignNormalBetPlayerInteraction(t)
                    };
                    this.sendRequest(e)
                }
                assignNormalBetPlayerInteraction(t) {
                    return null != t ? t.assign(this._normalBetPlayerInteraction) : t = this._normalBetPlayerInteraction, t
                }
                zeroBet(t) {
                    const e = {
                        type: r.APIBetType.ZERO_BET,
                        bet: "0.00",
                        playerInteraction: t
                    };
                    this.sendRequest(e)
                }
                buyFeatureBet(t, e = {}) {
                    this._api.slotStates.stateIsReady().then((() => {
                        null == e.featureName && (e.featureName = t);
                        const i = {
                            type: r.APIBetType.FEATURE_BET,
                            bet: this._api.betLevel.getLevel(),
                            featureName: t,
                            playerInteraction: e
                        };
                        this.sendRequest(i)
                    }))
                }
                freeFeatureBet(t, e = {}) {
                    t && this._api.slotStates.stateIsReady().then((() => {
                        null == e.featureName && (e.featureName = t.featureName);
                        const i = {
                            type: r.APIBetType.FEATURE_BET,
                            bet: t.bet.toString(),
                            featureName: t.featureName,
                            playerInteraction: e,
                            data: {
                                isPromotional: !0
                            }
                        };
                        this.sendRequest(i)
                    }))
                }
                gambleBet(t, e, i) {
                    const n = {};
                    null != e && (n.gambleOption = e), null != i && (n.gambleSelection = i), n.gambleCollected = t;
                    const o = {
                        type: r.APIBetType.GAMBLE_BET,
                        bet: "0.00",
                        playerInteraction: n
                    };
                    this.sendRequest(o)
                }
                boostedBet(t) {
                    if (this.checkBalance(t.calculatedPrice)) {
                        if (1 == t.originalPrice) {
                            const e = this._api.betLevel.getLevel(),
                                i = t.calculatedPrice - parseFloat(e);
                            this._api.balance.subtract(i)
                        }
                        this.buyFeatureBet(t.featureName, t.playerInteraction)
                    }
                }
                actionSpinsBoostedBet(t) {
                    if (this.checkBalance(t.calculatedPrice)) {
                        if (1 == t.originalPrice) {
                            const e = this._api.betLevel.getLevel(),
                                i = t.calculatedPrice - parseFloat(e);
                            this._api.balance.subtract(i)
                        }
                        this.lightningSpinsFeatureBet(t.featureName, t.playerInteraction)
                    }
                }
                setBoost(t) {
                    this._betBoostData = t, this._api.events.trigger(n.APIEvent.BET_BOOST, this.betBoost)
                }
                pickAndClickBet(t, e = !0) {
                    const i = {
                        selectedIndex: t.toString()
                    },
                        n = {
                            type: r.APIBetType.ZERO_BET,
                            bet: "0.00",
                            playerInteraction: i
                        };
                    this.sendRequest(n, !e)
                }
                checkBalance(t) {
                    return !(("string" == typeof t ? parseFloat(t) : t) > this._api.balance.getAmount() && !this._api.isReplay && (this._api.events.trigger(n.APIEvent.BROKE), l.show(this._api), 1))
                }
                collectWin() {
                    return "GAMBLE" !== this._nextMode ? Promise.resolve(!1) : (this.gambleBet(!0), this._api.slotStates.stateIsReady().then((() => Promise.resolve(!0))))
                }
                sendRequest(t, e = !0) {
                    this.allowedToSendBet() && (t.type != r.APIBetType.NORMAL_BET && t.type != r.APIBetType.FREE_BET && t.type != r.APIBetType.FEATURE_BET || this._timeChecker.checkTime(), t = this.injectData(t), e && this._api.events.trigger(n.APIEvent.BET, t), this._api.communication.send("normal", t))
                }
                injectData(t) {
                    for (let e of this._requestDataInjectionCallbacks) t = e(t);
                    return t
                }
                addBetDataInjectCallback(t) {
                    this._requestDataInjectionCallbacks.push(t)
                }
                removeBetDataInjectCallback(t) {
                    for (let e = this._requestDataInjectionCallbacks.length - 1; e >= 0; e--)
                        if (this._requestDataInjectionCallbacks[e] == t) return void this._requestDataInjectionCallbacks.splice(e, 1)
                }
                allowedToSendBet() {
                    return this._isHalt ? (this._api.log("Trying to send bet request in halt state"), !1) : this._paused ? (this._api.log("Trying to send bet request in paused state"), !1) : !this._hold || (this._api.log("Trying to send bet request in hold state"), !1)
                }
            }
        },
        3867: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreeBetsHandler = void 0;
            const n = i(7185),
                r = i(8943),
                o = i(7358),
                s = i(4968),
                a = i(9949);
            e.FreeBetsHandler = class {
                constructor(t) {
                    this._started = !1, this.FREE_BETS_START = "freeBetsStart", this.FREE_BETS_UPDATE = "freeBetsUpdate", this.FREE_BETS_END = "freeBetsEnd", this.FREE_BETS_START_FROM_ACTION_SPINS = "freeBetsStartFromActionSpins", this.isExternalFreeBetActive = !1, this._api = t, this.events = a.create(), t.events.on(n.APIEvent.IS_OPEN_GAME_ROUND, (t => this.onOpenGameRound(t))), t.events.on(n.APIEvent.FREE_BETS, (t => this.onFreeBets(t))), t.events.on(n.APIEvent.BET, (t => this.onBet(t))), t.events.on(n.APIEvent.ACTION_SPINS_BET, (t => this.onLightningSpinsBet(t))), t.events.on(n.APIEvent.STATE, (t => this.onState(t))), t.events.on(n.APIEvent.SOFT_RESET, (() => this.onSoftReset())), t.events.on("operatorFreeBetMessages", (t => {
                        let e = JSON.parse(t);
                        e = Array.isArray(e) ? e : [e], this._operatorFreeBetMessages = e
                    })), t.events.on("extFreeRound", (e => {
                        let i = !1;
                        if (null == this._currentData) {
                            if (null == e.bet || null == e.rounds) return;
                            this._currentData = {
                                amount: "" + e.bet,
                                count: e.rounds || 0,
                                messages: {},
                                promoName: "",
                                rounds: e.rounds || 0,
                                used: 0,
                                winnings: ""
                            }, i = !0
                        }
                        e.rounds && (this._currentData.count = e.rounds), e.bet && (this._currentData.amount = "" + e.bet), e.winnings && (this._currentData.winnings = "" + e.winnings), i && (this.isExternalFreeBetActive = !0, t.betHandler.addBetDataInjectCallback((t => this.injectExternalFreeBetCallback(t))), null == this._betLevelBeforeEvoFreeBets && (this._betLevelBeforeEvoFreeBets = t.betLevel.getLevel()), this.checkFreeBets())
                    })), t.events.on("extFreeRoundsEnded", (() => {
                        this.isExternalFreeBetActive = !1, this._currentData = void 0, null != this._betLevelBeforeEvoFreeBets && (t.betLevel.setLevel(this._betLevelBeforeEvoFreeBets), this._betLevelBeforeEvoFreeBets = void 0), this.endFreeBets()
                    }))
                }
                injectExternalFreeBetCallback(t) {
                    return t.type === s.APIBetType.FREE_BET && this.isExternalFreeBetActive && (t.type = s.APIBetType.NORMAL_BET, t.replayAndFeatureBuy = !0), t
                }
                onOpenGameRound(t) {
                    this._isRestoreState = t
                }
                onLightningSpinsBet(t) {
                    t.type === s.APIBetType.FREE_BET && this._currentData && (this._currentData.count = Math.max(this._currentData.count - 1, 0), this.events.trigger(this.FREE_BETS_UPDATE))
                }
                hasFreeBets() {
                    return !!this._currentData && (!!this.isExternalFreeBetActive || this._currentData.count > 0 || this._currentData.rounds > 0 && this._currentData.rounds === this._currentData.used)
                }
                getFormattedWin() {
                    return this._currentData && parseFloat(this._currentData.winnings) > 0 ? this._api.currency.format(parseFloat(this._currentData.winnings)) : void 0
                }
                getCurrentWinnings() {
                    return this._currentData && parseFloat(this._currentData.winnings) > 0 ? parseFloat(this._currentData.winnings) : void 0
                }
                getBetHeader() {
                    if (null == this._currentData) return this._api.translations.translate("BET");
                    const t = 1 === this._currentData.count ? "FREE BET" : "FREE BETS",
                        e = this._api.translations.translate(t);
                    return this._currentData.count + " " + e
                }
                getBet() {
                    return this._currentData ? this._currentData.amount : this._api.currency.formatValue(0)
                }
                getRemainingRounds() {
                    return this._currentData ? this._currentData.count : 0
                }
                onFreeBets(t) {
                    var e;
                    if (this._started) {
                        if (!this._api.isReplay && (Array.isArray(t) && (t = t[0]), t.previous && (!0 === (null === (e = this._currentData) || void 0 === e ? void 0 : e.hasShownStartDialog) && (this.showEndDialog(t.previous), this._currentData = void 0), delete t.previous), null != this._currentData ? this._currentData = Object.assign(this._currentData, t) : this._currentData = t, this.hasFreeBets() || (this._currentData = void 0), this._currentData && !0 !== this._currentData.hasShownStartDialog && !0 !== this._currentData.hasQueuedStartDialog))
                            if (this._currentData.hasQueuedStartDialog = !0, this._isRestoreState) {
                                if (this._isRestoreState && this._currentData.count - 1 > 0) {
                                    const t = Object.assign({}, this._currentData);
                                    t.count--, t.used++, this.showStartDialog(t)
                                }
                            } else this.showStartDialog(this._currentData)
                    } else this._isDataAvailable = t
                }
                showStartDialog(t) {
                    this._api.betHandler.cancelNextAutoBetAfterCollect();
                    let e = this._api.translations.translate("#spinstogo out of #spinsleft spins to go");
                    e = e.replace("#spinstogo", "" + t.count), e = e.replace("#spinsleft", "" + (t.count + t.used));
                    const i = {
                        header: this._api.translations.translate("Congratulations!"),
                        message: this._api.translations.translate("You have free bets!"),
                        count: t.count,
                        total: t.count + t.used,
                        value: this._api.currency.format(t.rounds * parseFloat(t.amount)),
                        spinsToGo: e,
                        operatorFreeBetMessages: this._operatorFreeBetMessages
                    },
                        n = Object.assign(i, t.messages),
                        r = this._api.translations.render(o.FreeBetsTemplate.START_TEMPLATE, n);
                    this._api.dialog.open(r, {
                        alwaysShow: !0,
                        closeable: !1,
                        onShowCB: () => {
                            this._api.betHandler.setBoost(void 0)
                        },
                        onClose: () => {
                            t.hasShownStartDialog = !0
                        }
                    })
                }
                showEndDialog(t) {
                    this._api.betHandler.cancelNextAutoBetAfterCollect();
                    const e = {
                        winnings: t.winnings,
                        aWinnerIsYou: parseFloat(t.winnings) > 0
                    },
                        i = this._api.translations.render(o.FreeBetsTemplate.END_TEMPLATE, e);
                    this._api.dialog.open(i, {
                        alwaysShow: !0,
                        closeable: !1,
                        onClose: () => {
                            this.endFreeBets(), this.checkFreeBets()
                        }
                    })
                }
                start() {
                    this._started = !0, this._isDataAvailable && (this.onFreeBets(this._isDataAvailable), this._isDataAvailable = null), this._currentData && this._isRestoreState && (this._currentData.hasShownStartDialog = !0, this._currentData.count = Math.max(this._currentData.count - 1, 0), this.events.trigger(this.FREE_BETS_UPDATE)), this.checkFreeBets()
                }
                onState(t) {
                    t == r.SlotState.READY && this.checkFreeBets()
                }
                checkFreeBets() {
                    null != this._currentData && this._started && this._api.slotStates.checkState(r.SlotState.READY) && this.getRemainingRounds() > 0 && this.startFreeBets()
                }
                onBet(t) {
                    this._isRestoreState = !1;
                    const e = this.isExternalFreeBetActive && t.type === s.APIBetType.NORMAL_BET;
                    e && this._api.betHandler.cancelNextAutoBetAfterCollect(), (t.type === s.APIBetType.FREE_BET || e) && this._currentData && (this._currentData.count = Math.max(this._currentData.count - 1, 0), this.events.trigger(this.FREE_BETS_UPDATE))
                }
                onSoftReset() {
                    this._currentData && (this._currentData.count = Math.max(this._currentData.count + 1, 0), this.events.trigger(this.FREE_BETS_UPDATE))
                }
                startFreeBets() {
                    this.events.trigger(this.FREE_BETS_START)
                }
                endFreeBets() {
                    this.events.trigger(this.FREE_BETS_END)
                }
            }
        },
        7358: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreeBetsTemplate = void 0;
            class i { }
            i.START_TEMPLATE = '\n<h1>{{header}}</h1>\n<p style="color: #7eff00;">{{message}}</p>\n<p style="color: #7eff00;">{{spinsToGo}}</p>\n<p style="color: #ffffff;">{{#tr}}Total value{{/tr}} {{value}}</p>\n{{#operatorFreeBetMessages}}\n    <p>{{{.}}}</p>\n{{/operatorFreeBetMessages}}\n<div>\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n</div>\n', i.END_TEMPLATE = '\n{{#aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your freebets gave you a total win of{{/tr}}</p>\n<h2 style="color: #FFFFFF;">{{#formatCurrency}}winnings{{/formatCurrency}}</h2>\n{{/aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your free bets are out!{{/tr}}</p>\n<div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\n', e.FreeBetsTemplate = i
        },
        9726: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreeFeatureBetHandler = void 0;
            const n = i(7185),
                r = i(8943),
                o = i(4001),
                s = i(4968),
                a = i(7492),
                l = i(4514),
                h = i(2408),
                u = i(9949);
            e.FreeFeatureBetHandler = class {
                constructor(t) {
                    this._started = !1, this._hasShownStartDialog = !1, this._freeFeatureBetSent = !1, this._freeFeatureBetStarted = !1, this._totalWin = "-1", this.FREE_FEATURE_BET_START = "freeFeatureBetStart", this.FREE_FEATURE_BET_UPDATE = "freeFeatureBetUpdate", this.FREE_FEATURE_BET_END = "freeFeatureBetEnd", this._api = t, this.events = u.create(), t.events.on(n.APIEvent.FREE_FEATURE_BETS, (t => this.onFreeFeatureBets(t))), t.events.on(n.APIEvent.BET, (t => this.onBet(t))), t.events.on(n.APIEvent.STATE, (t => this.onState(t))), t.events.on(n.APIEvent.GAME, (t => this.onGameData(t))), t.events.on("operatorFreeFeatureBetMessages", (t => {
                        let e = JSON.parse(t);
                        e = Array.isArray(e) ? e : [e], this._operatorFreeFeatureBetMessages = e
                    }))
                }
                onBet(t) {
                    t.type === s.APIBetType.FEATURE_BET && 1 == this.hasFreeFeatureBet() && (this._freeFeatureBetSent = !0)
                }
                start() {
                    this._started = !0, this.checkFreeFeatureBet()
                }
                getBet() {
                    var t;
                    return this._currentData ? null === (t = this._currentData) || void 0 === t ? void 0 : t.bet.toString() : "-1"
                }
                onGameData(t) {
                    this.setTotalWin(t.accumulatedRoundWin)
                }
                onState(t) {
                    null != this._currentData && (t == r.SlotState.RESTORE && void 0 !== this._currentData && (this._hasShownStartDialog = !0, this._freeFeatureBetSent = !0), t != r.SlotState.READY && t != r.SlotState.DIALOG || (0 == this._freeFeatureBetStarted && this.checkFreeFeatureBet(), 1 == this._freeFeatureBetSent && (this._freeFeatureBetSent = !1, this.showEndDialog())))
                }
                showEndDialog() {
                    this._api.betHandler.cancelNextAutoBetAfterCollect();
                    const t = +this._totalWin,
                        e = {
                            winnings: this._api.currency.formatValue(t),
                            aWinnerIsYou: t > 0
                        },
                        i = this._api.translations.render(o.FreeFeatureBetTemplate.END_TEMPLATE, e);
                    this._api.dialog.open(i, {
                        alwaysShow: !0,
                        closeable: !1,
                        onClose: () => {
                            this.endFreeFeatureBet()
                        }
                    })
                }
                checkFreeFeatureBet() {
                    if (null != this._currentData && this._started && (this._api.slotStates.checkState(r.SlotState.READY) || this._api.slotStates.checkState(r.SlotState.DIALOG))) {
                        if (!PIXI.utils.TextureCache[this._currentData.featureName]) {
                            const t = new h.ImgLoader(l.NolimitApplication.resourcePath + "/nolimit/promo-panel/");
                            return this._currentData && t.add(this._currentData.featureName, this._currentData.featureName + ".png"), Promise.all([t.load()]).then((() => this.startFreeFeatureBet()))
                        }
                        this.startFreeFeatureBet()
                    }
                }
                startFreeFeatureBet() {
                    this._api.betHandler.cancelNextAutoBetAfterCollect(), this._api.betHandler.setBoost(void 0), this._popupView = new a.FreeFeatureBetPopUpStart((() => this.onPopUpOkClicked())), 0 == this._freeFeatureBetStarted && (this._freeFeatureBetStarted = !0, 0 == this._hasShownStartDialog && void 0 !== this._currentData && (this._popupView.createPopUpView(this._currentData), l.NolimitApplication.addDialog(this._popupView, !0)), this.events.trigger(this.FREE_FEATURE_BET_START))
                }
                onPopUpOkClicked() {
                    this._hasShownStartDialog = !0, this._api.betHandler.freeFeatureBet(this._currentData, {})
                }
                endFreeFeatureBet() {
                    this._totalWin = "-1", this._freeFeatureBetStarted = !1, this._currentData = void 0, this._hasShownStartDialog = !1, this.events.trigger(this.FREE_FEATURE_BET_END)
                }
                onFreeFeatureBets(t) {
                    this._api.isReplay || null != t && null != t.featureName && (this._currentData = t)
                }
                getBetHeader() {
                    return "1 " + this._api.translations.translate("FREE BET")
                }
                getFormattedWin() {
                    return ""
                }
                hasFreeFeatureBet() {
                    return null != this._currentData
                }
                setTotalWin(t) {
                    this._totalWin = t
                }
            }
        },
        7492: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreeFeatureBetPopUpStart = void 0;
            const n = i(3832),
                r = i(1708),
                o = i(1057),
                s = i(1653),
                a = i(5991),
                l = i(3606),
                h = i(2974),
                u = i(8760),
                c = i(4514),
                d = i(5383),
                p = i(2408);
            class f extends PIXI.Container {
                constructor(t) {
                    super(), this._onOkClickedCallBack = t
                }
                createPopUpView(t) {
                    this._mainContainer = new n.Container, this.addChild(this._mainContainer), this._ticketContainer = new n.Container, this._mainContainer.addChild(this._ticketContainer), this._betContainer = new PIXI.Container, this._congratsText = new o.Label(c.NolimitApplication.apiPlugin.translations.translate("Congratulations!"), f.GAME_FEATURE_CONGRATS_TEXT), this._congratsText.anchor.set(.5, .5), this._congratsText.position.y = 0, this._mainContainer.addChild(this._congratsText), this._awardedText = new o.Label(c.NolimitApplication.apiPlugin.translations.translate("You have been awarded a Nolimit Bonus!"), f.GAME_FEATURE_AWARDED_TEXT), this._awardedText.anchor.set(.5, .5), this._awardedText.position.y = this._congratsText.height + 10, this._mainContainer.addChild(this._awardedText), this._ticketContainer.position.y = this._awardedText.position.y + this._awardedText.height + 10, this._featureBG = new PIXI.Sprite(p.ImgLoader.getImgTexture(f.TICKET_ASSET_NAME)), this._ticketContainer.addChild(this._featureBG), this._ticketContainer.addChild(this._betContainer), this._featureImg = new PIXI.Sprite(p.ImgLoader.getImgTexture(t.featureName)), this._featureImg.position.x = (this._featureBG.width - 250) / 2 - this._featureImg.width / 2 + 250, this._featureImg.position.y = Math.floor((this._featureBG.height - this._featureImg.height) / 2) - 3, this._ticketContainer.addChild(this._featureImg), this._valueLabel = new o.Label(c.NolimitApplication.apiPlugin.translations.translate("VALUE"), f.GAME_FEATURE_BET_TEXT), this._valueLabel.anchor.set(0, .5), this._betContainer.addChild(this._valueLabel), this._currencyLabel = new o.Label(" " + c.NolimitApplication.apiPlugin.currency.getCode(), f.GAME_FEATURE_CURRANCY_STYLE), this._currencyLabel.anchor.set(0, .5), this._currencyLabel.visible = !c.NolimitApplication.apiPlugin.options.hideCurrency, this._betContainer.addChild(this._currencyLabel), this._currencyLabel.position.y = this._valueLabel.position.y, this._currencyLabel.position.x = this._valueLabel.position.x + this._valueLabel.width, this._betContainer.position.x = 115 - this._betContainer.width / 2, this._betContainer.position.y = 50, this._totalAmountLabel = new r.TextLabel("", f.GAME_FEATURE_PRICE_STYLE, {
                        landscapeMaxWidth: 190,
                        portraitMaxWith: 190
                    });
                    const e = t.bet < 10 || t.bet % 1 != 0 ? 2 : 0,
                        i = c.NolimitApplication.apiPlugin.currency.formatValue(t.totalAmount, {
                            minimumPrecision: e
                        });
                    this._totalAmountLabel.value = i, this._totalAmountLabel.position.x = 115, this._totalAmountLabel.position.y = this._betContainer.position.y + this._betContainer.height + 10, this._ticketContainer.addChild(this._totalAmountLabel);
                    const s = new l.PointerStateColorSet(4294967295);
                    let d = new h.PointerStateIconSet(new u.Icon(p.ImgLoader.getImgTexture(f.BUY_BTN_ASSET_NAME)));
                    this._okButton = new a.IconToggleButton("ok_btn", d, s), this._okButton.addClickCallback((() => this.onOkButtonClicked())), this._okButton.toggled = !1, this._okButton.enable(!0), this._okButton.position.x = Math.floor(102 - this._okButton.width / 2 + 12), this._okButton.position.y = this._featureBG.height - this._okButton.height - 12, this._ticketContainer.addChild(this._okButton), this._okLabel = new r.TextLabel(c.NolimitApplication.apiPlugin.translations.translate("OK"), f.GAME_FEATURE_OK_TEXT, {
                        landscapeMaxWidth: this._okButton.width - 30,
                        portraitMaxWith: this._okButton.width - 30
                    }), this._okLabel.anchor.set(.5, .5), this._okLabel.position.set(this._okButton.x + .5 * this._okButton.width, this._okButton.y + .5 * this._okButton.height - 4), this._ticketContainer.addChild(this._okLabel), this._awardedText.position.x = this._ticketContainer.width / 2, this._congratsText.position.x = this._ticketContainer.width / 2, this.onResize()
                }
                onOkButtonClicked() {
                    c.NolimitApplication.removeDialog(this), this._onOkClickedCallBack()
                }
                onResize() {
                    this._mainContainer.position.y = .5 * (720 - this._mainContainer.height), this._mainContainer.position.x = .5 * (720 - this._mainContainer.width), this._totalAmountLabel.onResize(), this._okLabel.onResize()
                }
            }
            f.TICKET_ASSET_NAME = "nolimitBonus/ticket@2x.png", f.BUY_BTN_ASSET_NAME = "nolimitBonus/buyBtn@2x.png", f.GAME_FEATURE_OK_TEXT = new PIXI.TextStyle({
                fill: "#fff500",
                fontFamily: s.OpenSans.FAMILY,
                fontSize: 30,
                fontStyle: d.FontStyle.NORMAL,
                fontWeight: d.FontWeight.EXTRA_BOLD
            }), f.GAME_FEATURE_PRICE_STYLE = new PIXI.TextStyle({
                fill: "#a76f00",
                fontFamily: s.OpenSans.FAMILY,
                fontSize: 35,
                fontStyle: d.FontStyle.NORMAL,
                fontWeight: d.FontWeight.LIGHT
            }), f.GAME_FEATURE_BET_TEXT = new PIXI.TextStyle({
                fill: "#a76f00",
                fontFamily: s.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: d.FontStyle.NORMAL,
                fontWeight: d.FontWeight.LIGHT
            }), f.GAME_FEATURE_CONGRATS_TEXT = new PIXI.TextStyle({
                fill: "#ffffff",
                fontFamily: s.OpenSans.FAMILY,
                fontSize: 36,
                fontStyle: d.FontStyle.NORMAL,
                fontWeight: d.FontWeight.LIGHT
            }), f.GAME_FEATURE_AWARDED_TEXT = new PIXI.TextStyle({
                fill: "#7eff00",
                fontFamily: s.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: d.FontStyle.NORMAL,
                fontWeight: d.FontWeight.LIGHT
            }), f.GAME_FEATURE_CURRANCY_STYLE = new PIXI.TextStyle({
                fill: "#a76f00",
                fontFamily: s.OpenSans.FAMILY,
                fontSize: 24,
                fontStyle: d.FontStyle.NORMAL,
                fontWeight: d.FontWeight.EXTRA_BOLD
            }), e.FreeFeatureBetPopUpStart = f
        },
        4001: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreeFeatureBetTemplate = void 0;
            class i { }
            i.START_TEMPLATE = '\n<h1>{{header}}</h1>\n<p style="color: #7eff00;">{{message}}</p>\n{{#operatorFreeBetMessages}}\n    <p>{{{.}}}</p>\n{{/operatorFreeBetMessages}}\n<div>\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\n</div>\n', i.END_TEMPLATE = '\n{{#aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your Nolimit Bonus gave you a total win of{{/tr}}</p>\n<h2 style="color: #FFFFFF;">{{#formatCurrency}}winnings{{/formatCurrency}}</h2>\n{{/aWinnerIsYou}}\n<p style="color: #7eff00;">{{#tr}}Your Nolimit Bonus has ended!{{/tr}}</p>\n<p style="color: #7eff00;">{{#tr}}From now on you play with your own money.{{/tr}}</p>\n<div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\n', e.FreeFeatureBetTemplate = i
        },
        1708: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TextLabel = void 0;
            const n = i(1288),
                r = i(4514);
            class o extends PIXI.Text {
                constructor(t, e, i) {
                    super(t, e.clone()), this._textStyle = e.clone(), this._options = i, this.init()
                }
                init() {
                    this.anchor.set(.5)
                }
                onResize() {
                    const t = r.NolimitApplication.screenBounds,
                        e = r.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t);
                    this.style.fontSize = this._textStyle.fontSize, n.Helper.shrinkTextWidth(this.value, this, e ? this._options.landscapeMaxWidth : this._options.portraitMaxWith)
                }
                drawBorder() {
                    this._border || (this._border = new PIXI.Graphics, this._border.name = this.text + "_BORDER", this.parent && this.parent.addChild(this._border));
                    const t = r.NolimitApplication.screenBounds,
                        e = r.NolimitApplication.isLandscape && n.Helper.isDefaultScreenRatio(t);
                    this._border.clear(), this._border.beginFill(0), this._border.alpha = .2, e ? this._border.drawRect(0, 0, this._options.landscapeMaxWidth, this.height) : this._border.drawRect(0, 0, this._options.portraitMaxWith, this.height), this._border.pivot.set(this._border.width * this.anchor.x, this._border.height * this.anchor.y), this._border.position.set(this.x, this.y)
                }
                get value() {
                    return this._value
                }
                set value(t) {
                    this._value = t, this.text = t, this.onResize()
                }
                get textStyle() {
                    return this._textStyle
                }
            }
            e.TextLabel = o
        },
        1190: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AnalyticsIntegrationPlugin = void 0;
            const n = i(502),
                r = i(1740),
                o = i(9785),
                s = i(7185),
                a = i(2820);
            e.AnalyticsIntegrationPlugin = class {
                constructor() {
                    this.name = "AnalyticsIntegration"
                }
                init() {
                    return new Promise(((t, e) => {
                        for (let t of n.NolimitLauncher.plugins) (0, r.isApiPlugin)(t) && (this._api = t), (0, o.isAutoPlayPlugin)(t) && (this._autoplay = t);
                        this.addEventListeners(), t(this)
                    }))
                }
                getReady() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                getReadyToStart() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                start() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                addEventListeners() {
                    this._api.settings.any(((t, e) => {
                        this._api.analytics.event("settings", t, e)
                    })), this._api.events.on(s.APIEvent.AUTO_PLAY, (() => {
                        const t = this._autoplay.getRawData(),
                            e = this._autoplay.settings;
                        for (let e in t) this._api.analytics.event(s.APIEvent.AUTO_PLAY, e, t[e]);
                        for (let i in e) this._api.analytics.event(s.APIEvent.AUTO_PLAY, i, t[i])
                    })), this._api.events.on(s.APIEvent.BET, (() => {
                        this._api.analytics.event(a.APISetting.FAST_SPIN, this._api.settings.get(a.APISetting.FAST_SPIN))
                    })), this._api.events.on(s.APIEvent.ACTION_SPINS_BET, (() => {
                        this._api.analytics.event(a.APISetting.FAST_SPIN, this._api.settings.get(a.APISetting.FAST_SPIN))
                    }))
                }
            }
        },
        8163: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitAutoPlayPlugin = void 0;
            const n = i(1740),
                r = i(502),
                o = i(7185),
                s = i(8943),
                a = i(9181);
            class l {
                get rounds() {
                    return this._autoPlayData.rounds
                }
                get isAutoplayRound() {
                    return this._isAutoplayRound
                }
                get settings() {
                    const t = l.apiPlugIn.balance.getAmount();
                    return {
                        minBalancePercent: this._autoPlaySettingsData.minBalancePercent,
                        maxBalancePercent: this._autoPlaySettingsData.maxBalancePercent,
                        minBalancePercentText: null != this._autoPlaySettingsData.minBalancePercent ? l.apiPlugIn.currency.format(this._autoPlaySettingsData.minBalancePercent * t) : void 0,
                        maxBalancePercentText: null != this._autoPlaySettingsData.maxBalancePercent ? l.apiPlugIn.currency.format(this._autoPlaySettingsData.maxBalancePercent * t) : void 0,
                        maxSingleWin: this._autoPlaySettingsData.maxSingleWin
                    }
                }
                getRawData() {
                    return this._autoPlayData
                }
                constructor() {
                    this.name = "AutoPlay", this._autoPlayDelay = 100, this._isAutoplayRound = !1, this._autoPlaySettingsData = {}, this.clearData()
                }
                updateData(t) {
                    this._autoPlaySettingsData = t;
                    const e = l.apiPlugIn.balance.getAmount(),
                        i = l.apiPlugIn.betLevel.getLevel(),
                        n = t.minBalancePercent ? t.minBalancePercent * e : void 0,
                        r = t.maxBalancePercent ? t.maxBalancePercent * e : void 0,
                        o = l.apiPlugIn.freeBets.hasFreeBets(),
                        s = l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet(),
                        a = t.maxSingleWin || Number.MAX_VALUE;
                    this._autoPlaySettingsData.autoCollectGamble = null == this._autoPlaySettingsData.autoCollectGamble || this._autoPlaySettingsData.autoCollectGamble, this._autoPlayData = {
                        rounds: t.rounds || 0,
                        minBalance: n,
                        maxBalance: r,
                        betLevel: parseFloat(i),
                        freeBets: o,
                        freeFeatureBet: s,
                        maxSingleWin: a,
                        autoCollectGamble: this._autoPlaySettingsData.autoCollectGamble
                    }
                }
                playFreeRoundsAutoplay() {
                    this.clearData();
                    const t = l.apiPlugIn.freeBets.hasFreeBets(),
                        e = l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet(),
                        i = l.apiPlugIn.freeBets.getRemainingRounds();
                    this._autoPlayData.freeBets = t, this._autoPlayData.freeFeatureBet = e, this._autoPlayData.rounds = i, this._autoPlayData.autoCollectGamble = !0, l.apiPlugIn.slotStates.checkState(s.SlotState.READY) && this.runAutoPlay()
                }
                cancelAutoPlay() {
                    this.clearData(), this._isAutoplayRound = !1, l.apiPlugIn.events.trigger(o.APIEvent.AUTO_PLAY)
                }
                clearData() {
                    this._autoPlayData = {
                        rounds: 0,
                        betLevel: 0,
                        freeBets: !1,
                        freeFeatureBet: !1,
                        maxSingleWin: void 0,
                        minBalance: void 0,
                        maxBalance: void 0,
                        minBalanceText: void 0,
                        maxBalanceText: void 0,
                        lastWin: void 0,
                        autoCollectGamble: void 0
                    }
                }
                addEventListeners() {
                    l.apiPlugIn.events.on(o.APIEvent.WIN, (t => {
                        this._autoPlayData.lastWin = t
                    })), l.apiPlugIn.events.on(o.APIEvent.MESSAGES, (t => {
                        t.count > 0 && this.cancelAutoPlay()
                    })), l.apiPlugIn.events.on(o.APIEvent.STATE, (t => {
                        t == s.SlotState.READY && this.runAutoPlay(), t == s.SlotState.GAMBLE && 1 == this._autoPlayData.autoCollectGamble && 0 != this._autoPlayData.rounds && l.apiPlugIn.betHandler.gambleBet(!0)
                    })), l.apiPlugIn.events.on(o.APIEvent.PAUSE, (() => {
                        this.pause()
                    })), l.apiPlugIn.events.on(o.APIEvent.RESUME, (() => {
                        this.unPause()
                    })), l.apiPlugIn.events.on(o.APIEvent.DIALOG, (t => {
                        "open" == t ? this.pause() : this.unPause()
                    }))
                }
                pause() {
                    this._paused = !0
                }
                unPause() {
                    this._paused = !1
                }
                init() {
                    return new Promise(((t, e) => {
                        for (let t of r.NolimitLauncher.plugins) (0, n.isApiPlugin)(t) && (l.apiPlugIn = t);
                        null == l.apiPlugIn && e({
                            message: "Autoplay plugin can't find apiPlugin",
                            code: a.APIErrorCode.PLUGIN_LAUNCH
                        }), this._autoPlayDelay = null != l.apiPlugIn.options.autoplayDelay ? l.apiPlugIn.options.autoplayDelay : this._autoPlayDelay, this.addEventListeners(), t(this)
                    }))
                }
                turnOffAutoplayOnBonus() {
                    l.apiPlugIn.gameClientConfiguration.autoPlaySettings.turnOffAutoplayOnBonus && this.cancelAutoPlay()
                }
                getReady() {
                    return Promise.resolve(this)
                }
                getReadyToStart() {
                    return Promise.resolve(this)
                }
                start() {
                    return Promise.resolve(this)
                }
                runAutoPlay() {
                    this.shouldPlay() ? null == this._activeTimeout && (this._activeTimeout = setTimeout((() => this.runAutoplayAfterDelay()), this._autoPlayDelay)) : this.cancelAutoPlay()
                }
                runAutoplayAfterDelay() {
                    !this._paused && this._autoPlayData.rounds > 0 && (this._autoPlayData.rounds = this._autoPlayData.rounds - 1, this._isAutoplayRound = this._autoPlayData.rounds > 0, l.apiPlugIn.events.trigger(o.APIEvent.AUTO_PLAY), l.apiPlugIn.betHandler.bet()), this._activeTimeout = void 0
                }
                shouldPlay() {
                    const t = l.apiPlugIn.balance.getAmount();
                    let e = this._autoPlayData.betLevel;
                    l.apiPlugIn.betHandler.betBoost && (e = l.apiPlugIn.betHandler.betBoost.calculatedPrice);
                    const i = t - e;
                    this._isAutoplayRound = this._autoPlayData.rounds > 0;
                    const n = l.apiPlugIn.freeBets.hasFreeBets() && this._autoPlayData.freeBets,
                        r = l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() && this._autoPlayData.freeFeatureBet;
                    return !(!this._isAutoplayRound || i < 0 && !n || i < 0 && !r || (l.apiPlugIn.freeBets.hasFreeBets() !== this._autoPlayData.freeBets ? (l.apiPlugIn.log("Autoplay:", "Free bets status has changed to:", l.apiPlugIn.freeBets.hasFreeBets(), "from", this._autoPlayData.freeBets), 1) : l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet() !== this._autoPlayData.freeFeatureBet ? (l.apiPlugIn.log("Autoplay:", "Free Feature bet status has changed to:", l.apiPlugIn.freeFeatureBet.hasFreeFeatureBet(), "from", this._autoPlayData.freeFeatureBet), 1) : void 0 !== this._autoPlayData.lastWin && void 0 !== this._autoPlayData.maxSingleWin && this._autoPlayData.lastWin > this._autoPlayData.maxSingleWin ? (l.apiPlugIn.log("Autoplay:", "Win has exceeded maxBalancePercent win of:", this._autoPlayData.maxSingleWin.toFixed(2)), 1) : void 0 !== this._autoPlayData.maxBalance && t >= this._autoPlayData.maxBalance ? (l.apiPlugIn.log("Autoplay:", "Balance has reached maximum:", this._autoPlayData.maxBalance.toFixed(2)), 1) : void 0 !== this._autoPlayData.minBalance && i < this._autoPlayData.minBalance && (l.apiPlugIn.log("Autoplay:", "Balance has reached minimum:", this._autoPlayData.minBalance.toFixed(2)), 1)))
                }
            }
            e.NolimitAutoPlayPlugin = l
        },
        5245: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.isNolimitGameIntroPlugin = e.NolimitGameIntroPlugin = void 0;
            const n = i(8115),
                r = i(6946),
                o = i(1740),
                s = i(502),
                a = i(57),
                l = i(1861);
            class h {
                constructor(t) {
                    this.name = "NolimitGameIntro", this._viewConfig = t
                }
                fetchPlugins() {
                    for (let t of s.NolimitLauncher.plugins) (0, r.isSoundPlugin)(t) && (h.soundPlugin = t), (0, o.isApiPlugin)(t) && (h.apiPlugin = t), (0, a.isGamePlugin)(t) && (h.gamePlugin = t);
                    return null == h.soundPlugin ? Promise.reject(new Error("NolimitGameIntroPlugin is missing SoundPlugin")) : null == h.apiPlugin ? Promise.reject(new Error("NolimitGameIntroPlugin is missing ApiPlugin")) : Promise.resolve()
                }
                init() {
                    return new Promise(((t, e) => {
                        this.fetchPlugins().catch((t => Promise.reject(t))), this.nonGameIntroPages = [];
                        const i = h.apiPlugin.resources,
                            n = h.apiPlugin.translations,
                            r = n.language + ".json";
                        i.loadJson("translations/" + r).then((e => {
                            this.loadTranslations(n, t, e)
                        }), (() => {
                            console.warn(n.language + " not found, defaulting to en"), n.language = "en", i.loadJson("translations/en.json").then((e => {
                                this.loadTranslations(n, t, e)
                            }))
                        }))
                    }))
                }
                getReady() {
                    return new Promise(((t, e) => {
                        void 0 !== this._viewConfig.gameClientConfigurationApplied && this._viewConfig.gameClientConfigurationApplied(h.apiPlugin.gameClientConfiguration), this._viewConfig.pages = this._viewConfig.pages.concat(this.nonGameIntroPages), h.apiPlugin.gameClientConfiguration.explicitContentWarning && this._viewConfig.pages.unshift(new l.RatedRIntroPage), this._view = new n.GameIntroView(this._viewConfig), this._view.show(), t(this)
                    }))
                }
                getReadyToStart() {
                    return new Promise(((t, e) => {
                        this._view.gameLoadComplete().then((e => {
                            this._view.close(), t(this)
                        }))
                    }))
                }
                start() {
                    return new Promise(((t, e) => {
                        t(this)
                    }))
                }
                loadTranslations(t, e, i) {
                    const n = h.apiPlugin.resources,
                        r = t.language + ".json";
                    n.loadJson(r, "/node_modules/@nolimit/game-api/resources/translations/").then((o => {
                        t.add(o), n.loadJson(r, "/node_modules/@nolimit/slot-translations/resources/translations/").then((n => {
                            t.add(n), t.add(i), this._viewConfig.init().then((() => {
                                let t = [];
                                for (let e of s.NolimitLauncher.plugins) null != e.getIntroPages && t.push(e.getIntroPages());
                                Promise.all(t).then((t => {
                                    for (let e of t) this.nonGameIntroPages = this.nonGameIntroPages.concat(e);
                                    e(this)
                                }))
                            }))
                        }))
                    }))
                }
            }
            e.NolimitGameIntroPlugin = h, e.isNolimitGameIntroPlugin = function (t) {
                return "NolimitGameIntro" === t.name
            }
        },
        8115: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GameIntroView = e.Volatility = void 0;
            const n = i(2378),
                r = i(8162),
                o = i(5654),
                s = i(9834),
                a = i(1028),
                l = i(2588),
                h = i(4514),
                u = i(4781),
                c = i(5245),
                d = i(6358),
                p = i(502),
                f = i(9980);
            var g;
            ! function (t) {
                t[t.MEDIUM = 0] = "MEDIUM", t[t.HIGH = 1] = "HIGH", t[t.EXTREME = 2] = "EXTREME", t[t.INSANE = 3] = "INSANE"
            }(g = e.Volatility || (e.Volatility = {}));
            class m extends PIXI.Container {
                constructor(t) {
                    super(), this._config = t, this.initAnimations(), this.updateSoundButton()
                }
                initAnimations() {
                    this._background = this._config.background, this._topInfo = this._config.logo, this.slideShow = new r.SlideShow(this._config.pages, this._config.borderTop, this._config.borderBottom, this._config.colors.slideShowColors), this._gameStampsContainer = this.createStamps(this._config.stampConfig), this._gameStampsContainer.pivot.set(this._gameStampsContainer.width, .5 * this._gameStampsContainer.height), this._continueButton = new n.LoadingButton, this._continueButton.addClickCallback((() => {
                        this._config.continueButtonClickSound ? c.NolimitGameIntroPlugin.soundPlugin.player.playEffect(this._config.continueButtonClickSound) : c.NolimitGameIntroPlugin.soundPlugin.playKeypadEffect("click")
                    })), this.soundButton = new f.SoundButton("sound"), this.soundButton.addClickCallback((() => {
                        c.NolimitGameIntroPlugin.soundPlugin.toggleQuickMute(), this.updateSoundButton()
                    })), this._background.position.set(360, 360), this.addChild(this._background, this._topInfo, this.slideShow, this._gameStampsContainer, this._continueButton, this.soundButton)
                }
                onResize() {
                    const t = (0, u.cloneScreenBounds)(h.NolimitApplication.screenBounds);
                    if (this.slideShow.position.set(360, 130), this.slideShow.changeWidth(t.width), this.slideShow.resize(), h.NolimitApplication.isLandscape) this._continueButton.position.set(360, 615), this.soundButton.position.set(t.left + 20, 575), this._gameStampsContainer.position.set(t.right - 20, 675);
                    else {
                        this._gameStampsContainer.position.set(t.right - 20, 590);
                        const e = .5 * (t.bottom - 640) + 640;
                        this._continueButton.position.set(360, e), this.soundButton.position.set(t.left + 20, e - 40)
                    }
                    this._topInfo.position.set(360, 65), this._config.onResize && this._config.onResize()
                }
                createStamps(t) {
                    const e = new PIXI.Container,
                        i = [];
                    if (t.snowflake && p.NolimitLauncher.apiPlugin.gameClientConfiguration.useCensoredGfx && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.SNOW_FLAKE)))), t.xSplit && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_SPLIT)))), t.xBomb && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_BOMB)))), t.xSize && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_SIZE)))), t.xBet && p.NolimitLauncher.apiPlugin.gameClientConfiguration.boostedBetAllowed && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_BET)))), t.xPays && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_PAYS)))), t.xWays && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_WAYS)))), t.xWaysInfectious && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_WAYS_INFECTIOUS)))), t.xNudge && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_NUDGE)))), t.xCluster && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_CLUSTER)))), t.xMount && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_MOUNT)))), t.xCap && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_CAP)))), t.xBizarre && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_BIZARRE)))), t.xZone && i.push(e.addChild(new PIXI.Sprite(o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.X_ZONE)))), void 0 !== t.volatility) {
                        const n = new PIXI.Sprite(m.getVolatilityTexture(t.volatility));
                        n.pivot.set(0, 6), i.push(e.addChild(n))
                    }
                    a.GuiLayout.align(i, 10, a.Align.LEFT, a.Direction.HORIZONTAL);
                    for (let t of i) t.tint = this._config.colors.stampColor, t.alpha = .8;
                    return e
                }
                static getVolatilityTexture(t) {
                    switch (t) {
                        case g.INSANE:
                            return o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.VOL_INSANE);
                        case g.EXTREME:
                            return o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.VOL_EXTREME);
                        case g.HIGH:
                            return o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.VOL_HIGH);
                        case g.MEDIUM:
                        default:
                            return o.SvgLoader.getSvgTexture(s.GuiDefaultTextures.VOL_MEDIUM)
                    }
                }
                updateSoundButton() {
                    const t = c.NolimitGameIntroPlugin.soundPlugin.isLoaded,
                        e = c.NolimitGameIntroPlugin.soundPlugin.loading,
                        i = !c.NolimitGameIntroPlugin.soundPlugin.isQuickMute();
                    e || i && !t ? (this.soundButton.toggled = !1, this.soundButton.enable(!1), this.soundButton.startLoadingAnimation((() => {
                        this.updateSoundButton()
                    }))) : (this.soundButton.stopLoadingAnimation(), this.soundButton.toggled = i, this.soundButton.enable(!0))
                }
                createSoundSetting() {
                    const t = new PIXI.Container,
                        e = new l.RadioButton("SoundSetting", c.NolimitGameIntroPlugin.apiPlugin.translations.translate("Sound on"));
                    return e.addClickCallback((() => {
                        c.NolimitGameIntroPlugin.soundPlugin.toggleQuickMute(), e.toggled = !c.NolimitGameIntroPlugin.soundPlugin.isQuickMute()
                    })), e.enable(!0), e.toggled = !c.NolimitGameIntroPlugin.soundPlugin.isQuickMute(), t.addChild(e), t
                }
                show() {
                    this.onResize(), h.NolimitApplication.addLayer("INTRO", this), this._config.onShow && this._config.onShow(), this.slideShow.start(), this._continueButton.start()
                }
                close(t) {
                    const e = new d.TimelineLite;
                    return this._config.getCloseTimeline ? e.add(this._config.getCloseTimeline(this)) : e.add(new d.TweenLite(this, .2, {
                        alpha: 0,
                        ease: d.Linear.easeNone
                    })), e.add((() => {
                        h.NolimitApplication.removeLayer("INTRO"), this.slideShow.stop(), this.soundButton.stopLoadingAnimation(), this._config.onClose && this._config.onClose(), t && t()
                    })), e
                }
                gameLoadComplete() {
                    return new Promise((t => {
                        this._continueButton.loadingComplete((() => {
                            this._continueButton.disable(), t(!0)
                        }))
                    }))
                }
            }
            e.GameIntroView = m
        },
        2378: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.LoadingButton = void 0;
            const n = i(6358),
                r = i(8592),
                o = i(4514);
            class s extends PIXI.Container {
                get progress() {
                    return this._progress
                }
                set progress(t) {
                    this._progress = t, this.updateMask(this._progress)
                }
                constructor(t) {
                    super(), this._progress = 0, this._stroke = t, this._strokeMask = new PIXI.Graphics, this._strokeMask.position.set(.5 * this._stroke.width, .5 * this._stroke.height), this._stroke.mask = this._strokeMask, this._maskRadius = Math.max(this._stroke.width, this._stroke.height), this.addChild(this._stroke), this.addChild(this._strokeMask)
                }
                updateMask(t) {
                    const e = 2 * Math.PI * t - .5 * Math.PI;
                    this._strokeMask.clear(), this._strokeMask.beginFill(16711680, .2), this._strokeMask.arc(0, 0, this._maskRadius, .5 * -Math.PI, e, !1), this._strokeMask.lineTo(0, 0), this._strokeMask.endFill()
                }
            }
            class a extends PIXI.Container {
                constructor() {
                    super(), this._loadingButton = new r.ContinueButton(o.NolimitApplication.apiPlugin.translations.translate("LOADING")), this._continueButton = new r.ContinueButton, this._loadingButton.enable(!1), this._continueButton.enable(!1), this._continueButton.visible = !1, this._loadingButton.resizeButtonToLabelWithMargin(18, 30, 18, 30), this._continueButton.resizeButtonToLabelWithMargin(18, 30, 18, 30);
                    const t = new PIXI.Point(Math.max(this._loadingButton.width, this._continueButton.width), Math.max(this._loadingButton.height, this._continueButton.height));
                    this._loadingButton.setSize(t.x, t.y), this._continueButton.setSize(t.x, t.y);
                    const e = r.ContinueButton.createButtonStroke();
                    e.width = t.x, e.height = t.y, this._animatedStroke = new s(e), this.addChild(this._loadingButton, this._animatedStroke, this._continueButton), this.pivot.set(.5 * t.x, .5 * t.y)
                }
                addClickCallback(t) {
                    this._continueButton.addClickCallback(t)
                }
                loadingComplete(t) {
                    this._progressTimeline.kill(), this._progressTimeline = new n.TimelineLite({
                        onComplete: () => {
                            this._continueButton.visible = !0, this.removeChild(this._loadingButton), this.removeChild(this._animatedStroke), this._continueButton.addClickCallback(t), this._continueButton.enable(!0)
                        }
                    }), this._progressTimeline.add(new n.TweenLite(this._animatedStroke, .2, {
                        progress: 1,
                        ease: n.Power2.easeOut
                    }))
                }
                disable() {
                    this._continueButton.enable(!1)
                }
                start() {
                    this._progressTimeline = new n.TimelineLite, this._progressTimeline.add(new n.TweenLite(this._animatedStroke, 10, {
                        progress: .8,
                        ease: n.Power2.easeOut
                    }))
                }
            }
            e.LoadingButton = a
        },
        1861: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.RatedRIntroPage = void 0;
            const n = i(2960),
                r = i(2408),
                o = i(9834),
                s = i(155),
                a = i(4514),
                l = i(1653),
                h = i(5383);
            class u extends n.SlideShowPage {
                constructor() {
                    super();
                    const t = new PIXI.TextStyle({
                        fill: "#000000",
                        fontFamily: l.OpenSans.FAMILY,
                        fontSize: 24,
                        fontStyle: h.FontStyle.NORMAL,
                        fontWeight: h.FontWeight.BOLD,
                        wordWrap: !0,
                        wordWrapWidth: 320,
                        breakWords: !0
                    }),
                        e = new PIXI.Container,
                        i = new PIXI.Sprite(r.ImgLoader.getImgTexture(o.GuiDefaultTextures.RATED_R));
                    i.anchor.set(.5, .5);
                    const n = new s.NLCText(a.NolimitApplication.apiPlugin.translations.translate("This game contains strong adult content that may be objectionable to some players."), t);
                    n.anchor.set(0, .5), n.position.set(-60, 0), e.addChild(i, n), this.addChild(e)
                }
            }
            e.RatedRIntroPage = u
        },
        7785: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.NolimitConfig = void 0;
            class i {
                static get isDevMode() {
                    var t;
                    return !0 === (null === (t = window.nolimit) || void 0 === t ? void 0 : t.development) || !1
                }
            }
            i.DEFAULT_SCREEN_MIN_RATIO = 1.6, e.NolimitConfig = i
        },
        851: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ElapsedTimeCheck = void 0, e.ElapsedTimeCheck = class {
                constructor(t, e) {
                    this._lastTime = 0, this.threshold = t, this._callback = e
                }
                checkTime() {
                    const t = Date.now(),
                        e = t - this._lastTime;
                    this._lastTime = t, e < this.threshold && this._callback()
                }
            }
        },
        5698: function (t, e, i) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function (t, e, i, n) {
                void 0 === n && (n = i);
                var r = Object.getOwnPropertyDescriptor(e, i);
                r && !("get" in r ? !e.__esModule : r.writable || r.configurable) || (r = {
                    enumerable: !0,
                    get: function () {
                        return e[i]
                    }
                }), Object.defineProperty(t, n, r)
            } : function (t, e, i, n) {
                void 0 === n && (n = i), t[n] = e[i]
            }),
                r = this && this.__setModuleDefault || (Object.create ? function (t, e) {
                    Object.defineProperty(t, "default", {
                        enumerable: !0,
                        value: e
                    })
                } : function (t, e) {
                    t.default = e
                }),
                o = this && this.__importStar || function (t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
                    return r(e, t), e
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GSAPCompatabilityWrapper = void 0;
            const s = o(i(6358)),
                a = i(8680);
            e.GSAPCompatabilityWrapper = class {
                constructor() { }
                static get isGsap3() {
                    if (null == this._isGsap3) {
                        try {
                            this._isGsap3 = null != s.gsap.ticker
                        } catch (t) {
                            this._isGsap3 = !1
                        }
                        this._isGsap3 ? a.Logger.log(`GSAP ${s.gsap.version}`) : a.Logger.log("GSAP 2.0.2")
                    }
                    return this._isGsap3
                }
                static initTicker(t) {
                    this.isGsap3 ? s.gsap.ticker.add(t) : s.TweenMax.ticker.addEventListener("tick", t)
                }
                static removeTicker(t) {
                    this.isGsap3 ? s.gsap.ticker.remove(t) : s.TweenMax.ticker.removeEventListener("tick", t)
                }
                static pauseGlobalTimeline() {
                    return this.isGsap3 ? (s.gsap.globalTimeline.pause(), s.gsap.ticker.sleep(), !0) : (s.TweenMax.globalTimeScale(0), !0)
                }
                static resumeGlobalTimeline() {
                    return this.isGsap3 ? (s.gsap.ticker.wake(), s.gsap.globalTimeline.play(), !0) : (s.TweenMax.globalTimeScale(1), !0)
                }
                static isGlobalTimelinePaused() {
                    return this.isGsap3 ? s.gsap.globalTimeline.paused() : 0 === s.TweenMax.globalTimeScale()
                }
                static delayedCall(t, e, i) {
                    return this.isGsap3 ? s.gsap.delayedCall(t, e, i) : s.TweenLite.delayedCall(t, e, i)
                }
            }
        },
        1288: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Helper = void 0;
            const n = i(7785);
            e.Helper = class {
                static shrinkTextWidth(t, e, i) {
                    for (; e.width > i;) {
                        if (this.isString(e.style.fontSize)) {
                            if (e.style.fontSize.indexOf("em") > -1) throw new Error("Helper.shrinkTextWidth(), I am lazy so I don't want to parse em, please use number or px.");
                            e.style.fontSize = parseInt(e.style.fontSize)
                        }
                        if (e.style.fontSize--, e.style.fontSize <= 10) return void (e.style.fontSize = 10)
                    }
                }
                static isString(t) {
                    return "string" == typeof t
                }
                static isDefaultScreenRatio(t) {
                    return Math.max(t.width, t.height) / Math.min(t.width, t.height) > n.NolimitConfig.DEFAULT_SCREEN_MIN_RATIO
                }
            }
        },
        8680: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Logger = e.NamedLogger = e.LogLevel = void 0;
            const n = i(7785);
            var r;
            ! function (t) {
                t.NONE = "NONE", t.DEV = "DEV", t.INFO = "INFO"
            }(r = e.LogLevel || (e.LogLevel = {}));
            class o {
                constructor(t, e) {
                    this.level = r.DEV, this.name = t, this.style = e, this.stylePrefix = null != e ? "%c" : ""
                }
                log(t, ...e) {
                    this.style && e.unshift(this.style), this.level == r.INFO ? s.log(`${this.stylePrefix}[${this.name}]: ${t}`, ...e) : this.level == r.DEV && s.logDev(`${this.stylePrefix}[${this.name}]: ${t}`, ...e)
                }
                warn(t, ...e) {
                    this.level != r.NONE && s.warn(`[${this.name}]: ${t}`, ...e)
                }
            }
            e.NamedLogger = o;
            class s {
                static createNamedLogger(t) {
                    const e = new o(t);
                    return s.namedLoggers.push(e), e
                }
                static findNamedLogger(t) {
                    s.namedLoggers.forEach((e => {
                        if (e.name == t) return e
                    }))
                }
                static log(t, ...e) {
                    console.log(t, ...e)
                }
                static logDev(t, ...e) {
                    n.NolimitConfig.isDevMode && console.log(t, ...e)
                }
                static warn(t, ...e) {
                    n.NolimitConfig.isDevMode && console.warn(t, ...e)
                }
                static deprecated(t, e) {
                    if (n.NolimitConfig.isDevMode) {
                        if (s.displayedDeprecationWarnings[t]) return;
                        console.warn("SlotGame Deprecation Warning: ", t + "\nDeprecated since v" + e), s.displayedDeprecationWarnings[t] = !0
                    }
                }
            }
            s.namedLoggers = [], s.displayedDeprecationWarnings = {}, e.Logger = s
        },
        2817: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ViewPort = void 0;
            class i {
                get confineToRatio() {
                    return this._confineToRatio
                }
                set confineToRatio(t) {
                    this._confineToRatio = t
                }
                get ratio() {
                    return this._ratio
                }
                set ratio(t) {
                    this._ratio = t
                }
                get element() {
                    return this._element
                }
                set element(t) {
                    this._element = t
                }
                static get instance() {
                    return null == this._instance && (this._instance = new i), this._instance
                }
                constructor() {
                    this._confineToRatio = !1, this.onWindowResize = t => {
                        const e = document.documentElement.clientWidth,
                            n = document.documentElement.clientHeight;
                        let r = new PIXI.Rectangle(0, 0, e, n);
                        i.instance.confineToRatio && (r = e / n < i.instance.ratio ? i.fitWidth(i.instance.ratio) : i.fitHeight(i.instance.ratio), r.x = (e - r.width) / 2, r.y = (n - r.height) / 2, i.instance.element.style.width = r.width + "px", i.instance.element.style.height = r.height + "px", i.instance.element.style.left = r.x + "px", i.instance.element.style.top = r.y + "px"), null != i.instance._resizeCallback && i.instance._resizeCallback(r.width, r.height)
                    }, window.addEventListener("resize", this.onWindowResize)
                }
                static fitWidth(t) {
                    return new PIXI.Rectangle(0, 0, document.documentElement.clientWidth, Math.round(document.documentElement.clientWidth / t))
                }
                static fitHeight(t) {
                    return new PIXI.Rectangle(0, 0, Math.round(document.documentElement.clientHeight * t), document.documentElement.clientHeight)
                }
                static confineToRatio(t, e) {
                    i.instance.confineToRatio = !0, i.instance.element = t, i.instance.ratio = e
                }
                static onResize(t) {
                    i.instance._resizeCallback = t
                }
                static shutDown() {
                    window.removeEventListener("resize", i.instance.onWindowResize)
                }
                static triggerResize() {
                    i.instance.onWindowResize(void 0)
                }
            }
            e.ViewPort = i
        },
        1924: (t, e, i) => {
            "use strict";
            var n = i(210),
                r = i(5559),
                o = r(n("String.prototype.indexOf"));
            t.exports = function (t, e) {
                var i = n(t, !!e);
                return "function" == typeof i && o(t, ".prototype.") > -1 ? r(i) : i
            }
        },
        5559: (t, e, i) => {
            "use strict";
            var n = i(8612),
                r = i(210),
                o = r("%Function.prototype.apply%"),
                s = r("%Function.prototype.call%"),
                a = r("%Reflect.apply%", !0) || n.call(s, o),
                l = r("%Object.getOwnPropertyDescriptor%", !0),
                h = r("%Object.defineProperty%", !0),
                u = r("%Math.max%");
            if (h) try {
                h({}, "a", {
                    value: 1
                })
            } catch (t) {
                h = null
            }
            t.exports = function (t) {
                var e = a(n, s, arguments);
                return l && h && l(e, "length").configurable && h(e, "length", {
                    value: 1 + u(0, t.length - (arguments.length - 1))
                }), e
            };
            var c = function () {
                return a(n, o, arguments)
            };
            h ? h(t.exports, "apply", {
                value: c
            }) : t.exports.apply = c
        },
        7284: (t, e, i) => {
            "use strict";
            i.d(e, {
                Z: () => a
            });
            var n = i(7537),
                r = i.n(n),
                o = i(3645),
                s = i.n(o)()(r());
            s.push([t.id, ".nolimit button {\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\n    color: white;\n    background-color: rgba(0, 0, 0, 0.5);\n\n    border: 0.05em solid rgba(255, 255, 255, 0.5);\n    border-radius: 0.4em;\n\n    background-clip: padding-box;\n\n    font-style: italic;\n    font-weight: 800;\n    font-size: 4em;\n\n    margin: 0.8em;\n    padding: 0.1em 1.0em;\n\n    text-transform: uppercase;\n\n\n    opacity: 0.8;\n\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n\n    cursor: pointer;\n\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n[data-device=\"desktop\"] .nolimit button:hover {\n    border-color: white;\n    opacity: 1;\n}\n\n[data-device=\"mobile\"] .nolimit button {\n    border-color: white;\n    opacity: 1;\n    cursor: default;\n}\n\n.nolimit button:active {\n    border-color: white;\n    transform: scale(0.95);\n    opacity: 1;\n}\n\n.nolimit button.active {\n    opacity: 1;\n    color: #fbf800;\n    border-color: #fbf800;\n}\n\n.nolimit button.close:not(.icon) {\n    width: auto;\n}\n\n[data-device=\"desktop\"] .nolimit button.disabled,\n[data-device=\"desktop\"] .nolimit button.disabled:hover,\n[data-device=\"mobile\"] .nolimit button.disabled {\n    border-color: rgba(255, 255, 255, 0.5);\n    cursor: default;\n    transform: none;\n    opacity: 0.5;\n}\n\n.nolimit button.disabled.waiting{\nanimation-name: waiting;\nanimation-duration: 2s;\nanimation-iteration-count:infinite;\n}\n\n@keyframes waiting {\n    0%  {opacity:0.5}\n    50% {opacity:0.2}\n    100% {opacity:0.5}\n}\n", "", {
                version: 3,
                sources: ["webpack://./node_modules/@nolimit/game-api/src/css/button.css"],
                names: [],
                mappings: "AAAA;IACI,wIAAwI;IACxI,YAAY;IACZ,oCAAoC;;IAEpC,6CAA6C;IAC7C,oBAAoB;;IAEpB,4BAA4B;;IAE5B,kBAAkB;IAClB,gBAAgB;IAChB,cAAc;;IAEd,aAAa;IACb,oBAAoB;;IAEpB,yBAAyB;;;IAGzB,YAAY;;IAEZ,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;;IAErB,eAAe;;IAEf,2BAA2B;IAC3B,mCAAmC;AACvC;;AAEA;IACI,mBAAmB;IACnB,UAAU;AACd;;AAEA;IACI,mBAAmB;IACnB,UAAU;IACV,eAAe;AACnB;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,UAAU;AACd;;AAEA;IACI,UAAU;IACV,cAAc;IACd,qBAAqB;AACzB;;AAEA;IACI,WAAW;AACf;;AAEA;;;IAGI,sCAAsC;IACtC,eAAe;IACf,eAAe;IACf,YAAY;AAChB;;AAEA;AACA,uBAAuB;AACvB,sBAAsB;AACtB,kCAAkC;AAClC;;AAEA;IACI,KAAK,WAAW;IAChB,KAAK,WAAW;IAChB,MAAM,WAAW;AACrB",
                sourcesContent: [".nolimit button {\r\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\r\n    color: white;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n\r\n    border: 0.05em solid rgba(255, 255, 255, 0.5);\r\n    border-radius: 0.4em;\r\n\r\n    background-clip: padding-box;\r\n\r\n    font-style: italic;\r\n    font-weight: 800;\r\n    font-size: 4em;\r\n\r\n    margin: 0.8em;\r\n    padding: 0.1em 1.0em;\r\n\r\n    text-transform: uppercase;\r\n\r\n\r\n    opacity: 0.8;\r\n\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n\r\n    cursor: pointer;\r\n\r\n    backface-visibility: hidden;\r\n    -webkit-backface-visibility: hidden;\r\n}\r\n\r\n[data-device=\"desktop\"] .nolimit button:hover {\r\n    border-color: white;\r\n    opacity: 1;\r\n}\r\n\r\n[data-device=\"mobile\"] .nolimit button {\r\n    border-color: white;\r\n    opacity: 1;\r\n    cursor: default;\r\n}\r\n\r\n.nolimit button:active {\r\n    border-color: white;\r\n    transform: scale(0.95);\r\n    opacity: 1;\r\n}\r\n\r\n.nolimit button.active {\r\n    opacity: 1;\r\n    color: #fbf800;\r\n    border-color: #fbf800;\r\n}\r\n\r\n.nolimit button.close:not(.icon) {\r\n    width: auto;\r\n}\r\n\r\n[data-device=\"desktop\"] .nolimit button.disabled,\r\n[data-device=\"desktop\"] .nolimit button.disabled:hover,\r\n[data-device=\"mobile\"] .nolimit button.disabled {\r\n    border-color: rgba(255, 255, 255, 0.5);\r\n    cursor: default;\r\n    transform: none;\r\n    opacity: 0.5;\r\n}\r\n\r\n.nolimit button.disabled.waiting{\r\nanimation-name: waiting;\r\nanimation-duration: 2s;\r\nanimation-iteration-count:infinite;\r\n}\r\n\r\n@keyframes waiting {\r\n    0%  {opacity:0.5}\r\n    50% {opacity:0.2}\r\n    100% {opacity:0.5}\r\n}\r\n"],
                sourceRoot: ""
            }]);
            const a = s
        },
        8779: (t, e, i) => {
            "use strict";
            i.d(e, {
                Z: () => a
            });
            var n = i(7537),
                r = i.n(n),
                o = i(3645),
                s = i.n(o)()(r());
            s.push([t.id, "\n.nolimit .dialog {\n    border: 0.2em solid rgba(255, 255, 255, 0.5);\n    border-radius: 2em;\n    background-clip: padding-box;\n    background-color: rgba(0, 0, 0, 0.5);\n    text-align: center;\n    padding-top: 0em;\n    padding-right: 4em;\n    padding-left: 4em;\n    padding-bottom: 0em;\n    font-weight: 200;\n    overflow: hidden;\n    height:auto;\n    width:auto;\n    max-width: 90%;\n    max-height: 90%;\n}\n\n.nolimit .dialog, .nolimit .dialog a {\n    color: #fbf800;\n}\n.nolimit .dialog a {\n    font-size:1.4em\n}\n\n.nolimit .dialog a:hover {\n    font-weight: 400;\n}\n\n.nolimit .hidden {\n    position: absolute;\n    left: -200vw;\n    padding: 0;\n    margin: 0;\n}\n\n.nolimit .hidden .dialog {\n    width: 70vw;\n    max-height: 90%;\n    height: auto;\n\n}\n\n.nolimit .dialog h1, .nolimit .dialog p, .nolimit .dialog ul {\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n}\n\n.nolimit .dialog h1, .nolimit .dialog h2 {\n    color: white;\n    margin-top: 1em;\n    margin-bottom: 1em;\n    font-weight: 300;\n}\n\n.nolimit .dialog h1 {\n    font-size: 3em;\n}\n\n.nolimit .dialog h2 {\n    font-size: 2.8em;\n}\n\n.nolimit .dialog ul {\n    list-style: none none;\n    font-size: 1.6em;\n    padding: 0;\n}\n\n.nolimit .dialog p {\n    margin: 1em;\n    font-weight: 200;\n    font-size: 1.7em;\n}\n\n.nolimit .dialog .grid {\n    width: 100%;\n    display: table;\n    table-layout: fixed;\n}\n\n.nolimit .dialog .grid > * {\n    display: table-cell;\n}\n", "", {
                version: 3,
                sources: ["webpack://./node_modules/@nolimit/game-api/src/css/dialog.css"],
                names: [],
                mappings: ";AACA;IACI,4CAA4C;IAC5C,kBAAkB;IAClB,4BAA4B;IAC5B,oCAAoC;IACpC,kBAAkB;IAClB,gBAAgB;IAChB,kBAAkB;IAClB,iBAAiB;IACjB,mBAAmB;IACnB,gBAAgB;IAChB,gBAAgB;IAChB,WAAW;IACX,UAAU;IACV,cAAc;IACd,eAAe;AACnB;;AAEA;IACI,cAAc;AAClB;AACA;IACI;AACJ;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,kBAAkB;IAClB,YAAY;IACZ,UAAU;IACV,SAAS;AACb;;AAEA;IACI,WAAW;IACX,eAAe;IACf,YAAY;;AAEhB;;AAEA;IACI,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;AACzB;;AAEA;IACI,YAAY;IACZ,eAAe;IACf,kBAAkB;IAClB,gBAAgB;AACpB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,gBAAgB;AACpB;;AAEA;IACI,qBAAqB;IACrB,gBAAgB;IAChB,UAAU;AACd;;AAEA;IACI,WAAW;IACX,gBAAgB;IAChB,gBAAgB;AACpB;;AAEA;IACI,WAAW;IACX,cAAc;IACd,mBAAmB;AACvB;;AAEA;IACI,mBAAmB;AACvB",
                sourcesContent: ["\r\n.nolimit .dialog {\r\n    border: 0.2em solid rgba(255, 255, 255, 0.5);\r\n    border-radius: 2em;\r\n    background-clip: padding-box;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n    text-align: center;\r\n    padding-top: 0em;\r\n    padding-right: 4em;\r\n    padding-left: 4em;\r\n    padding-bottom: 0em;\r\n    font-weight: 200;\r\n    overflow: hidden;\r\n    height:auto;\r\n    width:auto;\r\n    max-width: 90%;\r\n    max-height: 90%;\r\n}\r\n\r\n.nolimit .dialog, .nolimit .dialog a {\r\n    color: #fbf800;\r\n}\r\n.nolimit .dialog a {\r\n    font-size:1.4em\r\n}\r\n\r\n.nolimit .dialog a:hover {\r\n    font-weight: 400;\r\n}\r\n\r\n.nolimit .hidden {\r\n    position: absolute;\r\n    left: -200vw;\r\n    padding: 0;\r\n    margin: 0;\r\n}\r\n\r\n.nolimit .hidden .dialog {\r\n    width: 70vw;\r\n    max-height: 90%;\r\n    height: auto;\r\n\r\n}\r\n\r\n.nolimit .dialog h1, .nolimit .dialog p, .nolimit .dialog ul {\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n}\r\n\r\n.nolimit .dialog h1, .nolimit .dialog h2 {\r\n    color: white;\r\n    margin-top: 1em;\r\n    margin-bottom: 1em;\r\n    font-weight: 300;\r\n}\r\n\r\n.nolimit .dialog h1 {\r\n    font-size: 3em;\r\n}\r\n\r\n.nolimit .dialog h2 {\r\n    font-size: 2.8em;\r\n}\r\n\r\n.nolimit .dialog ul {\r\n    list-style: none none;\r\n    font-size: 1.6em;\r\n    padding: 0;\r\n}\r\n\r\n.nolimit .dialog p {\r\n    margin: 1em;\r\n    font-weight: 200;\r\n    font-size: 1.7em;\r\n}\r\n\r\n.nolimit .dialog .grid {\r\n    width: 100%;\r\n    display: table;\r\n    table-layout: fixed;\r\n}\r\n\r\n.nolimit .dialog .grid > * {\r\n    display: table-cell;\r\n}\r\n"],
                sourceRoot: ""
            }]);
            const a = s
        },
        4894: (t, e, i) => {
            "use strict";
            i.d(e, {
                Z: () => a
            });
            var n = i(7537),
                r = i.n(n),
                o = i(3645),
                s = i.n(o)()(r());
            s.push([t.id, "@keyframes blink {\n    0% {\n        opacity: 1;\n    }\n    50% {\n        opacity: 0;\n    }\n    100% {\n        opacity: 1;\n    }\n}\n\nhtml {\n    box-sizing: border-box;\n}\n\n[data-device=\"mobile\"] .nolimit .desktop {\n    display: none !important;\n}\n\n[data-device=\"desktop\"] .nolimit .mobile {\n    display: none !important;\n}\n\n.nolimit #game-name-version {\n    /*    pointer-events: none;\n        position: absolute;\n        z-index: 2147483647;\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n\n       padding: 0.1em 0.4em;\n        border-radius: 0.3em;\n        font-size: 1.4em;\n        font-weight: 100;\n        opacity: 1;\n        color: #ffffff;\n        background-color: rgba(0, 0, 0, 0.5);\n\n        top: 0.71em;\n        right: 0.71em;\n        margin-right: env(safe-area-inset-right);*/\n}\n\n.nolimit #net-position{\n    pointer-events: none;\n    position: absolute;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    white-space: nowrap;\n\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n\n    top: 1.8em;\n    right: 0em;\n    margin-right: env(safe-area-inset-right);\n}\n\n.nolimit * {\n    position: initial;\n    width: initial;\n    height: initial;\n    object-fit: initial;\n}\n\nhtml, body, .nolimit.container, .nolimit.container > .game {\n    margin: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n}\n\nbody {\n    position: fixed;\n    background-color: #000;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\n}\n\n*, *:before, *:after {\n    box-sizing: inherit;\n}\n\n.blurred {\n    -webkit-filter: blur(3em);\n    filter: blur(3em);\n}\n\nhtml, button, a {\n    -ms-touch-action: manipulation;\n    touch-action: manipulation;\n}\n\n.nolimit.container {\n    position: absolute;\n}\n\n[data-device=\"mobile\"] .nolimit.container {\n    top: 0;\n    left: 0;\n}\n\n.nolimit.container.loading {\n    visibility: hidden;\n}\n\n.nolimit > .fun, .nolimit > .beta, .nolimit > .replay {\n    position: absolute;\n    z-index: 10000;\n    font-weight: 600;\n    padding: 4px 8px;\n    font-size: 1rem;\n    top: 0;\n\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n}\n\n[data-device=\"mobile\"] .nolimit > .replay {\n    top: 1rem;\n}\n\n@media screen and (orientation: portrait) {\n    [data-device=\"mobile\"] .nolimit > .replay {\n        font-size: 10vw;\n    }\n}\n\n.nolimit > .replay {\n    color: white;\n    right: 0;\n    font-weight: bold;\n    font-size: 5vw;\n    margin: 0 0.6rem;\n    animation: 1.5s linear infinite blink;\n    display: none;\n}\n\n\n\n\n.nolimit > .beta {\n    color: #fbf800;\n    right: 0;\n    opacity: 0.7;\n}\n\n.nolimit > .game {\n    text-align: center;\n    position: relative;\n}\n\n\n.nolimit .top-label-left, .top-label-right {\n    pointer-events: none;\n    position: absolute;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n    top: 0.71em;\n}\n\n\n.nolimit .top-bar-left, .top-bar-right {\n    pointer-events: none;\n    z-index: 2147483647;\n    -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n    display: flex;\n    flex-direction: row;\n    position: absolute;\n    top:1em;\n}\n.nolimit .top-bar-left{\n    left: 1em;\n    margin-left: env(safe-area-inset-left);\n}\n.nolimit .top-bar-left .top-bar-item  {\n    margin-right: 0.5em;\n}\n\n.nolimit .top-bar-right{\n    right: 1em;\n    margin-right: env(safe-area-inset-right);\n}\n.nolimit .top-bar-right .top-bar-item  {\n    margin-left: 0.5em;\n}\n\n.nolimit .top-bar-item {\n    padding: 0.1em 0.4em;\n    border-radius: 0.3em;\n    font-size: 1.4em;\n    font-weight: 100;\n    opacity: 1;\n    color: #ffffff;\n    background-color: rgba(0, 0, 0, 0.5);\n}\n\n\n\n", "", {
                version: 3,
                sources: ["webpack://./node_modules/@nolimit/game-api/src/css/main.css"],
                names: [],
                mappings: "AAAA;IACI;QACI,UAAU;IACd;IACA;QACI,UAAU;IACd;IACA;QACI,UAAU;IACd;AACJ;;AAEA;IACI,sBAAsB;AAC1B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI,wBAAwB;AAC5B;;AAEA;IACI;;;;;;;;;;;;;;;;;;;kDAmB8C;AAClD;;AAEA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,mBAAmB;IACnB,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;IACrB,iBAAiB;IACjB,mBAAmB;;IAEnB,oBAAoB;IACpB,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;IACV,cAAc;IACd,oCAAoC;;IAEpC,UAAU;IACV,UAAU;IACV,wCAAwC;AAC5C;;AAEA;IACI,iBAAiB;IACjB,cAAc;IACd,eAAe;IACf,mBAAmB;AACvB;;AAEA;IACI,SAAS;IACT,WAAW;IACX,YAAY;IACZ,gBAAgB;AACpB;;AAEA;IACI,eAAe;IACf,sBAAsB;IACtB,6CAA6C;IAC7C,wIAAwI;AAC5I;;AAEA;IACI,mBAAmB;AACvB;;AAEA;IACI,yBAAyB;IACzB,iBAAiB;AACrB;;AAEA;IACI,8BAA8B;IAC9B,0BAA0B;AAC9B;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,MAAM;IACN,OAAO;AACX;;AAEA;IACI,kBAAkB;AACtB;;AAEA;IACI,kBAAkB;IAClB,cAAc;IACd,gBAAgB;IAChB,gBAAgB;IAChB,eAAe;IACf,MAAM;;IAEN,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;AACzB;;AAEA;IACI,SAAS;AACb;;AAEA;IACI;QACI,eAAe;IACnB;AACJ;;AAEA;IACI,YAAY;IACZ,QAAQ;IACR,iBAAiB;IACjB,cAAc;IACd,gBAAgB;IAChB,qCAAqC;IACrC,aAAa;AACjB;;;;;AAKA;IACI,cAAc;IACd,QAAQ;IACR,YAAY;AAChB;;AAEA;IACI,kBAAkB;IAClB,kBAAkB;AACtB;;;AAGA;IACI,oBAAoB;IACpB,kBAAkB;IAClB,mBAAmB;IACnB,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;IACrB,iBAAiB;;IAEjB,oBAAoB;IACpB,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;IACV,cAAc;IACd,oCAAoC;IACpC,WAAW;AACf;;;AAGA;IACI,oBAAoB;IACpB,mBAAmB;IACnB,2BAA2B;IAC3B,yBAAyB;IACzB,sBAAsB;IACtB,qBAAqB;IACrB,iBAAiB;;IAEjB,aAAa;IACb,mBAAmB;IACnB,kBAAkB;IAClB,OAAO;AACX;AACA;IACI,SAAS;IACT,sCAAsC;AAC1C;AACA;IACI,mBAAmB;AACvB;;AAEA;IACI,UAAU;IACV,wCAAwC;AAC5C;AACA;IACI,kBAAkB;AACtB;;AAEA;IACI,oBAAoB;IACpB,oBAAoB;IACpB,gBAAgB;IAChB,gBAAgB;IAChB,UAAU;IACV,cAAc;IACd,oCAAoC;AACxC",
                sourcesContent: ["@keyframes blink {\r\n    0% {\r\n        opacity: 1;\r\n    }\r\n    50% {\r\n        opacity: 0;\r\n    }\r\n    100% {\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\nhtml {\r\n    box-sizing: border-box;\r\n}\r\n\r\n[data-device=\"mobile\"] .nolimit .desktop {\r\n    display: none !important;\r\n}\r\n\r\n[data-device=\"desktop\"] .nolimit .mobile {\r\n    display: none !important;\r\n}\r\n\r\n.nolimit #game-name-version {\r\n    /*    pointer-events: none;\r\n        position: absolute;\r\n        z-index: 2147483647;\r\n        -webkit-touch-callout: none;\r\n        -webkit-user-select: none;\r\n        -moz-user-select: none;\r\n        -ms-user-select: none;\r\n        user-select: none;\r\n\r\n       padding: 0.1em 0.4em;\r\n        border-radius: 0.3em;\r\n        font-size: 1.4em;\r\n        font-weight: 100;\r\n        opacity: 1;\r\n        color: #ffffff;\r\n        background-color: rgba(0, 0, 0, 0.5);\r\n\r\n        top: 0.71em;\r\n        right: 0.71em;\r\n        margin-right: env(safe-area-inset-right);*/\r\n}\r\n\r\n.nolimit #net-position{\r\n    pointer-events: none;\r\n    position: absolute;\r\n    z-index: 2147483647;\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;\r\n    white-space: nowrap;\r\n\r\n    padding: 0.1em 0.4em;\r\n    border-radius: 0.3em;\r\n    font-size: 1.4em;\r\n    font-weight: 100;\r\n    opacity: 1;\r\n    color: #ffffff;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n\r\n    top: 1.8em;\r\n    right: 0em;\r\n    margin-right: env(safe-area-inset-right);\r\n}\r\n\r\n.nolimit * {\r\n    position: initial;\r\n    width: initial;\r\n    height: initial;\r\n    object-fit: initial;\r\n}\r\n\r\nhtml, body, .nolimit.container, .nolimit.container > .game {\r\n    margin: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n}\r\n\r\nbody {\r\n    position: fixed;\r\n    background-color: #000;\r\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\r\n    font-family: 'Open Sans', 'HelveticaNeue-Light', 'Helvetica Neue Light', 'Helvetica Neue', Helvetica, Arial, 'Lucida Grande', sans-serif;\r\n}\r\n\r\n*, *:before, *:after {\r\n    box-sizing: inherit;\r\n}\r\n\r\n.blurred {\r\n    -webkit-filter: blur(3em);\r\n    filter: blur(3em);\r\n}\r\n\r\nhtml, button, a {\r\n    -ms-touch-action: manipulation;\r\n    touch-action: manipulation;\r\n}\r\n\r\n.nolimit.container {\r\n    position: absolute;\r\n}\r\n\r\n[data-device=\"mobile\"] .nolimit.container {\r\n    top: 0;\r\n    left: 0;\r\n}\r\n\r\n.nolimit.container.loading {\r\n    visibility: hidden;\r\n}\r\n\r\n.nolimit > .fun, .nolimit > .beta, .nolimit > .replay {\r\n    position: absolute;\r\n    z-index: 10000;\r\n    font-weight: 600;\r\n    padding: 4px 8px;\r\n    font-size: 1rem;\r\n    top: 0;\r\n\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n}\r\n\r\n[data-device=\"mobile\"] .nolimit > .replay {\r\n    top: 1rem;\r\n}\r\n\r\n@media screen and (orientation: portrait) {\r\n    [data-device=\"mobile\"] .nolimit > .replay {\r\n        font-size: 10vw;\r\n    }\r\n}\r\n\r\n.nolimit > .replay {\r\n    color: white;\r\n    right: 0;\r\n    font-weight: bold;\r\n    font-size: 5vw;\r\n    margin: 0 0.6rem;\r\n    animation: 1.5s linear infinite blink;\r\n    display: none;\r\n}\r\n\r\n\r\n\r\n\r\n.nolimit > .beta {\r\n    color: #fbf800;\r\n    right: 0;\r\n    opacity: 0.7;\r\n}\r\n\r\n.nolimit > .game {\r\n    text-align: center;\r\n    position: relative;\r\n}\r\n\r\n\r\n.nolimit .top-label-left, .top-label-right {\r\n    pointer-events: none;\r\n    position: absolute;\r\n    z-index: 2147483647;\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;\r\n\r\n    padding: 0.1em 0.4em;\r\n    border-radius: 0.3em;\r\n    font-size: 1.4em;\r\n    font-weight: 100;\r\n    opacity: 1;\r\n    color: #ffffff;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n    top: 0.71em;\r\n}\r\n\r\n\r\n.nolimit .top-bar-left, .top-bar-right {\r\n    pointer-events: none;\r\n    z-index: 2147483647;\r\n    -webkit-touch-callout: none;\r\n    -webkit-user-select: none;\r\n    -moz-user-select: none;\r\n    -ms-user-select: none;\r\n    user-select: none;\r\n\r\n    display: flex;\r\n    flex-direction: row;\r\n    position: absolute;\r\n    top:1em;\r\n}\r\n.nolimit .top-bar-left{\r\n    left: 1em;\r\n    margin-left: env(safe-area-inset-left);\r\n}\r\n.nolimit .top-bar-left .top-bar-item  {\r\n    margin-right: 0.5em;\r\n}\r\n\r\n.nolimit .top-bar-right{\r\n    right: 1em;\r\n    margin-right: env(safe-area-inset-right);\r\n}\r\n.nolimit .top-bar-right .top-bar-item  {\r\n    margin-left: 0.5em;\r\n}\r\n\r\n.nolimit .top-bar-item {\r\n    padding: 0.1em 0.4em;\r\n    border-radius: 0.3em;\r\n    font-size: 1.4em;\r\n    font-weight: 100;\r\n    opacity: 1;\r\n    color: #ffffff;\r\n    background-color: rgba(0, 0, 0, 0.5);\r\n}\r\n\r\n\r\n\r\n"],
                sourceRoot: ""
            }]);
            const a = s
        },
        1672: (t, e, i) => {
            "use strict";
            i.d(e, {
                Z: () => a
            });
            var n = i(7537),
                r = i.n(n),
                o = i(3645),
                s = i.n(o)()(r());
            s.push([t.id, ".nolimit .overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    overflow: hidden;\n    z-index: 2147483645;\n    display: none;\n\n    align-items: center;\n    justify-content: center;\n    width: 100%;\n    height: 100%;\n}\n\n.nolimit.overlay .overlay {\n    display: -webkit-flex;\n    display: -ms-flexbox;\n    display: flex;\n}\n\n.nolimit.overlay .overlay {\n    background-color: rgba(0, 0, 0, 0);\n}\n\n.nolimit.overlay .overlay.blackout {\n    background-color: rgba(0, 0, 0, 1);\n}\n", "", {
                version: 3,
                sources: ["webpack://./node_modules/@nolimit/game-api/src/css/overlay.css"],
                names: [],
                mappings: "AAAA;IACI,eAAe;IACf,MAAM;IACN,OAAO;IACP,gBAAgB;IAChB,mBAAmB;IACnB,aAAa;;IAEb,mBAAmB;IACnB,uBAAuB;IACvB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,qBAAqB;IACrB,oBAAoB;IACpB,aAAa;AACjB;;AAEA;IACI,kCAAkC;AACtC;;AAEA;IACI,kCAAkC;AACtC",
                sourcesContent: [".nolimit .overlay {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    overflow: hidden;\r\n    z-index: 2147483645;\r\n    display: none;\r\n\r\n    align-items: center;\r\n    justify-content: center;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.nolimit.overlay .overlay {\r\n    display: -webkit-flex;\r\n    display: -ms-flexbox;\r\n    display: flex;\r\n}\r\n\r\n.nolimit.overlay .overlay {\r\n    background-color: rgba(0, 0, 0, 0);\r\n}\r\n\r\n.nolimit.overlay .overlay.blackout {\r\n    background-color: rgba(0, 0, 0, 1);\r\n}\r\n"],
                sourceRoot: ""
            }]);
            const a = s
        },
        3645: t => {
            "use strict";
            t.exports = function (t) {
                var e = [];
                return e.toString = function () {
                    return this.map((function (e) {
                        var i = "",
                            n = void 0 !== e[5];
                        return e[4] && (i += "@supports (".concat(e[4], ") {")), e[2] && (i += "@media ".concat(e[2], " {")), n && (i += "@layer".concat(e[5].length > 0 ? " ".concat(e[5]) : "", " {")), i += t(e), n && (i += "}"), e[2] && (i += "}"), e[4] && (i += "}"), i
                    })).join("")
                }, e.i = function (t, i, n, r, o) {
                    "string" == typeof t && (t = [
                        [null, t, void 0]
                    ]);
                    var s = {};
                    if (n)
                        for (var a = 0; a < this.length; a++) {
                            var l = this[a][0];
                            null != l && (s[l] = !0)
                        }
                    for (var h = 0; h < t.length; h++) {
                        var u = [].concat(t[h]);
                        n && s[u[0]] || (void 0 !== o && (void 0 === u[5] || (u[1] = "@layer".concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {").concat(u[1], "}")), u[5] = o), i && (u[2] ? (u[1] = "@media ".concat(u[2], " {").concat(u[1], "}"), u[2] = i) : u[2] = i), r && (u[4] ? (u[1] = "@supports (".concat(u[4], ") {").concat(u[1], "}"), u[4] = r) : u[4] = "".concat(r)), e.push(u))
                    }
                }, e
            }
        },
        7537: t => {
            "use strict";
            t.exports = function (t) {
                var e = t[1],
                    i = t[3];
                if (!i) return e;
                if ("function" == typeof btoa) {
                    var n = btoa(unescape(encodeURIComponent(JSON.stringify(i)))),
                        r = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(n),
                        o = "/*# ".concat(r, " */");
                    return [e].concat([o]).join("\n")
                }
                return [e].join("\n")
            }
        },
        9187: t => {
            "use strict";

            function e(t, e, n) {
                n = n || 2;
                var o, s, a, l, c, d, f, g = e && e.length,
                    m = g ? e[0] * n : t.length,
                    _ = i(t, 0, m, n, !0),
                    y = [];
                if (!_ || _.next === _.prev) return y;
                if (g && (_ = function (t, e, n, r) {
                    var o, s, a, l = [];
                    for (o = 0, s = e.length; o < s; o++)(a = i(t, e[o] * r, o < s - 1 ? e[o + 1] * r : t.length, r, !1)) === a.next && (a.steiner = !0), l.push(p(a));
                    for (l.sort(h), o = 0; o < l.length; o++) n = u(l[o], n);
                    return n
                }(t, e, _, n)), t.length > 80 * n) {
                    o = a = t[0], s = l = t[1];
                    for (var S = n; S < m; S += n)(c = t[S]) < o && (o = c), (d = t[S + 1]) < s && (s = d), c > a && (a = c), d > l && (l = d);
                    f = 0 !== (f = Math.max(a - o, l - s)) ? 32767 / f : 0
                }
                return r(_, y, n, o, s, f, 0), y
            }

            function i(t, e, i, n, r) {
                var o, s;
                if (r === w(t, e, i, n) > 0)
                    for (o = e; o < i; o += n) s = P(o, t[o], t[o + 1], s);
                else
                    for (o = i - n; o >= e; o -= n) s = P(o, t[o], t[o + 1], s);
                return s && _(s, s.next) && (A(s), s = s.next), s
            }

            function n(t, e) {
                if (!t) return t;
                e || (e = t);
                var i, n = t;
                do {
                    if (i = !1, n.steiner || !_(n, n.next) && 0 !== m(n.prev, n, n.next)) n = n.next;
                    else {
                        if (A(n), (n = e = n.prev) === n.next) break;
                        i = !0
                    }
                } while (i || n !== e);
                return e
            }

            function r(t, e, i, h, u, c, p) {
                if (t) {
                    !p && c && function (t, e, i, n) {
                        var r = t;
                        do {
                            0 === r.z && (r.z = d(r.x, r.y, e, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                        } while (r !== t);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function (t) {
                                var e, i, n, r, o, s, a, l, h = 1;
                                do {
                                    for (i = t, t = null, o = null, s = 0; i;) {
                                        for (s++, n = i, a = 0, e = 0; e < h && (a++, n = n.nextZ); e++);
                                        for (l = h; a > 0 || l > 0 && n;) 0 !== a && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, a--) : (r = n, n = n.nextZ, l--), o ? o.nextZ = r : t = r, r.prevZ = o, o = r;
                                        i = n
                                    }
                                    o.nextZ = null, h *= 2
                                } while (s > 1)
                            }(r)
                    }(t, h, u, c);
                    for (var f, g, m = t; t.prev !== t.next;)
                        if (f = t.prev, g = t.next, c ? s(t, h, u, c) : o(t)) e.push(f.i / i | 0), e.push(t.i / i | 0), e.push(g.i / i | 0), A(t), t = g.next, m = g.next;
                        else if ((t = g) === m) {
                            p ? 1 === p ? r(t = a(n(t), e, i), e, i, h, u, c, 2) : 2 === p && l(t, e, i, h, u, c) : r(n(t), e, i, h, u, c, 1);
                            break
                        }
                }
            }

            function o(t) {
                var e = t.prev,
                    i = t,
                    n = t.next;
                if (m(e, i, n) >= 0) return !1;
                for (var r = e.x, o = i.x, s = n.x, a = e.y, l = i.y, h = n.y, u = r < o ? r < s ? r : s : o < s ? o : s, c = a < l ? a < h ? a : h : l < h ? l : h, d = r > o ? r > s ? r : s : o > s ? o : s, p = a > l ? a > h ? a : h : l > h ? l : h, g = n.next; g !== e;) {
                    if (g.x >= u && g.x <= d && g.y >= c && g.y <= p && f(r, a, o, l, s, h, g.x, g.y) && m(g.prev, g, g.next) >= 0) return !1;
                    g = g.next
                }
                return !0
            }

            function s(t, e, i, n) {
                var r = t.prev,
                    o = t,
                    s = t.next;
                if (m(r, o, s) >= 0) return !1;
                for (var a = r.x, l = o.x, h = s.x, u = r.y, c = o.y, p = s.y, g = a < l ? a < h ? a : h : l < h ? l : h, _ = u < c ? u < p ? u : p : c < p ? c : p, y = a > l ? a > h ? a : h : l > h ? l : h, S = u > c ? u > p ? u : p : c > p ? c : p, v = d(g, _, e, i, n), b = d(y, S, e, i, n), T = t.prevZ, P = t.nextZ; T && T.z >= v && P && P.z <= b;) {
                    if (T.x >= g && T.x <= y && T.y >= _ && T.y <= S && T !== r && T !== s && f(a, u, l, c, h, p, T.x, T.y) && m(T.prev, T, T.next) >= 0) return !1;
                    if (T = T.prevZ, P.x >= g && P.x <= y && P.y >= _ && P.y <= S && P !== r && P !== s && f(a, u, l, c, h, p, P.x, P.y) && m(P.prev, P, P.next) >= 0) return !1;
                    P = P.nextZ
                }
                for (; T && T.z >= v;) {
                    if (T.x >= g && T.x <= y && T.y >= _ && T.y <= S && T !== r && T !== s && f(a, u, l, c, h, p, T.x, T.y) && m(T.prev, T, T.next) >= 0) return !1;
                    T = T.prevZ
                }
                for (; P && P.z <= b;) {
                    if (P.x >= g && P.x <= y && P.y >= _ && P.y <= S && P !== r && P !== s && f(a, u, l, c, h, p, P.x, P.y) && m(P.prev, P, P.next) >= 0) return !1;
                    P = P.nextZ
                }
                return !0
            }

            function a(t, e, i) {
                var r = t;
                do {
                    var o = r.prev,
                        s = r.next.next;
                    !_(o, s) && y(o, r, r.next, s) && b(o, s) && b(s, o) && (e.push(o.i / i | 0), e.push(r.i / i | 0), e.push(s.i / i | 0), A(r), A(r.next), r = t = s), r = r.next
                } while (r !== t);
                return n(r)
            }

            function l(t, e, i, o, s, a) {
                var l = t;
                do {
                    for (var h = l.next.next; h !== l.prev;) {
                        if (l.i !== h.i && g(l, h)) {
                            var u = T(l, h);
                            return l = n(l, l.next), u = n(u, u.next), r(l, e, i, o, s, a, 0), void r(u, e, i, o, s, a, 0)
                        }
                        h = h.next
                    }
                    l = l.next
                } while (l !== t)
            }

            function h(t, e) {
                return t.x - e.x
            }

            function u(t, e) {
                var i = function (t, e) {
                    var i, n = e,
                        r = t.x,
                        o = t.y,
                        s = -1 / 0;
                    do {
                        if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                            var a = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                            if (a <= r && a > s && (s = a, i = n.x < n.next.x ? n : n.next, a === r)) return i
                        }
                        n = n.next
                    } while (n !== e);
                    if (!i) return null;
                    var l, h = i,
                        u = i.x,
                        d = i.y,
                        p = 1 / 0;
                    n = i;
                    do {
                        r >= n.x && n.x >= u && r !== n.x && f(o < d ? r : s, o, u, d, o < d ? s : r, o, n.x, n.y) && (l = Math.abs(o - n.y) / (r - n.x), b(n, t) && (l < p || l === p && (n.x > i.x || n.x === i.x && c(i, n))) && (i = n, p = l)), n = n.next
                    } while (n !== h);
                    return i
                }(t, e);
                if (!i) return e;
                var r = T(i, t);
                return n(r, r.next), n(i, i.next)
            }

            function c(t, e) {
                return m(t.prev, t, e.prev) < 0 && m(e.next, t, t.next) < 0
            }

            function d(t, e, i, n, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function p(t) {
                var e = t,
                    i = t;
                do {
                    (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e), e = e.next
                } while (e !== t);
                return i
            }

            function f(t, e, i, n, r, o, s, a) {
                return (r - s) * (e - a) >= (t - s) * (o - a) && (t - s) * (n - a) >= (i - s) * (e - a) && (i - s) * (o - a) >= (r - s) * (n - a)
            }

            function g(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function (t, e) {
                    var i = t;
                    do {
                        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && y(i, i.next, t, e)) return !0;
                        i = i.next
                    } while (i !== t);
                    return !1
                }(t, e) && (b(t, e) && b(e, t) && function (t, e) {
                    var i = t,
                        n = !1,
                        r = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next
                    } while (i !== t);
                    return n
                }(t, e) && (m(t.prev, t, e.prev) || m(t, e.prev, e)) || _(t, e) && m(t.prev, t, t.next) > 0 && m(e.prev, e, e.next) > 0)
            }

            function m(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
            }

            function _(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function y(t, e, i, n) {
                var r = v(m(t, e, i)),
                    o = v(m(t, e, n)),
                    s = v(m(i, n, t)),
                    a = v(m(i, n, e));
                return r !== o && s !== a || !(0 !== r || !S(t, i, e)) || !(0 !== o || !S(t, n, e)) || !(0 !== s || !S(i, t, n)) || !(0 !== a || !S(i, e, n))
            }

            function S(t, e, i) {
                return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
            }

            function v(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function b(t, e) {
                return m(t.prev, t, t.next) < 0 ? m(t, e, t.next) >= 0 && m(t, t.prev, e) >= 0 : m(t, e, t.prev) < 0 || m(t, t.next, e) < 0
            }

            function T(t, e) {
                var i = new I(t.i, t.x, t.y),
                    n = new I(e.i, e.x, e.y),
                    r = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n
            }

            function P(t, e, i, n) {
                var r = new I(t, e, i);
                return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r
            }

            function A(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function I(t, e, i) {
                this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function w(t, e, i, n) {
                for (var r = 0, o = e, s = i - n; o < i; o += n) r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o;
                return r
            }
            t.exports = e, t.exports.default = e, e.deviation = function (t, e, i, n) {
                var r = e && e.length,
                    o = r ? e[0] * i : t.length,
                    s = Math.abs(w(t, 0, o, i));
                if (r)
                    for (var a = 0, l = e.length; a < l; a++) {
                        var h = e[a] * i,
                            u = a < l - 1 ? e[a + 1] * i : t.length;
                        s -= Math.abs(w(t, h, u, i))
                    }
                var c = 0;
                for (a = 0; a < n.length; a += 3) {
                    var d = n[a] * i,
                        p = n[a + 1] * i,
                        f = n[a + 2] * i;
                    c += Math.abs((t[d] - t[f]) * (t[p + 1] - t[d + 1]) - (t[d] - t[p]) * (t[f + 1] - t[d + 1]))
                }
                return 0 === s && 0 === c ? 0 : Math.abs((c - s) / s)
            }, e.flatten = function (t) {
                for (var e = t[0][0].length, i = {
                    vertices: [],
                    holes: [],
                    dimensions: e
                }, n = 0, r = 0; r < t.length; r++) {
                    for (var o = 0; o < t[r].length; o++)
                        for (var s = 0; s < e; s++) i.vertices.push(t[r][o][s]);
                    r > 0 && (n += t[r - 1].length, i.holes.push(n))
                }
                return i
            }
        },
        6713: function (t, e, i) {
            var n;
            ! function (r) {
                var o = r.Promise,
                    s = o && "resolve" in o && "reject" in o && "all" in o && "race" in o && function () {
                        var t;
                        return new o((function (e) {
                            t = e
                        })), "function" == typeof t
                    }();
                e ? (e.Promise = s ? o : w, e.Polyfill = w) : void 0 === (n = function () {
                    return s ? o : w
                }.call(e, i, e, t)) || (t.exports = n);
                var a = "pending",
                    l = "sealed",
                    h = "fulfilled",
                    u = "rejected",
                    c = function () { };

                function d(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                }
                var p, f = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
                    g = [];

                function m() {
                    for (var t = 0; t < g.length; t++) g[t][0](g[t][1]);
                    g = [], p = !1
                }

                function _(t, e) {
                    g.push([t, e]), p || (p = !0, f(m, 0))
                }

                function y(t) {
                    var e = t.owner,
                        i = e.state_,
                        n = e.data_,
                        r = t[i],
                        o = t.then;
                    if ("function" == typeof r) {
                        i = h;
                        try {
                            n = r(n)
                        } catch (t) {
                            T(o, t)
                        }
                    }
                    S(o, n) || (i === h && v(o, n), i === u && T(o, n))
                }

                function S(t, e) {
                    var i;
                    try {
                        if (t === e) throw new TypeError("A promises callback cannot return that same promise.");
                        if (e && ("function" == typeof e || "object" == typeof e)) {
                            var n = e.then;
                            if ("function" == typeof n) return n.call(e, (function (n) {
                                i || (i = !0, e !== n ? v(t, n) : b(t, n))
                            }), (function (e) {
                                i || (i = !0, T(t, e))
                            })), !0
                        }
                    } catch (e) {
                        return i || T(t, e), !0
                    }
                    return !1
                }

                function v(t, e) {
                    t !== e && S(t, e) || b(t, e)
                }

                function b(t, e) {
                    t.state_ === a && (t.state_ = l, t.data_ = e, _(A, t))
                }

                function T(t, e) {
                    t.state_ === a && (t.state_ = l, t.data_ = e, _(I, t))
                }

                function P(t) {
                    var e = t.then_;
                    t.then_ = void 0;
                    for (var i = 0; i < e.length; i++) y(e[i])
                }

                function A(t) {
                    t.state_ = h, P(t)
                }

                function I(t) {
                    t.state_ = u, P(t)
                }

                function w(t) {
                    if ("function" != typeof t) throw new TypeError("Promise constructor takes a function argument");
                    if (this instanceof w == 0) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                    this.then_ = [],
                        function (t, e) {
                            function i(t) {
                                T(e, t)
                            }
                            try {
                                t((function (t) {
                                    v(e, t)
                                }), i)
                            } catch (t) {
                                i(t)
                            }
                        }(t, this)
                }
                w.prototype = {
                    constructor: w,
                    state_: a,
                    then_: null,
                    data_: void 0,
                    then: function (t, e) {
                        var i = {
                            owner: this,
                            then: new this.constructor(c),
                            fulfilled: t,
                            rejected: e
                        };
                        return this.state_ === h || this.state_ === u ? _(y, i) : this.then_.push(i), i.then
                    },
                    catch: function (t) {
                        return this.then(null, t)
                    }
                }, w.all = function (t) {
                    if (!d(t)) throw new TypeError("You must pass an array to Promise.all().");
                    return new this((function (e, i) {
                        var n = [],
                            r = 0;

                        function o(t) {
                            return r++,
                                function (i) {
                                    n[t] = i, --r || e(n)
                                }
                        }
                        for (var s, a = 0; a < t.length; a++)(s = t[a]) && "function" == typeof s.then ? s.then(o(a), i) : n[a] = s;
                        r || e(n)
                    }))
                }, w.race = function (t) {
                    if (!d(t)) throw new TypeError("You must pass an array to Promise.race().");
                    return new this((function (e, i) {
                        for (var n, r = 0; r < t.length; r++)(n = t[r]) && "function" == typeof n.then ? n.then(e, i) : e(n)
                    }))
                }, w.resolve = function (t) {
                    return t && "object" == typeof t && t.constructor === this ? t : new this((function (e) {
                        e(t)
                    }))
                }, w.reject = function (t) {
                    return new this((function (e, i) {
                        i(t)
                    }))
                }
            }("undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self ? self : this)
        },
        6729: t => {
            "use strict";
            var e = Object.prototype.hasOwnProperty,
                i = "~";

            function n() { }

            function r(t, e, i) {
                this.fn = t, this.context = e, this.once = i || !1
            }

            function o(t, e, n, o, s) {
                if ("function" != typeof n) throw new TypeError("The listener must be a function");
                var a = new r(n, o || t, s),
                    l = i ? i + e : e;
                return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], a] : t._events[l].push(a) : (t._events[l] = a, t._eventsCount++), t
            }

            function s(t, e) {
                0 == --t._eventsCount ? t._events = new n : delete t._events[e]
            }

            function a() {
                this._events = new n, this._eventsCount = 0
            }
            Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (i = !1)), a.prototype.eventNames = function () {
                var t, n, r = [];
                if (0 === this._eventsCount) return r;
                for (n in t = this._events) e.call(t, n) && r.push(i ? n.slice(1) : n);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
            }, a.prototype.listeners = function (t) {
                var e = i ? i + t : t,
                    n = this._events[e];
                if (!n) return [];
                if (n.fn) return [n.fn];
                for (var r = 0, o = n.length, s = new Array(o); r < o; r++) s[r] = n[r].fn;
                return s
            }, a.prototype.listenerCount = function (t) {
                var e = i ? i + t : t,
                    n = this._events[e];
                return n ? n.fn ? 1 : n.length : 0
            }, a.prototype.emit = function (t, e, n, r, o, s) {
                var a = i ? i + t : t;
                if (!this._events[a]) return !1;
                var l, h, u = this._events[a],
                    c = arguments.length;
                if (u.fn) {
                    switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) {
                        case 1:
                            return u.fn.call(u.context), !0;
                        case 2:
                            return u.fn.call(u.context, e), !0;
                        case 3:
                            return u.fn.call(u.context, e, n), !0;
                        case 4:
                            return u.fn.call(u.context, e, n, r), !0;
                        case 5:
                            return u.fn.call(u.context, e, n, r, o), !0;
                        case 6:
                            return u.fn.call(u.context, e, n, r, o, s), !0
                    }
                    for (h = 1, l = new Array(c - 1); h < c; h++) l[h - 1] = arguments[h];
                    u.fn.apply(u.context, l)
                } else {
                    var d, p = u.length;
                    for (h = 0; h < p; h++) switch (u[h].once && this.removeListener(t, u[h].fn, void 0, !0), c) {
                        case 1:
                            u[h].fn.call(u[h].context);
                            break;
                        case 2:
                            u[h].fn.call(u[h].context, e);
                            break;
                        case 3:
                            u[h].fn.call(u[h].context, e, n);
                            break;
                        case 4:
                            u[h].fn.call(u[h].context, e, n, r);
                            break;
                        default:
                            if (!l)
                                for (d = 1, l = new Array(c - 1); d < c; d++) l[d - 1] = arguments[d];
                            u[h].fn.apply(u[h].context, l)
                    }
                }
                return !0
            }, a.prototype.on = function (t, e, i) {
                return o(this, t, e, i, !1)
            }, a.prototype.once = function (t, e, i) {
                return o(this, t, e, i, !0)
            }, a.prototype.removeListener = function (t, e, n, r) {
                var o = i ? i + t : t;
                if (!this._events[o]) return this;
                if (!e) return s(this, o), this;
                var a = this._events[o];
                if (a.fn) a.fn !== e || r && !a.once || n && a.context !== n || s(this, o);
                else {
                    for (var l = 0, h = [], u = a.length; l < u; l++)(a[l].fn !== e || r && !a[l].once || n && a[l].context !== n) && h.push(a[l]);
                    h.length ? this._events[o] = 1 === h.length ? h[0] : h : s(this, o)
                }
                return this
            }, a.prototype.removeAllListeners = function (t) {
                var e;
                return t ? (e = i ? i + t : t, this._events[e] && s(this, e)) : (this._events = new n, this._eventsCount = 0), this
            }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = i, a.EventEmitter = a, t.exports = a
        },
        7347: t => {
            ! function () {
                function e(t, e) {
                    document.addEventListener ? t.addEventListener("scroll", e, !1) : t.attachEvent("scroll", e)
                }

                function i(t) {
                    this.g = document.createElement("div"), this.g.setAttribute("aria-hidden", "true"), this.g.appendChild(document.createTextNode(t)), this.h = document.createElement("span"), this.i = document.createElement("span"), this.m = document.createElement("span"), this.j = document.createElement("span"), this.l = -1, this.h.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.i.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.j.style.cssText = "max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;", this.m.style.cssText = "display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;", this.h.appendChild(this.m), this.i.appendChild(this.j), this.g.appendChild(this.h), this.g.appendChild(this.i)
                }

                function n(t, e) {
                    t.g.style.cssText = "max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:" + e + ";"
                }

                function r(t) {
                    var e = t.g.offsetWidth,
                        i = e + 100;
                    return t.j.style.width = i + "px", t.i.scrollLeft = i, t.h.scrollLeft = t.h.scrollWidth + 100, t.l !== e && (t.l = e, !0)
                }

                function o(t, i) {
                    function n() {
                        var t = o;
                        r(t) && null !== t.g.parentNode && i(t.l)
                    }
                    var o = t;
                    e(t.h, n), e(t.i, n), r(t)
                }

                function s(t, e, i) {
                    e = e || {}, i = i || window, this.family = t, this.style = e.style || "normal", this.weight = e.weight || "normal", this.stretch = e.stretch || "normal", this.context = i
                }
                var a = null,
                    l = null,
                    h = null,
                    u = null;

                function c(t) {
                    return null === u && (u = !!t.document.fonts), u
                }

                function d(t, e) {
                    var i = t.style,
                        n = t.weight;
                    if (null === h) {
                        var r = document.createElement("div");
                        try {
                            r.style.font = "condensed 100px sans-serif"
                        } catch (t) { }
                        h = "" !== r.style.font
                    }
                    return [i, n, h ? t.stretch : "", "100px", e].join(" ")
                }
                s.prototype.load = function (t, e) {
                    var r = this,
                        s = t || "BESbswy",
                        h = 0,
                        u = e || 3e3,
                        p = (new Date).getTime();
                    return new Promise((function (t, e) {
                        if (c(r.context) && ! function (t) {
                            return null === l && (c(t) && /Apple/.test(window.navigator.vendor) ? (t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent), l = !!t && 603 > parseInt(t[1], 10)) : l = !1), l
                        }(r.context)) {
                            var f = new Promise((function (t, e) {
                                ! function i() {
                                    (new Date).getTime() - p >= u ? e(Error(u + "ms timeout exceeded")) : r.context.document.fonts.load(d(r, '"' + r.family + '"'), s).then((function (e) {
                                        1 <= e.length ? t() : setTimeout(i, 25)
                                    }), e)
                                }()
                            })),
                                g = new Promise((function (t, e) {
                                    h = setTimeout((function () {
                                        e(Error(u + "ms timeout exceeded"))
                                    }), u)
                                }));
                            Promise.race([g, f]).then((function () {
                                clearTimeout(h), t(r)
                            }), e)
                        } else ! function (t) {
                            document.body ? t() : document.addEventListener ? document.addEventListener("DOMContentLoaded", (function e() {
                                document.removeEventListener("DOMContentLoaded", e), t()
                            })) : document.attachEvent("onreadystatechange", (function e() {
                                "interactive" != document.readyState && "complete" != document.readyState || (document.detachEvent("onreadystatechange", e), t())
                            }))
                        }((function () {
                            function l() {
                                var e;
                                (e = -1 != m && -1 != _ || -1 != m && -1 != y || -1 != _ && -1 != y) && ((e = m != _ && m != y && _ != y) || (null === a && (e = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent), a = !!e && (536 > parseInt(e[1], 10) || 536 === parseInt(e[1], 10) && 11 >= parseInt(e[2], 10))), e = a && (m == S && _ == S && y == S || m == v && _ == v && y == v || m == b && _ == b && y == b)), e = !e), e && (null !== T.parentNode && T.parentNode.removeChild(T), clearTimeout(h), t(r))
                            }
                            var c = new i(s),
                                f = new i(s),
                                g = new i(s),
                                m = -1,
                                _ = -1,
                                y = -1,
                                S = -1,
                                v = -1,
                                b = -1,
                                T = document.createElement("div");
                            T.dir = "ltr", n(c, d(r, "sans-serif")), n(f, d(r, "serif")), n(g, d(r, "monospace")), T.appendChild(c.g), T.appendChild(f.g), T.appendChild(g.g), r.context.document.body.appendChild(T), S = c.g.offsetWidth, v = f.g.offsetWidth, b = g.g.offsetWidth,
                                function t() {
                                    if ((new Date).getTime() - p >= u) null !== T.parentNode && T.parentNode.removeChild(T), e(Error(u + "ms timeout exceeded"));
                                    else {
                                        var i = r.context.document.hidden;
                                        !0 !== i && void 0 !== i || (m = c.g.offsetWidth, _ = f.g.offsetWidth, y = g.g.offsetWidth, l()), h = setTimeout(t, 50)
                                    }
                                }(), o(c, (function (t) {
                                    m = t, l()
                                })), n(c, d(r, '"' + r.family + '",sans-serif')), o(f, (function (t) {
                                    _ = t, l()
                                })), n(f, d(r, '"' + r.family + '",serif')), o(g, (function (t) {
                                    y = t, l()
                                })), n(g, d(r, '"' + r.family + '",monospace'))
                        }))
                    }))
                }, t.exports = s
            }()
        },
        7648: t => {
            "use strict";
            var e = Array.prototype.slice,
                i = Object.prototype.toString;
            t.exports = function (t) {
                var n = this;
                if ("function" != typeof n || "[object Function]" !== i.call(n)) throw new TypeError("Function.prototype.bind called on incompatible " + n);
                for (var r, o = e.call(arguments, 1), s = Math.max(0, n.length - o.length), a = [], l = 0; l < s; l++) a.push("$" + l);
                if (r = Function("binder", "return function (" + a.join(",") + "){ return binder.apply(this,arguments); }")((function () {
                    if (this instanceof r) {
                        var i = n.apply(this, o.concat(e.call(arguments)));
                        return Object(i) === i ? i : this
                    }
                    return n.apply(t, o.concat(e.call(arguments)))
                })), n.prototype) {
                    var h = function () { };
                    h.prototype = n.prototype, r.prototype = new h, h.prototype = null
                }
                return r
            }
        },
        8612: (t, e, i) => {
            "use strict";
            var n = i(7648);
            t.exports = Function.prototype.bind || n
        },
        210: (t, e, i) => {
            "use strict";
            var n, r = SyntaxError,
                o = Function,
                s = TypeError,
                a = function (t) {
                    try {
                        return o('"use strict"; return (' + t + ").constructor;")()
                    } catch (t) { }
                },
                l = Object.getOwnPropertyDescriptor;
            if (l) try {
                l({}, "")
            } catch (t) {
                l = null
            }
            var h = function () {
                throw new s
            },
                u = l ? function () {
                    try {
                        return h
                    } catch (t) {
                        try {
                            return l(arguments, "callee").get
                        } catch (t) {
                            return h
                        }
                    }
                }() : h,
                c = i(1405)(),
                d = i(8185)(),
                p = Object.getPrototypeOf || (d ? function (t) {
                    return t.__proto__
                } : null),
                f = {},
                g = "undefined" != typeof Uint8Array && p ? p(Uint8Array) : n,
                m = {
                    "%AggregateError%": "undefined" == typeof AggregateError ? n : AggregateError,
                    "%Array%": Array,
                    "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? n : ArrayBuffer,
                    "%ArrayIteratorPrototype%": c && p ? p([][Symbol.iterator]()) : n,
                    "%AsyncFromSyncIteratorPrototype%": n,
                    "%AsyncFunction%": f,
                    "%AsyncGenerator%": f,
                    "%AsyncGeneratorFunction%": f,
                    "%AsyncIteratorPrototype%": f,
                    "%Atomics%": "undefined" == typeof Atomics ? n : Atomics,
                    "%BigInt%": "undefined" == typeof BigInt ? n : BigInt,
                    "%BigInt64Array%": "undefined" == typeof BigInt64Array ? n : BigInt64Array,
                    "%BigUint64Array%": "undefined" == typeof BigUint64Array ? n : BigUint64Array,
                    "%Boolean%": Boolean,
                    "%DataView%": "undefined" == typeof DataView ? n : DataView,
                    "%Date%": Date,
                    "%decodeURI%": decodeURI,
                    "%decodeURIComponent%": decodeURIComponent,
                    "%encodeURI%": encodeURI,
                    "%encodeURIComponent%": encodeURIComponent,
                    "%Error%": Error,
                    "%eval%": eval,
                    "%EvalError%": EvalError,
                    "%Float32Array%": "undefined" == typeof Float32Array ? n : Float32Array,
                    "%Float64Array%": "undefined" == typeof Float64Array ? n : Float64Array,
                    "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? n : FinalizationRegistry,
                    "%Function%": o,
                    "%GeneratorFunction%": f,
                    "%Int8Array%": "undefined" == typeof Int8Array ? n : Int8Array,
                    "%Int16Array%": "undefined" == typeof Int16Array ? n : Int16Array,
                    "%Int32Array%": "undefined" == typeof Int32Array ? n : Int32Array,
                    "%isFinite%": isFinite,
                    "%isNaN%": isNaN,
                    "%IteratorPrototype%": c && p ? p(p([][Symbol.iterator]())) : n,
                    "%JSON%": "object" == typeof JSON ? JSON : n,
                    "%Map%": "undefined" == typeof Map ? n : Map,
                    "%MapIteratorPrototype%": "undefined" != typeof Map && c && p ? p((new Map)[Symbol.iterator]()) : n,
                    "%Math%": Math,
                    "%Number%": Number,
                    "%Object%": Object,
                    "%parseFloat%": parseFloat,
                    "%parseInt%": parseInt,
                    "%Promise%": "undefined" == typeof Promise ? n : Promise,
                    "%Proxy%": "undefined" == typeof Proxy ? n : Proxy,
                    "%RangeError%": RangeError,
                    "%ReferenceError%": ReferenceError,
                    "%Reflect%": "undefined" == typeof Reflect ? n : Reflect,
                    "%RegExp%": RegExp,
                    "%Set%": "undefined" == typeof Set ? n : Set,
                    "%SetIteratorPrototype%": "undefined" != typeof Set && c && p ? p((new Set)[Symbol.iterator]()) : n,
                    "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? n : SharedArrayBuffer,
                    "%String%": String,
                    "%StringIteratorPrototype%": c && p ? p(""[Symbol.iterator]()) : n,
                    "%Symbol%": c ? Symbol : n,
                    "%SyntaxError%": r,
                    "%ThrowTypeError%": u,
                    "%TypedArray%": g,
                    "%TypeError%": s,
                    "%Uint8Array%": "undefined" == typeof Uint8Array ? n : Uint8Array,
                    "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? n : Uint8ClampedArray,
                    "%Uint16Array%": "undefined" == typeof Uint16Array ? n : Uint16Array,
                    "%Uint32Array%": "undefined" == typeof Uint32Array ? n : Uint32Array,
                    "%URIError%": URIError,
                    "%WeakMap%": "undefined" == typeof WeakMap ? n : WeakMap,
                    "%WeakRef%": "undefined" == typeof WeakRef ? n : WeakRef,
                    "%WeakSet%": "undefined" == typeof WeakSet ? n : WeakSet
                };
            if (p) try {
                null.error
            } catch (t) {
                var _ = p(p(t));
                m["%Error.prototype%"] = _
            }
            var y = function t(e) {
                var i;
                if ("%AsyncFunction%" === e) i = a("async function () {}");
                else if ("%GeneratorFunction%" === e) i = a("function* () {}");
                else if ("%AsyncGeneratorFunction%" === e) i = a("async function* () {}");
                else if ("%AsyncGenerator%" === e) {
                    var n = t("%AsyncGeneratorFunction%");
                    n && (i = n.prototype)
                } else if ("%AsyncIteratorPrototype%" === e) {
                    var r = t("%AsyncGenerator%");
                    r && p && (i = p(r.prototype))
                }
                return m[e] = i, i
            },
                S = {
                    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                    "%ArrayPrototype%": ["Array", "prototype"],
                    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                    "%ArrayProto_values%": ["Array", "prototype", "values"],
                    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                    "%BooleanPrototype%": ["Boolean", "prototype"],
                    "%DataViewPrototype%": ["DataView", "prototype"],
                    "%DatePrototype%": ["Date", "prototype"],
                    "%ErrorPrototype%": ["Error", "prototype"],
                    "%EvalErrorPrototype%": ["EvalError", "prototype"],
                    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                    "%FunctionPrototype%": ["Function", "prototype"],
                    "%Generator%": ["GeneratorFunction", "prototype"],
                    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                    "%JSONParse%": ["JSON", "parse"],
                    "%JSONStringify%": ["JSON", "stringify"],
                    "%MapPrototype%": ["Map", "prototype"],
                    "%NumberPrototype%": ["Number", "prototype"],
                    "%ObjectPrototype%": ["Object", "prototype"],
                    "%ObjProto_toString%": ["Object", "prototype", "toString"],
                    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                    "%PromisePrototype%": ["Promise", "prototype"],
                    "%PromiseProto_then%": ["Promise", "prototype", "then"],
                    "%Promise_all%": ["Promise", "all"],
                    "%Promise_reject%": ["Promise", "reject"],
                    "%Promise_resolve%": ["Promise", "resolve"],
                    "%RangeErrorPrototype%": ["RangeError", "prototype"],
                    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                    "%RegExpPrototype%": ["RegExp", "prototype"],
                    "%SetPrototype%": ["Set", "prototype"],
                    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                    "%StringPrototype%": ["String", "prototype"],
                    "%SymbolPrototype%": ["Symbol", "prototype"],
                    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                    "%TypeErrorPrototype%": ["TypeError", "prototype"],
                    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                    "%URIErrorPrototype%": ["URIError", "prototype"],
                    "%WeakMapPrototype%": ["WeakMap", "prototype"],
                    "%WeakSetPrototype%": ["WeakSet", "prototype"]
                },
                v = i(8612),
                b = i(7642),
                T = v.call(Function.call, Array.prototype.concat),
                P = v.call(Function.apply, Array.prototype.splice),
                A = v.call(Function.call, String.prototype.replace),
                I = v.call(Function.call, String.prototype.slice),
                w = v.call(Function.call, RegExp.prototype.exec),
                E = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
                C = /\\(\\)?/g,
                x = function (t, e) {
                    var i, n = t;
                    if (b(S, n) && (n = "%" + (i = S[n])[0] + "%"), b(m, n)) {
                        var o = m[n];
                        if (o === f && (o = y(n)), void 0 === o && !e) throw new s("intrinsic " + t + " exists, but is not available. Please file an issue!");
                        return {
                            alias: i,
                            name: n,
                            value: o
                        }
                    }
                    throw new r("intrinsic " + t + " does not exist!")
                };
            t.exports = function (t, e) {
                if ("string" != typeof t || 0 === t.length) throw new s("intrinsic name must be a non-empty string");
                if (arguments.length > 1 && "boolean" != typeof e) throw new s('"allowMissing" argument must be a boolean');
                if (null === w(/^%?[^%]*%?$/, t)) throw new r("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                var i = function (t) {
                    var e = I(t, 0, 1),
                        i = I(t, -1);
                    if ("%" === e && "%" !== i) throw new r("invalid intrinsic syntax, expected closing `%`");
                    if ("%" === i && "%" !== e) throw new r("invalid intrinsic syntax, expected opening `%`");
                    var n = [];
                    return A(t, E, (function (t, e, i, r) {
                        n[n.length] = i ? A(r, C, "$1") : e || t
                    })), n
                }(t),
                    n = i.length > 0 ? i[0] : "",
                    o = x("%" + n + "%", e),
                    a = o.name,
                    h = o.value,
                    u = !1,
                    c = o.alias;
                c && (n = c[0], P(i, T([0, 1], c)));
                for (var d = 1, p = !0; d < i.length; d += 1) {
                    var f = i[d],
                        g = I(f, 0, 1),
                        _ = I(f, -1);
                    if (('"' === g || "'" === g || "`" === g || '"' === _ || "'" === _ || "`" === _) && g !== _) throw new r("property names with quotes must have matching quotes");
                    if ("constructor" !== f && p || (u = !0), b(m, a = "%" + (n += "." + f) + "%")) h = m[a];
                    else if (null != h) {
                        if (!(f in h)) {
                            if (!e) throw new s("base intrinsic for " + t + " exists, but the property is not available.");
                            return
                        }
                        if (l && d + 1 >= i.length) {
                            var y = l(h, f);
                            h = (p = !!y) && "get" in y && !("originalValue" in y.get) ? y.get : h[f]
                        } else p = b(h, f), h = h[f];
                        p && !u && (m[a] = h)
                    }
                }
                return h
            }
        },
        4347: function (t, e) {
            ! function (t) {
                "use strict";
                var e = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    i = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
                    n = Math.PI / 180,
                    r = Math.sin,
                    o = Math.cos,
                    s = Math.abs,
                    a = Math.sqrt,
                    l = 1e5,
                    h = function (t) {
                        return Math.round(t * l) / l || 0
                    };

                function u(t, e, i, l, h, u, c, d, p) {
                    if (t !== d || e !== p) {
                        i = s(i), l = s(l);
                        var f = h % 360 * n,
                            g = o(f),
                            m = r(f),
                            _ = Math.PI,
                            y = 2 * _,
                            S = (t - d) / 2,
                            v = (e - p) / 2,
                            b = g * S + m * v,
                            T = -m * S + g * v,
                            P = b * b,
                            A = T * T,
                            I = P / (i * i) + A / (l * l);
                        I > 1 && (i = a(I) * i, l = a(I) * l);
                        var w = i * i,
                            E = l * l,
                            C = (w * E - w * A - E * P) / (w * A + E * P);
                        C < 0 && (C = 0);
                        var x = (u === c ? -1 : 1) * a(C),
                            B = x * (i * T / l),
                            L = x * (-l * b / i),
                            O = (t + d) / 2 + (g * B - m * L),
                            N = (e + p) / 2 + (m * B + g * L),
                            M = (b - B) / i,
                            R = (T - L) / l,
                            D = (-b - B) / i,
                            F = (-T - L) / l,
                            k = M * M + R * R,
                            U = (R < 0 ? -1 : 1) * Math.acos(M / a(k)),
                            G = (M * F - R * D < 0 ? -1 : 1) * Math.acos((M * D + R * F) / a(k * (D * D + F * F)));
                        isNaN(G) && (G = _), !c && G > 0 ? G -= y : c && G < 0 && (G += y), U %= y, G %= y;
                        var W, V = Math.ceil(s(G) / (y / 4)),
                            X = [],
                            H = G / V,
                            Y = 4 / 3 * r(H / 2) / (1 + o(H / 2)),
                            j = g * i,
                            z = m * i,
                            K = m * -l,
                            q = g * l;
                        for (W = 0; W < V; W++) b = o(h = U + W * H), T = r(h), M = o(h += H), R = r(h), X.push(b - Y * T, T + Y * b, M + Y * R, R - Y * M, M, R);
                        for (W = 0; W < X.length; W += 2) b = X[W], T = X[W + 1], X[W] = b * j + T * K + O, X[W + 1] = b * z + T * q + N;
                        return X[W - 2] = d, X[W - 1] = p, X
                    }
                }
                var c, d, p = function () {
                    return c || "undefined" != typeof window && (c = window.gsap) && c.registerPlugin && c
                },
                    f = function () {
                        (c = p()) ? (c.registerEase("_CE", S.create), d = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
                    },
                    g = function (t) {
                        return ~~(1e3 * t + (t < 0 ? -.5 : .5)) / 1e3
                    },
                    m = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                    _ = /[cLlsSaAhHvVtTqQ]/g,
                    y = function t(e, i, n, r, o, s, a, l, h, u, c) {
                        var d, p = (e + n) / 2,
                            f = (i + r) / 2,
                            g = (n + o) / 2,
                            m = (r + s) / 2,
                            _ = (o + a) / 2,
                            y = (s + l) / 2,
                            S = (p + g) / 2,
                            v = (f + m) / 2,
                            b = (g + _) / 2,
                            T = (m + y) / 2,
                            P = (S + b) / 2,
                            A = (v + T) / 2,
                            I = a - e,
                            w = l - i,
                            E = Math.abs((n - a) * w - (r - l) * I),
                            C = Math.abs((o - a) * w - (s - l) * I);
                        return u || (u = [{
                            x: e,
                            y: i
                        }, {
                            x: a,
                            y: l
                        }], c = 1), u.splice(c || u.length - 1, 0, {
                            x: P,
                            y: A
                        }), (E + C) * (E + C) > h * (I * I + w * w) && (d = u.length, t(e, i, p, f, S, v, P, A, h, u, c), t(P, A, b, T, _, y, a, l, h, u, c + 1 + (u.length - d))), u
                    },
                    S = function () {
                        function t(t, e, i) {
                            d || f(), this.id = t, this.setData(e, i)
                        }
                        var n = t.prototype;
                        return n.setData = function (t, n) {
                            n = n || {};
                            var r, o, a, l, h, d, p, f, g, S = (t = t || "0,0,1,1").match(m),
                                v = 1,
                                b = [],
                                T = [],
                                P = n.precision || 1,
                                A = P <= 1;
                            if (this.data = t, (_.test(t) || ~t.indexOf("M") && t.indexOf("C") < 0) && (S = function (t) {
                                var n, r, o, a, l, h, c, d, p, f, g, m, _, y, S, v = (t + "").replace(i, (function (t) {
                                    var e = +t;
                                    return e < 1e-4 && e > -1e-4 ? 0 : e
                                })).match(e) || [],
                                    b = [],
                                    T = 0,
                                    P = 0,
                                    A = 2 / 3,
                                    I = v.length,
                                    w = 0,
                                    E = "ERROR: malformed path: " + t,
                                    C = function (t, e, i, n) {
                                        f = (i - t) / 3, g = (n - e) / 3, c.push(t + f, e + g, i - f, n - g, i, n)
                                    };
                                if (!t || !isNaN(v[0]) || isNaN(v[1])) return console.log(E), b;
                                for (n = 0; n < I; n++)
                                    if (_ = l, isNaN(v[n]) ? h = (l = v[n].toUpperCase()) !== v[n] : n--, o = +v[n + 1], a = +v[n + 2], h && (o += T, a += P), n || (d = o, p = a), "M" === l) c && (c.length < 8 ? b.length -= 1 : w += c.length), T = d = o, P = p = a, c = [o, a], b.push(c), n += 2, l = "L";
                                    else if ("C" === l) c || (c = [0, 0]), h || (T = P = 0), c.push(o, a, T + 1 * v[n + 3], P + 1 * v[n + 4], T += 1 * v[n + 5], P += 1 * v[n + 6]), n += 6;
                                    else if ("S" === l) f = T, g = P, "C" !== _ && "S" !== _ || (f += T - c[c.length - 4], g += P - c[c.length - 3]), h || (T = P = 0), c.push(f, g, o, a, T += 1 * v[n + 3], P += 1 * v[n + 4]), n += 4;
                                    else if ("Q" === l) f = T + (o - T) * A, g = P + (a - P) * A, h || (T = P = 0), T += 1 * v[n + 3], P += 1 * v[n + 4], c.push(f, g, T + (o - T) * A, P + (a - P) * A, T, P), n += 4;
                                    else if ("T" === l) f = T - c[c.length - 4], g = P - c[c.length - 3], c.push(T + f, P + g, o + (T + 1.5 * f - o) * A, a + (P + 1.5 * g - a) * A, T = o, P = a), n += 2;
                                    else if ("H" === l) C(T, P, T = o, P), n += 1;
                                    else if ("V" === l) C(T, P, T, P = o + (h ? P - T : 0)), n += 1;
                                    else if ("L" === l || "Z" === l) "Z" === l && (o = d, a = p, c.closed = !0), ("L" === l || s(T - o) > .5 || s(P - a) > .5) && (C(T, P, o, a), "L" === l && (n += 2)), T = o, P = a;
                                    else if ("A" === l) {
                                        if (y = v[n + 4], S = v[n + 5], f = v[n + 6], g = v[n + 7], r = 7, y.length > 1 && (y.length < 3 ? (g = f, f = S, r--) : (g = S, f = y.substr(2), r -= 2), S = y.charAt(1), y = y.charAt(0)), m = u(T, P, +v[n + 1], +v[n + 2], +v[n + 3], +y, +S, (h ? T : 0) + 1 * f, (h ? P : 0) + 1 * g), n += r, m)
                                            for (r = 0; r < m.length; r++) c.push(m[r]);
                                        T = c[c.length - 2], P = c[c.length - 1]
                                    } else console.log(E);
                                return (n = c.length) < 6 ? (b.pop(), n = 0) : c[0] === c[n - 2] && c[1] === c[n - 1] && (c.closed = !0), b.totalPoints = w + n, b
                            }(t)[0]), 4 === (r = S.length)) S.unshift(0, 0), S.push(1, 1), r = 8;
                            else if ((r - 2) % 6) throw "Invalid CustomEase";
                            for (0 == +S[0] && 1 == +S[r - 2] || function (t, e, i) {
                                i || 0 === i || (i = Math.max(+t[t.length - 1], +t[1]));
                                var n, r = -1 * +t[0],
                                    o = -i,
                                    s = t.length,
                                    a = 1 / (+t[s - 2] + r),
                                    l = -e || (Math.abs(+t[s - 1] - +t[1]) < .01 * (+t[s - 2] - +t[0]) ? function (t) {
                                        var e, i = t.length,
                                            n = 1e20;
                                        for (e = 1; e < i; e += 6) + t[e] < n && (n = +t[e]);
                                        return n
                                    }(t) + o : +t[s - 1] + o);
                                for (l = l ? 1 / l : -a, n = 0; n < s; n += 2) t[n] = (+t[n] + r) * a, t[n + 1] = (+t[n + 1] + o) * l
                            }(S, n.height, n.originY), this.segment = S, l = 2; l < r; l += 6) o = {
                                x: +S[l - 2],
                                y: +S[l - 1]
                            }, a = {
                                x: +S[l + 4],
                                y: +S[l + 5]
                            }, b.push(o, a), y(o.x, o.y, +S[l], +S[l + 1], +S[l + 2], +S[l + 3], a.x, a.y, 1 / (2e5 * P), b, b.length - 1);
                            for (r = b.length, l = 0; l < r; l++) p = b[l], f = b[l - 1] || p, (p.x > f.x || f.y !== p.y && f.x === p.x || p === f) && p.x <= 1 ? (f.cx = p.x - f.x, f.cy = p.y - f.y, f.n = p, f.nx = p.x, A && l > 1 && Math.abs(f.cy / f.cx - b[l - 2].cy / b[l - 2].cx) > 2 && (A = 0), f.cx < v && (f.cx ? v = f.cx : (f.cx = .001, l === r - 1 && (f.x -= .001, v = Math.min(v, .001), A = 0)))) : (b.splice(l--, 1), r--);
                            if (h = 1 / (r = 1 / v + 1 | 0), d = 0, p = b[0], A) {
                                for (l = 0; l < r; l++) g = l * h, p.nx < g && (p = b[++d]), o = p.y + (g - p.x) / p.cx * p.cy, T[l] = {
                                    x: g,
                                    cx: h,
                                    y: o,
                                    cy: 0,
                                    nx: 9
                                }, l && (T[l - 1].cy = o - T[l - 1].y);
                                T[r - 1].cy = b[b.length - 1].y - o
                            } else {
                                for (l = 0; l < r; l++) p.nx < l * h && (p = b[++d]), T[l] = p;
                                d < b.length - 1 && (T[l - 1] = b[b.length - 2])
                            }
                            return this.ease = function (t) {
                                var e = T[t * r | 0] || T[r - 1];
                                return e.nx < t && (e = e.n), e.y + (t - e.x) / e.cx * e.cy
                            }, this.ease.custom = this, this.id && c && c.registerEase(this.id, this.ease), this
                        }, n.getSVGData = function (e) {
                            return t.getSVGData(this, e)
                        }, t.create = function (e, i, n) {
                            return new t(e, i, n).ease
                        }, t.register = function (t) {
                            c = t, f()
                        }, t.get = function (t) {
                            return c.parseEase(t)
                        }, t.getSVGData = function (e, i) {
                            var n, r, o, s, a, l, u, d, p, f, m = (i = i || {}).width || 100,
                                _ = i.height || 100,
                                y = i.x || 0,
                                S = (i.y || 0) + _,
                                v = c.utils.toArray(i.path)[0];
                            if (i.invert && (_ = -_, S = 0), "string" == typeof e && (e = c.parseEase(e)), e.custom && (e = e.custom), e instanceof t) n = function (t) {
                                "number" == typeof t[0] && (t = [t]);
                                var e, i, n, r, o = "",
                                    s = t.length;
                                for (i = 0; i < s; i++) {
                                    for (r = t[i], o += "M" + h(r[0]) + "," + h(r[1]) + " C", e = r.length, n = 2; n < e; n++) o += h(r[n++]) + "," + h(r[n++]) + " " + h(r[n++]) + "," + h(r[n++]) + " " + h(r[n++]) + "," + h(r[n]) + " ";
                                    r.closed && (o += "z")
                                }
                                return o
                            }(function (t, e, i, n, r, o, s) {
                                for (var a, l, h, u, c, d = t.length; --d > -1;)
                                    for (l = (a = t[d]).length, h = 0; h < l; h += 2) u = a[h], c = a[h + 1], a[h] = u * e + c * n + o, a[h + 1] = u * i + c * r + s;
                                return t._dirty = 1, t
                            }([e.segment], m, 0, 0, -_, y, S));
                            else {
                                for (n = [y, S], s = 1 / (u = Math.max(5, 200 * (i.precision || 1))), d = 5 / (u += 2), p = g(y + s * m), r = ((f = g(S + e(s) * -_)) - S) / (p - y), o = 2; o < u; o++) a = g(y + o * s * m), l = g(S + e(o * s) * -_), (Math.abs((l - f) / (a - p) - r) > d || o === u - 1) && (n.push(p, f), r = (l - f) / (a - p)), p = a, f = l;
                                n = "M" + n.join(",")
                            }
                            return v && v.setAttribute("d", n), n
                        }, t
                    }();
                p() && c.registerPlugin(S), S.version = "3.12.1", t.CustomEase = S, t.default = S, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e)
        },
        3875: function (t, e) {
            ! function (t) {
                "use strict";
                var e, i, n, r = function () {
                    return e || "undefined" != typeof window && (e = window.gsap) && e.registerPlugin && e
                },
                    o = {
                        easeOut: "M0,1,C0.7,1,0.6,0,1,0",
                        easeInOut: "M0,0,C0.1,0,0.24,1,0.444,1,0.644,1,0.6,0,1,0",
                        anticipate: "M0,0,C0,0.222,0.024,0.386,0,0.4,0.18,0.455,0.65,0.646,0.7,0.67,0.9,0.76,1,0.846,1,1",
                        uniform: "M0,0,C0,0.95,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0"
                    },
                    s = function (t) {
                        return t
                    },
                    a = function (t) {
                        if (!i)
                            if (e = r(), n = e && e.parseEase("_CE")) {
                                for (var s in o) o[s] = n("", o[s]);
                                i = 1, h("wiggle").config = function (t) {
                                    return "object" == typeof t ? h("", t) : h("wiggle(" + t + ")", {
                                        wiggles: +t
                                    })
                                }
                            } else t && console.warn("Please gsap.registerPlugin(CustomEase, CustomWiggle)")
                    },
                    l = function (t, i) {
                        return "function" != typeof t && (t = e.parseEase(t) || n("", t)), t.custom || !i ? t : function (e) {
                            return 1 - t(e)
                        }
                    },
                    h = function (t, e) {
                        i || a(1);
                        var r, h, u, c, d, p, f, g, m, _ = 0 | ((e = e || {}).wiggles || 10),
                            y = 1 / _,
                            S = y / 2,
                            v = "anticipate" === e.type,
                            b = o[e.type] || o.easeOut,
                            T = s;
                        if (v && (T = b, b = o.easeOut), e.timingEase && (T = l(e.timingEase)), e.amplitudeEase && (b = l(e.amplitudeEase, !0)), g = [0, 0, (p = T(S)) / 4, 0, p / 2, f = v ? -b(S) : b(S), p, f], "random" === e.type) {
                            for (g.length = 4, r = T(y), h = 2 * Math.random() - 1, m = 2; m < _; m++) S = r, f = h, r = T(y * m), h = 2 * Math.random() - 1, u = Math.atan2(h - g[g.length - 3], r - g[g.length - 4]), c = Math.cos(u) * y, d = Math.sin(u) * y, g.push(S - c, f - d, S, f, S + c, f + d);
                            g.push(r, 0, 1, 0)
                        } else {
                            for (m = 1; m < _; m++) g.push(T(S + y / 2), f), S += y, f = (f > 0 ? -1 : 1) * b(m * y), p = T(S), g.push(T(S - y / 2), f, p, f);
                            g.push(T(S + y / 4), f, T(S + y / 4), 0, 1, 0)
                        }
                        for (m = g.length; --m > -1;) g[m] = ~~(1e3 * g[m]) / 1e3;
                        return g[2] = "C" + g[2], n(t, "M" + g.join(","))
                    },
                    u = function () {
                        function t(t, e) {
                            this.ease = h(t, e)
                        }
                        return t.create = function (t, e) {
                            return h(t, e)
                        }, t.register = function (t) {
                            e = t, a()
                        }, t
                    }();
                r() && e.registerPlugin(u), u.version = "3.12.1", t.CustomWiggle = u, t.default = u, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e)
        },
        9276: function (t, e) {
            ! function (t) {
                "use strict";
                var e = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    i = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                    n = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
                    r = /(^[#\.][a-z]|[a-y][a-z])/i,
                    o = Math.PI / 180,
                    s = 180 / Math.PI,
                    a = Math.sin,
                    l = Math.cos,
                    h = Math.abs,
                    u = Math.sqrt,
                    c = Math.atan2,
                    d = 1e8,
                    p = function (t) {
                        return "string" == typeof t
                    },
                    f = function (t) {
                        return "number" == typeof t
                    },
                    g = {},
                    m = {},
                    _ = 1e5,
                    y = function (t) {
                        return Math.round((t + d) % 1 * _) / _ || (t < 0 ? 0 : 1)
                    },
                    S = function (t) {
                        return Math.round(t * _) / _ || 0
                    },
                    v = function (t) {
                        return Math.round(1e10 * t) / 1e10 || 0
                    },
                    b = function (t, e, i, n) {
                        var r = t[e],
                            o = 1 === n ? 6 : N(r, i, n);
                        if (o && o + i + 2 < r.length) return t.splice(e, 0, r.slice(0, i + o + 2)), r.splice(0, i + o), 1
                    },
                    T = function (t, e, i) {
                        var n = t.length,
                            r = ~~(i * n);
                        if (t[r] > e) {
                            for (; --r && t[r] > e;);
                            r < 0 && (r = 0)
                        } else
                            for (; t[++r] < e && r < n;);
                        return r < n ? r : n - 1
                    },
                    P = function (t, e) {
                        return e.totalLength = t.totalLength, t.samples ? (e.samples = t.samples.slice(0), e.lookup = t.lookup.slice(0), e.minLength = t.minLength, e.resolution = t.resolution) : t.totalPoints && (e.totalPoints = t.totalPoints), e
                    },
                    A = function (t, e) {
                        var i = t.length,
                            n = t[i - 1] || [],
                            r = n.length;
                        i && e[0] === n[r - 2] && e[1] === n[r - 1] && (e = n.concat(e.slice(2)), i--), t[i] = e
                    };

                function I(t) {
                    var e, i = (t = p(t) && r.test(t) && document.querySelector(t) || t).getAttribute ? t : 0;
                    return i && (t = t.getAttribute("d")) ? (i._gsPath || (i._gsPath = {}), (e = i._gsPath[t]) && !e._dirty ? e : i._gsPath[t] = k(t)) : t ? p(t) ? k(t) : f(t[0]) ? [t] : t : console.warn("Expecting a <path> element or an SVG path data string")
                }

                function w(t) {
                    var e, i = 0;
                    for (t.reverse(); i < t.length; i += 2) e = t[i], t[i] = t[i + 1], t[i + 1] = e;
                    t.reversed = !t.reversed
                }
                var E = {
                    rect: "rx,ry,x,y,width,height",
                    circle: "r,cx,cy",
                    ellipse: "rx,ry,cx,cy",
                    line: "x1,x2,y1,y2"
                };

                function C(t, e) {
                    var n, r, o, s, a, l, h, u, c, d, p, f, g, m, _, y, S, v, b, T, P, A, I = t.tagName.toLowerCase(),
                        w = .552284749831;
                    return "path" !== I && t.getBBox ? (l = function (t, e) {
                        var i, n = document.createElementNS("http://www.w3.org/2000/svg", "path"),
                            r = [].slice.call(t.attributes),
                            o = r.length;
                        for (e = "," + e + ","; --o > -1;) i = r[o].nodeName.toLowerCase(), e.indexOf("," + i + ",") < 0 && n.setAttributeNS(null, i, r[o].nodeValue);
                        return n
                    }(t, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points"), A = function (t, e) {
                        for (var i = e ? e.split(",") : [], n = {}, r = i.length; --r > -1;) n[i[r]] = +t.getAttribute(i[r]) || 0;
                        return n
                    }(t, E[I]), "rect" === I ? (s = A.rx, a = A.ry || s, r = A.x, o = A.y, d = A.width - 2 * s, p = A.height - 2 * a, n = s || a ? "M" + (y = (m = (g = r + s) + d) + s) + "," + (v = o + a) + " V" + (b = v + p) + " C" + [y, T = b + a * w, _ = m + s * w, P = b + a, m, P, m - (m - g) / 3, P, g + (m - g) / 3, P, g, P, f = r + s * (1 - w), P, r, T, r, b, r, b - (b - v) / 3, r, v + (b - v) / 3, r, v, r, S = o + a * (1 - w), f, o, g, o, g + (m - g) / 3, o, m - (m - g) / 3, o, m, o, _, o, y, S, y, v].join(",") + "z" : "M" + (r + d) + "," + o + " v" + p + " h" + -d + " v" + -p + " h" + d + "z") : "circle" === I || "ellipse" === I ? ("circle" === I ? u = (s = a = A.r) * w : (s = A.rx, u = (a = A.ry) * w), n = "M" + ((r = A.cx) + s) + "," + (o = A.cy) + " C" + [r + s, o + u, r + (h = s * w), o + a, r, o + a, r - h, o + a, r - s, o + u, r - s, o, r - s, o - u, r - h, o - a, r, o - a, r + h, o - a, r + s, o - u, r + s, o].join(",") + "z") : "line" === I ? n = "M" + A.x1 + "," + A.y1 + " L" + A.x2 + "," + A.y2 : "polyline" !== I && "polygon" !== I || (n = "M" + (r = (c = (t.getAttribute("points") + "").match(i) || []).shift()) + "," + (o = c.shift()) + " L" + c.join(","), "polygon" === I && (n += "," + r + "," + o + "z")), l.setAttribute("d", W(l._gsRawPath = k(n))), e && t.parentNode && (t.parentNode.insertBefore(l, t), t.parentNode.removeChild(t)), l) : t
                }

                function x(t, e, i) {
                    var n, r = t[e],
                        o = t[e + 2],
                        a = t[e + 4];
                    return r += (o - r) * i, r += ((o += (a - o) * i) - r) * i, n = o + (a + (t[e + 6] - a) * i - o) * i - r, r = t[e + 1], r += ((o = t[e + 3]) - r) * i, r += ((o += ((a = t[e + 5]) - o) * i) - r) * i, S(c(o + (a + (t[e + 7] - a) * i - o) * i - r, n) * s)
                }

                function B(t, e, i) {
                    i = void 0 === i ? 1 : v(i) || 0, e = v(e) || 0;
                    var n = Math.max(0, ~~(h(i - e) - 1e-8)),
                        r = function (t) {
                            for (var e = [], i = 0; i < t.length; i++) e[i] = P(t[i], t[i].slice(0));
                            return P(t, e)
                        }(t);
                    if (e > i && (e = 1 - e, i = 1 - i, function (t, e) {
                        var i = t.length;
                        for (e || t.reverse(); i--;) t[i].reversed || w(t[i])
                    }(r), r.totalLength = 0), e < 0 || i < 0) {
                        var o = Math.abs(~~Math.min(e, i)) + 1;
                        e += o, i += o
                    }
                    r.totalLength || O(r);
                    var s, a, l, u, c, d, p, f, _ = i > 1,
                        y = M(r, e, g, !0),
                        S = M(r, i, m),
                        T = S.segment,
                        I = y.segment,
                        E = S.segIndex,
                        C = y.segIndex,
                        B = S.i,
                        L = y.i,
                        R = C === E,
                        D = B === L && R;
                    if (_ || n) {
                        for (s = E < C || R && B < L || D && S.t < y.t, b(r, C, L, y.t) && (C++, s || (E++, D ? (S.t = (S.t - y.t) / (1 - y.t), B = 0) : R && (B -= L))), Math.abs(1 - (i - e)) < 1e-5 ? E = C - 1 : !S.t && E ? E-- : b(r, E, B, S.t) && s && C++, 1 === y.t && (C = (C + 1) % r.length), c = [], p = 1 + (d = r.length) * n, f = C, p += (d - C + E) % d, u = 0; u < p; u++) A(c, r[f++ % d]);
                        r = c
                    } else if (l = 1 === S.t ? 6 : N(T, B, S.t), e !== i)
                        for (a = N(I, L, D ? y.t / S.t : y.t), R && (l += a), T.splice(B + l + 2), (a || L) && I.splice(0, L + a), u = r.length; u--;)(u < C || u > E) && r.splice(u, 1);
                    else T.angle = x(T, B + l, 0), y = T[B += l], S = T[B + 1], T.length = T.totalLength = 0, T.totalPoints = r.totalPoints = 8, T.push(y, S, y, S, y, S, y, S);
                    return r.totalLength = 0, r
                }

                function L(t, e, i) {
                    e = e || 0, t.samples || (t.samples = [], t.lookup = []);
                    var n, r, o, s, a, l, c, p, f, g, m, _, y, S, v, b, T, P = ~~t.resolution || 12,
                        A = 1 / P,
                        I = i ? e + 6 * i + 1 : t.length,
                        w = t[e],
                        E = t[e + 1],
                        C = e ? e / 6 * P : 0,
                        x = t.samples,
                        B = t.lookup,
                        L = (e ? t.minLength : d) || d,
                        O = x[C + i * P - 1],
                        N = e ? x[C - 1] : 0;
                    for (x.length = B.length = 0, r = e + 2; r < I; r += 6) {
                        if (o = t[r + 4] - w, s = t[r + 2] - w, a = t[r] - w, p = t[r + 5] - E, f = t[r + 3] - E, g = t[r + 1] - E, l = c = m = _ = 0, h(o) < .01 && h(p) < .01 && h(a) + h(g) < .01) t.length > 8 && (t.splice(r, 6), r -= 6, I -= 6);
                        else
                            for (n = 1; n <= P; n++) l = c - (c = ((S = A * n) * S * o + 3 * (y = 1 - S) * (S * s + y * a)) * S), m = _ - (_ = (S * S * p + 3 * y * (S * f + y * g)) * S), (b = u(m * m + l * l)) < L && (L = b), N += b, x[C++] = N;
                        w += o, E += p
                    }
                    if (O)
                        for (O -= N; C < x.length; C++) x[C] += O;
                    if (x.length && L) {
                        if (t.totalLength = T = x[x.length - 1] || 0, t.minLength = L, T / L < 9999)
                            for (b = v = 0, n = 0; n < T; n += L) B[b++] = x[v] < n ? ++v : v
                    } else t.totalLength = x[0] = 0;
                    return e ? N - x[e / 2 - 1] : N
                }

                function O(t, e) {
                    var i, n, r;
                    for (r = i = n = 0; r < t.length; r++) t[r].resolution = ~~e || 12, n += t[r].length, i += L(t[r]);
                    return t.totalPoints = n, t.totalLength = i, t
                }

                function N(t, e, i) {
                    if (i <= 0 || i >= 1) return 0;
                    var n = t[e],
                        r = t[e + 1],
                        o = t[e + 2],
                        s = t[e + 3],
                        a = t[e + 4],
                        l = t[e + 5],
                        h = n + (o - n) * i,
                        u = o + (a - o) * i,
                        c = r + (s - r) * i,
                        d = s + (l - s) * i,
                        p = h + (u - h) * i,
                        f = c + (d - c) * i,
                        g = a + (t[e + 6] - a) * i,
                        m = l + (t[e + 7] - l) * i;
                    return u += (g - u) * i, d += (m - d) * i, t.splice(e + 2, 4, S(h), S(c), S(p), S(f), S(p + (u - p) * i), S(f + (d - f) * i), S(u), S(d), S(g), S(m)), t.samples && t.samples.splice(e / 6 * t.resolution | 0, 0, 0, 0, 0, 0, 0, 0), 6
                }

                function M(t, e, i, n) {
                    i = i || {}, t.totalLength || O(t), (e < 0 || e > 1) && (e = y(e));
                    var r, o, s, a, l, h, u, c = 0,
                        d = t[0];
                    if (e)
                        if (1 === e) u = 1, h = (d = t[c = t.length - 1]).length - 8;
                        else {
                            if (t.length > 1) {
                                for (s = t.totalLength * e, l = h = 0;
                                    (l += t[h++].totalLength) < s;) c = h;
                                e = (s - (a = l - (d = t[c]).totalLength)) / (l - a) || 0
                            }
                            r = d.samples, o = d.resolution, s = d.totalLength * e, a = (h = d.lookup.length ? d.lookup[~~(s / d.minLength)] || 0 : T(r, s, e)) ? r[h - 1] : 0, (l = r[h]) < s && (a = l, l = r[++h]), u = 1 / o * ((s - a) / (l - a) + h % o), h = 6 * ~~(h / o), n && 1 === u && (h + 6 < d.length ? (h += 6, u = 0) : c + 1 < t.length && (h = u = 0, d = t[++c]))
                        }
                    else u = h = c = 0, d = t[0];
                    return i.t = u, i.i = h, i.path = t, i.segment = d, i.segIndex = c, i
                }

                function R(t, e, i, n) {
                    var r, o, s, a, l, h, u, c, d, p = t[0],
                        f = n || {};
                    if ((e < 0 || e > 1) && (e = y(e)), p.lookup || O(t), t.length > 1) {
                        for (s = t.totalLength * e, l = h = 0;
                            (l += t[h++].totalLength) < s;) p = t[h];
                        e = (s - (a = l - p.totalLength)) / (l - a) || 0
                    }
                    return r = p.samples, o = p.resolution, s = p.totalLength * e, a = (h = p.lookup.length ? p.lookup[e < 1 ? ~~(s / p.minLength) : p.lookup.length - 1] || 0 : T(r, s, e)) ? r[h - 1] : 0, (l = r[h]) < s && (a = l, l = r[++h]), d = 1 - (u = 1 / o * ((s - a) / (l - a) + h % o) || 0), c = p[h = 6 * ~~(h / o)], f.x = S((u * u * (p[h + 6] - c) + 3 * d * (u * (p[h + 4] - c) + d * (p[h + 2] - c))) * u + c), f.y = S((u * u * (p[h + 7] - (c = p[h + 1])) + 3 * d * (u * (p[h + 5] - c) + d * (p[h + 3] - c))) * u + c), i && (f.angle = p.totalLength ? x(p, h, u >= 1 ? 1 - 1e-9 : u || 1e-9) : p.angle || 0), f
                }

                function D(t, e, i, n, r, o, s) {
                    for (var a, l, h, u, c, d = t.length; --d > -1;)
                        for (l = (a = t[d]).length, h = 0; h < l; h += 2) u = a[h], c = a[h + 1], a[h] = u * e + c * n + o, a[h + 1] = u * i + c * r + s;
                    return t._dirty = 1, t
                }

                function F(t, e, i, n, r, s, c, d, p) {
                    if (t !== d || e !== p) {
                        i = h(i), n = h(n);
                        var f = r % 360 * o,
                            g = l(f),
                            m = a(f),
                            _ = Math.PI,
                            y = 2 * _,
                            S = (t - d) / 2,
                            v = (e - p) / 2,
                            b = g * S + m * v,
                            T = -m * S + g * v,
                            P = b * b,
                            A = T * T,
                            I = P / (i * i) + A / (n * n);
                        I > 1 && (i = u(I) * i, n = u(I) * n);
                        var w = i * i,
                            E = n * n,
                            C = (w * E - w * A - E * P) / (w * A + E * P);
                        C < 0 && (C = 0);
                        var x = (s === c ? -1 : 1) * u(C),
                            B = x * (i * T / n),
                            L = x * (-n * b / i),
                            O = (t + d) / 2 + (g * B - m * L),
                            N = (e + p) / 2 + (m * B + g * L),
                            M = (b - B) / i,
                            R = (T - L) / n,
                            D = (-b - B) / i,
                            F = (-T - L) / n,
                            k = M * M + R * R,
                            U = (R < 0 ? -1 : 1) * Math.acos(M / u(k)),
                            G = (M * F - R * D < 0 ? -1 : 1) * Math.acos((M * D + R * F) / u(k * (D * D + F * F)));
                        isNaN(G) && (G = _), !c && G > 0 ? G -= y : c && G < 0 && (G += y), U %= y, G %= y;
                        var W, V = Math.ceil(h(G) / (y / 4)),
                            X = [],
                            H = G / V,
                            Y = 4 / 3 * a(H / 2) / (1 + l(H / 2)),
                            j = g * i,
                            z = m * i,
                            K = m * -n,
                            q = g * n;
                        for (W = 0; W < V; W++) b = l(r = U + W * H), T = a(r), M = l(r += H), R = a(r), X.push(b - Y * T, T + Y * b, M + Y * R, R - Y * M, M, R);
                        for (W = 0; W < X.length; W += 2) b = X[W], T = X[W + 1], X[W] = b * j + T * K + O, X[W + 1] = b * z + T * q + N;
                        return X[W - 2] = d, X[W - 1] = p, X
                    }
                }

                function k(t) {
                    var i, r, o, s, a, l, u, c, d, p, f, g, m, _, y, S = (t + "").replace(n, (function (t) {
                        var e = +t;
                        return e < 1e-4 && e > -1e-4 ? 0 : e
                    })).match(e) || [],
                        v = [],
                        b = 0,
                        T = 0,
                        P = 2 / 3,
                        A = S.length,
                        I = 0,
                        w = "ERROR: malformed path: " + t,
                        E = function (t, e, i, n) {
                            p = (i - t) / 3, f = (n - e) / 3, u.push(t + p, e + f, i - p, n - f, i, n)
                        };
                    if (!t || !isNaN(S[0]) || isNaN(S[1])) return console.log(w), v;
                    for (i = 0; i < A; i++)
                        if (m = a, isNaN(S[i]) ? l = (a = S[i].toUpperCase()) !== S[i] : i--, o = +S[i + 1], s = +S[i + 2], l && (o += b, s += T), i || (c = o, d = s), "M" === a) u && (u.length < 8 ? v.length -= 1 : I += u.length), b = c = o, T = d = s, u = [o, s], v.push(u), i += 2, a = "L";
                        else if ("C" === a) u || (u = [0, 0]), l || (b = T = 0), u.push(o, s, b + 1 * S[i + 3], T + 1 * S[i + 4], b += 1 * S[i + 5], T += 1 * S[i + 6]), i += 6;
                        else if ("S" === a) p = b, f = T, "C" !== m && "S" !== m || (p += b - u[u.length - 4], f += T - u[u.length - 3]), l || (b = T = 0), u.push(p, f, o, s, b += 1 * S[i + 3], T += 1 * S[i + 4]), i += 4;
                        else if ("Q" === a) p = b + (o - b) * P, f = T + (s - T) * P, l || (b = T = 0), b += 1 * S[i + 3], T += 1 * S[i + 4], u.push(p, f, b + (o - b) * P, T + (s - T) * P, b, T), i += 4;
                        else if ("T" === a) p = b - u[u.length - 4], f = T - u[u.length - 3], u.push(b + p, T + f, o + (b + 1.5 * p - o) * P, s + (T + 1.5 * f - s) * P, b = o, T = s), i += 2;
                        else if ("H" === a) E(b, T, b = o, T), i += 1;
                        else if ("V" === a) E(b, T, b, T = o + (l ? T - b : 0)), i += 1;
                        else if ("L" === a || "Z" === a) "Z" === a && (o = c, s = d, u.closed = !0), ("L" === a || h(b - o) > .5 || h(T - s) > .5) && (E(b, T, o, s), "L" === a && (i += 2)), b = o, T = s;
                        else if ("A" === a) {
                            if (_ = S[i + 4], y = S[i + 5], p = S[i + 6], f = S[i + 7], r = 7, _.length > 1 && (_.length < 3 ? (f = p, p = y, r--) : (f = y, p = _.substr(2), r -= 2), y = _.charAt(1), _ = _.charAt(0)), g = F(b, T, +S[i + 1], +S[i + 2], +S[i + 3], +_, +y, (l ? b : 0) + 1 * p, (l ? T : 0) + 1 * f), i += r, g)
                                for (r = 0; r < g.length; r++) u.push(g[r]);
                            b = u[u.length - 2], T = u[u.length - 1]
                        } else console.log(w);
                    return (i = u.length) < 6 ? (v.pop(), i = 0) : u[0] === u[i - 2] && u[1] === u[i - 1] && (u.closed = !0), v.totalPoints = I + i, v
                }

                function U(t, e) {
                    void 0 === e && (e = 1);
                    for (var i = t[0], n = 0, r = [i, n], o = 2; o < t.length; o += 2) r.push(i, n, t[o], n = (t[o] - i) * e / 2, i = t[o], -n);
                    return r
                }

                function G(t, e) {
                    h(t[0] - t[2]) < 1e-4 && h(t[1] - t[3]) < 1e-4 && (t = t.slice(2));
                    var i, n, r, o, s, a, l, c, d, p, f, g, m, _, y = t.length - 2,
                        v = +t[0],
                        b = +t[1],
                        T = +t[2],
                        P = +t[3],
                        A = [v, b, v, b],
                        I = T - v,
                        w = P - b,
                        E = Math.abs(t[y] - v) < .001 && Math.abs(t[y + 1] - b) < .001;
                    for (E && (t.push(T, P), T = v, P = b, v = t[y - 2], b = t[y - 1], t.unshift(v, b), y += 4), e = e || 0 === e ? +e : 1, r = 2; r < y; r += 2) i = v, n = b, v = T, b = P, T = +t[r + 2], P = +t[r + 3], v === T && b === P || (o = I, s = w, I = T - v, w = P - b, c = ((a = u(o * o + s * s)) + (l = u(I * I + w * w))) * e * .25 / u(Math.pow(I / l + o / a, 2) + Math.pow(w / l + s / a, 2)), f = v - ((d = v - (v - i) * (a ? c / a : 0)) + (((p = v + (T - v) * (l ? c / l : 0)) - d) * (3 * a / (a + l) + .5) / 4 || 0)), _ = b - ((g = b - (b - n) * (a ? c / a : 0)) + (((m = b + (P - b) * (l ? c / l : 0)) - g) * (3 * a / (a + l) + .5) / 4 || 0)), v === i && b === n || A.push(S(d + f), S(g + _), S(v), S(b), S(p + f), S(m + _)));
                    return v !== T || b !== P || A.length < 4 ? A.push(S(T), S(P), S(T), S(P)) : A.length -= 2, 2 === A.length ? A.push(v, b, v, b, v, b) : E && (A.splice(0, 6), A.length = A.length - 6), A
                }

                function W(t) {
                    f(t[0]) && (t = [t]);
                    var e, i, n, r, o = "",
                        s = t.length;
                    for (i = 0; i < s; i++) {
                        for (r = t[i], o += "M" + S(r[0]) + "," + S(r[1]) + " C", e = r.length, n = 2; n < e; n++) o += S(r[n++]) + "," + S(r[n++]) + " " + S(r[n++]) + "," + S(r[n++]) + " " + S(r[n++]) + "," + S(r[n]) + " ";
                        r.closed && (o += "z")
                    }
                    return o
                }
                var V, X, H, Y, j, z, K, q, Z, $ = "transform",
                    J = $ + "Origin",
                    Q = function (t) {
                        var e = t.ownerDocument || t;
                        !($ in t.style) && "msTransform" in t.style && (J = ($ = "msTransform") + "Origin");
                        for (; e.parentNode && (e = e.parentNode););
                        if (X = window, K = new at, e) {
                            V = e, H = e.documentElement, Y = e.body, (q = V.createElementNS("http://www.w3.org/2000/svg", "g")).style.transform = "none";
                            var i = e.createElement("div"),
                                n = e.createElement("div");
                            Y.appendChild(i), i.appendChild(n), i.style.position = "static", i.style[$] = "translate3d(0,0,1px)", Z = n.offsetParent !== i, Y.removeChild(i)
                        }
                        return e
                    },
                    tt = [],
                    et = [],
                    it = function (t) {
                        return t.ownerSVGElement || ("svg" === (t.tagName + "").toLowerCase() ? t : null)
                    },
                    nt = function t(e) {
                        return "fixed" === X.getComputedStyle(e).position || ((e = e.parentNode) && 1 === e.nodeType ? t(e) : void 0)
                    },
                    rt = function t(e, i) {
                        if (e.parentNode && (V || Q(e))) {
                            var n = it(e),
                                r = n ? n.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
                                o = n ? i ? "rect" : "g" : "div",
                                s = 2 !== i ? 0 : 100,
                                a = 3 === i ? 100 : 0,
                                l = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
                                h = V.createElementNS ? V.createElementNS(r.replace(/^https/, "http"), o) : V.createElement(o);
                            return i && (n ? (z || (z = t(e)), h.setAttribute("width", .01), h.setAttribute("height", .01), h.setAttribute("transform", "translate(" + s + "," + a + ")"), z.appendChild(h)) : (j || ((j = t(e)).style.cssText = l), h.style.cssText = l + "width:0.1px;height:0.1px;top:" + a + "px;left:" + s + "px", j.appendChild(h))), h
                        }
                        throw "Need document and parent."
                    },
                    ot = function (t, e) {
                        var i, n, r, o, s, a, l = it(t),
                            h = t === l,
                            u = l ? tt : et,
                            c = t.parentNode;
                        if (t === X) return t;
                        if (u.length || u.push(rt(t, 1), rt(t, 2), rt(t, 3)), i = l ? z : j, l) h ? (o = -(r = function (t) {
                            var e, i = t.getCTM();
                            return i || (e = t.style[$], t.style[$] = "none", t.appendChild(q), i = q.getCTM(), t.removeChild(q), e ? t.style[$] = e : t.style.removeProperty($.replace(/([A-Z])/g, "-$1").toLowerCase())), i || K.clone()
                        }(t)).e / r.a, s = -r.f / r.d, n = K) : t.getBBox ? (r = t.getBBox(), o = (n = (n = t.transform ? t.transform.baseVal : {}).numberOfItems ? n.numberOfItems > 1 ? function (t) {
                            for (var e = new at, i = 0; i < t.numberOfItems; i++) e.multiply(t.getItem(i).matrix);
                            return e
                        }(n) : n.getItem(0).matrix : K).a * r.x + n.c * r.y, s = n.b * r.x + n.d * r.y) : (n = new at, o = s = 0), e && "g" === t.tagName.toLowerCase() && (o = s = 0), (h ? l : c).appendChild(i), i.setAttribute("transform", "matrix(" + n.a + "," + n.b + "," + n.c + "," + n.d + "," + (n.e + o) + "," + (n.f + s) + ")");
                        else {
                            if (o = s = 0, Z)
                                for (n = t.offsetParent, r = t; r && (r = r.parentNode) && r !== n && r.parentNode;)(X.getComputedStyle(r)[$] + "").length > 4 && (o = r.offsetLeft, s = r.offsetTop, r = 0);
                            if ("absolute" !== (a = X.getComputedStyle(t)).position && "fixed" !== a.position)
                                for (n = t.offsetParent; c && c !== n;) o += c.scrollLeft || 0, s += c.scrollTop || 0, c = c.parentNode;
                            (r = i.style).top = t.offsetTop - s + "px", r.left = t.offsetLeft - o + "px", r[$] = a[$], r[J] = a[J], r.position = "fixed" === a.position ? "fixed" : "absolute", t.parentNode.appendChild(i)
                        }
                        return i
                    },
                    st = function (t, e, i, n, r, o, s) {
                        return t.a = e, t.b = i, t.c = n, t.d = r, t.e = o, t.f = s, t
                    },
                    at = function () {
                        function t(t, e, i, n, r, o) {
                            void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === o && (o = 0), st(this, t, e, i, n, r, o)
                        }
                        var e = t.prototype;
                        return e.inverse = function () {
                            var t = this.a,
                                e = this.b,
                                i = this.c,
                                n = this.d,
                                r = this.e,
                                o = this.f,
                                s = t * n - e * i || 1e-10;
                            return st(this, n / s, -e / s, -i / s, t / s, (i * o - n * r) / s, -(t * o - e * r) / s)
                        }, e.multiply = function (t) {
                            var e = this.a,
                                i = this.b,
                                n = this.c,
                                r = this.d,
                                o = this.e,
                                s = this.f,
                                a = t.a,
                                l = t.c,
                                h = t.b,
                                u = t.d,
                                c = t.e,
                                d = t.f;
                            return st(this, a * e + h * n, a * i + h * r, l * e + u * n, l * i + u * r, o + c * e + d * n, s + c * i + d * r)
                        }, e.clone = function () {
                            return new t(this.a, this.b, this.c, this.d, this.e, this.f)
                        }, e.equals = function (t) {
                            var e = this.a,
                                i = this.b,
                                n = this.c,
                                r = this.d,
                                o = this.e,
                                s = this.f;
                            return e === t.a && i === t.b && n === t.c && r === t.d && o === t.e && s === t.f
                        }, e.apply = function (t, e) {
                            void 0 === e && (e = {});
                            var i = t.x,
                                n = t.y,
                                r = this.a,
                                o = this.b,
                                s = this.c,
                                a = this.d,
                                l = this.e,
                                h = this.f;
                            return e.x = i * r + n * s + l || 0, e.y = i * o + n * a + h || 0, e
                        }, t
                    }();

                function lt(t, e, i, n) {
                    if (!t || !t.parentNode || (V || Q(t)).documentElement === t) return new at;
                    var r = function (t) {
                        for (var e, i; t && t !== Y;)(i = t._gsap) && i.uncache && i.get(t, "x"), i && !i.scaleX && !i.scaleY && i.renderTransform && (i.scaleX = i.scaleY = 1e-4, i.renderTransform(1, i), e ? e.push(i) : e = [i]), t = t.parentNode;
                        return e
                    }(t),
                        o = it(t) ? tt : et,
                        s = ot(t, i),
                        a = o[0].getBoundingClientRect(),
                        l = o[1].getBoundingClientRect(),
                        h = o[2].getBoundingClientRect(),
                        u = s.parentNode,
                        c = !n && nt(t),
                        d = new at((l.left - a.left) / 100, (l.top - a.top) / 100, (h.left - a.left) / 100, (h.top - a.top) / 100, a.left + (c ? 0 : X.pageXOffset || V.scrollLeft || H.scrollLeft || Y.scrollLeft || 0), a.top + (c ? 0 : X.pageYOffset || V.scrollTop || H.scrollTop || Y.scrollTop || 0));
                    if (u.removeChild(s), r)
                        for (a = r.length; a--;)(l = r[a]).scaleX = l.scaleY = 0, l.renderTransform(1, l);
                    return e ? d.inverse() : d
                }
                var ht, ut, ct, dt, pt, ft, gt = "x,translateX,left,marginLeft,xPercent".split(","),
                    mt = "y,translateY,top,marginTop,yPercent".split(","),
                    _t = Math.PI / 180,
                    yt = function (t, e, i, n) {
                        for (var r = e.length, o = 2 === n ? 0 : n, s = 0; s < r; s++) t[o] = parseFloat(e[s][i]), 2 === n && (t[o + 1] = 0), o += 2;
                        return t
                    },
                    St = function (t, e, i) {
                        return parseFloat(t._gsap.get(t, e, i || "px")) || 0
                    },
                    vt = function (t) {
                        var e, i = t[0],
                            n = t[1];
                        for (e = 2; e < t.length; e += 2) i = t[e] += i, n = t[e + 1] += n
                    },
                    bt = function (t, e, i, n, r, o, s, a, l) {
                        return "cubic" === s.type ? e = [e] : (!1 !== s.fromCurrent && e.unshift(St(i, n, a), r ? St(i, r, l) : 0), s.relative && vt(e), e = [(r ? G : U)(e, s.curviness)]), e = o(wt(e, i, s)), Et(t, i, n, e, "x", a), r && Et(t, i, r, e, "y", l), O(e, s.resolution || (0 === s.curviness ? 20 : 12))
                    },
                    Tt = function (t) {
                        return t
                    },
                    Pt = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
                    At = function (t, e, i) {
                        var n, r = lt(t),
                            o = 0,
                            s = 0;
                        return "svg" === (t.tagName + "").toLowerCase() ? (n = t.viewBox.baseVal).width || (n = {
                            width: +t.getAttribute("width"),
                            height: +t.getAttribute("height")
                        }) : n = e && t.getBBox && t.getBBox(), e && "auto" !== e && (o = e.push ? e[0] * (n ? n.width : t.offsetWidth || 0) : e.x, s = e.push ? e[1] * (n ? n.height : t.offsetHeight || 0) : e.y), i.apply(o || s ? r.apply({
                            x: o,
                            y: s
                        }) : {
                            x: r.e,
                            y: r.f
                        })
                    },
                    It = function (t, e, i, n) {
                        var r, o = lt(t.parentNode, !0, !0),
                            s = o.clone().multiply(lt(e)),
                            a = At(t, i, o),
                            l = At(e, n, o),
                            h = l.x,
                            u = l.y;
                        return s.e = s.f = 0, "auto" === n && e.getTotalLength && "path" === e.tagName.toLowerCase() && (r = e.getAttribute("d").match(Pt) || [], h += (r = s.apply({
                            x: +r[0],
                            y: +r[1]
                        })).x, u += r.y), r && (h -= (r = s.apply(e.getBBox())).x, u -= r.y), s.e = h - a.x, s.f = u - a.y, s
                    },
                    wt = function (t, e, i) {
                        var n, r, o, s = i.align,
                            a = i.matrix,
                            l = i.offsetX,
                            h = i.offsetY,
                            u = i.alignOrigin,
                            c = t[0][0],
                            d = t[0][1],
                            p = St(e, "x"),
                            f = St(e, "y");
                        return t && t.length ? (s && ("self" === s || (n = dt(s)[0] || e) === e ? D(t, 1, 0, 0, 1, p - c, f - d) : (u && !1 !== u[2] ? ht.set(e, {
                            transformOrigin: 100 * u[0] + "% " + 100 * u[1] + "%"
                        }) : u = [St(e, "xPercent") / -100, St(e, "yPercent") / -100], o = (r = It(e, n, u, "auto")).apply({
                            x: c,
                            y: d
                        }), D(t, r.a, r.b, r.c, r.d, p + r.e - (o.x - r.e), f + r.f - (o.y - r.f)))), a ? D(t, a.a, a.b, a.c, a.d, a.e, a.f) : (l || h) && D(t, 1, 0, 0, 1, l || 0, h || 0), t) : I("M0,0L0,0")
                    },
                    Et = function (t, e, i, n, r, o) {
                        var s = e._gsap,
                            a = s.harness,
                            l = a && a.aliases && a.aliases[i],
                            h = l && l.indexOf(",") < 0 ? l : i,
                            u = t._pt = new ut(t._pt, e, h, 0, 0, Tt, 0, s.set(e, h, t));
                        u.u = ct(s.get(e, h, o)) || 0, u.path = n, u.pp = r, t._props.push(h)
                    },
                    Ct = {
                        version: "3.12.1",
                        name: "motionPath",
                        register: function (t, e, i) {
                            ct = (ht = t).utils.getUnit, dt = ht.utils.toArray, pt = ht.core.getStyleSaver, ft = ht.core.reverting || function () { }, ut = i
                        },
                        init: function (t, e, i) {
                            if (!ht) return console.warn("Please gsap.registerPlugin(MotionPathPlugin)"), !1;
                            "object" == typeof e && !e.style && e.path || (e = {
                                path: e
                            });
                            var n, r, o, s, a = [],
                                l = e,
                                h = l.path,
                                u = l.autoRotate,
                                c = l.unitX,
                                d = l.unitY,
                                p = l.x,
                                f = l.y,
                                g = h[0],
                                m = (o = e.start, s = "end" in e ? e.end : 1, function (t) {
                                    return o || 1 !== s ? B(t, o, s) : t
                                });
                            if (this.rawPaths = a, this.target = t, this.tween = i, this.styles = pt && pt(t, "transform"), (this.rotate = u || 0 === u) && (this.rOffset = parseFloat(u) || 0, this.radians = !!e.useRadians, this.rProp = e.rotation || "rotation", this.rSet = t._gsap.set(t, this.rProp, this), this.ru = ct(t._gsap.get(t, this.rProp)) || 0), Array.isArray(h) && !("closed" in h) && "number" != typeof g) {
                                for (r in g) !p && ~gt.indexOf(r) ? p = r : !f && ~mt.indexOf(r) && (f = r);
                                for (r in p && f ? a.push(bt(this, yt(yt([], h, p, 0), h, f, 1), t, p, f, m, e, c || ct(h[0][p]), d || ct(h[0][f]))) : p = f = 0, g) r !== p && r !== f && a.push(bt(this, yt([], h, r, 2), t, r, 0, m, e, ct(h[0][r])))
                            } else O(n = m(wt(I(e.path), t, e)), e.resolution), a.push(n), Et(this, t, e.x || "x", n, "x", e.unitX || "px"), Et(this, t, e.y || "y", n, "y", e.unitY || "px")
                        },
                        render: function (t, e) {
                            var i = e.rawPaths,
                                n = i.length,
                                r = e._pt;
                            if (e.tween._time || !ft()) {
                                for (t > 1 ? t = 1 : t < 0 && (t = 0); n--;) R(i[n], t, !n && e.rotate, i[n]);
                                for (; r;) r.set(r.t, r.p, r.path[r.pp] + r.u, r.d, t), r = r._next;
                                e.rotate && e.rSet(e.target, e.rProp, i[0].angle * (e.radians ? _t : 1) + e.rOffset + e.ru, e, t)
                            } else e.styles.revert()
                        },
                        getLength: function (t) {
                            return O(I(t)).totalLength
                        },
                        sliceRawPath: B,
                        getRawPath: I,
                        pointsToSegment: G,
                        stringToRawPath: k,
                        rawPathToString: W,
                        transformRawPath: D,
                        getGlobalMatrix: lt,
                        getPositionOnPath: R,
                        cacheRawPathMeasurements: O,
                        convertToPath: function (t, e) {
                            return dt(t).map((function (t) {
                                return C(t, !1 !== e)
                            }))
                        },
                        convertCoordinates: function (t, e, i) {
                            var n = lt(e, !0, !0).multiply(lt(t));
                            return i ? n.apply(i) : n
                        },
                        getAlignMatrix: It,
                        getRelativePosition: function (t, e, i, n) {
                            var r = It(t, e, i, n);
                            return {
                                x: r.e,
                                y: r.f
                            }
                        },
                        arrayToRawPath: function (t, e) {
                            var i = yt(yt([], t, (e = e || {}).x || "x", 0), t, e.y || "y", 1);
                            return e.relative && vt(i), ["cubic" === e.type ? i : G(i, e.curviness)]
                        }
                    };
                (ht || "undefined" != typeof window && (ht = window.gsap) && ht.registerPlugin && ht) && ht.registerPlugin(Ct), t.MotionPathPlugin = Ct, t.default = Ct, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e)
        },
        2983: function (t, e) {
            ! function (t) {
                "use strict";
                var e, i, n, r, o, s, a, l, h, u = function () {
                    return "undefined" != typeof window
                },
                    c = function () {
                        return e || u() && (e = window.gsap) && e.registerPlugin && e
                    },
                    d = function (t) {
                        return "function" == typeof t
                    },
                    p = function (t) {
                        return console.warn(t)
                    },
                    f = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
                    g = .212671,
                    m = .71516,
                    _ = .072169,
                    y = function (t) {
                        return d(r[t]) ? r[t] : r.filters[t]
                    },
                    S = function (t, e) {
                        var i, n, r = [],
                            o = 0,
                            s = 0;
                        for (i = 0; i < 4; i++) {
                            for (n = 0; n < 5; n++) s = 4 === n ? t[o + 4] : 0, r[o + n] = t[o] * e[n] + t[o + 1] * e[n + 5] + t[o + 2] * e[n + 10] + t[o + 3] * e[n + 15] + s;
                            o += 5
                        }
                        return r
                    },
                    v = function (t, e) {
                        var i = 1 - e,
                            n = i * g,
                            r = i * m,
                            o = i * _;
                        return S([n + e, r, o, 0, 0, n, r + e, o, 0, 0, n, r, o + e, 0, 0, 0, 0, 0, 1, 0], t)
                    },
                    b = function (t, e, i) {
                        var r = n(e),
                            o = r[0] / 255,
                            s = r[1] / 255,
                            a = r[2] / 255,
                            l = 1 - i;
                        return S([l + i * o * g, i * o * m, i * o * _, 0, 0, i * s * g, l + i * s * m, i * s * _, 0, 0, i * a * g, i * a * m, l + i * a * _, 0, 0, 0, 0, 0, 1, 0], t)
                    },
                    T = function (t, e) {
                        e *= Math.PI / 180;
                        var i = Math.cos(e),
                            n = Math.sin(e);
                        return S([g + i * (1 - g) + n * -g, m + i * -m + n * -m, _ + i * -_ + n * (1 - _), 0, 0, g + i * -g + .143 * n, m + .28484 * i + .14 * n, _ + i * -_ + -.283 * n, 0, 0, g + i * -g + -.787329 * n, m + i * -m + n * m, _ + i * (1 - _) + n * _, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], t)
                    },
                    P = function (t, e) {
                        return S([e, 0, 0, 0, .5 * (1 - e), 0, e, 0, 0, .5 * (1 - e), 0, 0, e, 0, .5 * (1 - e), 0, 0, 0, 1, 0], t)
                    },
                    A = function (t, e) {
                        var i, n = y(e),
                            r = t.filters || [],
                            o = r.length;
                        for (n || p(e + " not found. PixiPlugin.registerPIXI(PIXI)"); --o > -1;)
                            if (r[o] instanceof n) return r[o];
                        return i = new n, "BlurFilter" === e && (i.blur = 0), r.push(i), t.filters = r, i
                    },
                    I = function (t, e, i, n) {
                        e.add(i, t, i[t], n[t]), e._props.push(t)
                    },
                    w = function (t, e) {
                        var i = y("ColorMatrixFilter")();
                        return i.matrix = e, i.brightness(t, !0), i.matrix
                    },
                    E = {
                        contrast: 1,
                        saturation: 1,
                        colorizeAmount: 0,
                        colorize: "rgb(255,255,255)",
                        hue: 0,
                        brightness: 1
                    },
                    C = function (t, e, i) {
                        var n, r, o, s = A(t, "ColorMatrixFilter"),
                            a = t._gsColorMatrixFilter = t._gsColorMatrixFilter || function (t) {
                                var e, i = {};
                                for (e in t) i[e] = t[e];
                                return i
                            }(E),
                            l = e.combineCMF && !("colorMatrixFilter" in e && !e.colorMatrixFilter);
                        o = s.matrix, e.resolution && (s.resolution = e.resolution), e.matrix && e.matrix.length === o.length ? (r = e.matrix, 1 !== a.contrast && I("contrast", i, a, E), a.hue && I("hue", i, a, E), 1 !== a.brightness && I("brightness", i, a, E), a.colorizeAmount && (I("colorize", i, a, E), I("colorizeAmount", i, a, E)), 1 !== a.saturation && I("saturation", i, a, E)) : (r = f.slice(), null != e.contrast ? (r = P(r, +e.contrast), I("contrast", i, a, e)) : 1 !== a.contrast && (l ? r = P(r, a.contrast) : I("contrast", i, a, E)), null != e.hue ? (r = T(r, +e.hue), I("hue", i, a, e)) : a.hue && (l ? r = T(r, a.hue) : I("hue", i, a, E)), null != e.brightness ? (r = w(+e.brightness, r), I("brightness", i, a, e)) : 1 !== a.brightness && (l ? r = w(a.brightness, r) : I("brightness", i, a, E)), null != e.colorize ? (e.colorizeAmount = "colorizeAmount" in e ? +e.colorizeAmount : 1, r = b(r, e.colorize, e.colorizeAmount), I("colorize", i, a, e), I("colorizeAmount", i, a, e)) : a.colorizeAmount && (l ? r = b(r, a.colorize, a.colorizeAmount) : (I("colorize", i, a, E), I("colorizeAmount", i, a, E))), null != e.saturation ? (r = v(r, +e.saturation), I("saturation", i, a, e)) : 1 !== a.saturation && (l ? r = v(r, a.saturation) : I("saturation", i, a, E))), n = r.length;
                        for (; --n > -1;) r[n] !== o[n] && i.add(o, n, o[n], r[n], "colorMatrixFilter");
                        i._props.push("colorMatrixFilter")
                    },
                    x = function (t, e) {
                        var i = e.t,
                            n = e.p,
                            r = e.color;
                        (0, e.set)(i, n, r[0] << 16 | r[1] << 8 | r[2])
                    },
                    B = function (t, e) {
                        var i = e.g;
                        i && (i.dirty++, i.clearDirty++)
                    },
                    L = function (t, e) {
                        e.t.visible = !!e.t.alpha
                    },
                    O = function (t, e, i, r) {
                        var a = t[e],
                            l = n(d(a) ? t[e.indexOf("set") || !d(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)]() : a),
                            h = n(i);
                        r._pt = new o(r._pt, t, e, 0, 0, x, {
                            t,
                            p: e,
                            color: l,
                            set: s(t, e)
                        }), r.add(l, 0, l[0], h[0]), r.add(l, 1, l[1], h[1]), r.add(l, 2, l[2], h[2])
                    },
                    N = {
                        tint: 1,
                        lineColor: 1,
                        fillColor: 1
                    },
                    M = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
                    R = {
                        x: "position",
                        y: "position",
                        tileX: "tilePosition",
                        tileY: "tilePosition"
                    },
                    D = {
                        colorMatrixFilter: 1,
                        saturation: 1,
                        contrast: 1,
                        hue: 1,
                        colorize: 1,
                        colorizeAmount: 1,
                        brightness: 1,
                        combineCMF: 1
                    },
                    F = Math.PI / 180,
                    k = function (t) {
                        return "string" == typeof t
                    },
                    U = function (t) {
                        return k(t) && "=" === t.charAt(1) ? t.substr(0, 2) + parseFloat(t.substr(2)) * F : t * F
                    },
                    G = function (t, e) {
                        return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e5 * (e.s + e.c * t)) / 1e5, e)
                    },
                    W = function (t, e, i, n, r, s) {
                        var a, l, h = 360 * (s ? F : 1),
                            u = k(r),
                            c = u && "=" === r.charAt(1) ? +(r.charAt(0) + "1") : 0,
                            d = parseFloat(c ? r.substr(2) : r) * (s ? F : 1),
                            p = c ? d * c : d - n,
                            f = n + p;
                        return u && ("short" === (a = r.split("_")[1]) && (p %= h) != p % (h / 2) && (p += p < 0 ? h : -h), "cw" === a && p < 0 ? p = (p + 1e10 * h) % h - ~~(p / h) * h : "ccw" === a && p > 0 && (p = (p - 1e10 * h) % h - ~~(p / h) * h)), t._pt = l = new o(t._pt, e, i, n, p, G), l.e = f, l
                    },
                    V = function () {
                        u() && (i = window, e = c(), r = r || i.PIXI, a = r && r.VERSION && "4" === r.VERSION.charAt(0), n = function (t) {
                            return e.utils.splitColor("0x" === (t + "").substr(0, 2) ? "#" + t.substr(2) : t)
                        })
                    };
                for (l = 0; l < M.length; l++) h = M[l], R[h + "X"] = h, R[h + "Y"] = h;
                var X = {
                    version: "3.12.1",
                    name: "pixi",
                    register: function (t, i, n) {
                        e = t, o = n, s = i.getSetter, V()
                    },
                    registerPIXI: function (t) {
                        r = t
                    },
                    init: function (t, e, i, n, s) {
                        if (r || V(), !(r && t instanceof r.DisplayObject)) return p(t), !1;
                        var l, h, u, c, d, f, g, m, _;
                        for (f in e) {
                            if (l = R[f], u = e[f], l) h = ~f.charAt(f.length - 1).toLowerCase().indexOf("x") ? "x" : "y", this.add(t[l], h, t[l][h], "skew" === l ? U(u) : u, 0, 0, 0, 0, 0, 1);
                            else if ("scale" === f || "anchor" === f || "pivot" === f || "tileScale" === f) this.add(t[f], "x", t[f].x, u), this.add(t[f], "y", t[f].y, u);
                            else if ("rotation" === f || "angle" === f) W(this, t, f, t[f], u, "rotation" === f);
                            else if (D[f]) c || (C(t, e.colorMatrixFilter || e, this), c = !0);
                            else if ("blur" === f || "blurX" === f || "blurY" === f || "blurPadding" === f) {
                                if (d = A(t, "BlurFilter"), this.add(d, f, d[f], u), 0 !== e.blurPadding)
                                    for (g = e.blurPadding || 2 * Math.max(d[f], u), m = t.filters.length; --m > -1;) t.filters[m].padding = Math.max(t.filters[m].padding, g)
                            } else if (N[f])
                                if (("lineColor" === f || "fillColor" === f) && t instanceof r.Graphics)
                                    for (_ = (t.geometry || t).graphicsData, this._pt = new o(this._pt, t, f, 0, 0, B, {
                                        g: t.geometry || t
                                    }), m = _.length; --m > -1;) O(a ? _[m] : _[m][f.substr(0, 4) + "Style"], a ? f : "color", u, this);
                                else O(t, f, u, this);
                            else "autoAlpha" === f ? (this._pt = new o(this._pt, t, "visible", 0, 0, L), this.add(t, "alpha", t.alpha, u), this._props.push("alpha", "visible")) : "resolution" !== f && this.add(t, f, "get", u);
                            this._props.push(f)
                        }
                    }
                };
                c() && e.registerPlugin(X), t.PixiPlugin = X, t.default = X, Object.defineProperty(t, "__esModule", {
                    value: !0
                })
            }(e)
        },
        6358: (t, e, i) => {
            "use strict";

            function n(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function r(t, e) {
                t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
            }
            i.r(e), i.d(e, {
                Back: () => Yi,
                Bounce: () => zi,
                CSSPlugin: () => hr,
                Circ: () => Zi,
                Cubic: () => Gi,
                Elastic: () => Hi,
                Expo: () => qi,
                Linear: () => ki,
                Power0: () => Ni,
                Power1: () => Mi,
                Power2: () => Ri,
                Power3: () => Di,
                Power4: () => Fi,
                Quad: () => Ui,
                Quart: () => Wi,
                Quint: () => Vi,
                Sine: () => Ki,
                SteppedEase: () => ji,
                Strong: () => Xi,
                TimelineLite: () => Ge,
                TimelineMax: () => Ge,
                TweenLite: () => $e,
                TweenMax: () => cr,
                default: () => ur,
                gsap: () => ur
            });
            var o, s, a, l, h, u, c, d, p, f, g, m, _, y, S, v = {
                autoSleep: 120,
                force3D: "auto",
                nullTargetWarn: 1,
                units: {
                    lineHeight: ""
                }
            },
                b = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                T = 1e8,
                P = 1e-8,
                A = 2 * Math.PI,
                I = A / 4,
                w = 0,
                E = Math.sqrt,
                C = Math.cos,
                x = Math.sin,
                B = function (t) {
                    return "string" == typeof t
                },
                L = function (t) {
                    return "function" == typeof t
                },
                O = function (t) {
                    return "number" == typeof t
                },
                N = function (t) {
                    return void 0 === t
                },
                M = function (t) {
                    return "object" == typeof t
                },
                R = function (t) {
                    return !1 !== t
                },
                D = function () {
                    return "undefined" != typeof window
                },
                F = function (t) {
                    return L(t) || B(t)
                },
                k = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function () { },
                U = Array.isArray,
                G = /(?:-?\.?\d|\.)+/gi,
                W = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                V = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                X = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                H = /[+-]=-?[.\d]+/,
                Y = /[^,'"\[\]\s]+/gi,
                j = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                z = {},
                K = {},
                q = function (t) {
                    return (K = At(t, z)) && Ai
                },
                Z = function (t, e) {
                    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
                },
                $ = function (t, e) {
                    return !e && console.warn(t)
                },
                J = function (t, e) {
                    return t && (z[t] = e) && K && (K[t] = e) || z
                },
                Q = function () {
                    return 0
                },
                tt = {
                    suppressEvents: !0,
                    isStart: !0,
                    kill: !1
                },
                et = {
                    suppressEvents: !0,
                    kill: !1
                },
                it = {
                    suppressEvents: !0
                },
                nt = {},
                rt = [],
                ot = {},
                st = {},
                at = {},
                lt = 30,
                ht = [],
                ut = "",
                ct = function (t) {
                    var e, i, n = t[0];
                    if (M(n) || L(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
                        for (i = ht.length; i-- && !ht[i].targetTest(n););
                        e = ht[i]
                    }
                    for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new ke(t[i], e))) || t.splice(i, 1);
                    return t
                },
                dt = function (t) {
                    return t._gsap || ct(ee(t))[0]._gsap
                },
                pt = function (t, e, i) {
                    return (i = t[e]) && L(i) ? t[e]() : N(i) && t.getAttribute && t.getAttribute(e) || i
                },
                ft = function (t, e) {
                    return (t = t.split(",")).forEach(e) || t
                },
                gt = function (t) {
                    return Math.round(1e5 * t) / 1e5 || 0
                },
                mt = function (t) {
                    return Math.round(1e7 * t) / 1e7 || 0
                },
                _t = function (t, e) {
                    var i = e.charAt(0),
                        n = parseFloat(e.substr(2));
                    return t = parseFloat(t), "+" === i ? t + n : "-" === i ? t - n : "*" === i ? t * n : t / n
                },
                yt = function (t, e) {
                    for (var i = e.length, n = 0; t.indexOf(e[n]) < 0 && ++n < i;);
                    return n < i
                },
                St = function () {
                    var t, e, i = rt.length,
                        n = rt.slice(0);
                    for (ot = {}, rt.length = 0, t = 0; t < i; t++)(e = n[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
                },
                vt = function (t, e, i, n) {
                    rt.length && !s && St(), t.render(e, i, n || s && e < 0 && (t._initted || t._startAt)), rt.length && !s && St()
                },
                bt = function (t) {
                    var e = parseFloat(t);
                    return (e || 0 === e) && (t + "").match(Y).length < 2 ? e : B(t) ? t.trim() : t
                },
                Tt = function (t) {
                    return t
                },
                Pt = function (t, e) {
                    for (var i in e) i in t || (t[i] = e[i]);
                    return t
                },
                At = function (t, e) {
                    for (var i in e) t[i] = e[i];
                    return t
                },
                It = function t(e, i) {
                    for (var n in i) "__proto__" !== n && "constructor" !== n && "prototype" !== n && (e[n] = M(i[n]) ? t(e[n] || (e[n] = {}), i[n]) : i[n]);
                    return e
                },
                wt = function (t, e) {
                    var i, n = {};
                    for (i in t) i in e || (n[i] = t[i]);
                    return n
                },
                Et = function (t) {
                    var e, i = t.parent || l,
                        n = t.keyframes ? (e = U(t.keyframes), function (t, i) {
                            for (var n in i) n in t || "duration" === n && e || "ease" === n || (t[n] = i[n])
                        }) : Pt;
                    if (R(t.inherit))
                        for (; i;) n(t, i.vars.defaults), i = i.parent || i._dp;
                    return t
                },
                Ct = function (t, e, i, n, r) {
                    void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                    var o, s = t[n];
                    if (r)
                        for (o = e[r]; s && s[r] > o;) s = s._prev;
                    return s ? (e._next = s._next, s._next = e) : (e._next = t[i], t[i] = e), e._next ? e._next._prev = e : t[n] = e, e._prev = s, e.parent = e._dp = t, e
                },
                xt = function (t, e, i, n) {
                    void 0 === i && (i = "_first"), void 0 === n && (n = "_last");
                    var r = e._prev,
                        o = e._next;
                    r ? r._next = o : t[i] === e && (t[i] = o), o ? o._prev = r : t[n] === e && (t[n] = r), e._next = e._prev = e.parent = null
                },
                Bt = function (t, e) {
                    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove && t.parent.remove(t), t._act = 0
                },
                Lt = function (t, e) {
                    if (t && (!e || e._end > t._dur || e._start < 0))
                        for (var i = t; i;) i._dirty = 1, i = i.parent;
                    return t
                },
                Ot = function (t, e, i, n) {
                    return t._startAt && (s ? t._startAt.revert(et) : t.vars.immediateRender && !t.vars.autoRevert || t._startAt.render(e, !0, n))
                },
                Nt = function t(e) {
                    return !e || e._ts && t(e.parent)
                },
                Mt = function (t) {
                    return t._repeat ? Rt(t._tTime, t = t.duration() + t._rDelay) * t : 0
                },
                Rt = function (t, e) {
                    var i = Math.floor(t /= e);
                    return t && i === t ? i - 1 : i
                },
                Dt = function (t, e) {
                    return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
                },
                Ft = function (t) {
                    return t._end = mt(t._start + (t._tDur / Math.abs(t._ts || t._rts || P) || 0))
                },
                kt = function (t, e) {
                    var i = t._dp;
                    return i && i.smoothChildTiming && t._ts && (t._start = mt(i._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Ft(t), i._dirty || Lt(i, t)), t
                },
                Ut = function (t, e) {
                    var i;
                    if ((e._time || e._initted && !e._dur) && (i = Dt(t.rawTime(), e), (!e._dur || $t(0, e.totalDuration(), i) - e._tTime > P) && e.render(i, !0)), Lt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                        if (t._dur < t.duration())
                            for (i = t; i._dp;) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
                        t._zTime = -1e-8
                    }
                },
                Gt = function (t, e, i, n) {
                    return e.parent && Bt(e), e._start = mt((O(i) ? i : i || t !== l ? Kt(t, i, e) : t._time) + e._delay), e._end = mt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Ct(t, e, "_first", "_last", t._sort ? "_start" : 0), Ht(e) || (t._recent = e), n || Ut(t, e), t._ts < 0 && kt(t, t._tTime), t
                },
                Wt = function (t, e) {
                    return (z.ScrollTrigger || Z("scrollTrigger", e)) && z.ScrollTrigger.create(e, t)
                },
                Vt = function (t, e, i, n, r) {
                    return je(t, e, r), t._initted ? !i && t._pt && !s && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && p !== Ie.frame ? (rt.push(t), t._lazy = [r, n], 1) : void 0 : 1
                },
                Xt = function t(e) {
                    var i = e.parent;
                    return i && i._ts && i._initted && !i._lock && (i.rawTime() < 0 || t(i))
                },
                Ht = function (t) {
                    var e = t.data;
                    return "isFromStart" === e || "isStart" === e
                },
                Yt = function (t, e, i, n) {
                    var r = t._repeat,
                        o = mt(e) || 0,
                        s = t._tTime / t._tDur;
                    return s && !n && (t._time *= o / t._dur), t._dur = o, t._tDur = r ? r < 0 ? 1e10 : mt(o * (r + 1) + t._rDelay * r) : o, s > 0 && !n && kt(t, t._tTime = t._tDur * s), t.parent && Ft(t), i || Lt(t.parent, t), t
                },
                jt = function (t) {
                    return t instanceof Ge ? Lt(t) : Yt(t, t._dur)
                },
                zt = {
                    _start: 0,
                    endTime: Q,
                    totalDuration: Q
                },
                Kt = function t(e, i, n) {
                    var r, o, s, a = e.labels,
                        l = e._recent || zt,
                        h = e.duration() >= T ? l.endTime(!1) : e._dur;
                    return B(i) && (isNaN(i) || i in a) ? (o = i.charAt(0), s = "%" === i.substr(-1), r = i.indexOf("="), "<" === o || ">" === o ? (r >= 0 && (i = i.replace(/=/, "")), ("<" === o ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(i.substr(1)) || 0) * (s ? (r < 0 ? l : n).totalDuration() / 100 : 1)) : r < 0 ? (i in a || (a[i] = h), a[i]) : (o = parseFloat(i.charAt(r - 1) + i.substr(r + 1)), s && n && (o = o / 100 * (U(n) ? n[0] : n).totalDuration()), r > 1 ? t(e, i.substr(0, r - 1), n) + o : h + o)) : null == i ? h : +i
                },
                qt = function (t, e, i) {
                    var n, r, o = O(e[1]),
                        s = (o ? 2 : 1) + (t < 2 ? 0 : 1),
                        a = e[s];
                    if (o && (a.duration = e[1]), a.parent = i, t) {
                        for (n = a, r = i; r && !("immediateRender" in n);) n = r.vars.defaults || {}, r = R(r.vars.inherit) && r.parent;
                        a.immediateRender = R(n.immediateRender), t < 2 ? a.runBackwards = 1 : a.startAt = e[s - 1]
                    }
                    return new $e(e[0], a, e[s + 1])
                },
                Zt = function (t, e) {
                    return t || 0 === t ? e(t) : e
                },
                $t = function (t, e, i) {
                    return i < t ? t : i > e ? e : i
                },
                Jt = function (t, e) {
                    return B(t) && (e = j.exec(t)) ? e[1] : ""
                },
                Qt = [].slice,
                te = function (t, e) {
                    return t && M(t) && "length" in t && (!e && !t.length || t.length - 1 in t && M(t[0])) && !t.nodeType && t !== h
                },
                ee = function (t, e, i) {
                    return a && !e && a.selector ? a.selector(t) : !B(t) || i || !u && we() ? U(t) ? function (t, e, i) {
                        return void 0 === i && (i = []), t.forEach((function (t) {
                            var n;
                            return B(t) && !e || te(t, 1) ? (n = i).push.apply(n, ee(t)) : i.push(t)
                        })) || i
                    }(t, i) : te(t) ? Qt.call(t, 0) : t ? [t] : [] : Qt.call((e || c).querySelectorAll(t), 0)
                },
                ie = function (t) {
                    return t = ee(t)[0] || $("Invalid scope") || {},
                        function (e) {
                            var i = t.current || t.nativeElement || t;
                            return ee(e, i.querySelectorAll ? i : i === t ? $("Invalid scope") || c.createElement("div") : t)
                        }
                },
                ne = function (t) {
                    return t.sort((function () {
                        return .5 - Math.random()
                    }))
                },
                re = function (t) {
                    if (L(t)) return t;
                    var e = M(t) ? t : {
                        each: t
                    },
                        i = Ne(e.ease),
                        n = e.from || 0,
                        r = parseFloat(e.base) || 0,
                        o = {},
                        s = n > 0 && n < 1,
                        a = isNaN(n) || s,
                        l = e.axis,
                        h = n,
                        u = n;
                    return B(n) ? h = u = {
                        center: .5,
                        edges: .5,
                        end: 1
                    }[n] || 0 : !s && a && (h = n[0], u = n[1]),
                        function (t, s, c) {
                            var d, p, f, g, m, _, y, S, v, b = (c || e).length,
                                P = o[b];
                            if (!P) {
                                if (!(v = "auto" === e.grid ? 0 : (e.grid || [1, T])[1])) {
                                    for (y = -T; y < (y = c[v++].getBoundingClientRect().left) && v < b;);
                                    v--
                                }
                                for (P = o[b] = [], d = a ? Math.min(v, b) * h - .5 : n % v, p = v === T ? 0 : a ? b * u / v - .5 : n / v | 0, y = 0, S = T, _ = 0; _ < b; _++) f = _ % v - d, g = p - (_ / v | 0), P[_] = m = l ? Math.abs("y" === l ? g : f) : E(f * f + g * g), m > y && (y = m), m < S && (S = m);
                                "random" === n && ne(P), P.max = y - S, P.min = S, P.v = b = (parseFloat(e.amount) || parseFloat(e.each) * (v > b ? b - 1 : l ? "y" === l ? b / v : v : Math.max(v, b / v)) || 0) * ("edges" === n ? -1 : 1), P.b = b < 0 ? r - b : r, P.u = Jt(e.amount || e.each) || 0, i = i && b < 0 ? Le(i) : i
                            }
                            return b = (P[t] - P.min) / P.max || 0, mt(P.b + (i ? i(b) : b) * P.v) + P.u
                        }
                },
                oe = function (t) {
                    var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
                    return function (i) {
                        var n = mt(Math.round(parseFloat(i) / t) * t * e);
                        return (n - n % 1) / e + (O(i) ? 0 : Jt(i))
                    }
                },
                se = function (t, e) {
                    var i, n, r = U(t);
                    return !r && M(t) && (i = r = t.radius || T, t.values ? (t = ee(t.values), (n = !O(t[0])) && (i *= i)) : t = oe(t.increment)), Zt(e, r ? L(t) ? function (e) {
                        return n = t(e), Math.abs(n - e) <= i ? n : e
                    } : function (e) {
                        for (var r, o, s = parseFloat(n ? e.x : e), a = parseFloat(n ? e.y : 0), l = T, h = 0, u = t.length; u--;)(r = n ? (r = t[u].x - s) * r + (o = t[u].y - a) * o : Math.abs(t[u] - s)) < l && (l = r, h = u);
                        return h = !i || l <= i ? t[h] : e, n || h === e || O(e) ? h : h + Jt(e)
                    } : oe(t))
                },
                ae = function (t, e, i, n) {
                    return Zt(U(t) ? !e : !0 === i ? !!(i = 0) : !n, (function () {
                        return U(t) ? t[~~(Math.random() * t.length)] : (i = i || 1e-5) && (n = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((t - i / 2 + Math.random() * (e - t + .99 * i)) / i) * i * n) / n
                    }))
                },
                le = function (t, e, i) {
                    return Zt(i, (function (i) {
                        return t[~~e(i)]
                    }))
                },
                he = function (t) {
                    for (var e, i, n, r, o = 0, s = ""; ~(e = t.indexOf("random(", o));) n = t.indexOf(")", e), r = "[" === t.charAt(e + 7), i = t.substr(e + 7, n - e - 7).match(r ? Y : G), s += t.substr(o, e - o) + ae(r ? i : +i[0], r ? 0 : +i[1], +i[2] || 1e-5), o = n + 1;
                    return s + t.substr(o, t.length - o)
                },
                ue = function (t, e, i, n, r) {
                    var o = e - t,
                        s = n - i;
                    return Zt(r, (function (e) {
                        return i + ((e - t) / o * s || 0)
                    }))
                },
                ce = function (t, e, i) {
                    var n, r, o, s = t.labels,
                        a = T;
                    for (n in s) (r = s[n] - e) < 0 == !!i && r && a > (r = Math.abs(r)) && (o = n, a = r);
                    return o
                },
                de = function (t, e, i) {
                    var n, r, o, s = t.vars,
                        l = s[e],
                        h = a,
                        u = t._ctx;
                    if (l) return n = s[e + "Params"], r = s.callbackScope || t, i && rt.length && St(), u && (a = u), o = n ? l.apply(r, n) : l.call(r), a = h, o
                },
                pe = function (t) {
                    return Bt(t), t.scrollTrigger && t.scrollTrigger.kill(!!s), t.progress() < 1 && de(t, "onInterrupt"), t
                },
                fe = [],
                ge = function (t) {
                    if (D() && t) {
                        var e = (t = !t.name && t.default || t).name,
                            i = L(t),
                            n = e && !i && t.init ? function () {
                                this._props = []
                            } : t,
                            r = {
                                init: Q,
                                render: si,
                                add: He,
                                kill: li,
                                modifier: ai,
                                rawVars: 0
                            },
                            o = {
                                targetTest: 0,
                                get: 0,
                                getSetter: ii,
                                aliases: {},
                                register: 0
                            };
                        if (we(), t !== n) {
                            if (st[e]) return;
                            Pt(n, Pt(wt(t, r), o)), At(n.prototype, At(r, wt(t, o))), st[n.prop = e] = n, t.targetTest && (ht.push(n), nt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                        }
                        J(e, n), t.register && t.register(Ai, n, ci)
                    } else t && fe.push(t)
                },
                me = 255,
                _e = {
                    aqua: [0, me, me],
                    lime: [0, me, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, me],
                    navy: [0, 0, 128],
                    white: [me, me, me],
                    olive: [128, 128, 0],
                    yellow: [me, me, 0],
                    orange: [me, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [me, 0, 0],
                    pink: [me, 192, 203],
                    cyan: [0, me, me],
                    transparent: [me, me, me, 0]
                },
                ye = function (t, e, i) {
                    return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) * me + .5 | 0
                },
                Se = function (t, e, i) {
                    var n, r, o, s, a, l, h, u, c, d, p = t ? O(t) ? [t >> 16, t >> 8 & me, t & me] : 0 : _e.black;
                    if (!p) {
                        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), _e[t]) p = _e[t];
                        else if ("#" === t.charAt(0)) {
                            if (t.length < 6 && (n = t.charAt(1), r = t.charAt(2), o = t.charAt(3), t = "#" + n + n + r + r + o + o + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & me, p & me, parseInt(t.substr(7), 16) / 255];
                            p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & me, t & me]
                        } else if ("hsl" === t.substr(0, 3))
                            if (p = d = t.match(G), e) {
                                if (~t.indexOf("=")) return p = t.match(W), i && p.length < 4 && (p[3] = 1), p
                            } else s = +p[0] % 360 / 360, a = +p[1] / 100, n = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), p.length > 3 && (p[3] *= 1), p[0] = ye(s + 1 / 3, n, r), p[1] = ye(s, n, r), p[2] = ye(s - 1 / 3, n, r);
                        else p = t.match(G) || _e.transparent;
                        p = p.map(Number)
                    }
                    return e && !d && (n = p[0] / me, r = p[1] / me, o = p[2] / me, l = ((h = Math.max(n, r, o)) + (u = Math.min(n, r, o))) / 2, h === u ? s = a = 0 : (c = h - u, a = l > .5 ? c / (2 - h - u) : c / (h + u), s = h === n ? (r - o) / c + (r < o ? 6 : 0) : h === r ? (o - n) / c + 2 : (n - r) / c + 4, s *= 60), p[0] = ~~(s + .5), p[1] = ~~(100 * a + .5), p[2] = ~~(100 * l + .5)), i && p.length < 4 && (p[3] = 1), p
                },
                ve = function (t) {
                    var e = [],
                        i = [],
                        n = -1;
                    return t.split(Te).forEach((function (t) {
                        var r = t.match(V) || [];
                        e.push.apply(e, r), i.push(n += r.length + 1)
                    })), e.c = i, e
                },
                be = function (t, e, i) {
                    var n, r, o, s, a = "",
                        l = (t + a).match(Te),
                        h = e ? "hsla(" : "rgba(",
                        u = 0;
                    if (!l) return t;
                    if (l = l.map((function (t) {
                        return (t = Se(t, e, 1)) && h + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                    })), i && (o = ve(t), (n = i.c).join(a) !== o.c.join(a)))
                        for (s = (r = t.replace(Te, "1").split(V)).length - 1; u < s; u++) a += r[u] + (~n.indexOf(u) ? l.shift() || h + "0,0,0,0)" : (o.length ? o : l.length ? l : i).shift());
                    if (!r)
                        for (s = (r = t.split(Te)).length - 1; u < s; u++) a += r[u] + l[u];
                    return a + r[s]
                },
                Te = function () {
                    var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                    for (t in _e) e += "|" + t + "\\b";
                    return new RegExp(e + ")", "gi")
                }(),
                Pe = /hsl[a]?\(/,
                Ae = function (t) {
                    var e, i = t.join(" ");
                    if (Te.lastIndex = 0, Te.test(i)) return e = Pe.test(i), t[1] = be(t[1], e), t[0] = be(t[0], e, ve(t[1])), !0
                },
                Ie = function () {
                    var t, e, i, n, r, o, s = Date.now,
                        a = 500,
                        l = 33,
                        p = s(),
                        f = p,
                        m = 1e3 / 240,
                        _ = m,
                        y = [],
                        S = function i(h) {
                            var u, c, d, g, S = s() - f,
                                v = !0 === h;
                            if (S > a && (p += S - l), ((u = (d = (f += S) - p) - _) > 0 || v) && (g = ++n.frame, r = d - 1e3 * n.time, n.time = d /= 1e3, _ += u + (u >= m ? 4 : m - u), c = 1), v || (t = e(i)), c)
                                for (o = 0; o < y.length; o++) y[o](d, r, g, h)
                        };
                    return n = {
                        time: 0,
                        frame: 0,
                        tick: function () {
                            S(!0)
                        },
                        deltaRatio: function (t) {
                            return r / (1e3 / (t || 60))
                        },
                        wake: function () {
                            d && (!u && D() && (h = u = window, c = h.document || {}, z.gsap = Ai, (h.gsapVersions || (h.gsapVersions = [])).push(Ai.version), q(K || h.GreenSockGlobals || !h.gsap && h || {}), i = h.requestAnimationFrame, fe.forEach(ge)), t && n.sleep(), e = i || function (t) {
                                return setTimeout(t, _ - 1e3 * n.time + 1 | 0)
                            }, g = 1, S(2))
                        },
                        sleep: function () {
                            (i ? h.cancelAnimationFrame : clearTimeout)(t), g = 0, e = Q
                        },
                        lagSmoothing: function (t, e) {
                            a = t || 1 / 0, l = Math.min(e || 33, a)
                        },
                        fps: function (t) {
                            m = 1e3 / (t || 240), _ = 1e3 * n.time + m
                        },
                        add: function (t, e, i) {
                            var r = e ? function (e, i, o, s) {
                                t(e, i, o, s), n.remove(r)
                            } : t;
                            return n.remove(t), y[i ? "unshift" : "push"](r), we(), r
                        },
                        remove: function (t, e) {
                            ~(e = y.indexOf(t)) && y.splice(e, 1) && o >= e && o--
                        },
                        _listeners: y
                    }
                }(),
                we = function () {
                    return !g && Ie.wake()
                },
                Ee = {},
                Ce = /^[\d.\-M][\d.\-,\s]/,
                xe = /["']/g,
                Be = function (t) {
                    for (var e, i, n, r = {}, o = t.substr(1, t.length - 3).split(":"), s = o[0], a = 1, l = o.length; a < l; a++) i = o[a], e = a !== l - 1 ? i.lastIndexOf(",") : i.length, n = i.substr(0, e), r[s] = isNaN(n) ? n.replace(xe, "").trim() : +n, s = i.substr(e + 1).trim();
                    return r
                },
                Le = function (t) {
                    return function (e) {
                        return 1 - t(1 - e)
                    }
                },
                Oe = function t(e, i) {
                    for (var n, r = e._first; r;) r instanceof Ge ? t(r, i) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === i || (r.timeline ? t(r.timeline, i) : (n = r._ease, r._ease = r._yEase, r._yEase = n, r._yoyo = i)), r = r._next
                },
                Ne = function (t, e) {
                    return t && (L(t) ? t : Ee[t] || function (t) {
                        var e, i, n, r, o = (t + "").split("("),
                            s = Ee[o[0]];
                        return s && o.length > 1 && s.config ? s.config.apply(null, ~t.indexOf("{") ? [Be(o[1])] : (e = t, i = e.indexOf("(") + 1, n = e.indexOf(")"), r = e.indexOf("(", i), e.substring(i, ~r && r < n ? e.indexOf(")", n + 1) : n)).split(",").map(bt)) : Ee._CE && Ce.test(t) ? Ee._CE("", t) : s
                    }(t)) || e
                },
                Me = function (t, e, i, n) {
                    void 0 === i && (i = function (t) {
                        return 1 - e(1 - t)
                    }), void 0 === n && (n = function (t) {
                        return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                    });
                    var r, o = {
                        easeIn: e,
                        easeOut: i,
                        easeInOut: n
                    };
                    return ft(t, (function (t) {
                        for (var e in Ee[t] = z[t] = o, Ee[r = t.toLowerCase()] = i, o) Ee[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = Ee[t + "." + e] = o[e]
                    })), o
                },
                Re = function (t) {
                    return function (e) {
                        return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                    }
                },
                De = function t(e, i, n) {
                    var r = i >= 1 ? i : 1,
                        o = (n || (e ? .3 : .45)) / (i < 1 ? i : 1),
                        s = o / A * (Math.asin(1 / r) || 0),
                        a = function (t) {
                            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * x((t - s) * o) + 1
                        },
                        l = "out" === e ? a : "in" === e ? function (t) {
                            return 1 - a(1 - t)
                        } : Re(a);
                    return o = A / o, l.config = function (i, n) {
                        return t(e, i, n)
                    }, l
                },
                Fe = function t(e, i) {
                    void 0 === i && (i = 1.70158);
                    var n = function (t) {
                        return t ? --t * t * ((i + 1) * t + i) + 1 : 0
                    },
                        r = "out" === e ? n : "in" === e ? function (t) {
                            return 1 - n(1 - t)
                        } : Re(n);
                    return r.config = function (i) {
                        return t(e, i)
                    }, r
                };
            ft("Linear,Quad,Cubic,Quart,Quint,Strong", (function (t, e) {
                var i = e < 5 ? e + 1 : e;
                Me(t + ",Power" + (i - 1), e ? function (t) {
                    return Math.pow(t, i)
                } : function (t) {
                    return t
                }, (function (t) {
                    return 1 - Math.pow(1 - t, i)
                }), (function (t) {
                    return t < .5 ? Math.pow(2 * t, i) / 2 : 1 - Math.pow(2 * (1 - t), i) / 2
                }))
            })), Ee.Linear.easeNone = Ee.none = Ee.Linear.easeIn, Me("Elastic", De("in"), De("out"), De()), m = 7.5625, y = 1 / (_ = 2.75), Me("Bounce", (function (t) {
                return 1 - S(1 - t)
            }), S = function (t) {
                return t < y ? m * t * t : t < .7272727272727273 ? m * Math.pow(t - 1.5 / _, 2) + .75 : t < .9090909090909092 ? m * (t -= 2.25 / _) * t + .9375 : m * Math.pow(t - 2.625 / _, 2) + .984375
            }), Me("Expo", (function (t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            })), Me("Circ", (function (t) {
                return -(E(1 - t * t) - 1)
            })), Me("Sine", (function (t) {
                return 1 === t ? 1 : 1 - C(t * I)
            })), Me("Back", Fe("in"), Fe("out"), Fe()), Ee.SteppedEase = Ee.steps = z.SteppedEase = {
                config: function (t, e) {
                    void 0 === t && (t = 1);
                    var i = 1 / t,
                        n = t + (e ? 0 : 1),
                        r = e ? 1 : 0;
                    return function (t) {
                        return ((n * $t(0, .99999999, t) | 0) + r) * i
                    }
                }
            }, b.ease = Ee["quad.out"], ft("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function (t) {
                return ut += t + "," + t + "Params,"
            }));
            var ke = function (t, e) {
                this.id = w++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : pt, this.set = e ? e.getSetter : ii
            },
                Ue = function () {
                    function t(t) {
                        this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Yt(this, +t.duration, 1, 1), this.data = t.data, a && (this._ctx = a, a.data.push(this)), g || Ie.wake()
                    }
                    var e = t.prototype;
                    return e.delay = function (t) {
                        return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                    }, e.duration = function (t) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                    }, e.totalDuration = function (t) {
                        return arguments.length ? (this._dirty = 0, Yt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, e.totalTime = function (t, e) {
                        if (we(), !arguments.length) return this._tTime;
                        var i = this._dp;
                        if (i && i.smoothChildTiming && this._ts) {
                            for (kt(this, t), !i._dp || i.parent || Ut(i, this); i && i.parent;) i.parent._time !== i._start + (i._ts >= 0 ? i._tTime / i._ts : (i.totalDuration() - i._tTime) / -i._ts) && i.totalTime(i._tTime, !0), i = i.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Gt(this._dp, this, this._start - this._delay)
                        }
                        return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === P || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), vt(this, t, e)), this
                    }, e.time = function (t, e) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Mt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
                    }, e.totalProgress = function (t, e) {
                        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                    }, e.progress = function (t, e) {
                        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Mt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                    }, e.iteration = function (t, e) {
                        var i = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (t - 1) * i, e) : this._repeat ? Rt(this._tTime, i) + 1 : 1
                    }, e.timeScale = function (t) {
                        if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                        if (this._rts === t) return this;
                        var e = this.parent && this._ts ? Dt(this.parent._time, this) : this._tTime;
                        return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, this.totalTime($t(-Math.abs(this._delay), this._tDur, e), !0), Ft(this),
                            function (t) {
                                for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                                return t
                            }(this)
                    }, e.paused = function (t) {
                        return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (we(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== P && (this._tTime -= P)))), this) : this._ps
                    }, e.startTime = function (t) {
                        if (arguments.length) {
                            this._start = t;
                            var e = this.parent || this._dp;
                            return e && (e._sort || !this.parent) && Gt(e, this, t - this._delay), this
                        }
                        return this._start
                    }, e.endTime = function (t) {
                        return this._start + (R(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                    }, e.rawTime = function (t) {
                        var e = this.parent || this._dp;
                        return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Dt(e.rawTime(t), this) : this._tTime : this._tTime
                    }, e.revert = function (t) {
                        void 0 === t && (t = it);
                        var e = s;
                        return s = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-.01, t.suppressEvents)), "nested" !== this.data && !1 !== t.kill && this.kill(), s = e, this
                    }, e.globalTime = function (t) {
                        for (var e = this, i = arguments.length ? t : e.rawTime(); e;) i = e._start + i / (e._ts || 1), e = e._dp;
                        return !this.parent && this._sat ? this._sat.vars.immediateRender ? -1 : this._sat.globalTime(t) : i
                    }, e.repeat = function (t) {
                        return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, jt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                    }, e.repeatDelay = function (t) {
                        if (arguments.length) {
                            var e = this._time;
                            return this._rDelay = t, jt(this), e ? this.time(e) : this
                        }
                        return this._rDelay
                    }, e.yoyo = function (t) {
                        return arguments.length ? (this._yoyo = t, this) : this._yoyo
                    }, e.seek = function (t, e) {
                        return this.totalTime(Kt(this, t), R(e))
                    }, e.restart = function (t, e) {
                        return this.play().totalTime(t ? -this._delay : 0, R(e))
                    }, e.play = function (t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, e.reverse = function (t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, e.pause = function (t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, e.resume = function () {
                        return this.paused(!1)
                    }, e.reversed = function (t) {
                        return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                    }, e.invalidate = function () {
                        return this._initted = this._act = 0, this._zTime = -1e-8, this
                    }, e.isActive = function () {
                        var t, e = this.parent || this._dp,
                            i = this._start;
                        return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= i && t < this.endTime(!0) - P))
                    }, e.eventCallback = function (t, e, i) {
                        var n = this.vars;
                        return arguments.length > 1 ? (e ? (n[t] = e, i && (n[t + "Params"] = i), "onUpdate" === t && (this._onUpdate = e)) : delete n[t], this) : n[t]
                    }, e.then = function (t) {
                        var e = this;
                        return new Promise((function (i) {
                            var n = L(t) ? t : Tt,
                                r = function () {
                                    var t = e.then;
                                    e.then = null, L(n) && (n = n(e)) && (n.then || n === e) && (e.then = t), i(n), e.then = t
                                };
                            e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                        }))
                    }, e.kill = function () {
                        pe(this)
                    }, t
                }();
            Pt(Ue.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -1e-8,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var Ge = function (t) {
                function e(e, i) {
                    var r;
                    return void 0 === e && (e = {}), (r = t.call(this, e) || this).labels = {}, r.smoothChildTiming = !!e.smoothChildTiming, r.autoRemoveChildren = !!e.autoRemoveChildren, r._sort = R(e.sortChildren), l && Gt(e.parent || l, n(r), i), e.reversed && r.reverse(), e.paused && r.paused(!0), e.scrollTrigger && Wt(n(r), e.scrollTrigger), r
                }
                r(e, t);
                var i = e.prototype;
                return i.to = function (t, e, i) {
                    return qt(0, arguments, this), this
                }, i.from = function (t, e, i) {
                    return qt(1, arguments, this), this
                }, i.fromTo = function (t, e, i, n) {
                    return qt(2, arguments, this), this
                }, i.set = function (t, e, i) {
                    return e.duration = 0, e.parent = this, Et(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new $e(t, e, Kt(this, i), 1), this
                }, i.call = function (t, e, i) {
                    return Gt(this, $e.delayedCall(0, t, e), i)
                }, i.staggerTo = function (t, e, i, n, r, o, s) {
                    return i.duration = e, i.stagger = i.stagger || n, i.onComplete = o, i.onCompleteParams = s, i.parent = this, new $e(t, i, Kt(this, r)), this
                }, i.staggerFrom = function (t, e, i, n, r, o, s) {
                    return i.runBackwards = 1, Et(i).immediateRender = R(i.immediateRender), this.staggerTo(t, e, i, n, r, o, s)
                }, i.staggerFromTo = function (t, e, i, n, r, o, s, a) {
                    return n.startAt = i, Et(n).immediateRender = R(n.immediateRender), this.staggerTo(t, e, n, r, o, s, a)
                }, i.render = function (t, e, i) {
                    var n, r, o, a, h, u, c, d, p, f, g, m, _ = this._time,
                        y = this._dirty ? this.totalDuration() : this._tDur,
                        S = this._dur,
                        v = t <= 0 ? 0 : mt(t),
                        b = this._zTime < 0 != t < 0 && (this._initted || !S);
                    if (this !== l && v > y && t >= 0 && (v = y), v !== this._tTime || i || b) {
                        if (_ !== this._time && S && (v += this._time - _, t += this._time - _), n = v, p = this._start, u = !(d = this._ts), b && (S || (_ = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                            if (g = this._yoyo, h = S + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * h + t, e, i);
                            if (n = mt(v % h), v === y ? (a = this._repeat, n = S) : ((a = ~~(v / h)) && a === v / h && (n = S, a--), n > S && (n = S)), f = Rt(this._tTime, h), !_ && this._tTime && f !== a && this._tTime - f * h - this._dur <= 0 && (f = a), g && 1 & a && (n = S - n, m = 1), a !== f && !this._lock) {
                                var T = g && 1 & f,
                                    A = T === (g && 1 & a);
                                if (a < f && (T = !T), _ = T ? 0 : S, this._lock = 1, this.render(_ || (m ? 0 : mt(a * h)), e, !S)._lock = 0, this._tTime = v, !e && this.parent && de(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), _ && _ !== this._time || u !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                                if (S = this._dur, y = this._tDur, A && (this._lock = 2, _ = T ? S : -1e-4, this.render(_, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !u) return this;
                                Oe(this, m)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (c = function (t, e, i) {
                            var n;
                            if (i > e)
                                for (n = t._first; n && n._start <= i;) {
                                    if ("isPause" === n.data && n._start > e) return n;
                                    n = n._next
                                } else
                                for (n = t._last; n && n._start >= i;) {
                                    if ("isPause" === n.data && n._start < e) return n;
                                    n = n._prev
                                }
                        }(this, mt(_), mt(n)), c && (v -= n - (n = c._start))), this._tTime = v, this._time = n, this._act = !d, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, _ = 0), !_ && n && !e && !a && (de(this, "onStart"), this._tTime !== v)) return this;
                        if (n >= _ && t >= 0)
                            for (r = this._first; r;) {
                                if (o = r._next, (r._act || n >= r._start) && r._ts && c !== r) {
                                    if (r.parent !== this) return this.render(t, e, i);
                                    if (r.render(r._ts > 0 ? (n - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (n - r._start) * r._ts, e, i), n !== this._time || !this._ts && !u) {
                                        c = 0, o && (v += this._zTime = -1e-8);
                                        break
                                    }
                                }
                                r = o
                            } else {
                            r = this._last;
                            for (var I = t < 0 ? t : n; r;) {
                                if (o = r._prev, (r._act || I <= r._end) && r._ts && c !== r) {
                                    if (r.parent !== this) return this.render(t, e, i);
                                    if (r.render(r._ts > 0 ? (I - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (I - r._start) * r._ts, e, i || s && (r._initted || r._startAt)), n !== this._time || !this._ts && !u) {
                                        c = 0, o && (v += this._zTime = I ? -1e-8 : P);
                                        break
                                    }
                                }
                                r = o
                            }
                        }
                        if (c && !e && (this.pause(), c.render(n >= _ ? 0 : -1e-8)._zTime = n >= _ ? 1 : -1, this._ts)) return this._start = p, Ft(this), this.render(t, e, i);
                        this._onUpdate && !e && de(this, "onUpdate", !0), (v === y && this._tTime >= this.totalDuration() || !v && _) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((t || !S) && (v === y && this._ts > 0 || !v && this._ts < 0) && Bt(this, 1), e || t < 0 && !_ || !v && !_ && y || (de(this, v === y && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(v < y && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }, i.add = function (t, e) {
                    var i = this;
                    if (O(e) || (e = Kt(this, e, t)), !(t instanceof Ue)) {
                        if (U(t)) return t.forEach((function (t) {
                            return i.add(t, e)
                        })), this;
                        if (B(t)) return this.addLabel(t, e);
                        if (!L(t)) return this;
                        t = $e.delayedCall(0, t)
                    }
                    return this !== t ? Gt(this, t, e) : this
                }, i.getChildren = function (t, e, i, n) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = -T);
                    for (var r = [], o = this._first; o;) o._start >= n && (o instanceof $e ? e && r.push(o) : (i && r.push(o), t && r.push.apply(r, o.getChildren(!0, e, i)))), o = o._next;
                    return r
                }, i.getById = function (t) {
                    for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)
                        if (e[i].vars.id === t) return e[i]
                }, i.remove = function (t) {
                    return B(t) ? this.removeLabel(t) : L(t) ? this.killTweensOf(t) : (xt(this, t), t === this._recent && (this._recent = this._last), Lt(this))
                }, i.totalTime = function (e, i) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = mt(Ie.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, i), this._forcing = 0, this) : this._tTime
                }, i.addLabel = function (t, e) {
                    return this.labels[t] = Kt(this, e), this
                }, i.removeLabel = function (t) {
                    return delete this.labels[t], this
                }, i.addPause = function (t, e, i) {
                    var n = $e.delayedCall(0, e || Q, i);
                    return n.data = "isPause", this._hasPause = 1, Gt(this, n, Kt(this, t))
                }, i.removePause = function (t) {
                    var e = this._first;
                    for (t = Kt(this, t); e;) e._start === t && "isPause" === e.data && Bt(e), e = e._next
                }, i.killTweensOf = function (t, e, i) {
                    for (var n = this.getTweensOf(t, i), r = n.length; r--;) We !== n[r] && n[r].kill(t, e);
                    return this
                }, i.getTweensOf = function (t, e) {
                    for (var i, n = [], r = ee(t), o = this._first, s = O(e); o;) o instanceof $e ? yt(o._targets, r) && (s ? (!We || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && n.push(o) : (i = o.getTweensOf(r, e)).length && n.push.apply(n, i), o = o._next;
                    return n
                }, i.tweenTo = function (t, e) {
                    e = e || {};
                    var i, n = this,
                        r = Kt(n, t),
                        o = e,
                        s = o.startAt,
                        a = o.onStart,
                        l = o.onStartParams,
                        h = o.immediateRender,
                        u = $e.to(n, Pt({
                            ease: e.ease || "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: r,
                            overwrite: "auto",
                            duration: e.duration || Math.abs((r - (s && "time" in s ? s.time : n._time)) / n.timeScale()) || P,
                            onStart: function () {
                                if (n.pause(), !i) {
                                    var t = e.duration || Math.abs((r - (s && "time" in s ? s.time : n._time)) / n.timeScale());
                                    u._dur !== t && Yt(u, t, 0, 1).render(u._time, !0, !0), i = 1
                                }
                                a && a.apply(u, l || [])
                            }
                        }, e));
                    return h ? u.render(0) : u
                }, i.tweenFromTo = function (t, e, i) {
                    return this.tweenTo(e, Pt({
                        startAt: {
                            time: Kt(this, t)
                        }
                    }, i))
                }, i.recent = function () {
                    return this._recent
                }, i.nextLabel = function (t) {
                    return void 0 === t && (t = this._time), ce(this, Kt(this, t))
                }, i.previousLabel = function (t) {
                    return void 0 === t && (t = this._time), ce(this, Kt(this, t), 1)
                }, i.currentLabel = function (t) {
                    return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + P)
                }, i.shiftChildren = function (t, e, i) {
                    void 0 === i && (i = 0);
                    for (var n, r = this._first, o = this.labels; r;) r._start >= i && (r._start += t, r._end += t), r = r._next;
                    if (e)
                        for (n in o) o[n] >= i && (o[n] += t);
                    return Lt(this)
                }, i.invalidate = function (e) {
                    var i = this._first;
                    for (this._lock = 0; i;) i.invalidate(e), i = i._next;
                    return t.prototype.invalidate.call(this, e)
                }, i.clear = function (t) {
                    void 0 === t && (t = !0);
                    for (var e, i = this._first; i;) e = i._next, this.remove(i), i = e;
                    return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Lt(this)
                }, i.totalDuration = function (t) {
                    var e, i, n, r = 0,
                        o = this,
                        s = o._last,
                        a = T;
                    if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
                    if (o._dirty) {
                        for (n = o.parent; s;) e = s._prev, s._dirty && s.totalDuration(), (i = s._start) > a && o._sort && s._ts && !o._lock ? (o._lock = 1, Gt(o, s, i - s._delay, 1)._lock = 0) : a = i, i < 0 && s._ts && (r -= i, (!n && !o._dp || n && n.smoothChildTiming) && (o._start += i / o._ts, o._time -= i, o._tTime -= i), o.shiftChildren(-i, !1, -Infinity), a = 0), s._end > r && s._ts && (r = s._end), s = e;
                        Yt(o, o === l && o._time > r ? o._time : r, 1, 1), o._dirty = 0
                    }
                    return o._tDur
                }, e.updateRoot = function (t) {
                    if (l._ts && (vt(l, Dt(t, l)), p = Ie.frame), Ie.frame >= lt) {
                        lt += v.autoSleep || 120;
                        var e = l._first;
                        if ((!e || !e._ts) && v.autoSleep && Ie._listeners.length < 2) {
                            for (; e && !e._ts;) e = e._next;
                            e || Ie.sleep()
                        }
                    }
                }, e
            }(Ue);
            Pt(Ge.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var We, Ve, Xe = function (t, e, i, n, r, o, s) {
                var a, l, h, u, c, d, p, f, g = new ci(this._pt, t, e, 0, 1, oi, null, r),
                    m = 0,
                    _ = 0;
                for (g.b = i, g.e = n, i += "", (p = ~(n += "").indexOf("random(")) && (n = he(n)), o && (o(f = [i, n], t, e), i = f[0], n = f[1]), l = i.match(X) || []; a = X.exec(n);) u = a[0], c = n.substring(m, a.index), h ? h = (h + 1) % 5 : "rgba(" === c.substr(-5) && (h = 1), u !== l[_++] && (d = parseFloat(l[_ - 1]) || 0, g._pt = {
                    _next: g._pt,
                    p: c || 1 === _ ? c : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? _t(d, u) - d : parseFloat(u) - d,
                    m: h && h < 4 ? Math.round : 0
                }, m = X.lastIndex);
                return g.c = m < n.length ? n.substring(m, n.length) : "", g.fp = s, (H.test(n) || p) && (g.e = 0), this._pt = g, g
            },
                He = function (t, e, i, n, r, o, s, a, l, h) {
                    L(n) && (n = n(r || 0, t, o));
                    var u, c = t[e],
                        d = "get" !== i ? i : L(c) ? l ? t[e.indexOf("set") || !L(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : c,
                        p = L(c) ? l ? ti : Qe : Je;
                    if (B(n) && (~n.indexOf("random(") && (n = he(n)), "=" === n.charAt(1) && ((u = _t(d, n) + (Jt(d) || 0)) || 0 === u) && (n = u)), !h || d !== n || Ve) return isNaN(d * n) || "" === n ? (!c && !(e in t) && Z(e, n), Xe.call(this, t, e, d, n, p, a || v.stringFilter, l)) : (u = new ci(this._pt, t, e, +d || 0, n - (d || 0), "boolean" == typeof c ? ri : ni, 0, p), l && (u.fp = l), s && u.modifier(s, this, t), this._pt = u)
                },
                Ye = function (t, e, i, n, r, o) {
                    var s, a, l, h;
                    if (st[t] && !1 !== (s = new st[t]).init(r, s.rawVars ? e[t] : function (t, e, i, n, r) {
                        if (L(t) && (t = Ke(t, r, e, i, n)), !M(t) || t.style && t.nodeType || U(t) || k(t)) return B(t) ? Ke(t, r, e, i, n) : t;
                        var o, s = {};
                        for (o in t) s[o] = Ke(t[o], r, e, i, n);
                        return s
                    }(e[t], n, r, o, i), i, n, o) && (i._pt = a = new ci(i._pt, r, t, 0, 1, s.render, s, 0, s.priority), i !== f))
                        for (l = i._ptLookup[i._targets.indexOf(r)], h = s._props.length; h--;) l[s._props[h]] = a;
                    return s
                },
                je = function t(e, i, n) {
                    var r, a, h, u, c, d, p, f, g, m, _, y, S, v = e.vars,
                        A = v.ease,
                        I = v.startAt,
                        w = v.immediateRender,
                        E = v.lazy,
                        C = v.onUpdate,
                        x = v.onUpdateParams,
                        B = v.callbackScope,
                        L = v.runBackwards,
                        O = v.yoyoEase,
                        N = v.keyframes,
                        M = v.autoRevert,
                        D = e._dur,
                        F = e._startAt,
                        k = e._targets,
                        U = e.parent,
                        G = U && "nested" === U.data ? U.vars.targets : k,
                        W = "auto" === e._overwrite && !o,
                        V = e.timeline;
                    if (V && (!N || !A) && (A = "none"), e._ease = Ne(A, b.ease), e._yEase = O ? Le(Ne(!0 === O ? A : O, b.ease)) : 0, O && e._yoyo && !e._repeat && (O = e._yEase, e._yEase = e._ease, e._ease = O), e._from = !V && !!v.runBackwards, !V || N && !v.stagger) {
                        if (y = (f = k[0] ? dt(k[0]).harness : 0) && v[f.prop], r = wt(v, nt), F && (F._zTime < 0 && F.progress(1), i < 0 && L && w && !M ? F.render(-1, !0) : F.revert(L && D ? et : tt), F._lazy = 0), I) {
                            if (Bt(e._startAt = $e.set(k, Pt({
                                data: "isStart",
                                overwrite: !1,
                                parent: U,
                                immediateRender: !0,
                                lazy: !F && R(E),
                                startAt: null,
                                delay: 0,
                                onUpdate: C,
                                onUpdateParams: x,
                                callbackScope: B,
                                stagger: 0
                            }, I))), e._startAt._dp = 0, e._startAt._sat = e, i < 0 && (s || !w && !M) && e._startAt.revert(et), w && D && i <= 0 && n <= 0) return void (i && (e._zTime = i))
                        } else if (L && D && !F)
                            if (i && (w = !1), h = Pt({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: w && !F && R(E),
                                immediateRender: w,
                                stagger: 0,
                                parent: U
                            }, r), y && (h[f.prop] = y), Bt(e._startAt = $e.set(k, h)), e._startAt._dp = 0, e._startAt._sat = e, i < 0 && (s ? e._startAt.revert(et) : e._startAt.render(-1, !0)), e._zTime = i, w) {
                                if (!i) return
                            } else t(e._startAt, P, P);
                        for (e._pt = e._ptCache = 0, E = D && R(E) || E && !D, a = 0; a < k.length; a++) {
                            if (p = (c = k[a])._gsap || ct(k)[a]._gsap, e._ptLookup[a] = m = {}, ot[p.id] && rt.length && St(), _ = G === k ? a : G.indexOf(c), f && !1 !== (g = new f).init(c, y || r, e, _, G) && (e._pt = u = new ci(e._pt, c, g.name, 0, 1, g.render, g, 0, g.priority), g._props.forEach((function (t) {
                                m[t] = u
                            })), g.priority && (d = 1)), !f || y)
                                for (h in r) st[h] && (g = Ye(h, r, e, _, c, G)) ? g.priority && (d = 1) : m[h] = u = He.call(e, c, h, "get", r[h], _, G, 0, v.stringFilter);
                            e._op && e._op[a] && e.kill(c, e._op[a]), W && e._pt && (We = e, l.killTweensOf(c, m, e.globalTime(i)), S = !e.parent, We = 0), e._pt && E && (ot[p.id] = 1)
                        }
                        d && ui(e), e._onInit && e._onInit(e)
                    }
                    e._onUpdate = C, e._initted = (!e._op || e._pt) && !S, N && i <= 0 && V.render(T, !0, !0)
                },
                ze = function (t, e, i, n) {
                    var r, o, s = e.ease || n || "power1.inOut";
                    if (U(e)) o = i[t] || (i[t] = []), e.forEach((function (t, i) {
                        return o.push({
                            t: i / (e.length - 1) * 100,
                            v: t,
                            e: s
                        })
                    }));
                    else
                        for (r in e) o = i[r] || (i[r] = []), "ease" === r || o.push({
                            t: parseFloat(t),
                            v: e[r],
                            e: s
                        })
                },
                Ke = function (t, e, i, n, r) {
                    return L(t) ? t.call(e, i, n, r) : B(t) && ~t.indexOf("random(") ? he(t) : t
                },
                qe = ut + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                Ze = {};
            ft(qe + ",id,stagger,delay,duration,paused,scrollTrigger", (function (t) {
                return Ze[t] = 1
            }));
            var $e = function (t) {
                function e(e, i, r, s) {
                    var a;
                    "number" == typeof i && (r.duration = i, i = r, r = null);
                    var h, u, c, d, p, f, g, m, _ = (a = t.call(this, s ? i : Et(i)) || this).vars,
                        y = _.duration,
                        S = _.delay,
                        b = _.immediateRender,
                        T = _.stagger,
                        P = _.overwrite,
                        A = _.keyframes,
                        I = _.defaults,
                        w = _.scrollTrigger,
                        E = _.yoyoEase,
                        C = i.parent || l,
                        x = (U(e) || k(e) ? O(e[0]) : "length" in i) ? [e] : ee(e);
                    if (a._targets = x.length ? ct(x) : $("GSAP target " + e + " not found. https://greensock.com", !v.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = P, A || T || F(y) || F(S)) {
                        if (i = a.vars, (h = a.timeline = new Ge({
                            data: "nested",
                            defaults: I || {},
                            targets: C && "nested" === C.data ? C.vars.targets : x
                        })).kill(), h.parent = h._dp = n(a), h._start = 0, T || F(y) || F(S)) {
                            if (d = x.length, g = T && re(T), M(T))
                                for (p in T) ~qe.indexOf(p) && (m || (m = {}), m[p] = T[p]);
                            for (u = 0; u < d; u++)(c = wt(i, Ze)).stagger = 0, E && (c.yoyoEase = E), m && At(c, m), f = x[u], c.duration = +Ke(y, n(a), u, f, x), c.delay = (+Ke(S, n(a), u, f, x) || 0) - a._delay, !T && 1 === d && c.delay && (a._delay = S = c.delay, a._start += S, c.delay = 0), h.to(f, c, g ? g(u, f, x) : 0), h._ease = Ee.none;
                            h.duration() ? y = S = 0 : a.timeline = 0
                        } else if (A) {
                            Et(Pt(h.vars.defaults, {
                                ease: "none"
                            })), h._ease = Ne(A.ease || i.ease || "none");
                            var B, L, N, D = 0;
                            if (U(A)) A.forEach((function (t) {
                                return h.to(x, t, ">")
                            })), h.duration();
                            else {
                                for (p in c = {}, A) "ease" === p || "easeEach" === p || ze(p, A[p], c, A.easeEach);
                                for (p in c)
                                    for (B = c[p].sort((function (t, e) {
                                        return t.t - e.t
                                    })), D = 0, u = 0; u < B.length; u++)(N = {
                                        ease: (L = B[u]).e,
                                        duration: (L.t - (u ? B[u - 1].t : 0)) / 100 * y
                                    })[p] = L.v, h.to(x, N, D), D += N.duration;
                                h.duration() < y && h.to({}, {
                                    duration: y - h.duration()
                                })
                            }
                        }
                        y || a.duration(y = h.duration())
                    } else a.timeline = 0;
                    return !0 !== P || o || (We = n(a), l.killTweensOf(x), We = 0), Gt(C, n(a), r), i.reversed && a.reverse(), i.paused && a.paused(!0), (b || !y && !A && a._start === mt(C._time) && R(b) && Nt(n(a)) && "nested" !== C.data) && (a._tTime = -1e-8, a.render(Math.max(0, -S) || 0)), w && Wt(n(a), w), a
                }
                r(e, t);
                var i = e.prototype;
                return i.render = function (t, e, i) {
                    var n, r, o, a, l, h, u, c, d, p = this._time,
                        f = this._tDur,
                        g = this._dur,
                        m = t < 0,
                        _ = t > f - P && !m ? f : t < P ? 0 : t;
                    if (g) {
                        if (_ !== this._tTime || !t || i || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m) {
                            if (n = _, c = this.timeline, this._repeat) {
                                if (a = g + this._rDelay, this._repeat < -1 && m) return this.totalTime(100 * a + t, e, i);
                                if (n = mt(_ % a), _ === f ? (o = this._repeat, n = g) : ((o = ~~(_ / a)) && o === _ / a && (n = g, o--), n > g && (n = g)), (h = this._yoyo && 1 & o) && (d = this._yEase, n = g - n), l = Rt(this._tTime, a), n === p && !i && this._initted) return this._tTime = _, this;
                                o !== l && (c && this._yEase && Oe(c, h), !this.vars.repeatRefresh || h || this._lock || (this._lock = i = 1, this.render(mt(a * o), !0).invalidate()._lock = 0))
                            }
                            if (!this._initted) {
                                if (Vt(this, m ? t : n, i, e, _)) return this._tTime = 0, this;
                                if (p !== this._time) return this;
                                if (g !== this._dur) return this.render(t, e, i)
                            }
                            if (this._tTime = _, this._time = n, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = u = (d || this._ease)(n / g), this._from && (this.ratio = u = 1 - u), n && !p && !e && !o && (de(this, "onStart"), this._tTime !== _)) return this;
                            for (r = this._pt; r;) r.r(u, r.d), r = r._next;
                            c && c.render(t < 0 ? t : !n && h ? -1e-8 : c._dur * c._ease(n / this._dur), e, i) || this._startAt && (this._zTime = t), this._onUpdate && !e && (m && Ot(this, t, 0, i), de(this, "onUpdate")), this._repeat && o !== l && this.vars.onRepeat && !e && this.parent && de(this, "onRepeat"), _ !== this._tDur && _ || this._tTime !== _ || (m && !this._onUpdate && Ot(this, t, 0, !0), (t || !g) && (_ === this._tDur && this._ts > 0 || !_ && this._ts < 0) && Bt(this, 1), e || m && !p || !(_ || p || h) || (de(this, _ === f ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < f && this.timeScale() > 0) && this._prom()))
                        }
                    } else ! function (t, e, i, n) {
                        var r, o, a, l = t.ratio,
                            h = e < 0 || !e && (!t._start && Xt(t) && (t._initted || !Ht(t)) || (t._ts < 0 || t._dp._ts < 0) && !Ht(t)) ? 0 : 1,
                            u = t._rDelay,
                            c = 0;
                        if (u && t._repeat && (c = $t(0, t._tDur, e), o = Rt(c, u), t._yoyo && 1 & o && (h = 1 - h), o !== Rt(t._tTime, u) && (l = 1 - h, t.vars.repeatRefresh && t._initted && t.invalidate())), h !== l || s || n || t._zTime === P || !e && t._zTime) {
                            if (!t._initted && Vt(t, e, n, i, c)) return;
                            for (a = t._zTime, t._zTime = e || (i ? P : 0), i || (i = e && !a), t.ratio = h, t._from && (h = 1 - h), t._time = 0, t._tTime = c, r = t._pt; r;) r.r(h, r.d), r = r._next;
                            e < 0 && Ot(t, e, 0, !0), t._onUpdate && !i && de(t, "onUpdate"), c && t._repeat && !i && t.parent && de(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === h && (h && Bt(t, 1), i || s || (de(t, h ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                        } else t._zTime || (t._zTime = e)
                    }(this, t, e, i);
                    return this
                }, i.targets = function () {
                    return this._targets
                }, i.invalidate = function (e) {
                    return (!e || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(e), t.prototype.invalidate.call(this, e)
                }, i.resetTo = function (t, e, i, n) {
                    g || Ie.wake(), this._ts || this.play();
                    var r = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                    return this._initted || je(this, r),
                        function (t, e, i, n, r, o, s) {
                            var a, l, h, u, c = (t._pt && t._ptCache || (t._ptCache = {}))[e];
                            if (!c)
                                for (c = t._ptCache[e] = [], h = t._ptLookup, u = t._targets.length; u--;) {
                                    if ((a = h[u][e]) && a.d && a.d._pt)
                                        for (a = a.d._pt; a && a.p !== e && a.fp !== e;) a = a._next;
                                    if (!a) return Ve = 1, t.vars[e] = "+=0", je(t, s), Ve = 0, 1;
                                    c.push(a)
                                }
                            for (u = c.length; u--;)(a = (l = c[u])._pt || l).s = !n && 0 !== n || r ? a.s + (n || 0) + o * a.c : n, a.c = i - a.s, l.e && (l.e = gt(i) + Jt(l.e)), l.b && (l.b = a.s + Jt(l.b))
                        }(this, t, e, i, n, this._ease(r / this._dur), r) ? this.resetTo(t, e, i, n) : (kt(this, 0), this.parent || Ct(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
                }, i.kill = function (t, e) {
                    if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? pe(this) : this;
                    if (this.timeline) {
                        var i = this.timeline.totalDuration();
                        return this.timeline.killTweensOf(t, e, We && !0 !== We.vars.overwrite)._first || pe(this), this.parent && i !== this.timeline.totalDuration() && Yt(this, this._dur * this.timeline._tDur / i, 0, 1), this
                    }
                    var n, r, o, s, a, l, h, u = this._targets,
                        c = t ? ee(t) : u,
                        d = this._ptLookup,
                        p = this._pt;
                    if ((!e || "all" === e) && function (t, e) {
                        for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];);
                        return i < 0
                    }(u, c)) return "all" === e && (this._pt = 0), pe(this);
                    for (n = this._op = this._op || [], "all" !== e && (B(e) && (a = {}, ft(e, (function (t) {
                        return a[t] = 1
                    })), e = a), e = function (t, e) {
                        var i, n, r, o, s = t[0] ? dt(t[0]).harness : 0,
                            a = s && s.aliases;
                        if (!a) return e;
                        for (n in i = At({}, e), a)
                            if (n in i)
                                for (r = (o = a[n].split(",")).length; r--;) i[o[r]] = i[n];
                        return i
                    }(u, e)), h = u.length; h--;)
                        if (~c.indexOf(u[h]))
                            for (a in r = d[h], "all" === e ? (n[h] = e, s = r, o = {}) : (o = n[h] = n[h] || {}, s = e), s) (l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || xt(this, l, "_pt"), delete r[a]), "all" !== o && (o[a] = 1);
                    return this._initted && !this._pt && p && pe(this), this
                }, e.to = function (t, i) {
                    return new e(t, i, arguments[2])
                }, e.from = function (t, e) {
                    return qt(1, arguments)
                }, e.delayedCall = function (t, i, n, r) {
                    return new e(i, 0, {
                        immediateRender: !1,
                        lazy: !1,
                        overwrite: !1,
                        delay: t,
                        onComplete: i,
                        onReverseComplete: i,
                        onCompleteParams: n,
                        onReverseCompleteParams: n,
                        callbackScope: r
                    })
                }, e.fromTo = function (t, e, i) {
                    return qt(2, arguments)
                }, e.set = function (t, i) {
                    return i.duration = 0, i.repeatDelay || (i.repeat = 0), new e(t, i)
                }, e.killTweensOf = function (t, e, i) {
                    return l.killTweensOf(t, e, i)
                }, e
            }(Ue);
            Pt($e.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), ft("staggerTo,staggerFrom,staggerFromTo", (function (t) {
                $e[t] = function () {
                    var e = new Ge,
                        i = Qt.call(arguments, 0);
                    return i.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, i)
                }
            }));
            var Je = function (t, e, i) {
                return t[e] = i
            },
                Qe = function (t, e, i) {
                    return t[e](i)
                },
                ti = function (t, e, i, n) {
                    return t[e](n.fp, i)
                },
                ei = function (t, e, i) {
                    return t.setAttribute(e, i)
                },
                ii = function (t, e) {
                    return L(t[e]) ? Qe : N(t[e]) && t.setAttribute ? ei : Je
                },
                ni = function (t, e) {
                    return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e)
                },
                ri = function (t, e) {
                    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
                },
                oi = function (t, e) {
                    var i = e._pt,
                        n = "";
                    if (!t && e.b) n = e.b;
                    else if (1 === t && e.e) n = e.e;
                    else {
                        for (; i;) n = i.p + (i.m ? i.m(i.s + i.c * t) : Math.round(1e4 * (i.s + i.c * t)) / 1e4) + n, i = i._next;
                        n += e.c
                    }
                    e.set(e.t, e.p, n, e)
                },
                si = function (t, e) {
                    for (var i = e._pt; i;) i.r(t, i.d), i = i._next
                },
                ai = function (t, e, i, n) {
                    for (var r, o = this._pt; o;) r = o._next, o.p === n && o.modifier(t, e, i), o = r
                },
                li = function (t) {
                    for (var e, i, n = this._pt; n;) i = n._next, n.p === t && !n.op || n.op === t ? xt(this, n, "_pt") : n.dep || (e = 1), n = i;
                    return !e
                },
                hi = function (t, e, i, n) {
                    n.mSet(t, e, n.m.call(n.tween, i, n.mt), n)
                },
                ui = function (t) {
                    for (var e, i, n, r, o = t._pt; o;) {
                        for (e = o._next, i = n; i && i.pr > o.pr;) i = i._next;
                        (o._prev = i ? i._prev : r) ? o._prev._next = o : n = o, (o._next = i) ? i._prev = o : r = o, o = e
                    }
                    t._pt = n
                },
                ci = function () {
                    function t(t, e, i, n, r, o, s, a, l) {
                        this.t = e, this.s = n, this.c = r, this.p = i, this.r = o || ni, this.d = s || this, this.set = a || Je, this.pr = l || 0, this._next = t, t && (t._prev = this)
                    }
                    return t.prototype.modifier = function (t, e, i) {
                        this.mSet = this.mSet || this.set, this.set = hi, this.m = t, this.mt = i, this.tween = e
                    }, t
                }();
            ft(ut + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function (t) {
                return nt[t] = 1
            })), z.TweenMax = z.TweenLite = $e, z.TimelineLite = z.TimelineMax = Ge, l = new Ge({
                sortChildren: !1,
                defaults: b,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), v.stringFilter = Ae;
            var di = [],
                pi = {},
                fi = [],
                gi = 0,
                mi = 0,
                _i = function (t) {
                    return (pi[t] || fi).map((function (t) {
                        return t()
                    }))
                },
                yi = function () {
                    var t = Date.now(),
                        e = [];
                    t - gi > 2 && (_i("matchMediaInit"), di.forEach((function (t) {
                        var i, n, r, o, s = t.queries,
                            a = t.conditions;
                        for (n in s) (i = h.matchMedia(s[n]).matches) && (r = 1), i !== a[n] && (a[n] = i, o = 1);
                        o && (t.revert(), r && e.push(t))
                    })), _i("matchMediaRevert"), e.forEach((function (t) {
                        return t.onMatch(t)
                    })), gi = t, _i("matchMedia"))
                },
                Si = function () {
                    function t(t, e) {
                        this.selector = e && ie(e), this.data = [], this._r = [], this.isReverted = !1, this.id = mi++, t && this.add(t)
                    }
                    var e = t.prototype;
                    return e.add = function (t, e, i) {
                        L(t) && (i = e, e = t, t = L);
                        var n = this,
                            r = function () {
                                var t, r = a,
                                    o = n.selector;
                                return r && r !== n && r.data.push(n), i && (n.selector = ie(i)), a = n, t = e.apply(n, arguments), L(t) && n._r.push(t), a = r, n.selector = o, n.isReverted = !1, t
                            };
                        return n.last = r, t === L ? r(n) : t ? n[t] = r : r
                    }, e.ignore = function (t) {
                        var e = a;
                        a = null, t(this), a = e
                    }, e.getTweens = function () {
                        var e = [];
                        return this.data.forEach((function (i) {
                            return i instanceof t ? e.push.apply(e, i.getTweens()) : i instanceof $e && !(i.parent && "nested" === i.parent.data) && e.push(i)
                        })), e
                    }, e.clear = function () {
                        this._r.length = this.data.length = 0
                    }, e.kill = function (t, e) {
                        var i = this;
                        if (t) {
                            var n = this.getTweens();
                            this.data.forEach((function (t) {
                                "isFlip" === t.data && (t.revert(), t.getChildren(!0, !0, !1).forEach((function (t) {
                                    return n.splice(n.indexOf(t), 1)
                                })))
                            })), n.map((function (t) {
                                return {
                                    g: t.globalTime(0),
                                    t
                                }
                            })).sort((function (t, e) {
                                return e.g - t.g || -1
                            })).forEach((function (e) {
                                return e.t.revert(t)
                            })), this.data.forEach((function (e) {
                                return e instanceof Ge ? "nested" !== e.data && e.kill() : !(e instanceof $e) && e.revert && e.revert(t)
                            })), this._r.forEach((function (e) {
                                return e(t, i)
                            })), this.isReverted = !0
                        } else this.data.forEach((function (t) {
                            return t.kill && t.kill()
                        }));
                        if (this.clear(), e)
                            for (var r = di.length; r--;) di[r].id === this.id && di.splice(r, 1)
                    }, e.revert = function (t) {
                        this.kill(t || {})
                    }, t
                }(),
                vi = function () {
                    function t(t) {
                        this.contexts = [], this.scope = t
                    }
                    var e = t.prototype;
                    return e.add = function (t, e, i) {
                        M(t) || (t = {
                            matches: t
                        });
                        var n, r, o, s = new Si(0, i || this.scope),
                            l = s.conditions = {};
                        for (r in a && !s.selector && (s.selector = a.selector), this.contexts.push(s), e = s.add("onMatch", e), s.queries = t, t) "all" === r ? o = 1 : (n = h.matchMedia(t[r])) && (di.indexOf(s) < 0 && di.push(s), (l[r] = n.matches) && (o = 1), n.addListener ? n.addListener(yi) : n.addEventListener("change", yi));
                        return o && e(s), this
                    }, e.revert = function (t) {
                        this.kill(t || {})
                    }, e.kill = function (t) {
                        this.contexts.forEach((function (e) {
                            return e.kill(t, !0)
                        }))
                    }, t
                }(),
                bi = {
                    registerPlugin: function () {
                        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                        e.forEach((function (t) {
                            return ge(t)
                        }))
                    },
                    timeline: function (t) {
                        return new Ge(t)
                    },
                    getTweensOf: function (t, e) {
                        return l.getTweensOf(t, e)
                    },
                    getProperty: function (t, e, i, n) {
                        B(t) && (t = ee(t)[0]);
                        var r = dt(t || {}).get,
                            o = i ? Tt : bt;
                        return "native" === i && (i = ""), t ? e ? o((st[e] && st[e].get || r)(t, e, i, n)) : function (e, i, n) {
                            return o((st[e] && st[e].get || r)(t, e, i, n))
                        } : t
                    },
                    quickSetter: function (t, e, i) {
                        if ((t = ee(t)).length > 1) {
                            var n = t.map((function (t) {
                                return Ai.quickSetter(t, e, i)
                            })),
                                r = n.length;
                            return function (t) {
                                for (var e = r; e--;) n[e](t)
                            }
                        }
                        t = t[0] || {};
                        var o = st[e],
                            s = dt(t),
                            a = s.harness && (s.harness.aliases || {})[e] || e,
                            l = o ? function (e) {
                                var n = new o;
                                f._pt = 0, n.init(t, i ? e + i : e, f, 0, [t]), n.render(1, n), f._pt && si(1, f)
                            } : s.set(t, a);
                        return o ? l : function (e) {
                            return l(t, a, i ? e + i : e, s, 1)
                        }
                    },
                    quickTo: function (t, e, i) {
                        var n, r = Ai.to(t, At(((n = {})[e] = "+=0.1", n.paused = !0, n), i || {})),
                            o = function (t, i, n) {
                                return r.resetTo(e, t, i, n)
                            };
                        return o.tween = r, o
                    },
                    isTweening: function (t) {
                        return l.getTweensOf(t, !0).length > 0
                    },
                    defaults: function (t) {
                        return t && t.ease && (t.ease = Ne(t.ease, b.ease)), It(b, t || {})
                    },
                    config: function (t) {
                        return It(v, t || {})
                    },
                    registerEffect: function (t) {
                        var e = t.name,
                            i = t.effect,
                            n = t.plugins,
                            r = t.defaults,
                            o = t.extendTimeline;
                        (n || "").split(",").forEach((function (t) {
                            return t && !st[t] && !z[t] && $(e + " effect requires " + t + " plugin.")
                        })), at[e] = function (t, e, n) {
                            return i(ee(t), Pt(e || {}, r), n)
                        }, o && (Ge.prototype[e] = function (t, i, n) {
                            return this.add(at[e](t, M(i) ? i : (n = i) && {}, this), n)
                        })
                    },
                    registerEase: function (t, e) {
                        Ee[t] = Ne(e)
                    },
                    parseEase: function (t, e) {
                        return arguments.length ? Ne(t, e) : Ee
                    },
                    getById: function (t) {
                        return l.getById(t)
                    },
                    exportRoot: function (t, e) {
                        void 0 === t && (t = {});
                        var i, n, r = new Ge(t);
                        for (r.smoothChildTiming = R(t.smoothChildTiming), l.remove(r), r._dp = 0, r._time = r._tTime = l._time, i = l._first; i;) n = i._next, !e && !i._dur && i instanceof $e && i.vars.onComplete === i._targets[0] || Gt(r, i, i._start - i._delay), i = n;
                        return Gt(l, r, 0), r
                    },
                    context: function (t, e) {
                        return t ? new Si(t, e) : a
                    },
                    matchMedia: function (t) {
                        return new vi(t)
                    },
                    matchMediaRefresh: function () {
                        return di.forEach((function (t) {
                            var e, i, n = t.conditions;
                            for (i in n) n[i] && (n[i] = !1, e = 1);
                            e && t.revert()
                        })) || yi()
                    },
                    addEventListener: function (t, e) {
                        var i = pi[t] || (pi[t] = []);
                        ~i.indexOf(e) || i.push(e)
                    },
                    removeEventListener: function (t, e) {
                        var i = pi[t],
                            n = i && i.indexOf(e);
                        n >= 0 && i.splice(n, 1)
                    },
                    utils: {
                        wrap: function t(e, i, n) {
                            var r = i - e;
                            return U(e) ? le(e, t(0, e.length), i) : Zt(n, (function (t) {
                                return (r + (t - e) % r) % r + e
                            }))
                        },
                        wrapYoyo: function t(e, i, n) {
                            var r = i - e,
                                o = 2 * r;
                            return U(e) ? le(e, t(0, e.length - 1), i) : Zt(n, (function (t) {
                                return e + ((t = (o + (t - e) % o) % o || 0) > r ? o - t : t)
                            }))
                        },
                        distribute: re,
                        random: ae,
                        snap: se,
                        normalize: function (t, e, i) {
                            return ue(t, e, 0, 1, i)
                        },
                        getUnit: Jt,
                        clamp: function (t, e, i) {
                            return Zt(i, (function (i) {
                                return $t(t, e, i)
                            }))
                        },
                        splitColor: Se,
                        toArray: ee,
                        selector: ie,
                        mapRange: ue,
                        pipe: function () {
                            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                            return function (t) {
                                return e.reduce((function (t, e) {
                                    return e(t)
                                }), t)
                            }
                        },
                        unitize: function (t, e) {
                            return function (i) {
                                return t(parseFloat(i)) + (e || Jt(i))
                            }
                        },
                        interpolate: function t(e, i, n, r) {
                            var o = isNaN(e + i) ? 0 : function (t) {
                                return (1 - t) * e + t * i
                            };
                            if (!o) {
                                var s, a, l, h, u, c = B(e),
                                    d = {};
                                if (!0 === n && (r = 1) && (n = null), c) e = {
                                    p: e
                                }, i = {
                                    p: i
                                };
                                else if (U(e) && !U(i)) {
                                    for (l = [], h = e.length, u = h - 2, a = 1; a < h; a++) l.push(t(e[a - 1], e[a]));
                                    h--, o = function (t) {
                                        t *= h;
                                        var e = Math.min(u, ~~t);
                                        return l[e](t - e)
                                    }, n = i
                                } else r || (e = At(U(e) ? [] : {}, e));
                                if (!l) {
                                    for (s in i) He.call(d, e, s, "get", i[s]);
                                    o = function (t) {
                                        return si(t, d) || (c ? e.p : e)
                                    }
                                }
                            }
                            return Zt(n, o)
                        },
                        shuffle: ne
                    },
                    install: q,
                    effects: at,
                    ticker: Ie,
                    updateRoot: Ge.updateRoot,
                    plugins: st,
                    globalTimeline: l,
                    core: {
                        PropTween: ci,
                        globals: J,
                        Tween: $e,
                        Timeline: Ge,
                        Animation: Ue,
                        getCache: dt,
                        _removeLinkedListItem: xt,
                        reverting: function () {
                            return s
                        },
                        context: function (t) {
                            return t && a && (a.data.push(t), t._ctx = a), a
                        },
                        suppressOverwrites: function (t) {
                            return o = t
                        }
                    }
                };
            ft("to,from,fromTo,delayedCall,set,killTweensOf", (function (t) {
                return bi[t] = $e[t]
            })), Ie.add(Ge.updateRoot), f = bi.to({}, {
                duration: 0
            });
            var Ti = function (t, e) {
                for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e;) i = i._next;
                return i
            },
                Pi = function (t, e) {
                    return {
                        name: t,
                        rawVars: 1,
                        init: function (t, i, n) {
                            n._onInit = function (t) {
                                var n, r;
                                if (B(i) && (n = {}, ft(i, (function (t) {
                                    return n[t] = 1
                                })), i = n), e) {
                                    for (r in n = {}, i) n[r] = e(i[r]);
                                    i = n
                                } ! function (t, e) {
                                    var i, n, r, o = t._targets;
                                    for (i in e)
                                        for (n = o.length; n--;)(r = t._ptLookup[n][i]) && (r = r.d) && (r._pt && (r = Ti(r, i)), r && r.modifier && r.modifier(e[i], t, o[n], i))
                                }(t, i)
                            }
                        }
                    }
                },
                Ai = bi.registerPlugin({
                    name: "attr",
                    init: function (t, e, i, n, r) {
                        var o, s, a;
                        for (o in this.tween = i, e) a = t.getAttribute(o) || "", (s = this.add(t, "setAttribute", (a || 0) + "", e[o], n, r, 0, 0, o)).op = o, s.b = a, this._props.push(o)
                    },
                    render: function (t, e) {
                        for (var i = e._pt; i;) s ? i.set(i.t, i.p, i.b, i) : i.r(t, i.d), i = i._next
                    }
                }, {
                    name: "endArray",
                    init: function (t, e) {
                        for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i], 0, 0, 0, 0, 0, 1)
                    }
                }, Pi("roundProps", oe), Pi("modifiers"), Pi("snap", se)) || bi;
            $e.version = Ge.version = Ai.version = "3.12.1", d = 1, D() && we();
            var Ii, wi, Ei, Ci, xi, Bi, Li, Oi, Ni = Ee.Power0,
                Mi = Ee.Power1,
                Ri = Ee.Power2,
                Di = Ee.Power3,
                Fi = Ee.Power4,
                ki = Ee.Linear,
                Ui = Ee.Quad,
                Gi = Ee.Cubic,
                Wi = Ee.Quart,
                Vi = Ee.Quint,
                Xi = Ee.Strong,
                Hi = Ee.Elastic,
                Yi = Ee.Back,
                ji = Ee.SteppedEase,
                zi = Ee.Bounce,
                Ki = Ee.Sine,
                qi = Ee.Expo,
                Zi = Ee.Circ,
                $i = {},
                Ji = 180 / Math.PI,
                Qi = Math.PI / 180,
                tn = Math.atan2,
                en = /([A-Z])/g,
                nn = /(left|right|width|margin|padding|x)/i,
                rn = /[\s,\(]\S/,
                on = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                sn = function (t, e) {
                    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
                },
                an = function (t, e) {
                    return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
                },
                ln = function (t, e) {
                    return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
                },
                hn = function (t, e) {
                    var i = e.s + e.c * t;
                    e.set(e.t, e.p, ~~(i + (i < 0 ? -.5 : .5)) + e.u, e)
                },
                un = function (t, e) {
                    return e.set(e.t, e.p, t ? e.e : e.b, e)
                },
                cn = function (t, e) {
                    return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
                },
                dn = function (t, e, i) {
                    return t.style[e] = i
                },
                pn = function (t, e, i) {
                    return t.style.setProperty(e, i)
                },
                fn = function (t, e, i) {
                    return t._gsap[e] = i
                },
                gn = function (t, e, i) {
                    return t._gsap.scaleX = t._gsap.scaleY = i
                },
                mn = function (t, e, i, n, r) {
                    var o = t._gsap;
                    o.scaleX = o.scaleY = i, o.renderTransform(r, o)
                },
                _n = function (t, e, i, n, r) {
                    var o = t._gsap;
                    o[e] = i, o.renderTransform(r, o)
                },
                yn = "transform",
                Sn = yn + "Origin",
                vn = function t(e, i) {
                    var n = this,
                        r = this.target,
                        o = r.style;
                    if (e in $i && o) {
                        if (this.tfm = this.tfm || {}, "transform" === e) return on.transform.split(",").forEach((function (e) {
                            return t.call(n, e, i)
                        }));
                        if (~(e = on[e] || e).indexOf(",") ? e.split(",").forEach((function (t) {
                            return n.tfm[t] = kn(r, t)
                        })) : this.tfm[e] = r._gsap.x ? r._gsap[e] : kn(r, e), this.props.indexOf(yn) >= 0) return;
                        r._gsap.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Sn, i, "")), e = yn
                    } (o || i) && this.props.push(e, i, o[e])
                },
                bn = function (t) {
                    t.translate && (t.removeProperty("translate"), t.removeProperty("scale"), t.removeProperty("rotate"))
                },
                Tn = function () {
                    var t, e, i = this.props,
                        n = this.target,
                        r = n.style,
                        o = n._gsap;
                    for (t = 0; t < i.length; t += 3) i[t + 1] ? n[i[t]] = i[t + 2] : i[t + 2] ? r[i[t]] = i[t + 2] : r.removeProperty("--" === i[t].substr(0, 2) ? i[t] : i[t].replace(en, "-$1").toLowerCase());
                    if (this.tfm) {
                        for (e in this.tfm) o[e] = this.tfm[e];
                        o.svg && (o.renderTransform(), n.setAttribute("data-svg-origin", this.svgo || "")), (t = Li()) && t.isStart || r[yn] || (bn(r), o.uncache = 1)
                    }
                },
                Pn = function (t, e) {
                    var i = {
                        target: t,
                        props: [],
                        revert: Tn,
                        save: vn
                    };
                    return t._gsap || Ai.core.getCache(t), e && e.split(",").forEach((function (t) {
                        return i.save(t)
                    })), i
                },
                An = function (t, e) {
                    var i = wi.createElementNS ? wi.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : wi.createElement(t);
                    return i.style ? i : wi.createElement(t)
                },
                In = function t(e, i, n) {
                    var r = getComputedStyle(e);
                    return r[i] || r.getPropertyValue(i.replace(en, "-$1").toLowerCase()) || r.getPropertyValue(i) || !n && t(e, En(i) || i, 1) || ""
                },
                wn = "O,Moz,ms,Ms,Webkit".split(","),
                En = function (t, e, i) {
                    var n = (e || xi).style,
                        r = 5;
                    if (t in n && !i) return t;
                    for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(wn[r] + t in n););
                    return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? wn[r] : "") + t
                },
                Cn = function () {
                    "undefined" != typeof window && window.document && (Ii = window, wi = Ii.document, Ei = wi.documentElement, xi = An("div") || {
                        style: {}
                    }, An("div"), yn = En(yn), Sn = yn + "Origin", xi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Oi = !!En("perspective"), Li = Ai.core.reverting, Ci = 1)
                },
                xn = function t(e) {
                    var i, n = An("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        r = this.parentNode,
                        o = this.nextSibling,
                        s = this.style.cssText;
                    if (Ei.appendChild(n), n.appendChild(this), this.style.display = "block", e) try {
                        i = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                    } catch (t) { } else this._gsapBBox && (i = this._gsapBBox());
                    return r && (o ? r.insertBefore(this, o) : r.appendChild(this)), Ei.removeChild(n), this.style.cssText = s, i
                },
                Bn = function (t, e) {
                    for (var i = e.length; i--;)
                        if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
                },
                Ln = function (t) {
                    var e;
                    try {
                        e = t.getBBox()
                    } catch (i) {
                        e = xn.call(t, !0)
                    }
                    return e && (e.width || e.height) || t.getBBox === xn || (e = xn.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                        x: +Bn(t, ["x", "cx", "x1"]) || 0,
                        y: +Bn(t, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                On = function (t) {
                    return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Ln(t))
                },
                Nn = function (t, e) {
                    if (e) {
                        var i = t.style;
                        e in $i && e !== Sn && (e = yn), i.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), i.removeProperty(e.replace(en, "-$1").toLowerCase())) : i.removeAttribute(e)
                    }
                },
                Mn = function (t, e, i, n, r, o) {
                    var s = new ci(t._pt, e, i, 0, 1, o ? cn : un);
                    return t._pt = s, s.b = n, s.e = r, t._props.push(i), s
                },
                Rn = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                Dn = {
                    grid: 1,
                    flex: 1
                },
                Fn = function t(e, i, n, r) {
                    var o, s, a, l, h = parseFloat(n) || 0,
                        u = (n + "").trim().substr((h + "").length) || "px",
                        c = xi.style,
                        d = nn.test(i),
                        p = "svg" === e.tagName.toLowerCase(),
                        f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                        g = 100,
                        m = "px" === r,
                        _ = "%" === r;
                    return r === u || !h || Rn[r] || Rn[u] ? h : ("px" !== u && !m && (h = t(e, i, n, "px")), l = e.getCTM && On(e), !_ && "%" !== u || !$i[i] && !~i.indexOf("adius") ? (c[d ? "width" : "height"] = g + (m ? u : r), s = ~i.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode, l && (s = (e.ownerSVGElement || {}).parentNode), s && s !== wi && s.appendChild || (s = wi.body), (a = s._gsap) && _ && a.width && d && a.time === Ie.time && !a.uncache ? gt(h / a.width * g) : ((_ || "%" === u) && !Dn[In(s, "display")] && (c.position = In(e, "position")), s === e && (c.position = "static"), s.appendChild(xi), o = xi[f], s.removeChild(xi), c.position = "absolute", d && _ && ((a = dt(s)).time = Ie.time, a.width = s[f]), gt(m ? o * h / g : o && h ? g / o * h : 0))) : (o = l ? e.getBBox()[d ? "width" : "height"] : e[f], gt(_ ? h / o * g : h / 100 * o)))
                },
                kn = function (t, e, i, n) {
                    var r;
                    return Ci || Cn(), e in on && "transform" !== e && ~(e = on[e]).indexOf(",") && (e = e.split(",")[0]), $i[e] && "transform" !== e ? (r = qn(t, n), r = "transformOrigin" !== e ? r[e] : r.svg ? r.origin : Zn(In(t, Sn)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || n || ~(r + "").indexOf("calc(")) && (r = Vn[e] && Vn[e](t, e, i) || In(t, e) || pt(t, e) || ("opacity" === e ? 1 : 0)), i && !~(r + "").trim().indexOf(" ") ? Fn(t, e, r, i) + i : r
                },
                Un = function (t, e, i, n) {
                    if (!i || "none" === i) {
                        var r = En(e, t, 1),
                            o = r && In(t, r, 1);
                        o && o !== i ? (e = r, i = o) : "borderColor" === e && (i = In(t, "borderTopColor"))
                    }
                    var s, a, l, h, u, c, d, p, f, g, m, _ = new ci(this._pt, t.style, e, 0, 1, oi),
                        y = 0,
                        S = 0;
                    if (_.b = i, _.e = n, i += "", "auto" == (n += "") && (t.style[e] = n, n = In(t, e) || n, t.style[e] = i), Ae(s = [i, n]), n = s[1], l = (i = s[0]).match(V) || [], (n.match(V) || []).length) {
                        for (; a = V.exec(n);) d = a[0], f = n.substring(y, a.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (c = l[S++] || "") && (h = parseFloat(c) || 0, m = c.substr((h + "").length), "=" === d.charAt(1) && (d = _t(h, d) + m), p = parseFloat(d), g = d.substr((p + "").length), y = V.lastIndex - g.length, g || (g = g || v.units[e] || m, y === n.length && (n += g, _.e += g)), m !== g && (h = Fn(t, e, c, g) || 0), _._pt = {
                            _next: _._pt,
                            p: f || 1 === S ? f : ",",
                            s: h,
                            c: p - h,
                            m: u && u < 4 || "zIndex" === e ? Math.round : 0
                        });
                        _.c = y < n.length ? n.substring(y, n.length) : ""
                    } else _.r = "display" === e && "none" === n ? cn : un;
                    return H.test(n) && (_.e = 0), this._pt = _, _
                },
                Gn = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                Wn = function (t, e) {
                    if (e.tween && e.tween._time === e.tween._dur) {
                        var i, n, r, o = e.t,
                            s = o.style,
                            a = e.u,
                            l = o._gsap;
                        if ("all" === a || !0 === a) s.cssText = "", n = 1;
                        else
                            for (r = (a = a.split(",")).length; --r > -1;) i = a[r], $i[i] && (n = 1, i = "transformOrigin" === i ? Sn : yn), Nn(o, i);
                        n && (Nn(o, yn), l && (l.svg && o.removeAttribute("transform"), qn(o, 1), l.uncache = 1, bn(s)))
                    }
                },
                Vn = {
                    clearProps: function (t, e, i, n, r) {
                        if ("isFromStart" !== r.data) {
                            var o = t._pt = new ci(t._pt, e, i, 0, 0, Wn);
                            return o.u = n, o.pr = -10, o.tween = r, t._props.push(i), 1
                        }
                    }
                },
                Xn = [1, 0, 0, 1, 0, 0],
                Hn = {},
                Yn = function (t) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
                },
                jn = function (t) {
                    var e = In(t, yn);
                    return Yn(e) ? Xn : e.substr(7).match(W).map(gt)
                },
                zn = function (t, e) {
                    var i, n, r, o, s = t._gsap || dt(t),
                        a = t.style,
                        l = jn(t);
                    return s.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Xn : l : (l !== Xn || t.offsetParent || t === Ei || s.svg || (r = a.display, a.display = "block", (i = t.parentNode) && t.offsetParent || (o = 1, n = t.nextElementSibling, Ei.appendChild(t)), l = jn(t), r ? a.display = r : Nn(t, "display"), o && (n ? i.insertBefore(t, n) : i ? i.appendChild(t) : Ei.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
                },
                Kn = function (t, e, i, n, r, o) {
                    var s, a, l, h = t._gsap,
                        u = r || zn(t, !0),
                        c = h.xOrigin || 0,
                        d = h.yOrigin || 0,
                        p = h.xOffset || 0,
                        f = h.yOffset || 0,
                        g = u[0],
                        m = u[1],
                        _ = u[2],
                        y = u[3],
                        S = u[4],
                        v = u[5],
                        b = e.split(" "),
                        T = parseFloat(b[0]) || 0,
                        P = parseFloat(b[1]) || 0;
                    i ? u !== Xn && (a = g * y - m * _) && (l = T * (-m / a) + P * (g / a) - (g * v - m * S) / a, T = T * (y / a) + P * (-_ / a) + (_ * v - y * S) / a, P = l) : (T = (s = Ln(t)).x + (~b[0].indexOf("%") ? T / 100 * s.width : T), P = s.y + (~(b[1] || b[0]).indexOf("%") ? P / 100 * s.height : P)), n || !1 !== n && h.smooth ? (S = T - c, v = P - d, h.xOffset = p + (S * g + v * _) - S, h.yOffset = f + (S * m + v * y) - v) : h.xOffset = h.yOffset = 0, h.xOrigin = T, h.yOrigin = P, h.smooth = !!n, h.origin = e, h.originIsAbsolute = !!i, t.style[Sn] = "0px 0px", o && (Mn(o, h, "xOrigin", c, T), Mn(o, h, "yOrigin", d, P), Mn(o, h, "xOffset", p, h.xOffset), Mn(o, h, "yOffset", f, h.yOffset)), t.setAttribute("data-svg-origin", T + " " + P)
                },
                qn = function (t, e) {
                    var i = t._gsap || new ke(t);
                    if ("x" in i && !e && !i.uncache) return i;
                    var n, r, o, s, a, l, h, u, c, d, p, f, g, m, _, y, S, b, T, P, A, I, w, E, C, x, B, L, O, N, M, R, D = t.style,
                        F = i.scaleX < 0,
                        k = "px",
                        U = "deg",
                        G = getComputedStyle(t),
                        W = In(t, Sn) || "0";
                    return n = r = o = l = h = u = c = d = p = 0, s = a = 1, i.svg = !(!t.getCTM || !On(t)), G.translate && ("none" === G.translate && "none" === G.scale && "none" === G.rotate || (D[yn] = ("none" !== G.translate ? "translate3d(" + (G.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== G.rotate ? "rotate(" + G.rotate + ") " : "") + ("none" !== G.scale ? "scale(" + G.scale.split(" ").join(",") + ") " : "") + ("none" !== G[yn] ? G[yn] : "")), D.scale = D.rotate = D.translate = "none"), m = zn(t, i.svg), i.svg && (i.uncache ? (C = t.getBBox(), W = i.xOrigin - C.x + "px " + (i.yOrigin - C.y) + "px", E = "") : E = !e && t.getAttribute("data-svg-origin"), Kn(t, E || W, !!E || i.originIsAbsolute, !1 !== i.smooth, m)), f = i.xOrigin || 0, g = i.yOrigin || 0, m !== Xn && (b = m[0], T = m[1], P = m[2], A = m[3], n = I = m[4], r = w = m[5], 6 === m.length ? (s = Math.sqrt(b * b + T * T), a = Math.sqrt(A * A + P * P), l = b || T ? tn(T, b) * Ji : 0, (c = P || A ? tn(P, A) * Ji + l : 0) && (a *= Math.abs(Math.cos(c * Qi))), i.svg && (n -= f - (f * b + g * P), r -= g - (f * T + g * A))) : (R = m[6], N = m[7], B = m[8], L = m[9], O = m[10], M = m[11], n = m[12], r = m[13], o = m[14], h = (_ = tn(R, O)) * Ji, _ && (E = I * (y = Math.cos(-_)) + B * (S = Math.sin(-_)), C = w * y + L * S, x = R * y + O * S, B = I * -S + B * y, L = w * -S + L * y, O = R * -S + O * y, M = N * -S + M * y, I = E, w = C, R = x), u = (_ = tn(-P, O)) * Ji, _ && (y = Math.cos(-_), M = A * (S = Math.sin(-_)) + M * y, b = E = b * y - B * S, T = C = T * y - L * S, P = x = P * y - O * S), l = (_ = tn(T, b)) * Ji, _ && (E = b * (y = Math.cos(_)) + T * (S = Math.sin(_)), C = I * y + w * S, T = T * y - b * S, w = w * y - I * S, b = E, I = C), h && Math.abs(h) + Math.abs(l) > 359.9 && (h = l = 0, u = 180 - u), s = gt(Math.sqrt(b * b + T * T + P * P)), a = gt(Math.sqrt(w * w + R * R)), _ = tn(I, w), c = Math.abs(_) > 2e-4 ? _ * Ji : 0, p = M ? 1 / (M < 0 ? -M : M) : 0), i.svg && (E = t.getAttribute("transform"), i.forceCSS = t.setAttribute("transform", "") || !Yn(In(t, yn)), E && t.setAttribute("transform", E))), Math.abs(c) > 90 && Math.abs(c) < 270 && (F ? (s *= -1, c += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, c += c <= 0 ? 180 : -180)), e = e || i.uncache, i.x = n - ((i.xPercent = n && (!e && i.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-n) ? -50 : 0))) ? t.offsetWidth * i.xPercent / 100 : 0) + k, i.y = r - ((i.yPercent = r && (!e && i.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * i.yPercent / 100 : 0) + k, i.z = o + k, i.scaleX = gt(s), i.scaleY = gt(a), i.rotation = gt(l) + U, i.rotationX = gt(h) + U, i.rotationY = gt(u) + U, i.skewX = c + U, i.skewY = d + U, i.transformPerspective = p + k, (i.zOrigin = parseFloat(W.split(" ")[2]) || 0) && (D[Sn] = Zn(W)), i.xOffset = i.yOffset = 0, i.force3D = v.force3D, i.renderTransform = i.svg ? nr : Oi ? ir : Jn, i.uncache = 0, i
                },
                Zn = function (t) {
                    return (t = t.split(" "))[0] + " " + t[1]
                },
                $n = function (t, e, i) {
                    var n = Jt(e);
                    return gt(parseFloat(e) + parseFloat(Fn(t, "x", i + "px", n))) + n
                },
                Jn = function (t, e) {
                    e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, ir(t, e)
                },
                Qn = "0deg",
                tr = "0px",
                er = ") ",
                ir = function (t, e) {
                    var i = e || this,
                        n = i.xPercent,
                        r = i.yPercent,
                        o = i.x,
                        s = i.y,
                        a = i.z,
                        l = i.rotation,
                        h = i.rotationY,
                        u = i.rotationX,
                        c = i.skewX,
                        d = i.skewY,
                        p = i.scaleX,
                        f = i.scaleY,
                        g = i.transformPerspective,
                        m = i.force3D,
                        _ = i.target,
                        y = i.zOrigin,
                        S = "",
                        v = "auto" === m && t && 1 !== t || !0 === m;
                    if (y && (u !== Qn || h !== Qn)) {
                        var b, T = parseFloat(h) * Qi,
                            P = Math.sin(T),
                            A = Math.cos(T);
                        T = parseFloat(u) * Qi, b = Math.cos(T), o = $n(_, o, P * b * -y), s = $n(_, s, -Math.sin(T) * -y), a = $n(_, a, A * b * -y + y)
                    }
                    g !== tr && (S += "perspective(" + g + er), (n || r) && (S += "translate(" + n + "%, " + r + "%) "), (v || o !== tr || s !== tr || a !== tr) && (S += a !== tr || v ? "translate3d(" + o + ", " + s + ", " + a + ") " : "translate(" + o + ", " + s + er), l !== Qn && (S += "rotate(" + l + er), h !== Qn && (S += "rotateY(" + h + er), u !== Qn && (S += "rotateX(" + u + er), c === Qn && d === Qn || (S += "skew(" + c + ", " + d + er), 1 === p && 1 === f || (S += "scale(" + p + ", " + f + er), _.style[yn] = S || "translate(0, 0)"
                },
                nr = function (t, e) {
                    var i, n, r, o, s, a = e || this,
                        l = a.xPercent,
                        h = a.yPercent,
                        u = a.x,
                        c = a.y,
                        d = a.rotation,
                        p = a.skewX,
                        f = a.skewY,
                        g = a.scaleX,
                        m = a.scaleY,
                        _ = a.target,
                        y = a.xOrigin,
                        S = a.yOrigin,
                        v = a.xOffset,
                        b = a.yOffset,
                        T = a.forceCSS,
                        P = parseFloat(u),
                        A = parseFloat(c);
                    d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= Qi, p *= Qi, i = Math.cos(d) * g, n = Math.sin(d) * g, r = Math.sin(d - p) * -m, o = Math.cos(d - p) * m, p && (f *= Qi, s = Math.tan(p - f), r *= s = Math.sqrt(1 + s * s), o *= s, f && (s = Math.tan(f), i *= s = Math.sqrt(1 + s * s), n *= s)), i = gt(i), n = gt(n), r = gt(r), o = gt(o)) : (i = g, o = m, n = r = 0), (P && !~(u + "").indexOf("px") || A && !~(c + "").indexOf("px")) && (P = Fn(_, "x", u, "px"), A = Fn(_, "y", c, "px")), (y || S || v || b) && (P = gt(P + y - (y * i + S * r) + v), A = gt(A + S - (y * n + S * o) + b)), (l || h) && (s = _.getBBox(), P = gt(P + l / 100 * s.width), A = gt(A + h / 100 * s.height)), s = "matrix(" + i + "," + n + "," + r + "," + o + "," + P + "," + A + ")", _.setAttribute("transform", s), T && (_.style[yn] = s)
                },
                rr = function (t, e, i, n, r) {
                    var o, s, a = 360,
                        l = B(r),
                        h = parseFloat(r) * (l && ~r.indexOf("rad") ? Ji : 1) - n,
                        u = n + h + "deg";
                    return l && ("short" === (o = r.split("_")[1]) && (h %= a) != h % 180 && (h += h < 0 ? a : -360), "cw" === o && h < 0 ? h = (h + 36e9) % a - ~~(h / a) * a : "ccw" === o && h > 0 && (h = (h - 36e9) % a - ~~(h / a) * a)), t._pt = s = new ci(t._pt, e, i, n, h, an), s.e = u, s.u = "deg", t._props.push(i), s
                },
                or = function (t, e) {
                    for (var i in e) t[i] = e[i];
                    return t
                },
                sr = function (t, e, i) {
                    var n, r, o, s, a, l, h, u = or({}, i._gsap),
                        c = i.style;
                    for (r in u.svg ? (o = i.getAttribute("transform"), i.setAttribute("transform", ""), c[yn] = e, n = qn(i, 1), Nn(i, yn), i.setAttribute("transform", o)) : (o = getComputedStyle(i)[yn], c[yn] = e, n = qn(i, 1), c[yn] = o), $i) (o = u[r]) !== (s = n[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Jt(o) !== (h = Jt(s)) ? Fn(i, r, o, h) : parseFloat(o), l = parseFloat(s), t._pt = new ci(t._pt, n, r, a, l - a, sn), t._pt.u = h || 0, t._props.push(r));
                    or(n, u)
                };
            ft("padding,margin,Width,Radius", (function (t, e) {
                var i = "Top",
                    n = "Right",
                    r = "Bottom",
                    o = "Left",
                    s = (e < 3 ? [i, n, r, o] : [i + o, i + n, r + n, r + o]).map((function (i) {
                        return e < 2 ? t + i : "border" + i + t
                    }));
                Vn[e > 1 ? "border" + t : t] = function (t, e, i, n, r) {
                    var o, a;
                    if (arguments.length < 4) return o = s.map((function (e) {
                        return kn(t, e, i)
                    })), 5 === (a = o.join(" ")).split(o[0]).length ? o[0] : a;
                    o = (n + "").split(" "), a = {}, s.forEach((function (t, e) {
                        return a[t] = o[e] = o[e] || o[(e - 1) / 2 | 0]
                    })), t.init(e, a, r)
                }
            }));
            var ar, lr, hr = {
                name: "css",
                register: Cn,
                targetTest: function (t) {
                    return t.style && t.nodeType
                },
                init: function (t, e, i, n, r) {
                    var o, s, a, l, h, u, c, d, p, f, g, m, _, y, S, b, T, P, A, I, w = this._props,
                        E = t.style,
                        C = i.vars.startAt;
                    for (c in Ci || Cn(), this.styles = this.styles || Pn(t), b = this.styles.props, this.tween = i, e)
                        if ("autoRound" !== c && (s = e[c], !st[c] || !Ye(c, e, i, n, t, r)))
                            if (h = typeof s, u = Vn[c], "function" === h && (h = typeof (s = s.call(i, n, t, r))), "string" === h && ~s.indexOf("random(") && (s = he(s)), u) u(this, t, c, s, i) && (S = 1);
                            else if ("--" === c.substr(0, 2)) o = (getComputedStyle(t).getPropertyValue(c) + "").trim(), s += "", Te.lastIndex = 0, Te.test(o) || (d = Jt(o), p = Jt(s)), p ? d !== p && (o = Fn(t, c, o, p) + p) : d && (s += d), this.add(E, "setProperty", o, s, n, r, 0, 0, c), w.push(c), b.push(c, 0, E[c]);
                            else if ("undefined" !== h) {
                                if (C && c in C ? (o = "function" == typeof C[c] ? C[c].call(i, n, t, r) : C[c], B(o) && ~o.indexOf("random(") && (o = he(o)), Jt(o + "") || (o += v.units[c] || Jt(kn(t, c)) || ""), "=" === (o + "").charAt(1) && (o = kn(t, c))) : o = kn(t, c), l = parseFloat(o), (f = "string" === h && "=" === s.charAt(1) && s.substr(0, 2)) && (s = s.substr(2)), a = parseFloat(s), c in on && ("autoAlpha" === c && (1 === l && "hidden" === kn(t, "visibility") && a && (l = 0), b.push("visibility", 0, E.visibility), Mn(this, E, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== c && "transform" !== c && ~(c = on[c]).indexOf(",") && (c = c.split(",")[0])), g = c in $i)
                                    if (this.styles.save(c), m || ((_ = t._gsap).renderTransform && !e.parseTransform || qn(t, e.parseTransform), y = !1 !== e.smoothOrigin && _.smooth, (m = this._pt = new ci(this._pt, E, yn, 0, 1, _.renderTransform, _, 0, -1)).dep = 1), "scale" === c) this._pt = new ci(this._pt, _, "scaleY", _.scaleY, (f ? _t(_.scaleY, f + a) : a) - _.scaleY || 0, sn), this._pt.u = 0, w.push("scaleY", c), c += "X";
                                    else {
                                        if ("transformOrigin" === c) {
                                            b.push(Sn, 0, E[Sn]), P = void 0, A = void 0, I = void 0, A = (P = (T = s).split(" "))[0], I = P[1] || "50%", "top" !== A && "bottom" !== A && "left" !== I && "right" !== I || (T = A, A = I, I = T), P[0] = Gn[A] || A, P[1] = Gn[I] || I, s = P.join(" "), _.svg ? Kn(t, s, 0, y, 0, this) : ((p = parseFloat(s.split(" ")[2]) || 0) !== _.zOrigin && Mn(this, _, "zOrigin", _.zOrigin, p), Mn(this, E, c, Zn(o), Zn(s)));
                                            continue
                                        }
                                        if ("svgOrigin" === c) {
                                            Kn(t, s, 1, y, 0, this);
                                            continue
                                        }
                                        if (c in Hn) {
                                            rr(this, _, c, l, f ? _t(l, f + s) : s);
                                            continue
                                        }
                                        if ("smoothOrigin" === c) {
                                            Mn(this, _, "smooth", _.smooth, s);
                                            continue
                                        }
                                        if ("force3D" === c) {
                                            _[c] = s;
                                            continue
                                        }
                                        if ("transform" === c) {
                                            sr(this, s, t);
                                            continue
                                        }
                                    }
                                else c in E || (c = En(c) || c);
                                if (g || (a || 0 === a) && (l || 0 === l) && !rn.test(s) && c in E) a || (a = 0), (d = (o + "").substr((l + "").length)) !== (p = Jt(s) || (c in v.units ? v.units[c] : d)) && (l = Fn(t, c, o, p)), this._pt = new ci(this._pt, g ? _ : E, c, l, (f ? _t(l, f + a) : a) - l, g || "px" !== p && "zIndex" !== c || !1 === e.autoRound ? sn : hn), this._pt.u = p || 0, d !== p && "%" !== p && (this._pt.b = o, this._pt.r = ln);
                                else if (c in E) Un.call(this, t, c, o, f ? f + s : s);
                                else if (c in t) this.add(t, c, o || t[c], f ? f + s : s, n, r);
                                else if ("parseTransform" !== c) {
                                    Z(c, s);
                                    continue
                                }
                                g || (c in E ? b.push(c, 0, E[c]) : b.push(c, 1, o || t[c])), w.push(c)
                            }
                    S && ui(this)
                },
                render: function (t, e) {
                    if (e.tween._time || !Li())
                        for (var i = e._pt; i;) i.r(t, i.d), i = i._next;
                    else e.styles.revert()
                },
                get: kn,
                aliases: on,
                getSetter: function (t, e, i) {
                    var n = on[e];
                    return n && n.indexOf(",") < 0 && (e = n), e in $i && e !== Sn && (t._gsap.x || kn(t, "x")) ? i && Bi === i ? "scale" === e ? gn : fn : (Bi = i || {}) && ("scale" === e ? mn : _n) : t.style && !N(t.style[e]) ? dn : ~e.indexOf("-") ? pn : ii(t, e)
                },
                core: {
                    _removeProperty: Nn,
                    _getMatrix: zn
                }
            };
            Ai.utils.checkPrefix = En, Ai.core.getStyleSaver = Pn, lr = ft("x,y,z,scale,scaleX,scaleY,xPercent,yPercent" + "," + (ar = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function (t) {
                $i[t] = 1
            })), ft(ar, (function (t) {
                v.units[t] = "deg", Hn[t] = 1
            })), on[lr[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + ar, ft("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function (t) {
                var e = t.split(":");
                on[e[1]] = lr[e[0]]
            })), ft("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function (t) {
                v.units[t] = "px"
            })), Ai.registerPlugin(hr);
            var ur = Ai.registerPlugin(hr) || Ai,
                cr = ur.core.Tween
        },
        8185: t => {
            "use strict";
            var e = {
                foo: {}
            },
                i = Object;
            t.exports = function () {
                return {
                    __proto__: e
                }.foo === e.foo && !({
                    __proto__: null
                }
                    instanceof i)
            }
        },
        1405: (t, e, i) => {
            "use strict";
            var n = "undefined" != typeof Symbol && Symbol,
                r = i(5419);
            t.exports = function () {
                return "function" == typeof n && "function" == typeof Symbol && "symbol" == typeof n("foo") && "symbol" == typeof Symbol("bar") && r()
            }
        },
        5419: t => {
            "use strict";
            t.exports = function () {
                if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
                if ("symbol" == typeof Symbol.iterator) return !0;
                var t = {},
                    e = Symbol("test"),
                    i = Object(e);
                if ("string" == typeof e) return !1;
                if ("[object Symbol]" !== Object.prototype.toString.call(e)) return !1;
                if ("[object Symbol]" !== Object.prototype.toString.call(i)) return !1;
                for (e in t[e] = 42, t) return !1;
                if ("function" == typeof Object.keys && 0 !== Object.keys(t).length) return !1;
                if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length) return !1;
                var n = Object.getOwnPropertySymbols(t);
                if (1 !== n.length || n[0] !== e) return !1;
                if (!Object.prototype.propertyIsEnumerable.call(t, e)) return !1;
                if ("function" == typeof Object.getOwnPropertyDescriptor) {
                    var r = Object.getOwnPropertyDescriptor(t, e);
                    if (42 !== r.value || !0 !== r.enumerable) return !1
                }
                return !0
            }
        },
        7642: (t, e, i) => {
            "use strict";
            var n = i(8612);
            t.exports = n.call(Function.call, Object.prototype.hasOwnProperty)
        },
        9397: (t, e) => {
            ! function (t) {
                var e = /\S/,
                    i = /\"/g,
                    n = /\n/g,
                    r = /\r/g,
                    o = /\\/g,
                    s = /\u2028/,
                    a = /\u2029/;

                function l(t) {
                    return t.trim ? t.trim() : t.replace(/^\s*|\s*$/g, "")
                }

                function h(t, e, i) {
                    if (e.charAt(i) != t.charAt(0)) return !1;
                    for (var n = 1, r = t.length; n < r; n++)
                        if (e.charAt(i + n) != t.charAt(n)) return !1;
                    return !0
                }
                t.tags = {
                    "#": 1,
                    "^": 2,
                    "<": 3,
                    $: 4,
                    "/": 5,
                    "!": 6,
                    ">": 7,
                    "=": 8,
                    _v: 9,
                    "{": 10,
                    "&": 11,
                    _t: 12
                }, t.scan = function (i, n) {
                    var r, o = i.length,
                        s = 0,
                        a = null,
                        u = null,
                        c = "",
                        d = [],
                        p = !1,
                        f = 0,
                        g = 0,
                        m = "{{",
                        _ = "}}";

                    function y() {
                        c.length > 0 && (d.push({
                            tag: "_t",
                            text: new String(c)
                        }), c = "")
                    }

                    function S(i, n) {
                        if (y(), i && function () {
                            for (var i = !0, n = g; n < d.length; n++)
                                if (!(i = t.tags[d[n].tag] < t.tags._v || "_t" == d[n].tag && null === d[n].text.match(e))) return !1;
                            return i
                        }())
                            for (var r, o = g; o < d.length; o++) d[o].text && ((r = d[o + 1]) && ">" == r.tag && (r.indent = d[o].text.toString()), d.splice(o, 1));
                        else n || d.push({
                            tag: "\n"
                        });
                        p = !1, g = d.length
                    }

                    function v(t, e) {
                        var i = "=" + _,
                            n = t.indexOf(i, e),
                            r = l(t.substring(t.indexOf("=", e) + 1, n)).split(" ");
                        return m = r[0], _ = r[r.length - 1], n + i.length - 1
                    }
                    for (n && (n = n.split(" "), m = n[0], _ = n[1]), f = 0; f < o; f++) 0 == s ? h(m, i, f) ? (--f, y(), s = 1) : "\n" == i.charAt(f) ? S(p) : c += i.charAt(f) : 1 == s ? (f += m.length - 1, "=" == (a = (u = t.tags[i.charAt(f + 1)]) ? i.charAt(f + 1) : "_v") ? (f = v(i, f), s = 0) : (u && f++, s = 2), p = f) : h(_, i, f) ? (d.push({
                        tag: a,
                        n: l(c),
                        otag: m,
                        ctag: _,
                        i: "/" == a ? p - m.length : f + _.length
                    }), c = "", f += _.length - 1, s = 0, "{" == a && ("}}" == _ ? f++ : "}" === (r = d[d.length - 1]).n.substr(r.n.length - 1) && (r.n = r.n.substring(0, r.n.length - 1)))) : c += i.charAt(f);
                    return S(p, !0), d
                };
                var u = {
                    _t: !0,
                    "\n": !0,
                    $: !0,
                    "/": !0
                };

                function c(e, i, n, r) {
                    var o, s = [],
                        a = null,
                        l = null;
                    for (o = n[n.length - 1]; e.length > 0;) {
                        if (l = e.shift(), o && "<" == o.tag && !(l.tag in u)) throw new Error("Illegal content in < super tag.");
                        if (t.tags[l.tag] <= t.tags.$ || d(l, r)) n.push(l), l.nodes = c(e, l.tag, n, r);
                        else {
                            if ("/" == l.tag) {
                                if (0 === n.length) throw new Error("Closing tag without opener: /" + l.n);
                                if (a = n.pop(), l.n != a.n && !p(l.n, a.n, r)) throw new Error("Nesting error: " + a.n + " vs. " + l.n);
                                return a.end = l.i, s
                            }
                            "\n" == l.tag && (l.last = 0 == e.length || "\n" == e[0].tag)
                        }
                        s.push(l)
                    }
                    if (n.length > 0) throw new Error("missing closing tag: " + n.pop().n);
                    return s
                }

                function d(t, e) {
                    for (var i = 0, n = e.length; i < n; i++)
                        if (e[i].o == t.n) return t.tag = "#", !0
                }

                function p(t, e, i) {
                    for (var n = 0, r = i.length; n < r; n++)
                        if (i[n].c == t && i[n].o == e) return !0
                }

                function f(t) {
                    var e = [];
                    for (var i in t.partials) e.push('"' + m(i) + '":{name:"' + m(t.partials[i].name) + '", ' + f(t.partials[i]) + "}");
                    return "partials: {" + e.join(",") + "}, subs: " + function (t) {
                        var e = [];
                        for (var i in t) e.push('"' + m(i) + '": function(c,p,t,i) {' + t[i] + "}");
                        return "{ " + e.join(",") + " }"
                    }(t.subs)
                }
                t.stringify = function (e, i, n) {
                    return "{code: function (c,p,i) { " + t.wrapMain(e.code) + " }," + f(e) + "}"
                };
                var g = 0;

                function m(t) {
                    return t.replace(o, "\\\\").replace(i, '\\"').replace(n, "\\n").replace(r, "\\r").replace(s, "\\u2028").replace(a, "\\u2029")
                }

                function _(t) {
                    return ~t.indexOf(".") ? "d" : "f"
                }

                function y(t, e) {
                    var i = "<" + (e.prefix || "") + t.n + g++;
                    return e.partials[i] = {
                        name: t.n,
                        partials: {}
                    }, e.code += 't.b(t.rp("' + m(i) + '",c,p,"' + (t.indent || "") + '"));', i
                }

                function S(t, e) {
                    e.code += "t.b(t.t(t." + _(t.n) + '("' + m(t.n) + '",c,p,0)));'
                }

                function v(t) {
                    return "t.b(" + t + ");"
                }
                t.generate = function (e, i, n) {
                    g = 0;
                    var r = {
                        code: "",
                        subs: {},
                        partials: {}
                    };
                    return t.walk(e, r), n.asString ? this.stringify(r, i, n) : this.makeTemplate(r, i, n)
                }, t.wrapMain = function (t) {
                    return 'var t=this;t.b(i=i||"");' + t + "return t.fl();"
                }, t.template = t.Template, t.makeTemplate = function (t, e, i) {
                    var n = this.makePartials(t);
                    return n.code = new Function("c", "p", "i", this.wrapMain(t.code)), new this.template(n, e, this, i)
                }, t.makePartials = function (t) {
                    var e, i = {
                        subs: {},
                        partials: t.partials,
                        name: t.name
                    };
                    for (e in i.partials) i.partials[e] = this.makePartials(i.partials[e]);
                    for (e in t.subs) i.subs[e] = new Function("c", "p", "t", "i", t.subs[e]);
                    return i
                }, t.codegen = {
                    "#": function (e, i) {
                        i.code += "if(t.s(t." + _(e.n) + '("' + m(e.n) + '",c,p,1),c,p,0,' + e.i + "," + e.end + ',"' + e.otag + " " + e.ctag + '")){t.rs(c,p,function(c,p,t){', t.walk(e.nodes, i), i.code += "});c.pop();}"
                    },
                    "^": function (e, i) {
                        i.code += "if(!t.s(t." + _(e.n) + '("' + m(e.n) + '",c,p,1),c,p,1,0,0,"")){', t.walk(e.nodes, i), i.code += "};"
                    },
                    ">": y,
                    "<": function (e, i) {
                        var n = {
                            partials: {},
                            code: "",
                            subs: {},
                            inPartial: !0
                        };
                        t.walk(e.nodes, n);
                        var r = i.partials[y(e, i)];
                        r.subs = n.subs, r.partials = n.partials
                    },
                    $: function (e, i) {
                        var n = {
                            subs: {},
                            code: "",
                            partials: i.partials,
                            prefix: e.n
                        };
                        t.walk(e.nodes, n), i.subs[e.n] = n.code, i.inPartial || (i.code += 't.sub("' + m(e.n) + '",c,p,i);')
                    },
                    "\n": function (t, e) {
                        e.code += v('"\\n"' + (t.last ? "" : " + i"))
                    },
                    _v: function (t, e) {
                        e.code += "t.b(t.v(t." + _(t.n) + '("' + m(t.n) + '",c,p,0)));'
                    },
                    _t: function (t, e) {
                        e.code += v('"' + m(t.text) + '"')
                    },
                    "{": S,
                    "&": S
                }, t.walk = function (e, i) {
                    for (var n, r = 0, o = e.length; r < o; r++)(n = t.codegen[e[r].tag]) && n(e[r], i);
                    return i
                }, t.parse = function (t, e, i) {
                    return c(t, 0, [], (i = i || {}).sectionTags || [])
                }, t.cache = {}, t.cacheKey = function (t, e) {
                    return [t, !!e.asString, !!e.disableLambda, e.delimiters, !!e.modelGet].join("||")
                }, t.compile = function (e, i) {
                    i = i || {};
                    var n = t.cacheKey(e, i),
                        r = this.cache[n];
                    if (r) {
                        var o = r.partials;
                        for (var s in o) delete o[s].instance;
                        return r
                    }
                    return r = this.generate(this.parse(this.scan(e, i.delimiters), e, i), e, i), this.cache[n] = r
                }
            }(e)
        },
        5485: (t, e, i) => {
            var n = i(9397);
            n.Template = i(2882).Template, n.template = n.Template, t.exports = n
        },
        2882: (t, e) => {
            ! function (t) {
                function e(t, e, i) {
                    var n;
                    return e && "object" == typeof e && (void 0 !== e[t] ? n = e[t] : i && e.get && "function" == typeof e.get && (n = e.get(t))), n
                }
                t.Template = function (t, e, i, n) {
                    t = t || {}, this.r = t.code || this.r, this.c = i, this.options = n || {}, this.text = e || "", this.partials = t.partials || {}, this.subs = t.subs || {}, this.buf = ""
                }, t.Template.prototype = {
                    r: function (t, e, i) {
                        return ""
                    },
                    v: function (t) {
                        return t = l(t), a.test(t) ? t.replace(i, "&amp;").replace(n, "&lt;").replace(r, "&gt;").replace(o, "&#39;").replace(s, "&quot;") : t
                    },
                    t: l,
                    render: function (t, e, i) {
                        return this.ri([t], e || {}, i)
                    },
                    ri: function (t, e, i) {
                        return this.r(t, e, i)
                    },
                    ep: function (t, e) {
                        var i = this.partials[t],
                            n = e[i.name];
                        if (i.instance && i.base == n) return i.instance;
                        if ("string" == typeof n) {
                            if (!this.c) throw new Error("No compiler available.");
                            n = this.c.compile(n, this.options)
                        }
                        if (!n) return null;
                        if (this.partials[t].base = n, i.subs) {
                            for (key in e.stackText || (e.stackText = {}), i.subs) e.stackText[key] || (e.stackText[key] = void 0 !== this.activeSub && e.stackText[this.activeSub] ? e.stackText[this.activeSub] : this.text);
                            n = function (t, e, i, n, r, o) {
                                function s() { }

                                function a() { }
                                var l;
                                s.prototype = t, a.prototype = t.subs;
                                var h = new s;
                                for (l in h.subs = new a, h.subsText = {}, h.buf = "", n = n || {}, h.stackSubs = n, h.subsText = o, e) n[l] || (n[l] = e[l]);
                                for (l in n) h.subs[l] = n[l];
                                for (l in r = r || {}, h.stackPartials = r, i) r[l] || (r[l] = i[l]);
                                for (l in r) h.partials[l] = r[l];
                                return h
                            }(n, i.subs, i.partials, this.stackSubs, this.stackPartials, e.stackText)
                        }
                        return this.partials[t].instance = n, n
                    },
                    rp: function (t, e, i, n) {
                        var r = this.ep(t, i);
                        return r ? r.ri(e, i, n) : ""
                    },
                    rs: function (t, e, i) {
                        var n = t[t.length - 1];
                        if (h(n))
                            for (var r = 0; r < n.length; r++) t.push(n[r]), i(t, e, this), t.pop();
                        else i(t, e, this)
                    },
                    s: function (t, e, i, n, r, o, s) {
                        var a;
                        return (!h(t) || 0 !== t.length) && ("function" == typeof t && (t = this.ms(t, e, i, n, r, o, s)), a = !!t, !n && a && e && e.push("object" == typeof t ? t : e[e.length - 1]), a)
                    },
                    d: function (t, i, n, r) {
                        var o, s = t.split("."),
                            a = this.f(s[0], i, n, r),
                            l = this.options.modelGet,
                            u = null;
                        if ("." === t && h(i[i.length - 2])) a = i[i.length - 1];
                        else
                            for (var c = 1; c < s.length; c++) void 0 !== (o = e(s[c], a, l)) ? (u = a, a = o) : a = "";
                        return !(r && !a) && (r || "function" != typeof a || (i.push(u), a = this.mv(a, i, n), i.pop()), a)
                    },
                    f: function (t, i, n, r) {
                        for (var o = !1, s = !1, a = this.options.modelGet, l = i.length - 1; l >= 0; l--)
                            if (void 0 !== (o = e(t, i[l], a))) {
                                s = !0;
                                break
                            } return s ? (r || "function" != typeof o || (o = this.mv(o, i, n)), o) : !r && ""
                    },
                    ls: function (t, e, i, n, r) {
                        var o = this.options.delimiters;
                        return this.options.delimiters = r, this.b(this.ct(l(t.call(e, n)), e, i)), this.options.delimiters = o, !1
                    },
                    ct: function (t, e, i) {
                        if (this.options.disableLambda) throw new Error("Lambda features disabled.");
                        return this.c.compile(t, this.options).render(e, i)
                    },
                    b: function (t) {
                        this.buf += t
                    },
                    fl: function () {
                        var t = this.buf;
                        return this.buf = "", t
                    },
                    ms: function (t, e, i, n, r, o, s) {
                        var a, l = e[e.length - 1],
                            h = t.call(l);
                        return "function" == typeof h ? !!n || (a = this.activeSub && this.subsText && this.subsText[this.activeSub] ? this.subsText[this.activeSub] : this.text, this.ls(h, l, i, a.substring(r, o), s)) : h
                    },
                    mv: function (t, e, i) {
                        var n = e[e.length - 1],
                            r = t.call(n);
                        return "function" == typeof r ? this.ct(l(r.call(n)), n, i) : r
                    },
                    sub: function (t, e, i, n) {
                        var r = this.subs[t];
                        r && (this.activeSub = t, r(e, i, this, n), this.activeSub = !1)
                    }
                };
                var i = /&/g,
                    n = /</g,
                    r = />/g,
                    o = /\'/g,
                    s = /\"/g,
                    a = /[&<>\"\']/;

                function l(t) {
                    return String(null == t ? "" : t)
                }
                var h = Array.isArray || function (t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                }
            }(e)
        },
        1766: (t, e, i) => {
            var n;
            ! function () {
                "use strict";
                var r = function () {
                    this.init()
                };
                r.prototype = {
                    init: function () {
                        var t = this || o;
                        return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = "canplaythrough", t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t
                    },
                    volume: function (t) {
                        var e = this || o;
                        if (t = parseFloat(t), e.ctx || p(), void 0 !== t && t >= 0 && t <= 1) {
                            if (e._volume = t, e._muted) return e;
                            e.usingWebAudio && e.masterGain.gain.setValueAtTime(t, o.ctx.currentTime);
                            for (var i = 0; i < e._howls.length; i++)
                                if (!e._howls[i]._webAudio)
                                    for (var n = e._howls[i]._getSoundIds(), r = 0; r < n.length; r++) {
                                        var s = e._howls[i]._soundById(n[r]);
                                        s && s._node && (s._node.volume = s._volume * t)
                                    }
                            return e
                        }
                        return e._volume
                    },
                    mute: function (t) {
                        var e = this || o;
                        e.ctx || p(), e._muted = t, e.usingWebAudio && e.masterGain.gain.setValueAtTime(t ? 0 : e._volume, o.ctx.currentTime);
                        for (var i = 0; i < e._howls.length; i++)
                            if (!e._howls[i]._webAudio)
                                for (var n = e._howls[i]._getSoundIds(), r = 0; r < n.length; r++) {
                                    var s = e._howls[i]._soundById(n[r]);
                                    s && s._node && (s._node.muted = !!t || s._muted)
                                }
                        return e
                    },
                    stop: function () {
                        for (var t = this || o, e = 0; e < t._howls.length; e++) t._howls[e].stop();
                        return t
                    },
                    unload: function () {
                        for (var t = this || o, e = t._howls.length - 1; e >= 0; e--) t._howls[e].unload();
                        return t.usingWebAudio && t.ctx && void 0 !== t.ctx.close && (t.ctx.close(), t.ctx = null, p()), t
                    },
                    codecs: function (t) {
                        return (this || o)._codecs[t.replace(/^x-/, "")]
                    },
                    _setup: function () {
                        var t = this || o;
                        if (t.state = t.ctx && t.ctx.state || "suspended", t._autoSuspend(), !t.usingWebAudio)
                            if ("undefined" != typeof Audio) try {
                                void 0 === (new Audio).oncanplaythrough && (t._canPlayEvent = "canplay")
                            } catch (e) {
                                t.noAudio = !0
                            } else t.noAudio = !0;
                        try {
                            (new Audio).muted && (t.noAudio = !0)
                        } catch (t) { }
                        return t.noAudio || t._setupCodecs(), t
                    },
                    _setupCodecs: function () {
                        var t = this || o,
                            e = null;
                        try {
                            e = "undefined" != typeof Audio ? new Audio : null
                        } catch (e) {
                            return t
                        }
                        if (!e || "function" != typeof e.canPlayType) return t;
                        var i = e.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                            n = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g),
                            r = n && parseInt(n[0].split("/")[1], 10) < 33;
                        return t._codecs = {
                            mp3: !(r || !i && !e.canPlayType("audio/mp3;").replace(/^no$/, "")),
                            mpeg: !!i,
                            opus: !!e.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                            ogg: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            oga: !!e.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                            wav: !!(e.canPlayType('audio/wav; codecs="1"') || e.canPlayType("audio/wav")).replace(/^no$/, ""),
                            aac: !!e.canPlayType("audio/aac;").replace(/^no$/, ""),
                            caf: !!e.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                            m4a: !!(e.canPlayType("audio/x-m4a;") || e.canPlayType("audio/m4a;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            m4b: !!(e.canPlayType("audio/x-m4b;") || e.canPlayType("audio/m4b;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            mp4: !!(e.canPlayType("audio/x-mp4;") || e.canPlayType("audio/mp4;") || e.canPlayType("audio/aac;")).replace(/^no$/, ""),
                            weba: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                            webm: !!e.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
                            dolby: !!e.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                            flac: !!(e.canPlayType("audio/x-flac;") || e.canPlayType("audio/flac;")).replace(/^no$/, "")
                        }, t
                    },
                    _unlockAudio: function () {
                        var t = this || o;
                        if (!t._audioUnlocked && t.ctx) {
                            t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050);
                            var e = function (i) {
                                for (; t._html5AudioPool.length < t.html5PoolSize;) try {
                                    var n = new Audio;
                                    n._unlocked = !0, t._releaseHtml5Audio(n)
                                } catch (i) {
                                    t.noAudio = !0;
                                    break
                                }
                                for (var r = 0; r < t._howls.length; r++)
                                    if (!t._howls[r]._webAudio)
                                        for (var o = t._howls[r]._getSoundIds(), s = 0; s < o.length; s++) {
                                            var a = t._howls[r]._soundById(o[s]);
                                            a && a._node && !a._node._unlocked && (a._node._unlocked = !0, a._node.load())
                                        }
                                t._autoResume();
                                var l = t.ctx.createBufferSource();
                                l.buffer = t._scratchBuffer, l.connect(t.ctx.destination), void 0 === l.start ? l.noteOn(0) : l.start(0), "function" == typeof t.ctx.resume && t.ctx.resume(), l.onended = function () {
                                    l.disconnect(0), t._audioUnlocked = !0, document.removeEventListener("touchstart", e, !0), document.removeEventListener("touchend", e, !0), document.removeEventListener("click", e, !0);
                                    for (var i = 0; i < t._howls.length; i++) t._howls[i]._emit("unlock")
                                }
                            };
                            return document.addEventListener("touchstart", e, !0), document.addEventListener("touchend", e, !0), document.addEventListener("click", e, !0), t
                        }
                    },
                    _obtainHtml5Audio: function () {
                        var t = this || o;
                        if (t._html5AudioPool.length) return t._html5AudioPool.pop();
                        var e = (new Audio).play();
                        return e && "undefined" != typeof Promise && (e instanceof Promise || "function" == typeof e.then) && e.catch((function () {
                            console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                        })), new Audio
                    },
                    _releaseHtml5Audio: function (t) {
                        var e = this || o;
                        return t._unlocked && e._html5AudioPool.push(t), e
                    },
                    _autoSuspend: function () {
                        var t = this;
                        if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && o.usingWebAudio) {
                            for (var e = 0; e < t._howls.length; e++)
                                if (t._howls[e]._webAudio)
                                    for (var i = 0; i < t._howls[e]._sounds.length; i++)
                                        if (!t._howls[e]._sounds[i]._paused) return t;
                            return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout((function () {
                                if (t.autoSuspend) {
                                    t._suspendTimer = null, t.state = "suspending";
                                    var e = function () {
                                        t.state = "suspended", t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume())
                                    };
                                    t.ctx.suspend().then(e, e)
                                }
                            }), 3e4), t
                        }
                    },
                    _autoResume: function () {
                        var t = this;
                        if (t.ctx && void 0 !== t.ctx.resume && o.usingWebAudio) return "running" === t.state && "interrupted" !== t.ctx.state && t._suspendTimer ? (clearTimeout(t._suspendTimer), t._suspendTimer = null) : "suspended" === t.state || "running" === t.state && "interrupted" === t.ctx.state ? (t.ctx.resume().then((function () {
                            t.state = "running";
                            for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("resume")
                        })), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0), t
                    }
                };
                var o = new r,
                    s = function (t) {
                        t.src && 0 !== t.src.length ? this.init(t) : console.error("An array of source files must be passed with any new Howl.")
                    };
                s.prototype = {
                    init: function (t) {
                        var e = this;
                        return o.ctx || p(), e._autoplay = t.autoplay || !1, e._format = "string" != typeof t.format ? t.format : [t.format], e._html5 = t.html5 || !1, e._muted = t.mute || !1, e._loop = t.loop || !1, e._pool = t.pool || 5, e._preload = "boolean" != typeof t.preload && "metadata" !== t.preload || t.preload, e._rate = t.rate || 1, e._sprite = t.sprite || {}, e._src = "string" != typeof t.src ? t.src : [t.src], e._volume = void 0 !== t.volume ? t.volume : 1, e._xhr = {
                            method: t.xhr && t.xhr.method ? t.xhr.method : "GET",
                            headers: t.xhr && t.xhr.headers ? t.xhr.headers : null,
                            withCredentials: !(!t.xhr || !t.xhr.withCredentials) && t.xhr.withCredentials
                        }, e._duration = 0, e._state = "unloaded", e._sounds = [], e._endTimers = {}, e._queue = [], e._playLock = !1, e._onend = t.onend ? [{
                            fn: t.onend
                        }] : [], e._onfade = t.onfade ? [{
                            fn: t.onfade
                        }] : [], e._onload = t.onload ? [{
                            fn: t.onload
                        }] : [], e._onloaderror = t.onloaderror ? [{
                            fn: t.onloaderror
                        }] : [], e._onplayerror = t.onplayerror ? [{
                            fn: t.onplayerror
                        }] : [], e._onpause = t.onpause ? [{
                            fn: t.onpause
                        }] : [], e._onplay = t.onplay ? [{
                            fn: t.onplay
                        }] : [], e._onstop = t.onstop ? [{
                            fn: t.onstop
                        }] : [], e._onmute = t.onmute ? [{
                            fn: t.onmute
                        }] : [], e._onvolume = t.onvolume ? [{
                            fn: t.onvolume
                        }] : [], e._onrate = t.onrate ? [{
                            fn: t.onrate
                        }] : [], e._onseek = t.onseek ? [{
                            fn: t.onseek
                        }] : [], e._onunlock = t.onunlock ? [{
                            fn: t.onunlock
                        }] : [], e._onresume = [], e._webAudio = o.usingWebAudio && !e._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(e), e._autoplay && e._queue.push({
                            event: "play",
                            action: function () {
                                e.play()
                            }
                        }), e._preload && "none" !== e._preload && e.load(), e
                    },
                    load: function () {
                        var t = this,
                            e = null;
                        if (o.noAudio) t._emit("loaderror", null, "No audio support.");
                        else {
                            "string" == typeof t._src && (t._src = [t._src]);
                            for (var i = 0; i < t._src.length; i++) {
                                var n, r;
                                if (t._format && t._format[i]) n = t._format[i];
                                else {
                                    if ("string" != typeof (r = t._src[i])) {
                                        t._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                        continue
                                    } (n = /^data:audio\/([^;,]+);/i.exec(r)) || (n = /\.([^.]+)$/.exec(r.split("?", 1)[0])), n && (n = n[1].toLowerCase())
                                }
                                if (n || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), n && o.codecs(n)) {
                                    e = t._src[i];
                                    break
                                }
                            }
                            if (e) return t._src = e, t._state = "loading", "https:" === window.location.protocol && "http:" === e.slice(0, 5) && (t._html5 = !0, t._webAudio = !1), new a(t), t._webAudio && h(t), t;
                            t._emit("loaderror", null, "No codec support for selected audio sources.")
                        }
                    },
                    play: function (t, e) {
                        var i = this,
                            n = null;
                        if ("number" == typeof t) n = t, t = null;
                        else {
                            if ("string" == typeof t && "loaded" === i._state && !i._sprite[t]) return null;
                            if (void 0 === t && (t = "__default", !i._playLock)) {
                                for (var r = 0, s = 0; s < i._sounds.length; s++) i._sounds[s]._paused && !i._sounds[s]._ended && (r++, n = i._sounds[s]._id);
                                1 === r ? t = null : n = null
                            }
                        }
                        var a = n ? i._soundById(n) : i._inactiveSound();
                        if (!a) return null;
                        if (n && !t && (t = a._sprite || "__default"), "loaded" !== i._state) {
                            a._sprite = t, a._ended = !1;
                            var l = a._id;
                            return i._queue.push({
                                event: "play",
                                action: function () {
                                    i.play(l)
                                }
                            }), l
                        }
                        if (n && !a._paused) return e || i._loadQueue("play"), a._id;
                        i._webAudio && o._autoResume();
                        var h = Math.max(0, a._seek > 0 ? a._seek : i._sprite[t][0] / 1e3),
                            u = Math.max(0, (i._sprite[t][0] + i._sprite[t][1]) / 1e3 - h),
                            c = 1e3 * u / Math.abs(a._rate),
                            d = i._sprite[t][0] / 1e3,
                            p = (i._sprite[t][0] + i._sprite[t][1]) / 1e3;
                        a._sprite = t, a._ended = !1;
                        var f = function () {
                            a._paused = !1, a._seek = h, a._start = d, a._stop = p, a._loop = !(!a._loop && !i._sprite[t][2])
                        };
                        if (!(h >= p)) {
                            var g = a._node;
                            if (i._webAudio) {
                                var m = function () {
                                    i._playLock = !1, f(), i._refreshBuffer(a);
                                    var t = a._muted || i._muted ? 0 : a._volume;
                                    g.gain.setValueAtTime(t, o.ctx.currentTime), a._playStart = o.ctx.currentTime, void 0 === g.bufferSource.start ? a._loop ? g.bufferSource.noteGrainOn(0, h, 86400) : g.bufferSource.noteGrainOn(0, h, u) : a._loop ? g.bufferSource.start(0, h, 86400) : g.bufferSource.start(0, h, u), c !== 1 / 0 && (i._endTimers[a._id] = setTimeout(i._ended.bind(i, a), c)), e || setTimeout((function () {
                                        i._emit("play", a._id), i._loadQueue()
                                    }), 0)
                                };
                                "running" === o.state && "interrupted" !== o.ctx.state ? m() : (i._playLock = !0, i.once("resume", m), i._clearTimer(a._id))
                            } else {
                                var _ = function () {
                                    g.currentTime = h, g.muted = a._muted || i._muted || o._muted || g.muted, g.volume = a._volume * o.volume(), g.playbackRate = a._rate;
                                    try {
                                        var n = g.play();
                                        if (n && "undefined" != typeof Promise && (n instanceof Promise || "function" == typeof n.then) ? (i._playLock = !0, f(), n.then((function () {
                                            i._playLock = !1, g._unlocked = !0, e || (i._emit("play", a._id), i._loadQueue())
                                        })).catch((function () {
                                            i._playLock = !1, i._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a._ended = !0, a._paused = !0
                                        }))) : e || (i._playLock = !1, f(), i._emit("play", a._id), i._loadQueue()), g.playbackRate = a._rate, g.paused) return void i._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                        "__default" !== t || a._loop ? i._endTimers[a._id] = setTimeout(i._ended.bind(i, a), c) : (i._endTimers[a._id] = function () {
                                            i._ended(a), g.removeEventListener("ended", i._endTimers[a._id], !1)
                                        }, g.addEventListener("ended", i._endTimers[a._id], !1))
                                    } catch (t) {
                                        i._emit("playerror", a._id, t)
                                    }
                                };
                                "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === g.src && (g.src = i._src, g.load());
                                var y = window && window.ejecta || !g.readyState && o._navigator.isCocoonJS;
                                if (g.readyState >= 3 || y) _();
                                else {
                                    i._playLock = !0;
                                    var S = function () {
                                        _(), g.removeEventListener(o._canPlayEvent, S, !1)
                                    };
                                    g.addEventListener(o._canPlayEvent, S, !1), i._clearTimer(a._id)
                                }
                            }
                            return a._id
                        }
                        i._ended(a)
                    },
                    pause: function (t) {
                        var e = this;
                        if ("loaded" !== e._state || e._playLock) return e._queue.push({
                            event: "pause",
                            action: function () {
                                e.pause(t)
                            }
                        }), e;
                        for (var i = e._getSoundIds(t), n = 0; n < i.length; n++) {
                            e._clearTimer(i[n]);
                            var r = e._soundById(i[n]);
                            if (r && !r._paused && (r._seek = e.seek(i[n]), r._rateSeek = 0, r._paused = !0, e._stopFade(i[n]), r._node))
                                if (e._webAudio) {
                                    if (!r._node.bufferSource) continue;
                                    void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), e._cleanBuffer(r._node)
                                } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                            arguments[1] || e._emit("pause", r ? r._id : null)
                        }
                        return e
                    },
                    stop: function (t, e) {
                        var i = this;
                        if ("loaded" !== i._state || i._playLock) return i._queue.push({
                            event: "stop",
                            action: function () {
                                i.stop(t)
                            }
                        }), i;
                        for (var n = i._getSoundIds(t), r = 0; r < n.length; r++) {
                            i._clearTimer(n[r]);
                            var o = i._soundById(n[r]);
                            o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, i._stopFade(n[r]), o._node && (i._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), i._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause(), o._node.duration === 1 / 0 && i._clearSound(o._node))), e || i._emit("stop", o._id))
                        }
                        return i
                    },
                    mute: function (t, e) {
                        var i = this;
                        if ("loaded" !== i._state || i._playLock) return i._queue.push({
                            event: "mute",
                            action: function () {
                                i.mute(t, e)
                            }
                        }), i;
                        if (void 0 === e) {
                            if ("boolean" != typeof t) return i._muted;
                            i._muted = t
                        }
                        for (var n = i._getSoundIds(e), r = 0; r < n.length; r++) {
                            var s = i._soundById(n[r]);
                            s && (s._muted = t, s._interval && i._stopFade(s._id), i._webAudio && s._node ? s._node.gain.setValueAtTime(t ? 0 : s._volume, o.ctx.currentTime) : s._node && (s._node.muted = !!o._muted || t), i._emit("mute", s._id))
                        }
                        return i
                    },
                    volume: function () {
                        var t, e, i, n = this,
                            r = arguments;
                        if (0 === r.length) return n._volume;
                        if (1 === r.length || 2 === r.length && void 0 === r[1] ? n._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0]) : r.length >= 2 && (t = parseFloat(r[0]), e = parseInt(r[1], 10)), !(void 0 !== t && t >= 0 && t <= 1)) return (i = e ? n._soundById(e) : n._sounds[0]) ? i._volume : 0;
                        if ("loaded" !== n._state || n._playLock) return n._queue.push({
                            event: "volume",
                            action: function () {
                                n.volume.apply(n, r)
                            }
                        }), n;
                        void 0 === e && (n._volume = t), e = n._getSoundIds(e);
                        for (var s = 0; s < e.length; s++)(i = n._soundById(e[s])) && (i._volume = t, r[2] || n._stopFade(e[s]), n._webAudio && i._node && !i._muted ? i._node.gain.setValueAtTime(t, o.ctx.currentTime) : i._node && !i._muted && (i._node.volume = t * o.volume()), n._emit("volume", i._id));
                        return n
                    },
                    fade: function (t, e, i, n) {
                        var r = this;
                        if ("loaded" !== r._state || r._playLock) return r._queue.push({
                            event: "fade",
                            action: function () {
                                r.fade(t, e, i, n)
                            }
                        }), r;
                        t = Math.min(Math.max(0, parseFloat(t)), 1), e = Math.min(Math.max(0, parseFloat(e)), 1), i = parseFloat(i), r.volume(t, n);
                        for (var s = r._getSoundIds(n), a = 0; a < s.length; a++) {
                            var l = r._soundById(s[a]);
                            if (l) {
                                if (n || r._stopFade(s[a]), r._webAudio && !l._muted) {
                                    var h = o.ctx.currentTime,
                                        u = h + i / 1e3;
                                    l._volume = t, l._node.gain.setValueAtTime(t, h), l._node.gain.linearRampToValueAtTime(e, u)
                                }
                                r._startFadeInterval(l, t, e, i, s[a], void 0 === n)
                            }
                        }
                        return r
                    },
                    _startFadeInterval: function (t, e, i, n, r, o) {
                        var s = this,
                            a = e,
                            l = i - e,
                            h = Math.abs(l / .01),
                            u = Math.max(4, h > 0 ? n / h : n),
                            c = Date.now();
                        t._fadeTo = i, t._interval = setInterval((function () {
                            var r = (Date.now() - c) / n;
                            c = Date.now(), a += l * r, a = Math.round(100 * a) / 100, a = l < 0 ? Math.max(i, a) : Math.min(i, a), s._webAudio ? t._volume = a : s.volume(a, t._id, !0), o && (s._volume = a), (i < e && a <= i || i > e && a >= i) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, s.volume(i, t._id), s._emit("fade", t._id))
                        }), u)
                    },
                    _stopFade: function (t) {
                        var e = this,
                            i = e._soundById(t);
                        return i && i._interval && (e._webAudio && i._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(i._interval), i._interval = null, e.volume(i._fadeTo, t), i._fadeTo = null, e._emit("fade", t)), e
                    },
                    loop: function () {
                        var t, e, i, n = this,
                            r = arguments;
                        if (0 === r.length) return n._loop;
                        if (1 === r.length) {
                            if ("boolean" != typeof r[0]) return !!(i = n._soundById(parseInt(r[0], 10))) && i._loop;
                            t = r[0], n._loop = t
                        } else 2 === r.length && (t = r[0], e = parseInt(r[1], 10));
                        for (var o = n._getSoundIds(e), s = 0; s < o.length; s++)(i = n._soundById(o[s])) && (i._loop = t, n._webAudio && i._node && i._node.bufferSource && (i._node.bufferSource.loop = t, t && (i._node.bufferSource.loopStart = i._start || 0, i._node.bufferSource.loopEnd = i._stop)));
                        return n
                    },
                    rate: function () {
                        var t, e, i, n = this,
                            r = arguments;
                        if (0 === r.length ? e = n._sounds[0]._id : 1 === r.length ? n._getSoundIds().indexOf(r[0]) >= 0 ? e = parseInt(r[0], 10) : t = parseFloat(r[0]) : 2 === r.length && (t = parseFloat(r[0]), e = parseInt(r[1], 10)), "number" != typeof t) return (i = n._soundById(e)) ? i._rate : n._rate;
                        if ("loaded" !== n._state || n._playLock) return n._queue.push({
                            event: "rate",
                            action: function () {
                                n.rate.apply(n, r)
                            }
                        }), n;
                        void 0 === e && (n._rate = t), e = n._getSoundIds(e);
                        for (var s = 0; s < e.length; s++)
                            if (i = n._soundById(e[s])) {
                                n.playing(e[s]) && (i._rateSeek = n.seek(e[s]), i._playStart = n._webAudio ? o.ctx.currentTime : i._playStart), i._rate = t, n._webAudio && i._node && i._node.bufferSource ? i._node.bufferSource.playbackRate.setValueAtTime(t, o.ctx.currentTime) : i._node && (i._node.playbackRate = t);
                                var a = n.seek(e[s]),
                                    l = 1e3 * ((n._sprite[i._sprite][0] + n._sprite[i._sprite][1]) / 1e3 - a) / Math.abs(i._rate);
                                !n._endTimers[e[s]] && i._paused || (n._clearTimer(e[s]), n._endTimers[e[s]] = setTimeout(n._ended.bind(n, i), l)), n._emit("rate", i._id)
                            } return n
                    },
                    seek: function () {
                        var t, e, i = this,
                            n = arguments;
                        if (0 === n.length ? e = i._sounds[0]._id : 1 === n.length ? i._getSoundIds().indexOf(n[0]) >= 0 ? e = parseInt(n[0], 10) : i._sounds.length && (e = i._sounds[0]._id, t = parseFloat(n[0])) : 2 === n.length && (t = parseFloat(n[0]), e = parseInt(n[1], 10)), void 0 === e) return i;
                        if ("number" == typeof t && ("loaded" !== i._state || i._playLock)) return i._queue.push({
                            event: "seek",
                            action: function () {
                                i.seek.apply(i, n)
                            }
                        }), i;
                        var r = i._soundById(e);
                        if (r) {
                            if (!("number" == typeof t && t >= 0)) {
                                if (i._webAudio) {
                                    var s = i.playing(e) ? o.ctx.currentTime - r._playStart : 0,
                                        a = r._rateSeek ? r._rateSeek - r._seek : 0;
                                    return r._seek + (a + s * Math.abs(r._rate))
                                }
                                return r._node.currentTime
                            }
                            var l = i.playing(e);
                            l && i.pause(e, !0), r._seek = t, r._ended = !1, i._clearTimer(e), i._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = t);
                            var h = function () {
                                i._emit("seek", e), l && i.play(e, !0)
                            };
                            if (l && !i._webAudio) {
                                var u = function () {
                                    i._playLock ? setTimeout(u, 0) : h()
                                };
                                setTimeout(u, 0)
                            } else h()
                        }
                        return i
                    },
                    playing: function (t) {
                        var e = this;
                        if ("number" == typeof t) {
                            var i = e._soundById(t);
                            return !!i && !i._paused
                        }
                        for (var n = 0; n < e._sounds.length; n++)
                            if (!e._sounds[n]._paused) return !0;
                        return !1
                    },
                    duration: function (t) {
                        var e = this,
                            i = e._duration,
                            n = e._soundById(t);
                        return n && (i = e._sprite[n._sprite][1] / 1e3), i
                    },
                    state: function () {
                        return this._state
                    },
                    unload: function () {
                        for (var t = this, e = t._sounds, i = 0; i < e.length; i++) e[i]._paused || t.stop(e[i]._id), t._webAudio || (t._clearSound(e[i]._node), e[i]._node.removeEventListener("error", e[i]._errorFn, !1), e[i]._node.removeEventListener(o._canPlayEvent, e[i]._loadFn, !1), e[i]._node.removeEventListener("ended", e[i]._endFn, !1), o._releaseHtml5Audio(e[i]._node)), delete e[i]._node, t._clearTimer(e[i]._id);
                        var n = o._howls.indexOf(t);
                        n >= 0 && o._howls.splice(n, 1);
                        var r = !0;
                        for (i = 0; i < o._howls.length; i++)
                            if (o._howls[i]._src === t._src || t._src.indexOf(o._howls[i]._src) >= 0) {
                                r = !1;
                                break
                            } return l && r && delete l[t._src], o.noAudio = !1, t._state = "unloaded", t._sounds = [], t = null, null
                    },
                    on: function (t, e, i, n) {
                        var r = this["_on" + t];
                        return "function" == typeof e && r.push(n ? {
                            id: i,
                            fn: e,
                            once: n
                        } : {
                            id: i,
                            fn: e
                        }), this
                    },
                    off: function (t, e, i) {
                        var n = this,
                            r = n["_on" + t],
                            o = 0;
                        if ("number" == typeof e && (i = e, e = null), e || i)
                            for (o = 0; o < r.length; o++) {
                                var s = i === r[o].id;
                                if (e === r[o].fn && s || !e && s) {
                                    r.splice(o, 1);
                                    break
                                }
                            } else if (t) n["_on" + t] = [];
                        else {
                            var a = Object.keys(n);
                            for (o = 0; o < a.length; o++) 0 === a[o].indexOf("_on") && Array.isArray(n[a[o]]) && (n[a[o]] = [])
                        } return n
                    },
                    once: function (t, e, i) {
                        return this.on(t, e, i, 1), this
                    },
                    _emit: function (t, e, i) {
                        for (var n = this, r = n["_on" + t], o = r.length - 1; o >= 0; o--) r[o].id && r[o].id !== e && "load" !== t || (setTimeout(function (t) {
                            t.call(this, e, i)
                        }.bind(n, r[o].fn), 0), r[o].once && n.off(t, r[o].fn, r[o].id));
                        return n._loadQueue(t), n
                    },
                    _loadQueue: function (t) {
                        var e = this;
                        if (e._queue.length > 0) {
                            var i = e._queue[0];
                            i.event === t && (e._queue.shift(), e._loadQueue()), t || i.action()
                        }
                        return e
                    },
                    _ended: function (t) {
                        var e = this,
                            i = t._sprite;
                        if (!e._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(e._ended.bind(e, t), 100), e;
                        var n = !(!t._loop && !e._sprite[i][2]);
                        if (e._emit("end", t._id), !e._webAudio && n && e.stop(t._id, !0).play(t._id), e._webAudio && n) {
                            e._emit("play", t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = o.ctx.currentTime;
                            var r = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
                            e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), r)
                        }
                        return e._webAudio && !n && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, e._clearTimer(t._id), e._cleanBuffer(t._node), o._autoSuspend()), e._webAudio || n || e.stop(t._id, !0), e
                    },
                    _clearTimer: function (t) {
                        var e = this;
                        if (e._endTimers[t]) {
                            if ("function" != typeof e._endTimers[t]) clearTimeout(e._endTimers[t]);
                            else {
                                var i = e._soundById(t);
                                i && i._node && i._node.removeEventListener("ended", e._endTimers[t], !1)
                            }
                            delete e._endTimers[t]
                        }
                        return e
                    },
                    _soundById: function (t) {
                        for (var e = this, i = 0; i < e._sounds.length; i++)
                            if (t === e._sounds[i]._id) return e._sounds[i];
                        return null
                    },
                    _inactiveSound: function () {
                        var t = this;
                        t._drain();
                        for (var e = 0; e < t._sounds.length; e++)
                            if (t._sounds[e]._ended) return t._sounds[e].reset();
                        return new a(t)
                    },
                    _drain: function () {
                        var t = this,
                            e = t._pool,
                            i = 0,
                            n = 0;
                        if (!(t._sounds.length < e)) {
                            for (n = 0; n < t._sounds.length; n++) t._sounds[n]._ended && i++;
                            for (n = t._sounds.length - 1; n >= 0; n--) {
                                if (i <= e) return;
                                t._sounds[n]._ended && (t._webAudio && t._sounds[n]._node && t._sounds[n]._node.disconnect(0), t._sounds.splice(n, 1), i--)
                            }
                        }
                    },
                    _getSoundIds: function (t) {
                        if (void 0 === t) {
                            for (var e = [], i = 0; i < this._sounds.length; i++) e.push(this._sounds[i]._id);
                            return e
                        }
                        return [t]
                    },
                    _refreshBuffer: function (t) {
                        return t._node.bufferSource = o.ctx.createBufferSource(), t._node.bufferSource.buffer = l[this._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, o.ctx.currentTime), this
                    },
                    _cleanBuffer: function (t) {
                        var e = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
                        if (o._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), e)) try {
                            t.bufferSource.buffer = o._scratchBuffer
                        } catch (t) { }
                        return t.bufferSource = null, this
                    },
                    _clearSound: function (t) {
                        /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (t.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                    }
                };
                var a = function (t) {
                    this._parent = t, this.init()
                };
                a.prototype = {
                    init: function () {
                        var t = this,
                            e = t._parent;
                        return t._muted = e._muted, t._loop = e._loop, t._volume = e._volume, t._rate = e._rate, t._seek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++o._counter, e._sounds.push(t), t.create(), t
                    },
                    create: function () {
                        var t = this,
                            e = t._parent,
                            i = o._muted || t._muted || t._parent._muted ? 0 : t._volume;
                        return e._webAudio ? (t._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), t._node.gain.setValueAtTime(i, o.ctx.currentTime), t._node.paused = !0, t._node.connect(o.masterGain)) : o.noAudio || (t._node = o._obtainHtml5Audio(), t._errorFn = t._errorListener.bind(t), t._node.addEventListener("error", t._errorFn, !1), t._loadFn = t._loadListener.bind(t), t._node.addEventListener(o._canPlayEvent, t._loadFn, !1), t._endFn = t._endListener.bind(t), t._node.addEventListener("ended", t._endFn, !1), t._node.src = e._src, t._node.preload = !0 === e._preload ? "auto" : e._preload, t._node.volume = i * o.volume(), t._node.load()), t
                    },
                    reset: function () {
                        var t = this,
                            e = t._parent;
                        return t._muted = e._muted, t._loop = e._loop, t._volume = e._volume, t._rate = e._rate, t._seek = 0, t._rateSeek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++o._counter, t
                    },
                    _errorListener: function () {
                        var t = this;
                        t._parent._emit("loaderror", t._id, t._node.error ? t._node.error.code : 0), t._node.removeEventListener("error", t._errorFn, !1)
                    },
                    _loadListener: function () {
                        var t = this,
                            e = t._parent;
                        e._duration = Math.ceil(10 * t._node.duration) / 10, 0 === Object.keys(e._sprite).length && (e._sprite = {
                            __default: [0, 1e3 * e._duration]
                        }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()), t._node.removeEventListener(o._canPlayEvent, t._loadFn, !1)
                    },
                    _endListener: function () {
                        var t = this,
                            e = t._parent;
                        e._duration === 1 / 0 && (e._duration = Math.ceil(10 * t._node.duration) / 10, e._sprite.__default[1] === 1 / 0 && (e._sprite.__default[1] = 1e3 * e._duration), e._ended(t)), t._node.removeEventListener("ended", t._endFn, !1)
                    }
                };
                var l = {},
                    h = function (t) {
                        var e = t._src;
                        if (l[e]) return t._duration = l[e].duration, void d(t);
                        if (/^data:[^;]+;base64,/.test(e)) {
                            for (var i = atob(e.split(",")[1]), n = new Uint8Array(i.length), r = 0; r < i.length; ++r) n[r] = i.charCodeAt(r);
                            c(n.buffer, t)
                        } else {
                            var o = new XMLHttpRequest;
                            o.open(t._xhr.method, e, !0), o.withCredentials = t._xhr.withCredentials, o.responseType = "arraybuffer", t._xhr.headers && Object.keys(t._xhr.headers).forEach((function (e) {
                                o.setRequestHeader(e, t._xhr.headers[e])
                            })), o.onload = function () {
                                var e = (o.status + "")[0];
                                "0" === e || "2" === e || "3" === e ? c(o.response, t) : t._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".")
                            }, o.onerror = function () {
                                t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete l[e], t.load())
                            }, u(o)
                        }
                    },
                    u = function (t) {
                        try {
                            t.send()
                        } catch (e) {
                            t.onerror()
                        }
                    },
                    c = function (t, e) {
                        var i = function () {
                            e._emit("loaderror", null, "Decoding audio data failed.")
                        },
                            n = function (t) {
                                t && e._sounds.length > 0 ? (l[e._src] = t, d(e, t)) : i()
                            };
                        "undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(t).then(n).catch(i) : o.ctx.decodeAudioData(t, n, i)
                    },
                    d = function (t, e) {
                        e && !t._duration && (t._duration = e.duration), 0 === Object.keys(t._sprite).length && (t._sprite = {
                            __default: [0, 1e3 * t._duration]
                        }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue())
                    },
                    p = function () {
                        if (o.usingWebAudio) {
                            try {
                                "undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1
                            } catch (t) {
                                o.usingWebAudio = !1
                            }
                            o.ctx || (o.usingWebAudio = !1);
                            var t = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform),
                                e = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                i = e ? parseInt(e[1], 10) : null;
                            if (t && i && i < 9) {
                                var n = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                                o._navigator && !n && (o.usingWebAudio = !1)
                            }
                            o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
                        }
                    };
                void 0 === (n = function () {
                    return {
                        Howler: o,
                        Howl: s
                    }
                }.apply(e, [])) || (t.exports = n), e.Howler = o, e.Howl = s, void 0 !== i.g ? (i.g.HowlerGlobal = r, i.g.Howler = o, i.g.Howl = s, i.g.Sound = a) : "undefined" != typeof window && (window.HowlerGlobal = r, window.Howler = o, window.Howl = s, window.Sound = a)
            }(),
                function () {
                    "use strict";
                    var t;
                    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (t) {
                        var e = this;
                        if (!e.ctx || !e.ctx.listener) return e;
                        for (var i = e._howls.length - 1; i >= 0; i--) e._howls[i].stereo(t);
                        return e
                    }, HowlerGlobal.prototype.pos = function (t, e, i) {
                        var n = this;
                        return n.ctx && n.ctx.listener ? (e = "number" != typeof e ? n._pos[1] : e, i = "number" != typeof i ? n._pos[2] : i, "number" != typeof t ? n._pos : (n._pos = [t, e, i], void 0 !== n.ctx.listener.positionX ? (n.ctx.listener.positionX.setTargetAtTime(n._pos[0], Howler.ctx.currentTime, .1), n.ctx.listener.positionY.setTargetAtTime(n._pos[1], Howler.ctx.currentTime, .1), n.ctx.listener.positionZ.setTargetAtTime(n._pos[2], Howler.ctx.currentTime, .1)) : n.ctx.listener.setPosition(n._pos[0], n._pos[1], n._pos[2]), n)) : n
                    }, HowlerGlobal.prototype.orientation = function (t, e, i, n, r, o) {
                        var s = this;
                        if (!s.ctx || !s.ctx.listener) return s;
                        var a = s._orientation;
                        return e = "number" != typeof e ? a[1] : e, i = "number" != typeof i ? a[2] : i, n = "number" != typeof n ? a[3] : n, r = "number" != typeof r ? a[4] : r, o = "number" != typeof o ? a[5] : o, "number" != typeof t ? a : (s._orientation = [t, e, i, n, r, o], void 0 !== s.ctx.listener.forwardX ? (s.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), s.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), s.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, .1), s.ctx.listener.upX.setTargetAtTime(n, Howler.ctx.currentTime, .1), s.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, .1), s.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : s.ctx.listener.setOrientation(t, e, i, n, r, o), s)
                    }, Howl.prototype.init = (t = Howl.prototype.init, function (e) {
                        var i = this;
                        return i._orientation = e.orientation || [1, 0, 0], i._stereo = e.stereo || null, i._pos = e.pos || null, i._pannerAttr = {
                            coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360,
                            coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360,
                            coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0,
                            distanceModel: void 0 !== e.distanceModel ? e.distanceModel : "inverse",
                            maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4,
                            panningModel: void 0 !== e.panningModel ? e.panningModel : "HRTF",
                            refDistance: void 0 !== e.refDistance ? e.refDistance : 1,
                            rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1
                        }, i._onstereo = e.onstereo ? [{
                            fn: e.onstereo
                        }] : [], i._onpos = e.onpos ? [{
                            fn: e.onpos
                        }] : [], i._onorientation = e.onorientation ? [{
                            fn: e.onorientation
                        }] : [], t.call(this, e)
                    }), Howl.prototype.stereo = function (t, i) {
                        var n = this;
                        if (!n._webAudio) return n;
                        if ("loaded" !== n._state) return n._queue.push({
                            event: "stereo",
                            action: function () {
                                n.stereo(t, i)
                            }
                        }), n;
                        var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                        if (void 0 === i) {
                            if ("number" != typeof t) return n._stereo;
                            n._stereo = t, n._pos = [t, 0, 0]
                        }
                        for (var o = n._getSoundIds(i), s = 0; s < o.length; s++) {
                            var a = n._soundById(o[s]);
                            if (a) {
                                if ("number" != typeof t) return a._stereo;
                                a._stereo = t, a._pos = [t, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || e(a, r), "spatial" === r ? void 0 !== a._panner.positionX ? (a._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(t, 0, 0) : a._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)), n._emit("stereo", a._id)
                            }
                        }
                        return n
                    }, Howl.prototype.pos = function (t, i, n, r) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({
                            event: "pos",
                            action: function () {
                                o.pos(t, i, n, r)
                            }
                        }), o;
                        if (i = "number" != typeof i ? 0 : i, n = "number" != typeof n ? -.5 : n, void 0 === r) {
                            if ("number" != typeof t) return o._pos;
                            o._pos = [t, i, n]
                        }
                        for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
                            var l = o._soundById(s[a]);
                            if (l) {
                                if ("number" != typeof t) return l._pos;
                                l._pos = [t, i, n], l._node && (l._panner && !l._panner.pan || e(l, "spatial"), void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(i, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(n, Howler.ctx.currentTime)) : l._panner.setPosition(t, i, n)), o._emit("pos", l._id)
                            }
                        }
                        return o
                    }, Howl.prototype.orientation = function (t, i, n, r) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({
                            event: "orientation",
                            action: function () {
                                o.orientation(t, i, n, r)
                            }
                        }), o;
                        if (i = "number" != typeof i ? o._orientation[1] : i, n = "number" != typeof n ? o._orientation[2] : n, void 0 === r) {
                            if ("number" != typeof t) return o._orientation;
                            o._orientation = [t, i, n]
                        }
                        for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
                            var l = o._soundById(s[a]);
                            if (l) {
                                if ("number" != typeof t) return l._orientation;
                                l._orientation = [t, i, n], l._node && (l._panner || (l._pos || (l._pos = o._pos || [0, 0, -.5]), e(l, "spatial")), void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(i, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(n, Howler.ctx.currentTime)) : l._panner.setOrientation(t, i, n)), o._emit("orientation", l._id)
                            }
                        }
                        return o
                    }, Howl.prototype.pannerAttr = function () {
                        var t, i, n, r = this,
                            o = arguments;
                        if (!r._webAudio) return r;
                        if (0 === o.length) return r._pannerAttr;
                        if (1 === o.length) {
                            if ("object" != typeof o[0]) return (n = r._soundById(parseInt(o[0], 10))) ? n._pannerAttr : r._pannerAttr;
                            t = o[0], void 0 === i && (t.pannerAttr || (t.pannerAttr = {
                                coneInnerAngle: t.coneInnerAngle,
                                coneOuterAngle: t.coneOuterAngle,
                                coneOuterGain: t.coneOuterGain,
                                distanceModel: t.distanceModel,
                                maxDistance: t.maxDistance,
                                refDistance: t.refDistance,
                                rolloffFactor: t.rolloffFactor,
                                panningModel: t.panningModel
                            }), r._pannerAttr = {
                                coneInnerAngle: void 0 !== t.pannerAttr.coneInnerAngle ? t.pannerAttr.coneInnerAngle : r._coneInnerAngle,
                                coneOuterAngle: void 0 !== t.pannerAttr.coneOuterAngle ? t.pannerAttr.coneOuterAngle : r._coneOuterAngle,
                                coneOuterGain: void 0 !== t.pannerAttr.coneOuterGain ? t.pannerAttr.coneOuterGain : r._coneOuterGain,
                                distanceModel: void 0 !== t.pannerAttr.distanceModel ? t.pannerAttr.distanceModel : r._distanceModel,
                                maxDistance: void 0 !== t.pannerAttr.maxDistance ? t.pannerAttr.maxDistance : r._maxDistance,
                                refDistance: void 0 !== t.pannerAttr.refDistance ? t.pannerAttr.refDistance : r._refDistance,
                                rolloffFactor: void 0 !== t.pannerAttr.rolloffFactor ? t.pannerAttr.rolloffFactor : r._rolloffFactor,
                                panningModel: void 0 !== t.pannerAttr.panningModel ? t.pannerAttr.panningModel : r._panningModel
                            })
                        } else 2 === o.length && (t = o[0], i = parseInt(o[1], 10));
                        for (var s = r._getSoundIds(i), a = 0; a < s.length; a++)
                            if (n = r._soundById(s[a])) {
                                var l = n._pannerAttr;
                                l = {
                                    coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : l.coneInnerAngle,
                                    coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : l.coneOuterAngle,
                                    coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : l.coneOuterGain,
                                    distanceModel: void 0 !== t.distanceModel ? t.distanceModel : l.distanceModel,
                                    maxDistance: void 0 !== t.maxDistance ? t.maxDistance : l.maxDistance,
                                    refDistance: void 0 !== t.refDistance ? t.refDistance : l.refDistance,
                                    rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : l.rolloffFactor,
                                    panningModel: void 0 !== t.panningModel ? t.panningModel : l.panningModel
                                };
                                var h = n._panner;
                                h ? (h.coneInnerAngle = l.coneInnerAngle, h.coneOuterAngle = l.coneOuterAngle, h.coneOuterGain = l.coneOuterGain, h.distanceModel = l.distanceModel, h.maxDistance = l.maxDistance, h.refDistance = l.refDistance, h.rolloffFactor = l.rolloffFactor, h.panningModel = l.panningModel) : (n._pos || (n._pos = r._pos || [0, 0, -.5]), e(n, "spatial"))
                            } return r
                    }, Sound.prototype.init = function (t) {
                        return function () {
                            var e = this,
                                i = e._parent;
                            e._orientation = i._orientation, e._stereo = i._stereo, e._pos = i._pos, e._pannerAttr = i._pannerAttr, t.call(this), e._stereo ? i.stereo(e._stereo) : e._pos && i.pos(e._pos[0], e._pos[1], e._pos[2], e._id)
                        }
                    }(Sound.prototype.init), Sound.prototype.reset = function (t) {
                        return function () {
                            var e = this,
                                i = e._parent;
                            return e._orientation = i._orientation, e._stereo = i._stereo, e._pos = i._pos, e._pannerAttr = i._pannerAttr, e._stereo ? i.stereo(e._stereo) : e._pos ? i.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, i._refreshBuffer(e)), t.call(this)
                        }
                    }(Sound.prototype.reset);
                    var e = function (t, e) {
                        "spatial" === (e = e || "spatial") ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, void 0 !== t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), void 0 !== t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0)
                    }
                }()
        },
        5299: (t, e, i) => {
            "use strict";
            var n = i(7798);

            function r(t) {
                return !0 === n(t) && "[object Object]" === Object.prototype.toString.call(t)
            }
            t.exports = function (t) {
                var e, i;
                return !1 !== r(t) && "function" == typeof (e = t.constructor) && !1 !== r(i = e.prototype) && !1 !== i.hasOwnProperty("isPrototypeOf")
            }
        },
        7798: t => {
            "use strict";
            t.exports = function (t) {
                return null != t && "object" == typeof t && !1 === Array.isArray(t)
            }
        },
        6808: (t, e, i) => {
            var n, r, o;
            void 0 === (r = "function" == typeof (n = o = function () {
                function t() {
                    for (var t = 0, e = {}; t < arguments.length; t++) {
                        var i = arguments[t];
                        for (var n in i) e[n] = i[n]
                    }
                    return e
                }

                function e(t) {
                    return t.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent)
                }
                return function i(n) {
                    function r() { }

                    function o(e, i, o) {
                        if ("undefined" != typeof document) {
                            "number" == typeof (o = t({
                                path: "/"
                            }, r.defaults, o)).expires && (o.expires = new Date(1 * new Date + 864e5 * o.expires)), o.expires = o.expires ? o.expires.toUTCString() : "";
                            try {
                                var s = JSON.stringify(i);
                                /^[\{\[]/.test(s) && (i = s)
                            } catch (t) { }
                            i = n.write ? n.write(i, e) : encodeURIComponent(String(i)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent), e = encodeURIComponent(String(e)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
                            var a = "";
                            for (var l in o) o[l] && (a += "; " + l, !0 !== o[l] && (a += "=" + o[l].split(";")[0]));
                            return document.cookie = e + "=" + i + a
                        }
                    }

                    function s(t, i) {
                        if ("undefined" != typeof document) {
                            for (var r = {}, o = document.cookie ? document.cookie.split("; ") : [], s = 0; s < o.length; s++) {
                                var a = o[s].split("="),
                                    l = a.slice(1).join("=");
                                i || '"' !== l.charAt(0) || (l = l.slice(1, -1));
                                try {
                                    var h = e(a[0]);
                                    if (l = (n.read || n)(l, h) || e(l), i) try {
                                        l = JSON.parse(l)
                                    } catch (t) { }
                                    if (r[h] = l, t === h) break
                                } catch (t) { }
                            }
                            return t ? r[t] : r
                        }
                    }
                    return r.set = o, r.get = function (t) {
                        return s(t, !1)
                    }, r.getJSON = function (t) {
                        return s(t, !0)
                    }, r.remove = function (e, i) {
                        o(e, "", t(i, {
                            expires: -1
                        }))
                    }, r.defaults = {}, r.withConverter = i, r
                }((function () { }))
            }) ? n.call(e, i, e, t) : n) || (t.exports = r), t.exports = o()
        },
        8565: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            class i extends Error { }
            class n extends i {
                constructor(t) {
                    super(`Invalid DateTime: ${t.toMessage()}`)
                }
            }
            class r extends i {
                constructor(t) {
                    super(`Invalid Interval: ${t.toMessage()}`)
                }
            }
            class o extends i {
                constructor(t) {
                    super(`Invalid Duration: ${t.toMessage()}`)
                }
            }
            class s extends i { }
            class a extends i {
                constructor(t) {
                    super(`Invalid unit ${t}`)
                }
            }
            class l extends i { }
            class h extends i {
                constructor() {
                    super("Zone is an abstract class")
                }
            }
            const u = "numeric",
                c = "short",
                d = "long",
                p = {
                    year: u,
                    month: u,
                    day: u
                },
                f = {
                    year: u,
                    month: c,
                    day: u
                },
                g = {
                    year: u,
                    month: c,
                    day: u,
                    weekday: c
                },
                m = {
                    year: u,
                    month: d,
                    day: u
                },
                _ = {
                    year: u,
                    month: d,
                    day: u,
                    weekday: d
                },
                y = {
                    hour: u,
                    minute: u
                },
                S = {
                    hour: u,
                    minute: u,
                    second: u
                },
                v = {
                    hour: u,
                    minute: u,
                    second: u,
                    timeZoneName: c
                },
                b = {
                    hour: u,
                    minute: u,
                    second: u,
                    timeZoneName: d
                },
                T = {
                    hour: u,
                    minute: u,
                    hourCycle: "h23"
                },
                P = {
                    hour: u,
                    minute: u,
                    second: u,
                    hourCycle: "h23"
                },
                A = {
                    hour: u,
                    minute: u,
                    second: u,
                    hourCycle: "h23",
                    timeZoneName: c
                },
                I = {
                    hour: u,
                    minute: u,
                    second: u,
                    hourCycle: "h23",
                    timeZoneName: d
                },
                w = {
                    year: u,
                    month: u,
                    day: u,
                    hour: u,
                    minute: u
                },
                E = {
                    year: u,
                    month: u,
                    day: u,
                    hour: u,
                    minute: u,
                    second: u
                },
                C = {
                    year: u,
                    month: c,
                    day: u,
                    hour: u,
                    minute: u
                },
                x = {
                    year: u,
                    month: c,
                    day: u,
                    hour: u,
                    minute: u,
                    second: u
                },
                B = {
                    year: u,
                    month: c,
                    day: u,
                    weekday: c,
                    hour: u,
                    minute: u
                },
                L = {
                    year: u,
                    month: d,
                    day: u,
                    hour: u,
                    minute: u,
                    timeZoneName: c
                },
                O = {
                    year: u,
                    month: d,
                    day: u,
                    hour: u,
                    minute: u,
                    second: u,
                    timeZoneName: c
                },
                N = {
                    year: u,
                    month: d,
                    day: u,
                    weekday: d,
                    hour: u,
                    minute: u,
                    timeZoneName: d
                },
                M = {
                    year: u,
                    month: d,
                    day: u,
                    weekday: d,
                    hour: u,
                    minute: u,
                    second: u,
                    timeZoneName: d
                };
            class R {
                get type() {
                    throw new h
                }
                get name() {
                    throw new h
                }
                get ianaName() {
                    return this.name
                }
                get isUniversal() {
                    throw new h
                }
                offsetName(t, e) {
                    throw new h
                }
                formatOffset(t, e) {
                    throw new h
                }
                offset(t) {
                    throw new h
                }
                equals(t) {
                    throw new h
                }
                get isValid() {
                    throw new h
                }
            }
            let D = null;
            class F extends R {
                static get instance() {
                    return null === D && (D = new F), D
                }
                get type() {
                    return "system"
                }
                get name() {
                    return (new Intl.DateTimeFormat).resolvedOptions().timeZone
                }
                get isUniversal() {
                    return !1
                }
                offsetName(t, {
                    format: e,
                    locale: i
                }) {
                    return xt(t, e, i)
                }
                formatOffset(t, e) {
                    return Nt(this.offset(t), e)
                }
                offset(t) {
                    return -new Date(t).getTimezoneOffset()
                }
                equals(t) {
                    return "system" === t.type
                }
                get isValid() {
                    return !0
                }
            }
            let k = {};
            const U = {
                year: 0,
                month: 1,
                day: 2,
                era: 3,
                hour: 4,
                minute: 5,
                second: 6
            };
            let G = {};
            class W extends R {
                static create(t) {
                    return G[t] || (G[t] = new W(t)), G[t]
                }
                static resetCache() {
                    G = {}, k = {}
                }
                static isValidSpecifier(t) {
                    return this.isValidZone(t)
                }
                static isValidZone(t) {
                    if (!t) return !1;
                    try {
                        return new Intl.DateTimeFormat("en-US", {
                            timeZone: t
                        }).format(), !0
                    } catch (t) {
                        return !1
                    }
                }
                constructor(t) {
                    super(), this.zoneName = t, this.valid = W.isValidZone(t)
                }
                get type() {
                    return "iana"
                }
                get name() {
                    return this.zoneName
                }
                get isUniversal() {
                    return !1
                }
                offsetName(t, {
                    format: e,
                    locale: i
                }) {
                    return xt(t, e, i, this.name)
                }
                formatOffset(t, e) {
                    return Nt(this.offset(t), e)
                }
                offset(t) {
                    const e = new Date(t);
                    if (isNaN(e)) return NaN;
                    const i = (n = this.name, k[n] || (k[n] = new Intl.DateTimeFormat("en-US", {
                        hour12: !1,
                        timeZone: n,
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit",
                        era: "short"
                    })), k[n]);
                    var n;
                    let [r, o, s, a, l, h, u] = i.formatToParts ? function (t, e) {
                        const i = t.formatToParts(e),
                            n = [];
                        for (let t = 0; t < i.length; t++) {
                            const {
                                type: e,
                                value: r
                            } = i[t], o = U[e];
                            "era" === e ? n[o] = r : ct(o) || (n[o] = parseInt(r, 10))
                        }
                        return n
                    }(i, e) : function (t, e) {
                        const i = t.format(e).replace(/\u200E/g, ""),
                            n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(i),
                            [, r, o, s, a, l, h, u] = n;
                        return [s, r, o, a, l, h, u]
                    }(i, e);
                    "BC" === a && (r = 1 - Math.abs(r));
                    let c = +e;
                    const d = c % 1e3;
                    return c -= d >= 0 ? d : 1e3 + d, (wt({
                        year: r,
                        month: o,
                        day: s,
                        hour: 24 === l ? 0 : l,
                        minute: h,
                        second: u,
                        millisecond: 0
                    }) - c) / 6e4
                }
                equals(t) {
                    return "iana" === t.type && t.name === this.name
                }
                get isValid() {
                    return this.valid
                }
            }
            let V = {},
                X = {};

            function H(t, e = {}) {
                const i = JSON.stringify([t, e]);
                let n = X[i];
                return n || (n = new Intl.DateTimeFormat(t, e), X[i] = n), n
            }
            let Y = {},
                j = {},
                z = null;

            function K(t, e, i, n, r) {
                const o = t.listingMode(i);
                return "error" === o ? null : "en" === o ? n(e) : r(e)
            }
            class q {
                constructor(t, e, i) {
                    this.padTo = i.padTo || 0, this.floor = i.floor || !1;
                    const {
                        padTo: n,
                        floor: r,
                        ...o
                    } = i;
                    if (!e || Object.keys(o).length > 0) {
                        const e = {
                            useGrouping: !1,
                            ...i
                        };
                        i.padTo > 0 && (e.minimumIntegerDigits = i.padTo), this.inf = function (t, e = {}) {
                            const i = JSON.stringify([t, e]);
                            let n = Y[i];
                            return n || (n = new Intl.NumberFormat(t, e), Y[i] = n), n
                        }(t, e)
                    }
                }
                format(t) {
                    if (this.inf) {
                        const e = this.floor ? Math.floor(t) : t;
                        return this.inf.format(e)
                    }
                    return yt(this.floor ? Math.floor(t) : Tt(t, 3), this.padTo)
                }
            }
            class Z {
                constructor(t, e, i) {
                    let n;
                    if (this.opts = i, this.originalZone = void 0, this.opts.timeZone) this.dt = t;
                    else if ("fixed" === t.zone.type) {
                        const e = t.offset / 60 * -1,
                            i = e >= 0 ? `Etc/GMT+${e}` : `Etc/GMT${e}`;
                        0 !== t.offset && W.create(i).valid ? (n = i, this.dt = t) : (n = "UTC", this.dt = 0 === t.offset ? t : t.setZone("UTC").plus({
                            minutes: t.offset
                        }), this.originalZone = t.zone)
                    } else "system" === t.zone.type ? this.dt = t : "iana" === t.zone.type ? (this.dt = t, n = t.zone.name) : (n = "UTC", this.dt = t.setZone("UTC").plus({
                        minutes: t.offset
                    }), this.originalZone = t.zone);
                    const r = {
                        ...this.opts
                    };
                    r.timeZone = r.timeZone || n, this.dtf = H(e, r)
                }
                format() {
                    return this.originalZone ? this.formatToParts().map((({
                        value: t
                    }) => t)).join("") : this.dtf.format(this.dt.toJSDate())
                }
                formatToParts() {
                    const t = this.dtf.formatToParts(this.dt.toJSDate());
                    return this.originalZone ? t.map((t => {
                        if ("timeZoneName" === t.type) {
                            const e = this.originalZone.offsetName(this.dt.ts, {
                                locale: this.dt.locale,
                                format: this.opts.timeZoneName
                            });
                            return {
                                ...t,
                                value: e
                            }
                        }
                        return t
                    })) : t
                }
                resolvedOptions() {
                    return this.dtf.resolvedOptions()
                }
            }
            class $ {
                constructor(t, e, i) {
                    this.opts = {
                        style: "long",
                        ...i
                    }, !e && ft() && (this.rtf = function (t, e = {}) {
                        const {
                            base: i,
                            ...n
                        } = e, r = JSON.stringify([t, n]);
                        let o = j[r];
                        return o || (o = new Intl.RelativeTimeFormat(t, e), j[r] = o), o
                    }(t, i))
                }
                format(t, e) {
                    return this.rtf ? this.rtf.format(t, e) : function (t, e, i = "always", n = !1) {
                        const r = {
                            years: ["year", "yr."],
                            quarters: ["quarter", "qtr."],
                            months: ["month", "mo."],
                            weeks: ["week", "wk."],
                            days: ["day", "day", "days"],
                            hours: ["hour", "hr."],
                            minutes: ["minute", "min."],
                            seconds: ["second", "sec."]
                        },
                            o = -1 === ["hours", "minutes", "seconds"].indexOf(t);
                        if ("auto" === i && o) {
                            const i = "days" === t;
                            switch (e) {
                                case 1:
                                    return i ? "tomorrow" : `next ${r[t][0]}`;
                                case -1:
                                    return i ? "yesterday" : `last ${r[t][0]}`;
                                case 0:
                                    return i ? "today" : `this ${r[t][0]}`
                            }
                        }
                        const s = Object.is(e, -0) || e < 0,
                            a = Math.abs(e),
                            l = 1 === a,
                            h = r[t],
                            u = n ? l ? h[1] : h[2] || h[1] : l ? r[t][0] : t;
                        return s ? `${a} ${u} ago` : `in ${a} ${u}`
                    }(e, t, this.opts.numeric, "long" !== this.opts.style)
                }
                formatToParts(t, e) {
                    return this.rtf ? this.rtf.formatToParts(t, e) : []
                }
            }
            class J {
                static fromOpts(t) {
                    return J.create(t.locale, t.numberingSystem, t.outputCalendar, t.defaultToEN)
                }
                static create(t, e, i, n = !1) {
                    const r = t || ut.defaultLocale,
                        o = r || (n ? "en-US" : z || (z = (new Intl.DateTimeFormat).resolvedOptions().locale, z)),
                        s = e || ut.defaultNumberingSystem,
                        a = i || ut.defaultOutputCalendar;
                    return new J(o, s, a, r)
                }
                static resetCache() {
                    z = null, X = {}, Y = {}, j = {}
                }
                static fromObject({
                    locale: t,
                    numberingSystem: e,
                    outputCalendar: i
                } = {}) {
                    return J.create(t, e, i)
                }
                constructor(t, e, i, n) {
                    const [r, o, s] = function (t) {
                        const e = t.indexOf("-x-"); - 1 !== e && (t = t.substring(0, e));
                        const i = t.indexOf("-u-");
                        if (-1 === i) return [t];
                        {
                            let e, n;
                            try {
                                e = H(t).resolvedOptions(), n = t
                            } catch (r) {
                                const o = t.substring(0, i);
                                e = H(o).resolvedOptions(), n = o
                            }
                            const {
                                numberingSystem: r,
                                calendar: o
                            } = e;
                            return [n, r, o]
                        }
                    }(t);
                    this.locale = r, this.numberingSystem = e || o || null, this.outputCalendar = i || s || null, this.intl = function (t, e, i) {
                        return i || e ? (t.includes("-u-") || (t += "-u"), i && (t += `-ca-${i}`), e && (t += `-nu-${e}`), t) : t
                    }(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = {
                        format: {},
                        standalone: {}
                    }, this.monthsCache = {
                        format: {},
                        standalone: {}
                    }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = n, this.fastNumbersCached = null
                }
                get fastNumbers() {
                    var t;
                    return null == this.fastNumbersCached && (this.fastNumbersCached = (!(t = this).numberingSystem || "latn" === t.numberingSystem) && ("latn" === t.numberingSystem || !t.locale || t.locale.startsWith("en") || "latn" === new Intl.DateTimeFormat(t.intl).resolvedOptions().numberingSystem)), this.fastNumbersCached
                }
                listingMode() {
                    const t = this.isEnglish(),
                        e = !(null !== this.numberingSystem && "latn" !== this.numberingSystem || null !== this.outputCalendar && "gregory" !== this.outputCalendar);
                    return t && e ? "en" : "intl"
                }
                clone(t) {
                    return t && 0 !== Object.getOwnPropertyNames(t).length ? J.create(t.locale || this.specifiedLocale, t.numberingSystem || this.numberingSystem, t.outputCalendar || this.outputCalendar, t.defaultToEN || !1) : this
                }
                redefaultToEN(t = {}) {
                    return this.clone({
                        ...t,
                        defaultToEN: !0
                    })
                }
                redefaultToSystem(t = {}) {
                    return this.clone({
                        ...t,
                        defaultToEN: !1
                    })
                }
                months(t, e = !1, i = !0) {
                    return K(this, t, i, kt, (() => {
                        const i = e ? {
                            month: t,
                            day: "numeric"
                        } : {
                            month: t
                        },
                            n = e ? "format" : "standalone";
                        return this.monthsCache[n][t] || (this.monthsCache[n][t] = function (t) {
                            const e = [];
                            for (let i = 1; i <= 12; i++) {
                                const n = qi.utc(2016, i, 1);
                                e.push(t(n))
                            }
                            return e
                        }((t => this.extract(t, i, "month")))), this.monthsCache[n][t]
                    }))
                }
                weekdays(t, e = !1, i = !0) {
                    return K(this, t, i, Vt, (() => {
                        const i = e ? {
                            weekday: t,
                            year: "numeric",
                            month: "long",
                            day: "numeric"
                        } : {
                            weekday: t
                        },
                            n = e ? "format" : "standalone";
                        return this.weekdaysCache[n][t] || (this.weekdaysCache[n][t] = function (t) {
                            const e = [];
                            for (let i = 1; i <= 7; i++) {
                                const n = qi.utc(2016, 11, 13 + i);
                                e.push(t(n))
                            }
                            return e
                        }((t => this.extract(t, i, "weekday")))), this.weekdaysCache[n][t]
                    }))
                }
                meridiems(t = !0) {
                    return K(this, void 0, t, (() => Xt), (() => {
                        if (!this.meridiemCache) {
                            const t = {
                                hour: "numeric",
                                hourCycle: "h12"
                            };
                            this.meridiemCache = [qi.utc(2016, 11, 13, 9), qi.utc(2016, 11, 13, 19)].map((e => this.extract(e, t, "dayperiod")))
                        }
                        return this.meridiemCache
                    }))
                }
                eras(t, e = !0) {
                    return K(this, t, e, zt, (() => {
                        const e = {
                            era: t
                        };
                        return this.eraCache[t] || (this.eraCache[t] = [qi.utc(-40, 1, 1), qi.utc(2017, 1, 1)].map((t => this.extract(t, e, "era")))), this.eraCache[t]
                    }))
                }
                extract(t, e, i) {
                    const n = this.dtFormatter(t, e).formatToParts().find((t => t.type.toLowerCase() === i));
                    return n ? n.value : null
                }
                numberFormatter(t = {}) {
                    return new q(this.intl, t.forceSimple || this.fastNumbers, t)
                }
                dtFormatter(t, e = {}) {
                    return new Z(t, this.intl, e)
                }
                relFormatter(t = {}) {
                    return new $(this.intl, this.isEnglish(), t)
                }
                listFormatter(t = {}) {
                    return function (t, e = {}) {
                        const i = JSON.stringify([t, e]);
                        let n = V[i];
                        return n || (n = new Intl.ListFormat(t, e), V[i] = n), n
                    }(this.intl, t)
                }
                isEnglish() {
                    return "en" === this.locale || "en-us" === this.locale.toLowerCase() || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us")
                }
                equals(t) {
                    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar
                }
            }
            let Q = null;
            class tt extends R {
                static get utcInstance() {
                    return null === Q && (Q = new tt(0)), Q
                }
                static instance(t) {
                    return 0 === t ? tt.utcInstance : new tt(t)
                }
                static parseSpecifier(t) {
                    if (t) {
                        const e = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
                        if (e) return new tt(Bt(e[1], e[2]))
                    }
                    return null
                }
                constructor(t) {
                    super(), this.fixed = t
                }
                get type() {
                    return "fixed"
                }
                get name() {
                    return 0 === this.fixed ? "UTC" : `UTC${Nt(this.fixed, "narrow")}`
                }
                get ianaName() {
                    return 0 === this.fixed ? "Etc/UTC" : `Etc/GMT${Nt(-this.fixed, "narrow")}`
                }
                offsetName() {
                    return this.name
                }
                formatOffset(t, e) {
                    return Nt(this.fixed, e)
                }
                get isUniversal() {
                    return !0
                }
                offset() {
                    return this.fixed
                }
                equals(t) {
                    return "fixed" === t.type && t.fixed === this.fixed
                }
                get isValid() {
                    return !0
                }
            }
            class et extends R {
                constructor(t) {
                    super(), this.zoneName = t
                }
                get type() {
                    return "invalid"
                }
                get name() {
                    return this.zoneName
                }
                get isUniversal() {
                    return !1
                }
                offsetName() {
                    return null
                }
                formatOffset() {
                    return ""
                }
                offset() {
                    return NaN
                }
                equals() {
                    return !1
                }
                get isValid() {
                    return !1
                }
            }

            function it(t, e) {
                if (ct(t) || null === t) return e;
                if (t instanceof R) return t;
                if ("string" == typeof t) {
                    const i = t.toLowerCase();
                    return "default" === i ? e : "local" === i || "system" === i ? F.instance : "utc" === i || "gmt" === i ? tt.utcInstance : tt.parseSpecifier(i) || W.create(t)
                }
                return dt(t) ? tt.instance(t) : "object" == typeof t && t.offset && "number" == typeof t.offset ? t : new et(t)
            }
            let nt, rt = () => Date.now(),
                ot = "system",
                st = null,
                at = null,
                lt = null,
                ht = 60;
            class ut {
                static get now() {
                    return rt
                }
                static set now(t) {
                    rt = t
                }
                static set defaultZone(t) {
                    ot = t
                }
                static get defaultZone() {
                    return it(ot, F.instance)
                }
                static get defaultLocale() {
                    return st
                }
                static set defaultLocale(t) {
                    st = t
                }
                static get defaultNumberingSystem() {
                    return at
                }
                static set defaultNumberingSystem(t) {
                    at = t
                }
                static get defaultOutputCalendar() {
                    return lt
                }
                static set defaultOutputCalendar(t) {
                    lt = t
                }
                static get twoDigitCutoffYear() {
                    return ht
                }
                static set twoDigitCutoffYear(t) {
                    ht = t % 100
                }
                static get throwOnInvalid() {
                    return nt
                }
                static set throwOnInvalid(t) {
                    nt = t
                }
                static resetCaches() {
                    J.resetCache(), W.resetCache()
                }
            }

            function ct(t) {
                return void 0 === t
            }

            function dt(t) {
                return "number" == typeof t
            }

            function pt(t) {
                return "number" == typeof t && t % 1 == 0
            }

            function ft() {
                try {
                    return "undefined" != typeof Intl && !!Intl.RelativeTimeFormat
                } catch (t) {
                    return !1
                }
            }

            function gt(t, e, i) {
                if (0 !== t.length) return t.reduce(((t, n) => {
                    const r = [e(n), n];
                    return t && i(t[0], r[0]) === t[0] ? t : r
                }), null)[1]
            }

            function mt(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }

            function _t(t, e, i) {
                return pt(t) && t >= e && t <= i
            }

            function yt(t, e = 2) {
                let i;
                return i = t < 0 ? "-" + ("" + -t).padStart(e, "0") : ("" + t).padStart(e, "0"), i
            }

            function St(t) {
                return ct(t) || null === t || "" === t ? void 0 : parseInt(t, 10)
            }

            function vt(t) {
                return ct(t) || null === t || "" === t ? void 0 : parseFloat(t)
            }

            function bt(t) {
                if (!ct(t) && null !== t && "" !== t) {
                    const e = 1e3 * parseFloat("0." + t);
                    return Math.floor(e)
                }
            }

            function Tt(t, e, i = !1) {
                const n = 10 ** e;
                return (i ? Math.trunc : Math.round)(t * n) / n
            }

            function Pt(t) {
                return t % 4 == 0 && (t % 100 != 0 || t % 400 == 0)
            }

            function At(t) {
                return Pt(t) ? 366 : 365
            }

            function It(t, e) {
                const i = (n = e - 1) - 12 * Math.floor(n / 12) + 1;
                var n;
                return 2 === i ? Pt(t + (e - i) / 12) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][i - 1]
            }

            function wt(t) {
                let e = Date.UTC(t.year, t.month - 1, t.day, t.hour, t.minute, t.second, t.millisecond);
                return t.year < 100 && t.year >= 0 && (e = new Date(e), e.setUTCFullYear(t.year, t.month - 1, t.day)), +e
            }

            function Et(t) {
                const e = (t + Math.floor(t / 4) - Math.floor(t / 100) + Math.floor(t / 400)) % 7,
                    i = t - 1,
                    n = (i + Math.floor(i / 4) - Math.floor(i / 100) + Math.floor(i / 400)) % 7;
                return 4 === e || 3 === n ? 53 : 52
            }

            function Ct(t) {
                return t > 99 ? t : t > ut.twoDigitCutoffYear ? 1900 + t : 2e3 + t
            }

            function xt(t, e, i, n = null) {
                const r = new Date(t),
                    o = {
                        hourCycle: "h23",
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                        hour: "2-digit",
                        minute: "2-digit"
                    };
                n && (o.timeZone = n);
                const s = {
                    timeZoneName: e,
                    ...o
                },
                    a = new Intl.DateTimeFormat(i, s).formatToParts(r).find((t => "timezonename" === t.type.toLowerCase()));
                return a ? a.value : null
            }

            function Bt(t, e) {
                let i = parseInt(t, 10);
                Number.isNaN(i) && (i = 0);
                const n = parseInt(e, 10) || 0;
                return 60 * i + (i < 0 || Object.is(i, -0) ? -n : n)
            }

            function Lt(t) {
                const e = Number(t);
                if ("boolean" == typeof t || "" === t || Number.isNaN(e)) throw new l(`Invalid unit value ${t}`);
                return e
            }

            function Ot(t, e) {
                const i = {};
                for (const n in t)
                    if (mt(t, n)) {
                        const r = t[n];
                        if (null == r) continue;
                        i[e(n)] = Lt(r)
                    } return i
            }

            function Nt(t, e) {
                const i = Math.trunc(Math.abs(t / 60)),
                    n = Math.trunc(Math.abs(t % 60)),
                    r = t >= 0 ? "+" : "-";
                switch (e) {
                    case "short":
                        return `${r}${yt(i, 2)}:${yt(n, 2)}`;
                    case "narrow":
                        return `${r}${i}${n > 0 ? `:${n}` : ""}`;
                    case "techie":
                        return `${r}${yt(i, 2)}${yt(n, 2)}`;
                    default:
                        throw new RangeError(`Value format ${e} is out of range for property format`)
                }
            }

            function Mt(t) {
                return function (t, e) {
                    return ["hour", "minute", "second", "millisecond"].reduce(((e, i) => (e[i] = t[i], e)), {})
                }(t)
            }
            const Rt = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                Dt = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                Ft = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];

            function kt(t) {
                switch (t) {
                    case "narrow":
                        return [...Ft];
                    case "short":
                        return [...Dt];
                    case "long":
                        return [...Rt];
                    case "numeric":
                        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
                    case "2-digit":
                        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
                    default:
                        return null
                }
            }
            const Ut = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                Gt = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
                Wt = ["M", "T", "W", "T", "F", "S", "S"];

            function Vt(t) {
                switch (t) {
                    case "narrow":
                        return [...Wt];
                    case "short":
                        return [...Gt];
                    case "long":
                        return [...Ut];
                    case "numeric":
                        return ["1", "2", "3", "4", "5", "6", "7"];
                    default:
                        return null
                }
            }
            const Xt = ["AM", "PM"],
                Ht = ["Before Christ", "Anno Domini"],
                Yt = ["BC", "AD"],
                jt = ["B", "A"];

            function zt(t) {
                switch (t) {
                    case "narrow":
                        return [...jt];
                    case "short":
                        return [...Yt];
                    case "long":
                        return [...Ht];
                    default:
                        return null
                }
            }

            function Kt(t, e) {
                let i = "";
                for (const n of t) n.literal ? i += n.val : i += e(n.val);
                return i
            }
            const qt = {
                D: p,
                DD: f,
                DDD: m,
                DDDD: _,
                t: y,
                tt: S,
                ttt: v,
                tttt: b,
                T,
                TT: P,
                TTT: A,
                TTTT: I,
                f: w,
                ff: C,
                fff: L,
                ffff: N,
                F: E,
                FF: x,
                FFF: O,
                FFFF: M
            };
            class Zt {
                static create(t, e = {}) {
                    return new Zt(t, e)
                }
                static parseFormat(t) {
                    let e = null,
                        i = "",
                        n = !1;
                    const r = [];
                    for (let o = 0; o < t.length; o++) {
                        const s = t.charAt(o);
                        "'" === s ? (i.length > 0 && r.push({
                            literal: n || /^\s+$/.test(i),
                            val: i
                        }), e = null, i = "", n = !n) : n || s === e ? i += s : (i.length > 0 && r.push({
                            literal: /^\s+$/.test(i),
                            val: i
                        }), i = s, e = s)
                    }
                    return i.length > 0 && r.push({
                        literal: n || /^\s+$/.test(i),
                        val: i
                    }), r
                }
                static macroTokenToFormatOpts(t) {
                    return qt[t]
                }
                constructor(t, e) {
                    this.opts = e, this.loc = t, this.systemLoc = null
                }
                formatWithSystemDefault(t, e) {
                    return null === this.systemLoc && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, {
                        ...this.opts,
                        ...e
                    }).format()
                }
                formatDateTime(t, e = {}) {
                    return this.loc.dtFormatter(t, {
                        ...this.opts,
                        ...e
                    }).format()
                }
                formatDateTimeParts(t, e = {}) {
                    return this.loc.dtFormatter(t, {
                        ...this.opts,
                        ...e
                    }).formatToParts()
                }
                formatInterval(t, e = {}) {
                    return this.loc.dtFormatter(t.start, {
                        ...this.opts,
                        ...e
                    }).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate())
                }
                resolvedOptions(t, e = {}) {
                    return this.loc.dtFormatter(t, {
                        ...this.opts,
                        ...e
                    }).resolvedOptions()
                }
                num(t, e = 0) {
                    if (this.opts.forceSimple) return yt(t, e);
                    const i = {
                        ...this.opts
                    };
                    return e > 0 && (i.padTo = e), this.loc.numberFormatter(i).format(t)
                }
                formatDateTimeFromString(t, e) {
                    const i = "en" === this.loc.listingMode(),
                        n = this.loc.outputCalendar && "gregory" !== this.loc.outputCalendar,
                        r = (e, i) => this.loc.extract(t, e, i),
                        o = e => t.isOffsetFixed && 0 === t.offset && e.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, e.format) : "",
                        s = (e, n) => i ? function (t, e) {
                            return kt(e)[t.month - 1]
                        }(t, e) : r(n ? {
                            month: e
                        } : {
                            month: e,
                            day: "numeric"
                        }, "month"),
                        a = (e, n) => i ? function (t, e) {
                            return Vt(e)[t.weekday - 1]
                        }(t, e) : r(n ? {
                            weekday: e
                        } : {
                            weekday: e,
                            month: "long",
                            day: "numeric"
                        }, "weekday"),
                        l = e => {
                            const i = Zt.macroTokenToFormatOpts(e);
                            return i ? this.formatWithSystemDefault(t, i) : e
                        },
                        h = e => i ? function (t, e) {
                            return zt(e)[t.year < 0 ? 0 : 1]
                        }(t, e) : r({
                            era: e
                        }, "era");
                    return Kt(Zt.parseFormat(e), (e => {
                        switch (e) {
                            case "S":
                                return this.num(t.millisecond);
                            case "u":
                            case "SSS":
                                return this.num(t.millisecond, 3);
                            case "s":
                                return this.num(t.second);
                            case "ss":
                                return this.num(t.second, 2);
                            case "uu":
                                return this.num(Math.floor(t.millisecond / 10), 2);
                            case "uuu":
                                return this.num(Math.floor(t.millisecond / 100));
                            case "m":
                                return this.num(t.minute);
                            case "mm":
                                return this.num(t.minute, 2);
                            case "h":
                                return this.num(t.hour % 12 == 0 ? 12 : t.hour % 12);
                            case "hh":
                                return this.num(t.hour % 12 == 0 ? 12 : t.hour % 12, 2);
                            case "H":
                                return this.num(t.hour);
                            case "HH":
                                return this.num(t.hour, 2);
                            case "Z":
                                return o({
                                    format: "narrow",
                                    allowZ: this.opts.allowZ
                                });
                            case "ZZ":
                                return o({
                                    format: "short",
                                    allowZ: this.opts.allowZ
                                });
                            case "ZZZ":
                                return o({
                                    format: "techie",
                                    allowZ: this.opts.allowZ
                                });
                            case "ZZZZ":
                                return t.zone.offsetName(t.ts, {
                                    format: "short",
                                    locale: this.loc.locale
                                });
                            case "ZZZZZ":
                                return t.zone.offsetName(t.ts, {
                                    format: "long",
                                    locale: this.loc.locale
                                });
                            case "z":
                                return t.zoneName;
                            case "a":
                                return i ? function (t) {
                                    return Xt[t.hour < 12 ? 0 : 1]
                                }(t) : r({
                                    hour: "numeric",
                                    hourCycle: "h12"
                                }, "dayperiod");
                            case "d":
                                return n ? r({
                                    day: "numeric"
                                }, "day") : this.num(t.day);
                            case "dd":
                                return n ? r({
                                    day: "2-digit"
                                }, "day") : this.num(t.day, 2);
                            case "c":
                            case "E":
                                return this.num(t.weekday);
                            case "ccc":
                                return a("short", !0);
                            case "cccc":
                                return a("long", !0);
                            case "ccccc":
                                return a("narrow", !0);
                            case "EEE":
                                return a("short", !1);
                            case "EEEE":
                                return a("long", !1);
                            case "EEEEE":
                                return a("narrow", !1);
                            case "L":
                                return n ? r({
                                    month: "numeric",
                                    day: "numeric"
                                }, "month") : this.num(t.month);
                            case "LL":
                                return n ? r({
                                    month: "2-digit",
                                    day: "numeric"
                                }, "month") : this.num(t.month, 2);
                            case "LLL":
                                return s("short", !0);
                            case "LLLL":
                                return s("long", !0);
                            case "LLLLL":
                                return s("narrow", !0);
                            case "M":
                                return n ? r({
                                    month: "numeric"
                                }, "month") : this.num(t.month);
                            case "MM":
                                return n ? r({
                                    month: "2-digit"
                                }, "month") : this.num(t.month, 2);
                            case "MMM":
                                return s("short", !1);
                            case "MMMM":
                                return s("long", !1);
                            case "MMMMM":
                                return s("narrow", !1);
                            case "y":
                                return n ? r({
                                    year: "numeric"
                                }, "year") : this.num(t.year);
                            case "yy":
                                return n ? r({
                                    year: "2-digit"
                                }, "year") : this.num(t.year.toString().slice(-2), 2);
                            case "yyyy":
                                return n ? r({
                                    year: "numeric"
                                }, "year") : this.num(t.year, 4);
                            case "yyyyyy":
                                return n ? r({
                                    year: "numeric"
                                }, "year") : this.num(t.year, 6);
                            case "G":
                                return h("short");
                            case "GG":
                                return h("long");
                            case "GGGGG":
                                return h("narrow");
                            case "kk":
                                return this.num(t.weekYear.toString().slice(-2), 2);
                            case "kkkk":
                                return this.num(t.weekYear, 4);
                            case "W":
                                return this.num(t.weekNumber);
                            case "WW":
                                return this.num(t.weekNumber, 2);
                            case "o":
                                return this.num(t.ordinal);
                            case "ooo":
                                return this.num(t.ordinal, 3);
                            case "q":
                                return this.num(t.quarter);
                            case "qq":
                                return this.num(t.quarter, 2);
                            case "X":
                                return this.num(Math.floor(t.ts / 1e3));
                            case "x":
                                return this.num(t.ts);
                            default:
                                return l(e)
                        }
                    }))
                }
                formatDurationFromString(t, e) {
                    const i = t => {
                        switch (t[0]) {
                            case "S":
                                return "millisecond";
                            case "s":
                                return "second";
                            case "m":
                                return "minute";
                            case "h":
                                return "hour";
                            case "d":
                                return "day";
                            case "w":
                                return "week";
                            case "M":
                                return "month";
                            case "y":
                                return "year";
                            default:
                                return null
                        }
                    },
                        n = Zt.parseFormat(e),
                        r = n.reduce(((t, {
                            literal: e,
                            val: i
                        }) => e ? t : t.concat(i)), []);
                    return Kt(n, (t => e => {
                        const n = i(e);
                        return n ? this.num(t.get(n), e.length) : e
                    })(t.shiftTo(...r.map(i).filter((t => t)))))
                }
            }
            class $t {
                constructor(t, e) {
                    this.reason = t, this.explanation = e
                }
                toMessage() {
                    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason
                }
            }
            const Jt = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;

            function Qt(...t) {
                const e = t.reduce(((t, e) => t + e.source), "");
                return RegExp(`^${e}$`)
            }

            function te(...t) {
                return e => t.reduce((([t, i, n], r) => {
                    const [o, s, a] = r(e, n);
                    return [{
                        ...t,
                        ...o
                    }, s || i, a]
                }), [{}, null, 1]).slice(0, 2)
            }

            function ee(t, ...e) {
                if (null == t) return [null, null];
                for (const [i, n] of e) {
                    const e = i.exec(t);
                    if (e) return n(e)
                }
                return [null, null]
            }

            function ie(...t) {
                return (e, i) => {
                    const n = {};
                    let r;
                    for (r = 0; r < t.length; r++) n[t[r]] = St(e[i + r]);
                    return [n, null, i + r]
                }
            }
            const ne = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
                re = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
                oe = RegExp(`${re.source}(?:${ne.source}?(?:\\[(${Jt.source})\\])?)?`),
                se = RegExp(`(?:T${oe.source})?`),
                ae = ie("weekYear", "weekNumber", "weekDay"),
                le = ie("year", "ordinal"),
                he = RegExp(`${re.source} ?(?:${ne.source}|(${Jt.source}))?`),
                ue = RegExp(`(?: ${he.source})?`);

            function ce(t, e, i) {
                const n = t[e];
                return ct(n) ? i : St(n)
            }

            function de(t, e) {
                return [{
                    hours: ce(t, e, 0),
                    minutes: ce(t, e + 1, 0),
                    seconds: ce(t, e + 2, 0),
                    milliseconds: bt(t[e + 3])
                }, null, e + 4]
            }

            function pe(t, e) {
                const i = !t[e] && !t[e + 1],
                    n = Bt(t[e + 1], t[e + 2]);
                return [{}, i ? null : tt.instance(n), e + 3]
            }

            function fe(t, e) {
                return [{}, t[e] ? W.create(t[e]) : null, e + 1]
            }
            const ge = RegExp(`^T?${re.source}$`),
                me = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;

            function _e(t) {
                const [e, i, n, r, o, s, a, l, h] = t, u = "-" === e[0], c = l && "-" === l[0], d = (t, e = !1) => void 0 !== t && (e || t && u) ? -t : t;
                return [{
                    years: d(vt(i)),
                    months: d(vt(n)),
                    weeks: d(vt(r)),
                    days: d(vt(o)),
                    hours: d(vt(s)),
                    minutes: d(vt(a)),
                    seconds: d(vt(l), "-0" === l),
                    milliseconds: d(bt(h), c)
                }]
            }
            const ye = {
                GMT: 0,
                EDT: -240,
                EST: -300,
                CDT: -300,
                CST: -360,
                MDT: -360,
                MST: -420,
                PDT: -420,
                PST: -480
            };

            function Se(t, e, i, n, r, o, s) {
                const a = {
                    year: 2 === e.length ? Ct(St(e)) : St(e),
                    month: Dt.indexOf(i) + 1,
                    day: St(n),
                    hour: St(r),
                    minute: St(o)
                };
                return s && (a.second = St(s)), t && (a.weekday = t.length > 3 ? Ut.indexOf(t) + 1 : Gt.indexOf(t) + 1), a
            }
            const ve = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

            function be(t) {
                const [, e, i, n, r, o, s, a, l, h, u, c] = t, d = Se(e, r, n, i, o, s, a);
                let p;
                return p = l ? ye[l] : h ? 0 : Bt(u, c), [d, new tt(p)]
            }
            const Te = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
                Pe = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
                Ae = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

            function Ie(t) {
                const [, e, i, n, r, o, s, a] = t;
                return [Se(e, r, n, i, o, s, a), tt.utcInstance]
            }

            function we(t) {
                const [, e, i, n, r, o, s, a] = t;
                return [Se(e, a, i, n, r, o, s), tt.utcInstance]
            }
            const Ee = Qt(/([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, se),
                Ce = Qt(/(\d{4})-?W(\d\d)(?:-?(\d))?/, se),
                xe = Qt(/(\d{4})-?(\d{3})/, se),
                Be = Qt(oe),
                Le = te((function (t, e) {
                    return [{
                        year: ce(t, e),
                        month: ce(t, e + 1, 1),
                        day: ce(t, e + 2, 1)
                    }, null, e + 3]
                }), de, pe, fe),
                Oe = te(ae, de, pe, fe),
                Ne = te(le, de, pe, fe),
                Me = te(de, pe, fe),
                Re = te(de),
                De = Qt(/(\d{4})-(\d\d)-(\d\d)/, ue),
                Fe = Qt(he),
                ke = te(de, pe, fe),
                Ue = {
                    weeks: {
                        days: 7,
                        hours: 168,
                        minutes: 10080,
                        seconds: 604800,
                        milliseconds: 6048e5
                    },
                    days: {
                        hours: 24,
                        minutes: 1440,
                        seconds: 86400,
                        milliseconds: 864e5
                    },
                    hours: {
                        minutes: 60,
                        seconds: 3600,
                        milliseconds: 36e5
                    },
                    minutes: {
                        seconds: 60,
                        milliseconds: 6e4
                    },
                    seconds: {
                        milliseconds: 1e3
                    }
                },
                Ge = {
                    years: {
                        quarters: 4,
                        months: 12,
                        weeks: 52,
                        days: 365,
                        hours: 8760,
                        minutes: 525600,
                        seconds: 31536e3,
                        milliseconds: 31536e6
                    },
                    quarters: {
                        months: 3,
                        weeks: 13,
                        days: 91,
                        hours: 2184,
                        minutes: 131040,
                        seconds: 7862400,
                        milliseconds: 78624e5
                    },
                    months: {
                        weeks: 4,
                        days: 30,
                        hours: 720,
                        minutes: 43200,
                        seconds: 2592e3,
                        milliseconds: 2592e6
                    },
                    ...Ue
                },
                We = {
                    years: {
                        quarters: 4,
                        months: 12,
                        weeks: 52.1775,
                        days: 365.2425,
                        hours: 8765.82,
                        minutes: 525949.2,
                        seconds: 525949.2 * 60,
                        milliseconds: 525949.2 * 60 * 1e3
                    },
                    quarters: {
                        months: 3,
                        weeks: 13.044375,
                        days: 91.310625,
                        hours: 2191.455,
                        minutes: 131487.3,
                        seconds: 525949.2 * 60 / 4,
                        milliseconds: 7889237999.999999
                    },
                    months: {
                        weeks: 4.3481250000000005,
                        days: 30.436875,
                        hours: 730.485,
                        minutes: 43829.1,
                        seconds: 2629746,
                        milliseconds: 2629746e3
                    },
                    ...Ue
                },
                Ve = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"],
                Xe = Ve.slice(0).reverse();

            function He(t, e, i = !1) {
                const n = {
                    values: i ? e.values : {
                        ...t.values,
                        ...e.values || {}
                    },
                    loc: t.loc.clone(e.loc),
                    conversionAccuracy: e.conversionAccuracy || t.conversionAccuracy,
                    matrix: e.matrix || t.matrix
                };
                return new je(n)
            }

            function Ye(t, e, i, n, r) {
                const o = t[r][i],
                    s = e[i] / o,
                    a = Math.sign(s) !== Math.sign(n[r]) && 0 !== n[r] && Math.abs(s) <= 1 ? function (t) {
                        return t < 0 ? Math.floor(t) : Math.ceil(t)
                    }(s) : Math.trunc(s);
                n[r] += a, e[i] -= a * o
            }
            class je {
                constructor(t) {
                    const e = "longterm" === t.conversionAccuracy || !1;
                    let i = e ? We : Ge;
                    t.matrix && (i = t.matrix), this.values = t.values, this.loc = t.loc || J.create(), this.conversionAccuracy = e ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = i, this.isLuxonDuration = !0
                }
                static fromMillis(t, e) {
                    return je.fromObject({
                        milliseconds: t
                    }, e)
                }
                static fromObject(t, e = {}) {
                    if (null == t || "object" != typeof t) throw new l("Duration.fromObject: argument expected to be an object, got " + (null === t ? "null" : typeof t));
                    return new je({
                        values: Ot(t, je.normalizeUnit),
                        loc: J.fromObject(e),
                        conversionAccuracy: e.conversionAccuracy,
                        matrix: e.matrix
                    })
                }
                static fromDurationLike(t) {
                    if (dt(t)) return je.fromMillis(t);
                    if (je.isDuration(t)) return t;
                    if ("object" == typeof t) return je.fromObject(t);
                    throw new l(`Unknown duration argument ${t} of type ${typeof t}`)
                }
                static fromISO(t, e) {
                    const [i] = function (t) {
                        return ee(t, [me, _e])
                    }(t);
                    return i ? je.fromObject(i, e) : je.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
                }
                static fromISOTime(t, e) {
                    const [i] = function (t) {
                        return ee(t, [ge, Re])
                    }(t);
                    return i ? je.fromObject(i, e) : je.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
                }
                static invalid(t, e = null) {
                    if (!t) throw new l("need to specify a reason the Duration is invalid");
                    const i = t instanceof $t ? t : new $t(t, e);
                    if (ut.throwOnInvalid) throw new o(i);
                    return new je({
                        invalid: i
                    })
                }
                static normalizeUnit(t) {
                    const e = {
                        year: "years",
                        years: "years",
                        quarter: "quarters",
                        quarters: "quarters",
                        month: "months",
                        months: "months",
                        week: "weeks",
                        weeks: "weeks",
                        day: "days",
                        days: "days",
                        hour: "hours",
                        hours: "hours",
                        minute: "minutes",
                        minutes: "minutes",
                        second: "seconds",
                        seconds: "seconds",
                        millisecond: "milliseconds",
                        milliseconds: "milliseconds"
                    }[t ? t.toLowerCase() : t];
                    if (!e) throw new a(t);
                    return e
                }
                static isDuration(t) {
                    return t && t.isLuxonDuration || !1
                }
                get locale() {
                    return this.isValid ? this.loc.locale : null
                }
                get numberingSystem() {
                    return this.isValid ? this.loc.numberingSystem : null
                }
                toFormat(t, e = {}) {
                    const i = {
                        ...e,
                        floor: !1 !== e.round && !1 !== e.floor
                    };
                    return this.isValid ? Zt.create(this.loc, i).formatDurationFromString(this, t) : "Invalid Duration"
                }
                toHuman(t = {}) {
                    const e = Ve.map((e => {
                        const i = this.values[e];
                        return ct(i) ? null : this.loc.numberFormatter({
                            style: "unit",
                            unitDisplay: "long",
                            ...t,
                            unit: e.slice(0, -1)
                        }).format(i)
                    })).filter((t => t));
                    return this.loc.listFormatter({
                        type: "conjunction",
                        style: t.listStyle || "narrow",
                        ...t
                    }).format(e)
                }
                toObject() {
                    return this.isValid ? {
                        ...this.values
                    } : {}
                }
                toISO() {
                    if (!this.isValid) return null;
                    let t = "P";
                    return 0 !== this.years && (t += this.years + "Y"), 0 === this.months && 0 === this.quarters || (t += this.months + 3 * this.quarters + "M"), 0 !== this.weeks && (t += this.weeks + "W"), 0 !== this.days && (t += this.days + "D"), 0 === this.hours && 0 === this.minutes && 0 === this.seconds && 0 === this.milliseconds || (t += "T"), 0 !== this.hours && (t += this.hours + "H"), 0 !== this.minutes && (t += this.minutes + "M"), 0 === this.seconds && 0 === this.milliseconds || (t += Tt(this.seconds + this.milliseconds / 1e3, 3) + "S"), "P" === t && (t += "T0S"), t
                }
                toISOTime(t = {}) {
                    if (!this.isValid) return null;
                    const e = this.toMillis();
                    if (e < 0 || e >= 864e5) return null;
                    t = {
                        suppressMilliseconds: !1,
                        suppressSeconds: !1,
                        includePrefix: !1,
                        format: "extended",
                        ...t
                    };
                    const i = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
                    let n = "basic" === t.format ? "hhmm" : "hh:mm";
                    t.suppressSeconds && 0 === i.seconds && 0 === i.milliseconds || (n += "basic" === t.format ? "ss" : ":ss", t.suppressMilliseconds && 0 === i.milliseconds || (n += ".SSS"));
                    let r = i.toFormat(n);
                    return t.includePrefix && (r = "T" + r), r
                }
                toJSON() {
                    return this.toISO()
                }
                toString() {
                    return this.toISO()
                }
                toMillis() {
                    return this.as("milliseconds")
                }
                valueOf() {
                    return this.toMillis()
                }
                plus(t) {
                    if (!this.isValid) return this;
                    const e = je.fromDurationLike(t),
                        i = {};
                    for (const t of Ve) (mt(e.values, t) || mt(this.values, t)) && (i[t] = e.get(t) + this.get(t));
                    return He(this, {
                        values: i
                    }, !0)
                }
                minus(t) {
                    if (!this.isValid) return this;
                    const e = je.fromDurationLike(t);
                    return this.plus(e.negate())
                }
                mapUnits(t) {
                    if (!this.isValid) return this;
                    const e = {};
                    for (const i of Object.keys(this.values)) e[i] = Lt(t(this.values[i], i));
                    return He(this, {
                        values: e
                    }, !0)
                }
                get(t) {
                    return this[je.normalizeUnit(t)]
                }
                set(t) {
                    return this.isValid ? He(this, {
                        values: {
                            ...this.values,
                            ...Ot(t, je.normalizeUnit)
                        }
                    }) : this
                }
                reconfigure({
                    locale: t,
                    numberingSystem: e,
                    conversionAccuracy: i,
                    matrix: n
                } = {}) {
                    return He(this, {
                        loc: this.loc.clone({
                            locale: t,
                            numberingSystem: e
                        }),
                        matrix: n,
                        conversionAccuracy: i
                    })
                }
                as(t) {
                    return this.isValid ? this.shiftTo(t).get(t) : NaN
                }
                normalize() {
                    if (!this.isValid) return this;
                    const t = this.toObject();
                    return function (t, e) {
                        Xe.reduce(((i, n) => ct(e[n]) ? i : (i && Ye(t, e, i, e, n), n)), null)
                    }(this.matrix, t), He(this, {
                        values: t
                    }, !0)
                }
                rescale() {
                    return this.isValid ? He(this, {
                        values: function (t) {
                            const e = {};
                            for (const [i, n] of Object.entries(t)) 0 !== n && (e[i] = n);
                            return e
                        }(this.normalize().shiftToAll().toObject())
                    }, !0) : this
                }
                shiftTo(...t) {
                    if (!this.isValid) return this;
                    if (0 === t.length) return this;
                    t = t.map((t => je.normalizeUnit(t)));
                    const e = {},
                        i = {},
                        n = this.toObject();
                    let r;
                    for (const o of Ve)
                        if (t.indexOf(o) >= 0) {
                            r = o;
                            let t = 0;
                            for (const e in i) t += this.matrix[e][o] * i[e], i[e] = 0;
                            dt(n[o]) && (t += n[o]);
                            const s = Math.trunc(t);
                            e[o] = s, i[o] = (1e3 * t - 1e3 * s) / 1e3;
                            for (const t in n) Ve.indexOf(t) > Ve.indexOf(o) && Ye(this.matrix, n, t, e, o)
                        } else dt(n[o]) && (i[o] = n[o]);
                    for (const t in i) 0 !== i[t] && (e[r] += t === r ? i[t] : i[t] / this.matrix[r][t]);
                    return He(this, {
                        values: e
                    }, !0).normalize()
                }
                shiftToAll() {
                    return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this
                }
                negate() {
                    if (!this.isValid) return this;
                    const t = {};
                    for (const e of Object.keys(this.values)) t[e] = 0 === this.values[e] ? 0 : -this.values[e];
                    return He(this, {
                        values: t
                    }, !0)
                }
                get years() {
                    return this.isValid ? this.values.years || 0 : NaN
                }
                get quarters() {
                    return this.isValid ? this.values.quarters || 0 : NaN
                }
                get months() {
                    return this.isValid ? this.values.months || 0 : NaN
                }
                get weeks() {
                    return this.isValid ? this.values.weeks || 0 : NaN
                }
                get days() {
                    return this.isValid ? this.values.days || 0 : NaN
                }
                get hours() {
                    return this.isValid ? this.values.hours || 0 : NaN
                }
                get minutes() {
                    return this.isValid ? this.values.minutes || 0 : NaN
                }
                get seconds() {
                    return this.isValid ? this.values.seconds || 0 : NaN
                }
                get milliseconds() {
                    return this.isValid ? this.values.milliseconds || 0 : NaN
                }
                get isValid() {
                    return null === this.invalid
                }
                get invalidReason() {
                    return this.invalid ? this.invalid.reason : null
                }
                get invalidExplanation() {
                    return this.invalid ? this.invalid.explanation : null
                }
                equals(t) {
                    if (!this.isValid || !t.isValid) return !1;
                    if (!this.loc.equals(t.loc)) return !1;
                    for (const n of Ve)
                        if (e = this.values[n], i = t.values[n], !(void 0 === e || 0 === e ? void 0 === i || 0 === i : e === i)) return !1;
                    var e, i;
                    return !0
                }
            }
            const ze = "Invalid Interval";
            class Ke {
                constructor(t) {
                    this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0
                }
                static invalid(t, e = null) {
                    if (!t) throw new l("need to specify a reason the Interval is invalid");
                    const i = t instanceof $t ? t : new $t(t, e);
                    if (ut.throwOnInvalid) throw new r(i);
                    return new Ke({
                        invalid: i
                    })
                }
                static fromDateTimes(t, e) {
                    const i = Zi(t),
                        n = Zi(e),
                        r = function (t, e) {
                            return t && t.isValid ? e && e.isValid ? e < t ? Ke.invalid("end before start", `The end of an interval must be after its start, but you had start=${t.toISO()} and end=${e.toISO()}`) : null : Ke.invalid("missing or invalid end") : Ke.invalid("missing or invalid start")
                        }(i, n);
                    return null == r ? new Ke({
                        start: i,
                        end: n
                    }) : r
                }
                static after(t, e) {
                    const i = je.fromDurationLike(e),
                        n = Zi(t);
                    return Ke.fromDateTimes(n, n.plus(i))
                }
                static before(t, e) {
                    const i = je.fromDurationLike(e),
                        n = Zi(t);
                    return Ke.fromDateTimes(n.minus(i), n)
                }
                static fromISO(t, e) {
                    const [i, n] = (t || "").split("/", 2);
                    if (i && n) {
                        let t, r, o, s;
                        try {
                            t = qi.fromISO(i, e), r = t.isValid
                        } catch (n) {
                            r = !1
                        }
                        try {
                            o = qi.fromISO(n, e), s = o.isValid
                        } catch (n) {
                            s = !1
                        }
                        if (r && s) return Ke.fromDateTimes(t, o);
                        if (r) {
                            const i = je.fromISO(n, e);
                            if (i.isValid) return Ke.after(t, i)
                        } else if (s) {
                            const t = je.fromISO(i, e);
                            if (t.isValid) return Ke.before(o, t)
                        }
                    }
                    return Ke.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`)
                }
                static isInterval(t) {
                    return t && t.isLuxonInterval || !1
                }
                get start() {
                    return this.isValid ? this.s : null
                }
                get end() {
                    return this.isValid ? this.e : null
                }
                get isValid() {
                    return null === this.invalidReason
                }
                get invalidReason() {
                    return this.invalid ? this.invalid.reason : null
                }
                get invalidExplanation() {
                    return this.invalid ? this.invalid.explanation : null
                }
                length(t = "milliseconds") {
                    return this.isValid ? this.toDuration(t).get(t) : NaN
                }
                count(t = "milliseconds") {
                    if (!this.isValid) return NaN;
                    const e = this.start.startOf(t),
                        i = this.end.startOf(t);
                    return Math.floor(i.diff(e, t).get(t)) + (i.valueOf() !== this.end.valueOf())
                }
                hasSame(t) {
                    return !!this.isValid && (this.isEmpty() || this.e.minus(1).hasSame(this.s, t))
                }
                isEmpty() {
                    return this.s.valueOf() === this.e.valueOf()
                }
                isAfter(t) {
                    return !!this.isValid && this.s > t
                }
                isBefore(t) {
                    return !!this.isValid && this.e <= t
                }
                contains(t) {
                    return !!this.isValid && this.s <= t && this.e > t
                }
                set({
                    start: t,
                    end: e
                } = {}) {
                    return this.isValid ? Ke.fromDateTimes(t || this.s, e || this.e) : this
                }
                splitAt(...t) {
                    if (!this.isValid) return [];
                    const e = t.map(Zi).filter((t => this.contains(t))).sort(),
                        i = [];
                    let {
                        s: n
                    } = this, r = 0;
                    for (; n < this.e;) {
                        const t = e[r] || this.e,
                            o = +t > +this.e ? this.e : t;
                        i.push(Ke.fromDateTimes(n, o)), n = o, r += 1
                    }
                    return i
                }
                splitBy(t) {
                    const e = je.fromDurationLike(t);
                    if (!this.isValid || !e.isValid || 0 === e.as("milliseconds")) return [];
                    let i, {
                        s: n
                    } = this,
                        r = 1;
                    const o = [];
                    for (; n < this.e;) {
                        const t = this.start.plus(e.mapUnits((t => t * r)));
                        i = +t > +this.e ? this.e : t, o.push(Ke.fromDateTimes(n, i)), n = i, r += 1
                    }
                    return o
                }
                divideEqually(t) {
                    return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : []
                }
                overlaps(t) {
                    return this.e > t.s && this.s < t.e
                }
                abutsStart(t) {
                    return !!this.isValid && +this.e == +t.s
                }
                abutsEnd(t) {
                    return !!this.isValid && +t.e == +this.s
                }
                engulfs(t) {
                    return !!this.isValid && this.s <= t.s && this.e >= t.e
                }
                equals(t) {
                    return !(!this.isValid || !t.isValid) && this.s.equals(t.s) && this.e.equals(t.e)
                }
                intersection(t) {
                    if (!this.isValid) return this;
                    const e = this.s > t.s ? this.s : t.s,
                        i = this.e < t.e ? this.e : t.e;
                    return e >= i ? null : Ke.fromDateTimes(e, i)
                }
                union(t) {
                    if (!this.isValid) return this;
                    const e = this.s < t.s ? this.s : t.s,
                        i = this.e > t.e ? this.e : t.e;
                    return Ke.fromDateTimes(e, i)
                }
                static merge(t) {
                    const [e, i] = t.sort(((t, e) => t.s - e.s)).reduce((([t, e], i) => e ? e.overlaps(i) || e.abutsStart(i) ? [t, e.union(i)] : [t.concat([e]), i] : [t, i]), [
                        [], null
                    ]);
                    return i && e.push(i), e
                }
                static xor(t) {
                    let e = null,
                        i = 0;
                    const n = [],
                        r = t.map((t => [{
                            time: t.s,
                            type: "s"
                        }, {
                            time: t.e,
                            type: "e"
                        }])),
                        o = Array.prototype.concat(...r).sort(((t, e) => t.time - e.time));
                    for (const t of o) i += "s" === t.type ? 1 : -1, 1 === i ? e = t.time : (e && +e != +t.time && n.push(Ke.fromDateTimes(e, t.time)), e = null);
                    return Ke.merge(n)
                }
                difference(...t) {
                    return Ke.xor([this].concat(t)).map((t => this.intersection(t))).filter((t => t && !t.isEmpty()))
                }
                toString() {
                    return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : ze
                }
                toLocaleString(t = p, e = {}) {
                    return this.isValid ? Zt.create(this.s.loc.clone(e), t).formatInterval(this) : ze
                }
                toISO(t) {
                    return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : ze
                }
                toISODate() {
                    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : ze
                }
                toISOTime(t) {
                    return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : ze
                }
                toFormat(t, {
                    separator: e = "  "
                } = {}) {
                    return this.isValid ? `${this.s.toFormat(t)}${e}${this.e.toFormat(t)}` : ze
                }
                toDuration(t, e) {
                    return this.isValid ? this.e.diff(this.s, t, e) : je.invalid(this.invalidReason)
                }
                mapEndpoints(t) {
                    return Ke.fromDateTimes(t(this.s), t(this.e))
                }
            }
            class qe {
                static hasDST(t = ut.defaultZone) {
                    const e = qi.now().setZone(t).set({
                        month: 12
                    });
                    return !t.isUniversal && e.offset !== e.set({
                        month: 6
                    }).offset
                }
                static isValidIANAZone(t) {
                    return W.isValidZone(t)
                }
                static normalizeZone(t) {
                    return it(t, ut.defaultZone)
                }
                static months(t = "long", {
                    locale: e = null,
                    numberingSystem: i = null,
                    locObj: n = null,
                    outputCalendar: r = "gregory"
                } = {}) {
                    return (n || J.create(e, i, r)).months(t)
                }
                static monthsFormat(t = "long", {
                    locale: e = null,
                    numberingSystem: i = null,
                    locObj: n = null,
                    outputCalendar: r = "gregory"
                } = {}) {
                    return (n || J.create(e, i, r)).months(t, !0)
                }
                static weekdays(t = "long", {
                    locale: e = null,
                    numberingSystem: i = null,
                    locObj: n = null
                } = {}) {
                    return (n || J.create(e, i, null)).weekdays(t)
                }
                static weekdaysFormat(t = "long", {
                    locale: e = null,
                    numberingSystem: i = null,
                    locObj: n = null
                } = {}) {
                    return (n || J.create(e, i, null)).weekdays(t, !0)
                }
                static meridiems({
                    locale: t = null
                } = {}) {
                    return J.create(t).meridiems()
                }
                static eras(t = "short", {
                    locale: e = null
                } = {}) {
                    return J.create(e, null, "gregory").eras(t)
                }
                static features() {
                    return {
                        relative: ft()
                    }
                }
            }

            function Ze(t, e) {
                const i = t => t.toUTC(0, {
                    keepLocalTime: !0
                }).startOf("day").valueOf(),
                    n = i(e) - i(t);
                return Math.floor(je.fromMillis(n).as("days"))
            }
            const $e = {
                arab: "[-]",
                arabext: "[-]",
                bali: "[-]",
                beng: "[-]",
                deva: "[-]",
                fullwide: "[-]",
                gujr: "[-]",
                hanidec: "[|||||||||]",
                khmr: "[-]",
                knda: "[-]",
                laoo: "[-]",
                limb: "[-]",
                mlym: "[-]",
                mong: "[-]",
                mymr: "[-]",
                orya: "[-]",
                tamldec: "[-]",
                telu: "[-]",
                thai: "[-]",
                tibt: "[-]",
                latn: "\\d"
            },
                Je = {
                    arab: [1632, 1641],
                    arabext: [1776, 1785],
                    bali: [6992, 7001],
                    beng: [2534, 2543],
                    deva: [2406, 2415],
                    fullwide: [65296, 65303],
                    gujr: [2790, 2799],
                    khmr: [6112, 6121],
                    knda: [3302, 3311],
                    laoo: [3792, 3801],
                    limb: [6470, 6479],
                    mlym: [3430, 3439],
                    mong: [6160, 6169],
                    mymr: [4160, 4169],
                    orya: [2918, 2927],
                    tamldec: [3046, 3055],
                    telu: [3174, 3183],
                    thai: [3664, 3673],
                    tibt: [3872, 3881]
                },
                Qe = $e.hanidec.replace(/[\[|\]]/g, "").split("");

            function ti({
                numberingSystem: t
            }, e = "") {
                return new RegExp(`${$e[t || "latn"]}${e}`)
            }

            function ei(t, e = (t => t)) {
                return {
                    regex: t,
                    deser: ([t]) => e(function (t) {
                        let e = parseInt(t, 10);
                        if (isNaN(e)) {
                            e = "";
                            for (let i = 0; i < t.length; i++) {
                                const n = t.charCodeAt(i);
                                if (-1 !== t[i].search($e.hanidec)) e += Qe.indexOf(t[i]);
                                else
                                    for (const t in Je) {
                                        const [i, r] = Je[t];
                                        n >= i && n <= r && (e += n - i)
                                    }
                            }
                            return parseInt(e, 10)
                        }
                        return e
                    }(t))
                }
            }
            const ii = `[ ${String.fromCharCode(160)}]`,
                ni = new RegExp(ii, "g");

            function ri(t) {
                return t.replace(/\./g, "\\.?").replace(ni, ii)
            }

            function oi(t) {
                return t.replace(/\./g, "").replace(ni, " ").toLowerCase()
            }

            function si(t, e) {
                return null === t ? null : {
                    regex: RegExp(t.map(ri).join("|")),
                    deser: ([i]) => t.findIndex((t => oi(i) === oi(t))) + e
                }
            }

            function ai(t, e) {
                return {
                    regex: t,
                    deser: ([, t, e]) => Bt(t, e),
                    groups: e
                }
            }

            function li(t) {
                return {
                    regex: t,
                    deser: ([t]) => t
                }
            }
            const hi = {
                year: {
                    "2-digit": "yy",
                    numeric: "yyyyy"
                },
                month: {
                    numeric: "M",
                    "2-digit": "MM",
                    short: "MMM",
                    long: "MMMM"
                },
                day: {
                    numeric: "d",
                    "2-digit": "dd"
                },
                weekday: {
                    short: "EEE",
                    long: "EEEE"
                },
                dayperiod: "a",
                dayPeriod: "a",
                hour: {
                    numeric: "h",
                    "2-digit": "hh"
                },
                minute: {
                    numeric: "m",
                    "2-digit": "mm"
                },
                second: {
                    numeric: "s",
                    "2-digit": "ss"
                },
                timeZoneName: {
                    long: "ZZZZZ",
                    short: "ZZZ"
                }
            };
            let ui = null;

            function ci(t, e) {
                return Array.prototype.concat(...t.map((t => function (t, e) {
                    if (t.literal) return t;
                    const i = pi(Zt.macroTokenToFormatOpts(t.val), e);
                    return null == i || i.includes(void 0) ? t : i
                }(t, e))))
            }

            function di(t, e, i) {
                const n = ci(Zt.parseFormat(i), t),
                    r = n.map((e => function (t, e) {
                        const i = ti(e),
                            n = ti(e, "{2}"),
                            r = ti(e, "{3}"),
                            o = ti(e, "{4}"),
                            s = ti(e, "{6}"),
                            a = ti(e, "{1,2}"),
                            l = ti(e, "{1,3}"),
                            h = ti(e, "{1,6}"),
                            u = ti(e, "{1,9}"),
                            c = ti(e, "{2,4}"),
                            d = ti(e, "{4,6}"),
                            p = t => {
                                return {
                                    regex: RegExp((e = t.val, e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"))),
                                    deser: ([t]) => t,
                                    literal: !0
                                };
                                var e
                            },
                            f = (f => {
                                if (t.literal) return p(f);
                                switch (f.val) {
                                    case "G":
                                        return si(e.eras("short", !1), 0);
                                    case "GG":
                                        return si(e.eras("long", !1), 0);
                                    case "y":
                                        return ei(h);
                                    case "yy":
                                    case "kk":
                                        return ei(c, Ct);
                                    case "yyyy":
                                    case "kkkk":
                                        return ei(o);
                                    case "yyyyy":
                                        return ei(d);
                                    case "yyyyyy":
                                        return ei(s);
                                    case "M":
                                    case "L":
                                    case "d":
                                    case "H":
                                    case "h":
                                    case "m":
                                    case "q":
                                    case "s":
                                    case "W":
                                        return ei(a);
                                    case "MM":
                                    case "LL":
                                    case "dd":
                                    case "HH":
                                    case "hh":
                                    case "mm":
                                    case "qq":
                                    case "ss":
                                    case "WW":
                                        return ei(n);
                                    case "MMM":
                                        return si(e.months("short", !0, !1), 1);
                                    case "MMMM":
                                        return si(e.months("long", !0, !1), 1);
                                    case "LLL":
                                        return si(e.months("short", !1, !1), 1);
                                    case "LLLL":
                                        return si(e.months("long", !1, !1), 1);
                                    case "o":
                                    case "S":
                                        return ei(l);
                                    case "ooo":
                                    case "SSS":
                                        return ei(r);
                                    case "u":
                                        return li(u);
                                    case "uu":
                                        return li(a);
                                    case "uuu":
                                    case "E":
                                    case "c":
                                        return ei(i);
                                    case "a":
                                        return si(e.meridiems(), 0);
                                    case "EEE":
                                        return si(e.weekdays("short", !1, !1), 1);
                                    case "EEEE":
                                        return si(e.weekdays("long", !1, !1), 1);
                                    case "ccc":
                                        return si(e.weekdays("short", !0, !1), 1);
                                    case "cccc":
                                        return si(e.weekdays("long", !0, !1), 1);
                                    case "Z":
                                    case "ZZ":
                                        return ai(new RegExp(`([+-]${a.source})(?::(${n.source}))?`), 2);
                                    case "ZZZ":
                                        return ai(new RegExp(`([+-]${a.source})(${n.source})?`), 2);
                                    case "z":
                                        return li(/[a-z_+-/]{1,256}?/i);
                                    case " ":
                                        return li(/[^\S\n\r]/);
                                    default:
                                        return p(f)
                                }
                            })(t) || {
                                invalidReason: "missing Intl.DateTimeFormat.formatToParts support"
                            };
                        return f.token = t, f
                    }(e, t))),
                    o = r.find((t => t.invalidReason));
                if (o) return {
                    input: e,
                    tokens: n,
                    invalidReason: o.invalidReason
                };
                {
                    const [t, i] = function (t) {
                        return [`^${t.map((t => t.regex)).reduce(((t, e) => `${t}(${e.source})`), "")}$`, t]
                    }(r), o = RegExp(t, "i"), [a, l] = function (t, e, i) {
                        const n = t.match(e);
                        if (n) {
                            const t = {};
                            let e = 1;
                            for (const r in i)
                                if (mt(i, r)) {
                                    const o = i[r],
                                        s = o.groups ? o.groups + 1 : 1;
                                    !o.literal && o.token && (t[o.token.val[0]] = o.deser(n.slice(e, e + s))), e += s
                                } return [n, t]
                        }
                        return [n, {}]
                    }(e, o, i), [h, u, c] = l ? function (t) {
                        let e, i = null;
                        return ct(t.z) || (i = W.create(t.z)), ct(t.Z) || (i || (i = new tt(t.Z)), e = t.Z), ct(t.q) || (t.M = 3 * (t.q - 1) + 1), ct(t.h) || (t.h < 12 && 1 === t.a ? t.h += 12 : 12 === t.h && 0 === t.a && (t.h = 0)), 0 === t.G && t.y && (t.y = -t.y), ct(t.u) || (t.S = bt(t.u)), [Object.keys(t).reduce(((e, i) => {
                            const n = (t => {
                                switch (t) {
                                    case "S":
                                        return "millisecond";
                                    case "s":
                                        return "second";
                                    case "m":
                                        return "minute";
                                    case "h":
                                    case "H":
                                        return "hour";
                                    case "d":
                                        return "day";
                                    case "o":
                                        return "ordinal";
                                    case "L":
                                    case "M":
                                        return "month";
                                    case "y":
                                        return "year";
                                    case "E":
                                    case "c":
                                        return "weekday";
                                    case "W":
                                        return "weekNumber";
                                    case "k":
                                        return "weekYear";
                                    case "q":
                                        return "quarter";
                                    default:
                                        return null
                                }
                            })(i);
                            return n && (e[n] = t[i]), e
                        }), {}), i, e]
                    }(l) : [null, null, void 0];
                    if (mt(l, "a") && mt(l, "H")) throw new s("Can't include meridiem when specifying 24-hour format");
                    return {
                        input: e,
                        tokens: n,
                        regex: o,
                        rawMatches: a,
                        matches: l,
                        result: h,
                        zone: u,
                        specificOffset: c
                    }
                }
            }

            function pi(t, e) {
                return t ? Zt.create(e, t).formatDateTimeParts((ui || (ui = qi.fromMillis(1555555555555)), ui)).map((e => function (t, e) {
                    const {
                        type: i,
                        value: n
                    } = t;
                    if ("literal" === i) {
                        const t = /^\s+$/.test(n);
                        return {
                            literal: !t,
                            val: t ? " " : n
                        }
                    }
                    const r = e[i];
                    let o = hi[i];
                    if ("object" == typeof o && (o = o[r]), o) return {
                        literal: !1,
                        val: o
                    }
                }(e, t))) : null
            }
            const fi = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
                gi = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

            function mi(t, e) {
                return new $t("unit out of range", `you specified ${e} (of type ${typeof e}) as a ${t}, which is invalid`)
            }

            function _i(t, e, i) {
                const n = new Date(Date.UTC(t, e - 1, i));
                t < 100 && t >= 0 && n.setUTCFullYear(n.getUTCFullYear() - 1900);
                const r = n.getUTCDay();
                return 0 === r ? 7 : r
            }

            function yi(t, e, i) {
                return i + (Pt(t) ? gi : fi)[e - 1]
            }

            function Si(t, e) {
                const i = Pt(t) ? gi : fi,
                    n = i.findIndex((t => t < e));
                return {
                    month: n + 1,
                    day: e - i[n]
                }
            }

            function vi(t) {
                const {
                    year: e,
                    month: i,
                    day: n
                } = t, r = yi(e, i, n), o = _i(e, i, n);
                let s, a = Math.floor((r - o + 10) / 7);
                return a < 1 ? (s = e - 1, a = Et(s)) : a > Et(e) ? (s = e + 1, a = 1) : s = e, {
                    weekYear: s,
                    weekNumber: a,
                    weekday: o,
                    ...Mt(t)
                }
            }

            function bi(t) {
                const {
                    weekYear: e,
                    weekNumber: i,
                    weekday: n
                } = t, r = _i(e, 1, 4), o = At(e);
                let s, a = 7 * i + n - r - 3;
                a < 1 ? (s = e - 1, a += At(s)) : a > o ? (s = e + 1, a -= At(e)) : s = e;
                const {
                    month: l,
                    day: h
                } = Si(s, a);
                return {
                    year: s,
                    month: l,
                    day: h,
                    ...Mt(t)
                }
            }

            function Ti(t) {
                const {
                    year: e,
                    month: i,
                    day: n
                } = t;
                return {
                    year: e,
                    ordinal: yi(e, i, n),
                    ...Mt(t)
                }
            }

            function Pi(t) {
                const {
                    year: e,
                    ordinal: i
                } = t, {
                    month: n,
                    day: r
                } = Si(e, i);
                return {
                    year: e,
                    month: n,
                    day: r,
                    ...Mt(t)
                }
            }

            function Ai(t) {
                const e = pt(t.year),
                    i = _t(t.month, 1, 12),
                    n = _t(t.day, 1, It(t.year, t.month));
                return e ? i ? !n && mi("day", t.day) : mi("month", t.month) : mi("year", t.year)
            }

            function Ii(t) {
                const {
                    hour: e,
                    minute: i,
                    second: n,
                    millisecond: r
                } = t, o = _t(e, 0, 23) || 24 === e && 0 === i && 0 === n && 0 === r, s = _t(i, 0, 59), a = _t(n, 0, 59), l = _t(r, 0, 999);
                return o ? s ? a ? !l && mi("millisecond", r) : mi("second", n) : mi("minute", i) : mi("hour", e)
            }
            const wi = "Invalid DateTime",
                Ei = 864e13;

            function Ci(t) {
                return new $t("unsupported zone", `the zone "${t.name}" is not supported`)
            }

            function xi(t) {
                return null === t.weekData && (t.weekData = vi(t.c)), t.weekData
            }

            function Bi(t, e) {
                const i = {
                    ts: t.ts,
                    zone: t.zone,
                    c: t.c,
                    o: t.o,
                    loc: t.loc,
                    invalid: t.invalid
                };
                return new qi({
                    ...i,
                    ...e,
                    old: i
                })
            }

            function Li(t, e, i) {
                let n = t - 60 * e * 1e3;
                const r = i.offset(n);
                if (e === r) return [n, e];
                n -= 60 * (r - e) * 1e3;
                const o = i.offset(n);
                return r === o ? [n, r] : [t - 60 * Math.min(r, o) * 1e3, Math.max(r, o)]
            }

            function Oi(t, e) {
                const i = new Date(t += 60 * e * 1e3);
                return {
                    year: i.getUTCFullYear(),
                    month: i.getUTCMonth() + 1,
                    day: i.getUTCDate(),
                    hour: i.getUTCHours(),
                    minute: i.getUTCMinutes(),
                    second: i.getUTCSeconds(),
                    millisecond: i.getUTCMilliseconds()
                }
            }

            function Ni(t, e, i) {
                return Li(wt(t), e, i)
            }

            function Mi(t, e) {
                const i = t.o,
                    n = t.c.year + Math.trunc(e.years),
                    r = t.c.month + Math.trunc(e.months) + 3 * Math.trunc(e.quarters),
                    o = {
                        ...t.c,
                        year: n,
                        month: r,
                        day: Math.min(t.c.day, It(n, r)) + Math.trunc(e.days) + 7 * Math.trunc(e.weeks)
                    },
                    s = je.fromObject({
                        years: e.years - Math.trunc(e.years),
                        quarters: e.quarters - Math.trunc(e.quarters),
                        months: e.months - Math.trunc(e.months),
                        weeks: e.weeks - Math.trunc(e.weeks),
                        days: e.days - Math.trunc(e.days),
                        hours: e.hours,
                        minutes: e.minutes,
                        seconds: e.seconds,
                        milliseconds: e.milliseconds
                    }).as("milliseconds"),
                    a = wt(o);
                let [l, h] = Li(a, i, t.zone);
                return 0 !== s && (l += s, h = t.zone.offset(l)), {
                    ts: l,
                    o: h
                }
            }

            function Ri(t, e, i, n, r, o) {
                const {
                    setZone: s,
                    zone: a
                } = i;
                if (t && 0 !== Object.keys(t).length || e) {
                    const n = e || a,
                        r = qi.fromObject(t, {
                            ...i,
                            zone: n,
                            specificOffset: o
                        });
                    return s ? r : r.setZone(a)
                }
                return qi.invalid(new $t("unparsable", `the input "${r}" can't be parsed as ${n}`))
            }

            function Di(t, e, i = !0) {
                return t.isValid ? Zt.create(J.create("en-US"), {
                    allowZ: i,
                    forceSimple: !0
                }).formatDateTimeFromString(t, e) : null
            }

            function Fi(t, e) {
                const i = t.c.year > 9999 || t.c.year < 0;
                let n = "";
                return i && t.c.year >= 0 && (n += "+"), n += yt(t.c.year, i ? 6 : 4), e ? (n += "-", n += yt(t.c.month), n += "-", n += yt(t.c.day)) : (n += yt(t.c.month), n += yt(t.c.day)), n
            }

            function ki(t, e, i, n, r, o) {
                let s = yt(t.c.hour);
                return e ? (s += ":", s += yt(t.c.minute), 0 === t.c.second && i || (s += ":")) : s += yt(t.c.minute), 0 === t.c.second && i || (s += yt(t.c.second), 0 === t.c.millisecond && n || (s += ".", s += yt(t.c.millisecond, 3))), r && (t.isOffsetFixed && 0 === t.offset && !o ? s += "Z" : t.o < 0 ? (s += "-", s += yt(Math.trunc(-t.o / 60)), s += ":", s += yt(Math.trunc(-t.o % 60))) : (s += "+", s += yt(Math.trunc(t.o / 60)), s += ":", s += yt(Math.trunc(t.o % 60)))), o && (s += "[" + t.zone.ianaName + "]"), s
            }
            const Ui = {
                month: 1,
                day: 1,
                hour: 0,
                minute: 0,
                second: 0,
                millisecond: 0
            },
                Gi = {
                    weekNumber: 1,
                    weekday: 1,
                    hour: 0,
                    minute: 0,
                    second: 0,
                    millisecond: 0
                },
                Wi = {
                    ordinal: 1,
                    hour: 0,
                    minute: 0,
                    second: 0,
                    millisecond: 0
                },
                Vi = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
                Xi = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
                Hi = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

            function Yi(t) {
                const e = {
                    year: "year",
                    years: "year",
                    month: "month",
                    months: "month",
                    day: "day",
                    days: "day",
                    hour: "hour",
                    hours: "hour",
                    minute: "minute",
                    minutes: "minute",
                    quarter: "quarter",
                    quarters: "quarter",
                    second: "second",
                    seconds: "second",
                    millisecond: "millisecond",
                    milliseconds: "millisecond",
                    weekday: "weekday",
                    weekdays: "weekday",
                    weeknumber: "weekNumber",
                    weeksnumber: "weekNumber",
                    weeknumbers: "weekNumber",
                    weekyear: "weekYear",
                    weekyears: "weekYear",
                    ordinal: "ordinal"
                }[t.toLowerCase()];
                if (!e) throw new a(t);
                return e
            }

            function ji(t, e) {
                const i = it(e.zone, ut.defaultZone),
                    n = J.fromObject(e),
                    r = ut.now();
                let o, s;
                if (ct(t.year)) o = r;
                else {
                    for (const e of Vi) ct(t[e]) && (t[e] = Ui[e]);
                    const e = Ai(t) || Ii(t);
                    if (e) return qi.invalid(e);
                    const n = i.offset(r);
                    [o, s] = Ni(t, n, i)
                }
                return new qi({
                    ts: o,
                    zone: i,
                    loc: n,
                    o: s
                })
            }

            function zi(t, e, i) {
                const n = !!ct(i.round) || i.round,
                    r = (t, r) => (t = Tt(t, n || i.calendary ? 0 : 2, !0), e.loc.clone(i).relFormatter(i).format(t, r)),
                    o = n => i.calendary ? e.hasSame(t, n) ? 0 : e.startOf(n).diff(t.startOf(n), n).get(n) : e.diff(t, n).get(n);
                if (i.unit) return r(o(i.unit), i.unit);
                for (const t of i.units) {
                    const e = o(t);
                    if (Math.abs(e) >= 1) return r(e, t)
                }
                return r(t > e ? -0 : 0, i.units[i.units.length - 1])
            }

            function Ki(t) {
                let e, i = {};
                return t.length > 0 && "object" == typeof t[t.length - 1] ? (i = t[t.length - 1], e = Array.from(t).slice(0, t.length - 1)) : e = Array.from(t), [i, e]
            }
            class qi {
                constructor(t) {
                    const e = t.zone || ut.defaultZone;
                    let i = t.invalid || (Number.isNaN(t.ts) ? new $t("invalid input") : null) || (e.isValid ? null : Ci(e));
                    this.ts = ct(t.ts) ? ut.now() : t.ts;
                    let n = null,
                        r = null;
                    if (!i)
                        if (t.old && t.old.ts === this.ts && t.old.zone.equals(e)) [n, r] = [t.old.c, t.old.o];
                        else {
                            const t = e.offset(this.ts);
                            n = Oi(this.ts, t), i = Number.isNaN(n.year) ? new $t("invalid input") : null, n = i ? null : n, r = i ? null : t
                        } this._zone = e, this.loc = t.loc || J.create(), this.invalid = i, this.weekData = null, this.c = n, this.o = r, this.isLuxonDateTime = !0
                }
                static now() {
                    return new qi({})
                }
                static local() {
                    const [t, e] = Ki(arguments), [i, n, r, o, s, a, l] = e;
                    return ji({
                        year: i,
                        month: n,
                        day: r,
                        hour: o,
                        minute: s,
                        second: a,
                        millisecond: l
                    }, t)
                }
                static utc() {
                    const [t, e] = Ki(arguments), [i, n, r, o, s, a, l] = e;
                    return t.zone = tt.utcInstance, ji({
                        year: i,
                        month: n,
                        day: r,
                        hour: o,
                        minute: s,
                        second: a,
                        millisecond: l
                    }, t)
                }
                static fromJSDate(t, e = {}) {
                    const i = (n = t, "[object Date]" === Object.prototype.toString.call(n) ? t.valueOf() : NaN);
                    var n;
                    if (Number.isNaN(i)) return qi.invalid("invalid input");
                    const r = it(e.zone, ut.defaultZone);
                    return r.isValid ? new qi({
                        ts: i,
                        zone: r,
                        loc: J.fromObject(e)
                    }) : qi.invalid(Ci(r))
                }
                static fromMillis(t, e = {}) {
                    if (dt(t)) return t < -Ei || t > Ei ? qi.invalid("Timestamp out of range") : new qi({
                        ts: t,
                        zone: it(e.zone, ut.defaultZone),
                        loc: J.fromObject(e)
                    });
                    throw new l(`fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`)
                }
                static fromSeconds(t, e = {}) {
                    if (dt(t)) return new qi({
                        ts: 1e3 * t,
                        zone: it(e.zone, ut.defaultZone),
                        loc: J.fromObject(e)
                    });
                    throw new l("fromSeconds requires a numerical input")
                }
                static fromObject(t, e = {}) {
                    t = t || {};
                    const i = it(e.zone, ut.defaultZone);
                    if (!i.isValid) return qi.invalid(Ci(i));
                    const n = ut.now(),
                        r = ct(e.specificOffset) ? i.offset(n) : e.specificOffset,
                        o = Ot(t, Yi),
                        a = !ct(o.ordinal),
                        l = !ct(o.year),
                        h = !ct(o.month) || !ct(o.day),
                        u = l || h,
                        c = o.weekYear || o.weekNumber,
                        d = J.fromObject(e);
                    if ((u || a) && c) throw new s("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
                    if (h && a) throw new s("Can't mix ordinal dates with month/day");
                    const p = c || o.weekday && !u;
                    let f, g, m = Oi(n, r);
                    p ? (f = Xi, g = Gi, m = vi(m)) : a ? (f = Hi, g = Wi, m = Ti(m)) : (f = Vi, g = Ui);
                    let _ = !1;
                    for (const t of f) ct(o[t]) ? o[t] = _ ? g[t] : m[t] : _ = !0;
                    const y = p ? function (t) {
                        const e = pt(t.weekYear),
                            i = _t(t.weekNumber, 1, Et(t.weekYear)),
                            n = _t(t.weekday, 1, 7);
                        return e ? i ? !n && mi("weekday", t.weekday) : mi("week", t.week) : mi("weekYear", t.weekYear)
                    }(o) : a ? function (t) {
                        const e = pt(t.year),
                            i = _t(t.ordinal, 1, At(t.year));
                        return e ? !i && mi("ordinal", t.ordinal) : mi("year", t.year)
                    }(o) : Ai(o),
                        S = y || Ii(o);
                    if (S) return qi.invalid(S);
                    const v = p ? bi(o) : a ? Pi(o) : o,
                        [b, T] = Ni(v, r, i),
                        P = new qi({
                            ts: b,
                            zone: i,
                            o: T,
                            loc: d
                        });
                    return o.weekday && u && t.weekday !== P.weekday ? qi.invalid("mismatched weekday", `you can't specify both a weekday of ${o.weekday} and a date of ${P.toISO()}`) : P
                }
                static fromISO(t, e = {}) {
                    const [i, n] = function (t) {
                        return ee(t, [Ee, Le], [Ce, Oe], [xe, Ne], [Be, Me])
                    }(t);
                    return Ri(i, n, e, "ISO 8601", t)
                }
                static fromRFC2822(t, e = {}) {
                    const [i, n] = function (t) {
                        return ee(function (t) {
                            return t.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
                        }(t), [ve, be])
                    }(t);
                    return Ri(i, n, e, "RFC 2822", t)
                }
                static fromHTTP(t, e = {}) {
                    const [i, n] = function (t) {
                        return ee(t, [Te, Ie], [Pe, Ie], [Ae, we])
                    }(t);
                    return Ri(i, n, e, "HTTP", e)
                }
                static fromFormat(t, e, i = {}) {
                    if (ct(t) || ct(e)) throw new l("fromFormat requires an input string and a format");
                    const {
                        locale: n = null,
                        numberingSystem: r = null
                    } = i, o = J.fromOpts({
                        locale: n,
                        numberingSystem: r,
                        defaultToEN: !0
                    }), [s, a, h, u] = function (t, e, i) {
                        const {
                            result: n,
                            zone: r,
                            specificOffset: o,
                            invalidReason: s
                        } = di(t, e, i);
                        return [n, r, o, s]
                    }(o, t, e);
                    return u ? qi.invalid(u) : Ri(s, a, i, `format ${e}`, t, h)
                }
                static fromString(t, e, i = {}) {
                    return qi.fromFormat(t, e, i)
                }
                static fromSQL(t, e = {}) {
                    const [i, n] = function (t) {
                        return ee(t, [De, Le], [Fe, ke])
                    }(t);
                    return Ri(i, n, e, "SQL", t)
                }
                static invalid(t, e = null) {
                    if (!t) throw new l("need to specify a reason the DateTime is invalid");
                    const i = t instanceof $t ? t : new $t(t, e);
                    if (ut.throwOnInvalid) throw new n(i);
                    return new qi({
                        invalid: i
                    })
                }
                static isDateTime(t) {
                    return t && t.isLuxonDateTime || !1
                }
                static parseFormatForOpts(t, e = {}) {
                    const i = pi(t, J.fromObject(e));
                    return i ? i.map((t => t ? t.val : null)).join("") : null
                }
                static expandFormat(t, e = {}) {
                    return ci(Zt.parseFormat(t), J.fromObject(e)).map((t => t.val)).join("")
                }
                get(t) {
                    return this[t]
                }
                get isValid() {
                    return null === this.invalid
                }
                get invalidReason() {
                    return this.invalid ? this.invalid.reason : null
                }
                get invalidExplanation() {
                    return this.invalid ? this.invalid.explanation : null
                }
                get locale() {
                    return this.isValid ? this.loc.locale : null
                }
                get numberingSystem() {
                    return this.isValid ? this.loc.numberingSystem : null
                }
                get outputCalendar() {
                    return this.isValid ? this.loc.outputCalendar : null
                }
                get zone() {
                    return this._zone
                }
                get zoneName() {
                    return this.isValid ? this.zone.name : null
                }
                get year() {
                    return this.isValid ? this.c.year : NaN
                }
                get quarter() {
                    return this.isValid ? Math.ceil(this.c.month / 3) : NaN
                }
                get month() {
                    return this.isValid ? this.c.month : NaN
                }
                get day() {
                    return this.isValid ? this.c.day : NaN
                }
                get hour() {
                    return this.isValid ? this.c.hour : NaN
                }
                get minute() {
                    return this.isValid ? this.c.minute : NaN
                }
                get second() {
                    return this.isValid ? this.c.second : NaN
                }
                get millisecond() {
                    return this.isValid ? this.c.millisecond : NaN
                }
                get weekYear() {
                    return this.isValid ? xi(this).weekYear : NaN
                }
                get weekNumber() {
                    return this.isValid ? xi(this).weekNumber : NaN
                }
                get weekday() {
                    return this.isValid ? xi(this).weekday : NaN
                }
                get ordinal() {
                    return this.isValid ? Ti(this.c).ordinal : NaN
                }
                get monthShort() {
                    return this.isValid ? qe.months("short", {
                        locObj: this.loc
                    })[this.month - 1] : null
                }
                get monthLong() {
                    return this.isValid ? qe.months("long", {
                        locObj: this.loc
                    })[this.month - 1] : null
                }
                get weekdayShort() {
                    return this.isValid ? qe.weekdays("short", {
                        locObj: this.loc
                    })[this.weekday - 1] : null
                }
                get weekdayLong() {
                    return this.isValid ? qe.weekdays("long", {
                        locObj: this.loc
                    })[this.weekday - 1] : null
                }
                get offset() {
                    return this.isValid ? +this.o : NaN
                }
                get offsetNameShort() {
                    return this.isValid ? this.zone.offsetName(this.ts, {
                        format: "short",
                        locale: this.locale
                    }) : null
                }
                get offsetNameLong() {
                    return this.isValid ? this.zone.offsetName(this.ts, {
                        format: "long",
                        locale: this.locale
                    }) : null
                }
                get isOffsetFixed() {
                    return this.isValid ? this.zone.isUniversal : null
                }
                get isInDST() {
                    return !this.isOffsetFixed && (this.offset > this.set({
                        month: 1,
                        day: 1
                    }).offset || this.offset > this.set({
                        month: 5
                    }).offset)
                }
                get isInLeapYear() {
                    return Pt(this.year)
                }
                get daysInMonth() {
                    return It(this.year, this.month)
                }
                get daysInYear() {
                    return this.isValid ? At(this.year) : NaN
                }
                get weeksInWeekYear() {
                    return this.isValid ? Et(this.weekYear) : NaN
                }
                resolvedLocaleOptions(t = {}) {
                    const {
                        locale: e,
                        numberingSystem: i,
                        calendar: n
                    } = Zt.create(this.loc.clone(t), t).resolvedOptions(this);
                    return {
                        locale: e,
                        numberingSystem: i,
                        outputCalendar: n
                    }
                }
                toUTC(t = 0, e = {}) {
                    return this.setZone(tt.instance(t), e)
                }
                toLocal() {
                    return this.setZone(ut.defaultZone)
                }
                setZone(t, {
                    keepLocalTime: e = !1,
                    keepCalendarTime: i = !1
                } = {}) {
                    if ((t = it(t, ut.defaultZone)).equals(this.zone)) return this;
                    if (t.isValid) {
                        let n = this.ts;
                        if (e || i) {
                            const e = t.offset(this.ts),
                                i = this.toObject();
                            [n] = Ni(i, e, t)
                        }
                        return Bi(this, {
                            ts: n,
                            zone: t
                        })
                    }
                    return qi.invalid(Ci(t))
                }
                reconfigure({
                    locale: t,
                    numberingSystem: e,
                    outputCalendar: i
                } = {}) {
                    return Bi(this, {
                        loc: this.loc.clone({
                            locale: t,
                            numberingSystem: e,
                            outputCalendar: i
                        })
                    })
                }
                setLocale(t) {
                    return this.reconfigure({
                        locale: t
                    })
                }
                set(t) {
                    if (!this.isValid) return this;
                    const e = Ot(t, Yi),
                        i = !ct(e.weekYear) || !ct(e.weekNumber) || !ct(e.weekday),
                        n = !ct(e.ordinal),
                        r = !ct(e.year),
                        o = !ct(e.month) || !ct(e.day),
                        a = r || o,
                        l = e.weekYear || e.weekNumber;
                    if ((a || n) && l) throw new s("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
                    if (o && n) throw new s("Can't mix ordinal dates with month/day");
                    let h;
                    i ? h = bi({
                        ...vi(this.c),
                        ...e
                    }) : ct(e.ordinal) ? (h = {
                        ...this.toObject(),
                        ...e
                    }, ct(e.day) && (h.day = Math.min(It(h.year, h.month), h.day))) : h = Pi({
                        ...Ti(this.c),
                        ...e
                    });
                    const [u, c] = Ni(h, this.o, this.zone);
                    return Bi(this, {
                        ts: u,
                        o: c
                    })
                }
                plus(t) {
                    return this.isValid ? Bi(this, Mi(this, je.fromDurationLike(t))) : this
                }
                minus(t) {
                    return this.isValid ? Bi(this, Mi(this, je.fromDurationLike(t).negate())) : this
                }
                startOf(t) {
                    if (!this.isValid) return this;
                    const e = {},
                        i = je.normalizeUnit(t);
                    switch (i) {
                        case "years":
                            e.month = 1;
                        case "quarters":
                        case "months":
                            e.day = 1;
                        case "weeks":
                        case "days":
                            e.hour = 0;
                        case "hours":
                            e.minute = 0;
                        case "minutes":
                            e.second = 0;
                        case "seconds":
                            e.millisecond = 0
                    }
                    if ("weeks" === i && (e.weekday = 1), "quarters" === i) {
                        const t = Math.ceil(this.month / 3);
                        e.month = 3 * (t - 1) + 1
                    }
                    return this.set(e)
                }
                endOf(t) {
                    return this.isValid ? this.plus({
                        [t]: 1
                    }).startOf(t).minus(1) : this
                }
                toFormat(t, e = {}) {
                    return this.isValid ? Zt.create(this.loc.redefaultToEN(e)).formatDateTimeFromString(this, t) : wi
                }
                toLocaleString(t = p, e = {}) {
                    return this.isValid ? Zt.create(this.loc.clone(e), t).formatDateTime(this) : wi
                }
                toLocaleParts(t = {}) {
                    return this.isValid ? Zt.create(this.loc.clone(t), t).formatDateTimeParts(this) : []
                }
                toISO({
                    format: t = "extended",
                    suppressSeconds: e = !1,
                    suppressMilliseconds: i = !1,
                    includeOffset: n = !0,
                    extendedZone: r = !1
                } = {}) {
                    if (!this.isValid) return null;
                    const o = "extended" === t;
                    let s = Fi(this, o);
                    return s += "T", s += ki(this, o, e, i, n, r), s
                }
                toISODate({
                    format: t = "extended"
                } = {}) {
                    return this.isValid ? Fi(this, "extended" === t) : null
                }
                toISOWeekDate() {
                    return Di(this, "kkkk-'W'WW-c")
                }
                toISOTime({
                    suppressMilliseconds: t = !1,
                    suppressSeconds: e = !1,
                    includeOffset: i = !0,
                    includePrefix: n = !1,
                    extendedZone: r = !1,
                    format: o = "extended"
                } = {}) {
                    return this.isValid ? (n ? "T" : "") + ki(this, "extended" === o, e, t, i, r) : null
                }
                toRFC2822() {
                    return Di(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1)
                }
                toHTTP() {
                    return Di(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'")
                }
                toSQLDate() {
                    return this.isValid ? Fi(this, !0) : null
                }
                toSQLTime({
                    includeOffset: t = !0,
                    includeZone: e = !1,
                    includeOffsetSpace: i = !0
                } = {}) {
                    let n = "HH:mm:ss.SSS";
                    return (e || t) && (i && (n += " "), e ? n += "z" : t && (n += "ZZ")), Di(this, n, !0)
                }
                toSQL(t = {}) {
                    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null
                }
                toString() {
                    return this.isValid ? this.toISO() : wi
                }
                valueOf() {
                    return this.toMillis()
                }
                toMillis() {
                    return this.isValid ? this.ts : NaN
                }
                toSeconds() {
                    return this.isValid ? this.ts / 1e3 : NaN
                }
                toUnixInteger() {
                    return this.isValid ? Math.floor(this.ts / 1e3) : NaN
                }
                toJSON() {
                    return this.toISO()
                }
                toBSON() {
                    return this.toJSDate()
                }
                toObject(t = {}) {
                    if (!this.isValid) return {};
                    const e = {
                        ...this.c
                    };
                    return t.includeConfig && (e.outputCalendar = this.outputCalendar, e.numberingSystem = this.loc.numberingSystem, e.locale = this.loc.locale), e
                }
                toJSDate() {
                    return new Date(this.isValid ? this.ts : NaN)
                }
                diff(t, e = "milliseconds", i = {}) {
                    if (!this.isValid || !t.isValid) return je.invalid("created by diffing an invalid DateTime");
                    const n = {
                        locale: this.locale,
                        numberingSystem: this.numberingSystem,
                        ...i
                    },
                        r = (a = e, Array.isArray(a) ? a : [a]).map(je.normalizeUnit),
                        o = t.valueOf() > this.valueOf(),
                        s = function (t, e, i, n) {
                            let [r, o, s, a] = function (t, e, i) {
                                const n = [
                                    ["years", (t, e) => e.year - t.year],
                                    ["quarters", (t, e) => e.quarter - t.quarter + 4 * (e.year - t.year)],
                                    ["months", (t, e) => e.month - t.month + 12 * (e.year - t.year)],
                                    ["weeks", (t, e) => {
                                        const i = Ze(t, e);
                                        return (i - i % 7) / 7
                                    }],
                                    ["days", Ze]
                                ],
                                    r = {},
                                    o = t;
                                let s, a;
                                for (const [l, h] of n) i.indexOf(l) >= 0 && (s = l, r[l] = h(t, e), a = o.plus(r), a > e ? (r[l]--, t = o.plus(r)) : t = a);
                                return [t, r, a, s]
                            }(t, e, i);
                            const l = e - r,
                                h = i.filter((t => ["hours", "minutes", "seconds", "milliseconds"].indexOf(t) >= 0));
                            0 === h.length && (s < e && (s = r.plus({
                                [a]: 1
                            })), s !== r && (o[a] = (o[a] || 0) + l / (s - r)));
                            const u = je.fromObject(o, n);
                            return h.length > 0 ? je.fromMillis(l, n).shiftTo(...h).plus(u) : u
                        }(o ? this : t, o ? t : this, r, n);
                    var a;
                    return o ? s.negate() : s
                }
                diffNow(t = "milliseconds", e = {}) {
                    return this.diff(qi.now(), t, e)
                }
                until(t) {
                    return this.isValid ? Ke.fromDateTimes(this, t) : this
                }
                hasSame(t, e) {
                    if (!this.isValid) return !1;
                    const i = t.valueOf(),
                        n = this.setZone(t.zone, {
                            keepLocalTime: !0
                        });
                    return n.startOf(e) <= i && i <= n.endOf(e)
                }
                equals(t) {
                    return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc)
                }
                toRelative(t = {}) {
                    if (!this.isValid) return null;
                    const e = t.base || qi.fromObject({}, {
                        zone: this.zone
                    }),
                        i = t.padding ? this < e ? -t.padding : t.padding : 0;
                    let n = ["years", "months", "days", "hours", "minutes", "seconds"],
                        r = t.unit;
                    return Array.isArray(t.unit) && (n = t.unit, r = void 0), zi(e, this.plus(i), {
                        ...t,
                        numeric: "always",
                        units: n,
                        unit: r
                    })
                }
                toRelativeCalendar(t = {}) {
                    return this.isValid ? zi(t.base || qi.fromObject({}, {
                        zone: this.zone
                    }), this, {
                        ...t,
                        numeric: "auto",
                        units: ["years", "months", "days"],
                        calendary: !0
                    }) : null
                }
                static min(...t) {
                    if (!t.every(qi.isDateTime)) throw new l("min requires all arguments be DateTimes");
                    return gt(t, (t => t.valueOf()), Math.min)
                }
                static max(...t) {
                    if (!t.every(qi.isDateTime)) throw new l("max requires all arguments be DateTimes");
                    return gt(t, (t => t.valueOf()), Math.max)
                }
                static fromFormatExplain(t, e, i = {}) {
                    const {
                        locale: n = null,
                        numberingSystem: r = null
                    } = i;
                    return di(J.fromOpts({
                        locale: n,
                        numberingSystem: r,
                        defaultToEN: !0
                    }), t, e)
                }
                static fromStringExplain(t, e, i = {}) {
                    return qi.fromFormatExplain(t, e, i)
                }
                static get DATE_SHORT() {
                    return p
                }
                static get DATE_MED() {
                    return f
                }
                static get DATE_MED_WITH_WEEKDAY() {
                    return g
                }
                static get DATE_FULL() {
                    return m
                }
                static get DATE_HUGE() {
                    return _
                }
                static get TIME_SIMPLE() {
                    return y
                }
                static get TIME_WITH_SECONDS() {
                    return S
                }
                static get TIME_WITH_SHORT_OFFSET() {
                    return v
                }
                static get TIME_WITH_LONG_OFFSET() {
                    return b
                }
                static get TIME_24_SIMPLE() {
                    return T
                }
                static get TIME_24_WITH_SECONDS() {
                    return P
                }
                static get TIME_24_WITH_SHORT_OFFSET() {
                    return A
                }
                static get TIME_24_WITH_LONG_OFFSET() {
                    return I
                }
                static get DATETIME_SHORT() {
                    return w
                }
                static get DATETIME_SHORT_WITH_SECONDS() {
                    return E
                }
                static get DATETIME_MED() {
                    return C
                }
                static get DATETIME_MED_WITH_SECONDS() {
                    return x
                }
                static get DATETIME_MED_WITH_WEEKDAY() {
                    return B
                }
                static get DATETIME_FULL() {
                    return L
                }
                static get DATETIME_FULL_WITH_SECONDS() {
                    return O
                }
                static get DATETIME_HUGE() {
                    return N
                }
                static get DATETIME_HUGE_WITH_SECONDS() {
                    return M
                }
            }

            function Zi(t) {
                if (qi.isDateTime(t)) return t;
                if (t && t.valueOf && dt(t.valueOf())) return qi.fromJSDate(t);
                if (t && "object" == typeof t) return qi.fromObject(t);
                throw new l(`Unknown datetime argument: ${t}, of type ${typeof t}`)
            }
            e.DateTime = qi, e.Duration = je, e.FixedOffsetZone = tt, e.IANAZone = W, e.Info = qe, e.Interval = Ke, e.InvalidZone = et, e.Settings = ut, e.SystemZone = F, e.VERSION = "3.3.0", e.Zone = R
        },
        2940: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            var i = function () {
                function t(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var n = e[i];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                    }
                }
                return function (e, i, n) {
                    return i && t(e.prototype, i), n && t(e, n), e
                }
            }();

            function n(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }
            var r = function () {
                function t(e, i, r) {
                    void 0 === i && (i = !1), n(this, t), this._fn = e, this._once = i, this._thisArg = r, this._next = this._prev = this._owner = null
                }
                return i(t, [{
                    key: "detach",
                    value: function () {
                        return null !== this._owner && (this._owner.detach(this), !0)
                    }
                }]), t
            }();

            function o(t, e) {
                return t._head ? (t._tail._next = e, e._prev = t._tail, t._tail = e) : (t._head = e, t._tail = e), e._owner = t, e
            }
            var s = function () {
                function t() {
                    n(this, t), this._head = this._tail = void 0
                }
                return i(t, [{
                    key: "handlers",
                    value: function () {
                        var t = !(arguments.length <= 0 || void 0 === arguments[0]) && arguments[0],
                            e = this._head;
                        if (t) return !!e;
                        for (var i = []; e;) i.push(e), e = e._next;
                        return i
                    }
                }, {
                    key: "has",
                    value: function (t) {
                        if (!(t instanceof r)) throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
                        return t._owner === this
                    }
                }, {
                    key: "dispatch",
                    value: function () {
                        var t = this._head;
                        if (!t) return !1;
                        for (; t;) t._once && this.detach(t), t._fn.apply(t._thisArg, arguments), t = t._next;
                        return !0
                    }
                }, {
                    key: "add",
                    value: function (t) {
                        var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
                        if ("function" != typeof t) throw new Error("MiniSignal#add(): First arg must be a Function.");
                        return o(this, new r(t, !1, e))
                    }
                }, {
                    key: "once",
                    value: function (t) {
                        var e = arguments.length <= 1 || void 0 === arguments[1] ? null : arguments[1];
                        if ("function" != typeof t) throw new Error("MiniSignal#once(): First arg must be a Function.");
                        return o(this, new r(t, !0, e))
                    }
                }, {
                    key: "detach",
                    value: function (t) {
                        if (!(t instanceof r)) throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
                        return t._owner !== this || (t._prev && (t._prev._next = t._next), t._next && (t._next._prev = t._prev), t === this._head ? (this._head = t._next, null === t._next && (this._tail = null)) : t === this._tail && (this._tail = t._prev, this._tail._next = null), t._owner = null), this
                    }
                }, {
                    key: "detachAll",
                    value: function () {
                        var t = this._head;
                        if (!t) return this;
                        for (this._head = this._tail = null; t;) t._owner = null, t = t._next;
                        return this
                    }
                }]), t
            }();
            s.MiniSignalBinding = r, e.default = s, t.exports = e.default
        },
        1984: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b('<div class="nolimit container loading">\r'), n.b("\n" + i), n.b('    <div class="fun" style="display: none;">'), n.s(n.f("tr", t, e, 1), t, e, 0, 92, 107, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("PLAYING FOR FUN")
                    })), t.pop()), n.b("</div>\r"), n.b("\n" + i), n.b('    <div class="replay" style="display: none;">R</div>\r'), n.b("\n" + i), n.b('    <div class="overlay"></div>\r'), n.b("\n" + i), n.b('    <div class="hidden" style="position:absolute;"></div>\r'), n.b("\n" + i), n.b('    <div class="game"></div>\r'), n.b("\n" + i), n.b('    <div id="game-name-version">'), n.b(n.v(n.f("game", t, e, 0))), n.b("</div>\r"), n.b("\n" + i), n.b('    <div id="net-position"></div>\r'), n.b("\n" + i), n.b("</div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '<div class="nolimit container loading">\r\n    <div class="fun" style="display: none;">{{#tr}}PLAYING FOR FUN{{/tr}}</div>\r\n    <div class="replay" style="display: none;">R</div>\r\n    <div class="overlay"></div>\r\n    <div class="hidden" style="position:absolute;"></div>\r\n    <div class="game"></div>\r\n    <div id="game-name-version">{{game}}</div>\r\n    <div id="net-position"></div>\r\n</div>\r\n', n)
        },
        446: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 38, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Oops, something went wrong!")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 62, 145, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("The location associated with your IP is not permitted to access the requested game.")
                    })), t.pop()), n.b("</p>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, "<h1>{{#tr}}Oops, something went wrong!{{/tr}}</h1>\r\n<p>{{#tr}}The location associated with your IP is not permitted to access the requested game.{{/tr}}</p>\r\n", n)
        },
        6192: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.s(n.f("title", t, e, 1), t, e, 1, 0, 0, "") || (n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 61, 88, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Oops, something went wrong!")
                    })), t.pop()), n.b("</h1>")), n.b("\r"), n.b("\n" + i), n.s(n.f("message", t, e, 1), t, e, 0, 124, 142, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<p>"), i.b(i.v(i.f("message", t, e, 0))), i.b("</p>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 167, 332, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("<div>\r"), n.b("\n" + i), n.b('    <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 222, 224, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("OK")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 291, 306, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("Contact support")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("</div>\r"), n.b("\n" + i)
                    })), t.pop()), n.s(n.f("desktop", t, e, 1), t, e, 0, 357, 441, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 408, 423, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("Contact support")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i)
                    })), t.pop()), n.fl()
                },
                partials: {},
                subs: {}
            }, '{{#title}}<h1>{{title}}</h1>{{/title}}\r\n{{^title}}<h1>{{#tr}}Oops, something went wrong!{{/tr}}</h1>{{/title}}\r\n{{#message}}<p>{{message}}</p>{{/message}}\r\n{{#mobile}}\r\n<div>\r\n    <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\r\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\r\n</div>\r\n{{/mobile}}\r\n{{#desktop}}\r\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\r\n{{/desktop}}\r\n', n)
        },
        172: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b('<p style="color: #9afb00">'), n.b(n.v(n.f("flash", t, e, 0))), n.b("</p>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '<p style="color: #9afb00">{{flash}}</p>\r\n', n)
        },
        9697: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<p>"), n.b(n.v(n.f("message", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 31, 126, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("    <div>\r"), n.b("\n" + i), n.b('        <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 94, 96, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("OK")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("    </div>\r"), n.b("\n" + i)
                    })), t.pop()), n.s(n.f("desktop", t, e, 1), t, e, 0, 151, 262, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("    <div>\r"), n.b("\n" + i), n.b('        <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 217, 232, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("Contact support")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("    </div>\r"), n.b("\n" + i)
                    })), t.pop()), n.fl()
                },
                partials: {},
                subs: {}
            }, '<p>{{message}}</p>\r\n{{#mobile}}\r\n    <div>\r\n        <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\r\n    </div>\r\n{{/mobile}}\r\n{{#desktop}}\r\n    <div>\r\n        <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\r\n    </div>\r\n{{/desktop}}\r\n', n)
        },
        1715: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 38, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Oops, something went wrong!")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.s(n.f("message", t, e, 1), t, e, 0, 64, 82, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<p>"), i.b(i.v(i.f("message", t, e, 0))), i.b("</p>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 106, 196, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Don't worry, you haven't lost any money! If the problem continues, please contact support.")
                    })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 220, 385, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("<div>\r"), n.b("\n" + i), n.b('    <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 275, 277, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("OK")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 344, 359, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("Contact support")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("</div>\r"), n.b("\n" + i)
                    })), t.pop()), n.s(n.f("desktop", t, e, 1), t, e, 0, 410, 494, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('    <button type="button" class="support">'), n.s(n.f("tr", t, e, 1), t, e, 0, 461, 476, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("Contact support")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i)
                    })), t.pop()), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Oops, something went wrong!{{/tr}}</h1>\r\n{{#message}}<p>{{message}}</p>{{/message}}\r\n<p>{{#tr}}Don\'t worry, you haven\'t lost any money! If the problem continues, please contact support.{{/tr}}</p>\r\n{{#mobile}}\r\n<div>\r\n    <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\r\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\r\n</div>\r\n{{/mobile}}\r\n{{#desktop}}\r\n    <button type="button" class="support">{{#tr}}Contact support{{/tr}}</button>\r\n{{/desktop}}\r\n', n)
        },
        4863: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("message", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.b("<div>\r"), n.b("\n" + i), n.b('    <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 114, 116, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("OK")
                    })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("</div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '{{#title}}<h1>{{title}}</h1>{{/title}}\r\n<p>{{message}}</p>\r\n<div>\r\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\r\n</div>\r\n', n)
        },
        891: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Insufficient funds")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.s(n.f("deposit", t, e, 1), t, e, 0, 55, 282, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("    <p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 71, 120, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("Would you like to open the operator cashier page?")
                        })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.b('    <div><button type="button" class="deposit close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 193, 196, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("YES")
                        })), t.pop()), n.b('</button> <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 256, 258, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("NO")
                        })), t.pop()), n.b("</button></div>\r"), n.b("\n" + i)
                    })), t.pop()), n.s(n.f("deposit", t, e, 1), t, e, 1, 0, 0, "") || (n.b("    <p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 324, 413, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Please go through the deposit flow to deposit more money if you wish to continue playing!")
                    })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.b('    <div><button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 478, 480, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("OK")
                    })), t.pop()), n.b("</button></div>\r"), n.b("\n" + i)), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Insufficient funds{{/tr}}</h1>\r\n{{#deposit}}\r\n    <p>{{#tr}}Would you like to open the operator cashier page?{{/tr}}</p>\r\n    <div><button type="button" class="deposit close">{{#tr}}YES{{/tr}}</button> <button type="button" class="close">{{#tr}}NO{{/tr}}</button></div>\r\n{{/deposit}}\r\n{{^deposit}}\r\n    <p>{{#tr}}Please go through the deposit flow to deposit more money if you wish to continue playing!{{/tr}}</p>\r\n    <div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\r\n{{/deposit}}\r\n', n)
        },
        4455: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Breaking the bank!")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 53, 128, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Congrats! You're insanely lucky - you just won the maximum possible amount!")
                    })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("amount", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 171, 268, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("<div>\r"), n.b("\n" + i), n.b('    <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 226, 242, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("End Game Session")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("</div>\r"), n.b("\n" + i)
                    })), t.pop()), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Breaking the bank!{{/tr}}</h1>\r\n<p>{{#tr}}Congrats! You\'re insanely lucky - you just won the maximum possible amount!{{/tr}}</p>\r\n<p>{{amount}}</p>\r\n{{#mobile}}\r\n<div>\r\n    <button type="button" class="exit">{{#tr}}End Game Session{{/tr}}</button>\r\n</div>\r\n{{/mobile}}\r\n', n)
        },
        2046: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("text", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.b("<div>\r"), n.b("\n" + i), n.b("\r"), n.b("\n" + i), n.s(n.f("continue", t, e, 1), t, e, 0, 83, 238, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('        <button type="button" class="stop">'), n.s(n.f("tr", t, e, 1), t, e, 0, 135, 139, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("STOP")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b('        <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 208, 216, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("CONTINUE")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i)
                    })), t.pop()), n.s(n.f("continue", t, e, 1), t, e, 1, 0, 0, "") || (n.b('        <button type="button" class="stop">'), n.s(n.f("tr", t, e, 1), t, e, 0, 322, 324, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("OK")
                    })), t.pop()), n.b("</button>\r"), n.b("\n" + i)), n.b("</div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '{{#title}}<h1>{{title}}</h1>{{/title}}\r\n<p>{{text}}</p>\r\n<div>\r\n\r\n    {{#continue}}\r\n        <button type="button" class="stop">{{#tr}}STOP{{/tr}}</button>\r\n        <button type="button" class="close">{{#tr}}CONTINUE{{/tr}}</button>\r\n    {{/continue}}\r\n    {{^continue}}\r\n        <button type="button" class="stop">{{#tr}}OK{{/tr}}</button>\r\n    {{/continue}}\r\n</div>\r\n', n)
        },
        8368: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Insufficient funds")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 53, 142, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Please go through the deposit flow to deposit more money if you wish to continue playing!")
                    })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.b("<div>\r"), n.b("\n" + i), n.s(n.f("continue", t, e, 1), t, e, 0, 179, 256, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('        <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 232, 234, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("OK")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i)
                    })), t.pop()), n.s(n.f("continue", t, e, 1), t, e, 1, 0, 0, "") || (n.b('        <button type="button" class="stop">'), n.s(n.f("tr", t, e, 1), t, e, 0, 340, 342, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("OK")
                    })), t.pop()), n.b("</button>\r"), n.b("\n" + i)), n.b("</div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Insufficient funds{{/tr}}</h1>\r\n<p>{{#tr}}Please go through the deposit flow to deposit more money if you wish to continue playing!{{/tr}}</p>\r\n<div>\r\n    {{#continue}}\r\n        <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\r\n    {{/continue}}\r\n    {{^continue}}\r\n        <button type="button" class="stop">{{#tr}}OK{{/tr}}</button>\r\n    {{/continue}}\r\n</div>\r\n', n)
        },
        1183: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Responsible Gaming")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 53, 167, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!")
                    })), t.pop()), n.b("</p>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, "<h1>{{#tr}}Responsible Gaming{{/tr}}</h1>\r\n<p>{{#tr}}Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!{{/tr}}</p>\r\n", n)
        },
        1181: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Responsible Gaming")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("message", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 73, 187, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!")
                    })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 211, 346, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('<div style="margin-bottom: 1rem;"><a style="color: white;" href="javascript:" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 311, 327, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("End Game Session")
                        })), t.pop()), n.b("</a></div>\r"), n.b("\n" + i)
                    })), t.pop()), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Responsible Gaming{{/tr}}</h1>\r\n<p>{{message}}</p>\r\n<p>{{#tr}}Your gaming session is now ended for this time, you have to close the game manually to proceed with other actions!{{/tr}}</p>\r\n{{#mobile}}\r\n<div style="margin-bottom: 1rem;"><a style="color: white;" href="javascript:" class="exit">{{#tr}}End Game Session{{/tr}}</a></div>\r\n{{/mobile}}\r\n', n)
        },
        150: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("<p>"), n.b(n.v(n.f("text", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.b("<div>\r"), n.b("\n" + i), n.b('    <button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 111, 113, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("OK")
                    })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.s(n.f("buttons", t, e, 1), t, e, 0, 147, 728, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('        <button type="button" class="'), n.b(n.v(n.f("action", t, e, 0))), n.b('"\r'), n.b("\n" + i), n.s(n.f("link", t, e, 1), t, e, 0, 220, 695, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                            n.s(n.f("linkType", t, e, 1), t, e, 0, 251, 668, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                                n.b("                    "), n.s(n.f("REDIRECT", t, e, 1), t, e, 0, 286, 324, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"window.location='"), i.b(i.v(i.f("link", t, e, 0))), i.b("'\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("                    "), n.s(n.f("NEW_WINDOW", t, e, 1), t, e, 0, 374, 409, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"window.open('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("                    "), n.s(n.f("REQUEST", t, e, 1), t, e, 0, 458, 489, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"request('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("                    "), n.s(n.f("NOTIFY", t, e, 1), t, e, 0, 534, 564, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"notify('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("                    "), n.s(n.f("EVENT", t, e, 1), t, e, 0, 607, 640, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"sendEvent('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i)
                            })), t.pop()), n.b("            ")
                        })), t.pop()), n.b(">"), n.b(n.v(n.f("text", t, e, 0))), n.b("</button>\r"), n.b("\n" + i)
                    })), t.pop()), n.b("</div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '{{#title}}<h1>{{title}}</h1>{{/title}}\r\n<p>{{text}}</p>\r\n<div>\r\n    <button type="button" class="close">{{#tr}}OK{{/tr}}</button>\r\n    {{#buttons}}\r\n        <button type="button" class="{{action}}"\r\n            {{#link}}\r\n                {{#linkType}}\r\n                    {{#REDIRECT}} onclick="window.location=\'{{link}}\'" {{/REDIRECT}}\r\n                    {{#NEW_WINDOW}} onclick="window.open(\'{{link}}\')" {{/NEW_WINDOW}}\r\n                    {{#REQUEST}} onclick="request(\'{{link}}\')" {{/REQUEST}}\r\n                    {{#NOTIFY}} onclick="notify(\'{{link}}\')" {{/NOTIFY}}\r\n                    {{#EVENT}} onclick="sendEvent(\'{{link}}\')" {{/EVENT}}\r\n                {{/linkType}}\r\n            {{/link}}>{{text}}</button>\r\n    {{/buttons}}\r\n</div>\r\n', n)
        },
        1720: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 29, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Responsible Gaming")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b('<p><span id="rc-message">'), n.b(n.v(n.f("message", t, e, 0))), n.b("</span></p>\r"), n.b("\n" + i), n.b('<ul class="responsible standings">\r'), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 143, 155, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Elapsed time")
                    })), t.pop()), n.b(': <span id="rc-hours">'), n.b(n.v(n.f("hours", t, e, 0))), n.b("</span>\r"), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 217, 228, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Total Bets:")
                    })), t.pop()), n.b(" "), n.b(n.v(n.f("bets", t, e, 0))), n.b("\r"), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 261, 271, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Total Win:")
                    })), t.pop()), n.b(' <span id="rc-winnings">'), n.b(n.v(n.f("winnings", t, e, 0))), n.b("</span>\r"), n.b("\n" + i), n.b("    <li>"), n.s(n.f("tr", t, e, 1), t, e, 0, 338, 351, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Total Profit:")
                    })), t.pop()), n.b(' <span id="rc-profit">'), n.b(n.v(n.f("profit", t, e, 0))), n.b("</span>\r"), n.b("\n" + i), n.b("</ul>\r"), n.b("\n" + i), n.b('<div><button type="button" class="close">'), n.s(n.f("tr", t, e, 1), t, e, 0, 454, 456, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("OK")
                    })), t.pop()), n.b("</button></div>\r"), n.b("\n" + i), n.b('<div style="margin-bottom: 1rem;" class="account-history"><a style="color: white; opacity: 0.6;" href="javascript:">'), n.s(n.f("tr", t, e, 1), t, e, 0, 603, 618, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Account history")
                    })), t.pop()), n.b("</a></div>\r"), n.b("\n" + i), n.b('<div style="margin-bottom: 1rem;" class="end-session"><a style="color: white; opacity: 0.6;" href="javascript:">'), n.s(n.f("tr", t, e, 1), t, e, 0, 756, 772, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("End Game Session")
                    })), t.pop()), n.b("</a></div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Responsible Gaming{{/tr}}</h1>\r\n<p><span id="rc-message">{{message}}</span></p>\r\n<ul class="responsible standings">\r\n    <li>{{#tr}}Elapsed time{{/tr}}: <span id="rc-hours">{{hours}}</span>\r\n    <li>{{#tr}}Total Bets:{{/tr}} {{bets}}\r\n    <li>{{#tr}}Total Win:{{/tr}} <span id="rc-winnings">{{winnings}}</span>\r\n    <li>{{#tr}}Total Profit:{{/tr}} <span id="rc-profit">{{profit}}</span>\r\n</ul>\r\n<div><button type="button" class="close">{{#tr}}OK{{/tr}}</button></div>\r\n<div style="margin-bottom: 1rem;" class="account-history"><a style="color: white; opacity: 0.6;" href="javascript:">{{#tr}}Account history{{/tr}}</a></div>\r\n<div style="margin-bottom: 1rem;" class="end-session"><a style="color: white; opacity: 0.6;" href="javascript:">{{#tr}}End Game Session{{/tr}}</a></div>\r\n', n)
        },
        5729: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.s(n.f("title", t, e, 1), t, e, 0, 10, 28, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("<h1>"), i.b(i.v(i.f("title", t, e, 0))), i.b("</h1>")
                    })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("<p>"), n.b(n.t(n.f("message", t, e, 0))), n.b("</p>\r"), n.b("\n" + i), n.b("<div>\r"), n.b("\n" + i), n.s(n.f("buttons", t, e, 1), t, e, 0, 85, 596, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b('        <button type="button" class="'), n.b(n.v(n.f("action", t, e, 0))), n.b('"\r'), n.b("\n" + i), n.s(n.f("link", t, e, 1), t, e, 0, 154, 563, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                            n.s(n.f("linkType", t, e, 1), t, e, 0, 179, 540, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                                n.b("            "), n.s(n.f("REDIRECT", t, e, 1), t, e, 0, 206, 244, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"window.location='"), i.b(i.v(i.f("link", t, e, 0))), i.b("'\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("            "), n.s(n.f("NEW_WINDOW", t, e, 1), t, e, 0, 286, 321, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"window.open('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("            "), n.s(n.f("REQUEST", t, e, 1), t, e, 0, 362, 393, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"request('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("            "), n.s(n.f("NOTIFY", t, e, 1), t, e, 0, 430, 460, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" onclick=\"notify('"), i.b(i.v(i.f("link", t, e, 0))), i.b("')\" ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i), n.b("            "), n.s(n.f("EVENT", t, e, 1), t, e, 0, 495, 518, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                                    i.b(" data-event='"), i.b(i.v(i.f("link", t, e, 0))), i.b("' ")
                                })), t.pop()), n.b("\r"), n.b("\n" + i)
                            })), t.pop()), n.b("        ")
                        })), t.pop()), n.b(">"), n.b(n.v(n.f("text", t, e, 0))), n.b("</button>\r"), n.b("\n" + i)
                    })), t.pop()), n.b("</div>\r"), n.b("\n"), n.fl()
                },
                partials: {},
                subs: {}
            }, '{{#title}}<h1>{{title}}</h1>{{/title}}\r\n<p>{{{message}}}</p>\r\n<div>\r\n    {{#buttons}}\r\n        <button type="button" class="{{action}}"\r\n        {{#link}}\r\n          {{#linkType}}\r\n            {{#REDIRECT}} onclick="window.location=\'{{link}}\'" {{/REDIRECT}}\r\n            {{#NEW_WINDOW}} onclick="window.open(\'{{link}}\')" {{/NEW_WINDOW}}\r\n            {{#REQUEST}} onclick="request(\'{{link}}\')" {{/REQUEST}}\r\n            {{#NOTIFY}} onclick="notify(\'{{link}}\')" {{/NOTIFY}}\r\n            {{#EVENT}} data-event=\'{{link}}\' {{/EVENT}}\r\n          {{/linkType}}\r\n        {{/link}}>{{text}}</button>\r\n    {{/buttons}}\r\n</div>\r\n', n)
        },
        3717: (t, e, i) => {
            var n = i(5485);
            t.exports = new n.Template({
                code: function (t, e, i) {
                    var n = this;
                    return n.b(i = i || ""), n.b("<h1>"), n.s(n.f("tr", t, e, 1), t, e, 0, 11, 37, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Your session has timed out")
                    })), t.pop()), n.b("</h1>\r"), n.b("\n" + i), n.b("<p>"), n.s(n.f("tr", t, e, 1), t, e, 0, 61, 97, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                        i.b("Please reload the game to try again.")
                    })), t.pop()), n.b("</p>\r"), n.b("\n" + i), n.s(n.f("mobile", t, e, 1), t, e, 0, 121, 216, "{{ }}") && (n.rs(t, e, (function (t, e, n) {
                        n.b("    <div>\r"), n.b("\n" + i), n.b('        <button type="button" class="exit">'), n.s(n.f("tr", t, e, 1), t, e, 0, 184, 186, "{{ }}") && (n.rs(t, e, (function (t, e, i) {
                            i.b("OK")
                        })), t.pop()), n.b("</button>\r"), n.b("\n" + i), n.b("    </div>\r"), n.b("\n" + i)
                    })), t.pop()), n.fl()
                },
                partials: {},
                subs: {}
            }, '<h1>{{#tr}}Your session has timed out{{/tr}}</h1>\r\n<p>{{#tr}}Please reload the game to try again.{{/tr}}</p>\r\n{{#mobile}}\r\n    <div>\r\n        <button type="button" class="exit">{{#tr}}OK{{/tr}}</button>\r\n    </div>\r\n{{/mobile}}\r\n', n)
        },
        7418: t => {
            "use strict";
            var e = Object.getOwnPropertySymbols,
                i = Object.prototype.hasOwnProperty,
                n = Object.prototype.propertyIsEnumerable;
            t.exports = function () {
                try {
                    if (!Object.assign) return !1;
                    var t = new String("abc");
                    if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                    for (var e = {}, i = 0; i < 10; i++) e["_" + String.fromCharCode(i)] = i;
                    if ("0123456789" !== Object.getOwnPropertyNames(e).map((function (t) {
                        return e[t]
                    })).join("")) return !1;
                    var n = {};
                    return "abcdefghijklmnopqrst".split("").forEach((function (t) {
                        n[t] = t
                    })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("")
                } catch (t) {
                    return !1
                }
            }() ? Object.assign : function (t, r) {
                for (var o, s, a = function (t) {
                    if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
                    return Object(t)
                }(t), l = 1; l < arguments.length; l++) {
                    for (var h in o = Object(arguments[l])) i.call(o, h) && (a[h] = o[h]);
                    if (e) {
                        s = e(o);
                        for (var u = 0; u < s.length; u++) n.call(o, s[u]) && (a[s[u]] = o[s[u]])
                    }
                }
                return a
            }
        },
        631: (t, e, i) => {
            var n = "function" == typeof Map && Map.prototype,
                r = Object.getOwnPropertyDescriptor && n ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
                o = n && r && "function" == typeof r.get ? r.get : null,
                s = n && Map.prototype.forEach,
                a = "function" == typeof Set && Set.prototype,
                l = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
                h = a && l && "function" == typeof l.get ? l.get : null,
                u = a && Set.prototype.forEach,
                c = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
                d = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
                p = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
                f = Boolean.prototype.valueOf,
                g = Object.prototype.toString,
                m = Function.prototype.toString,
                _ = String.prototype.match,
                y = String.prototype.slice,
                S = String.prototype.replace,
                v = String.prototype.toUpperCase,
                b = String.prototype.toLowerCase,
                T = RegExp.prototype.test,
                P = Array.prototype.concat,
                A = Array.prototype.join,
                I = Array.prototype.slice,
                w = Math.floor,
                E = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
                C = Object.getOwnPropertySymbols,
                x = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null,
                B = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
                L = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag, 1) ? Symbol.toStringTag : null,
                O = Object.prototype.propertyIsEnumerable,
                N = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (t) {
                    return t.__proto__
                } : null);

            function M(t, e) {
                if (t === 1 / 0 || t === -1 / 0 || t != t || t && t > -1e3 && t < 1e3 || T.call(/e/, e)) return e;
                var i = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
                if ("number" == typeof t) {
                    var n = t < 0 ? -w(-t) : w(t);
                    if (n !== t) {
                        var r = String(n),
                            o = y.call(e, r.length + 1);
                        return S.call(r, i, "$&_") + "." + S.call(S.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
                    }
                }
                return S.call(e, i, "$&_")
            }
            var R = i(4654),
                D = R.custom,
                F = V(D) ? D : null;

            function k(t, e, i) {
                var n = "double" === (i.quoteStyle || e) ? '"' : "'";
                return n + t + n
            }

            function U(t) {
                return S.call(String(t), /"/g, "&quot;")
            }

            function G(t) {
                return !("[object Array]" !== Y(t) || L && "object" == typeof t && L in t)
            }

            function W(t) {
                return !("[object RegExp]" !== Y(t) || L && "object" == typeof t && L in t)
            }

            function V(t) {
                if (B) return t && "object" == typeof t && t instanceof Symbol;
                if ("symbol" == typeof t) return !0;
                if (!t || "object" != typeof t || !x) return !1;
                try {
                    return x.call(t), !0
                } catch (t) { }
                return !1
            }
            t.exports = function t(e, i, n, r) {
                var a = i || {};
                if (H(a, "quoteStyle") && "single" !== a.quoteStyle && "double" !== a.quoteStyle) throw new TypeError('option "quoteStyle" must be "single" or "double"');
                if (H(a, "maxStringLength") && ("number" == typeof a.maxStringLength ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : null !== a.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
                var l = !H(a, "customInspect") || a.customInspect;
                if ("boolean" != typeof l && "symbol" !== l) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
                if (H(a, "indent") && null !== a.indent && "\t" !== a.indent && !(parseInt(a.indent, 10) === a.indent && a.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
                if (H(a, "numericSeparator") && "boolean" != typeof a.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
                var g = a.numericSeparator;
                if (void 0 === e) return "undefined";
                if (null === e) return "null";
                if ("boolean" == typeof e) return e ? "true" : "false";
                if ("string" == typeof e) return z(e, a);
                if ("number" == typeof e) {
                    if (0 === e) return 1 / 0 / e > 0 ? "0" : "-0";
                    var v = String(e);
                    return g ? M(e, v) : v
                }
                if ("bigint" == typeof e) {
                    var T = String(e) + "n";
                    return g ? M(e, T) : T
                }
                var w = void 0 === a.depth ? 5 : a.depth;
                if (void 0 === n && (n = 0), n >= w && w > 0 && "object" == typeof e) return G(e) ? "[Array]" : "[Object]";
                var C, D = function (t, e) {
                    var i;
                    if ("\t" === t.indent) i = "\t";
                    else {
                        if (!("number" == typeof t.indent && t.indent > 0)) return null;
                        i = A.call(Array(t.indent + 1), " ")
                    }
                    return {
                        base: i,
                        prev: A.call(Array(e + 1), i)
                    }
                }(a, n);
                if (void 0 === r) r = [];
                else if (j(r, e) >= 0) return "[Circular]";

                function X(e, i, o) {
                    if (i && (r = I.call(r)).push(i), o) {
                        var s = {
                            depth: a.depth
                        };
                        return H(a, "quoteStyle") && (s.quoteStyle = a.quoteStyle), t(e, s, n + 1, r)
                    }
                    return t(e, a, n + 1, r)
                }
                if ("function" == typeof e && !W(e)) {
                    var K = function (t) {
                        if (t.name) return t.name;
                        var e = _.call(m.call(t), /^function\s*([\w$]+)/);
                        return e ? e[1] : null
                    }(e),
                        tt = Q(e, X);
                    return "[Function" + (K ? ": " + K : " (anonymous)") + "]" + (tt.length > 0 ? " { " + A.call(tt, ", ") + " }" : "")
                }
                if (V(e)) {
                    var et = B ? S.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : x.call(e);
                    return "object" != typeof e || B ? et : q(et)
                }
                if ((C = e) && "object" == typeof C && ("undefined" != typeof HTMLElement && C instanceof HTMLElement || "string" == typeof C.nodeName && "function" == typeof C.getAttribute)) {
                    for (var it = "<" + b.call(String(e.nodeName)), nt = e.attributes || [], rt = 0; rt < nt.length; rt++) it += " " + nt[rt].name + "=" + k(U(nt[rt].value), "double", a);
                    return it += ">", e.childNodes && e.childNodes.length && (it += "..."), it + "</" + b.call(String(e.nodeName)) + ">"
                }
                if (G(e)) {
                    if (0 === e.length) return "[]";
                    var ot = Q(e, X);
                    return D && ! function (t) {
                        for (var e = 0; e < t.length; e++)
                            if (j(t[e], "\n") >= 0) return !1;
                        return !0
                    }(ot) ? "[" + J(ot, D) + "]" : "[ " + A.call(ot, ", ") + " ]"
                }
                if (function (t) {
                    return !("[object Error]" !== Y(t) || L && "object" == typeof t && L in t)
                }(e)) {
                    var st = Q(e, X);
                    return "cause" in Error.prototype || !("cause" in e) || O.call(e, "cause") ? 0 === st.length ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + A.call(st, ", ") + " }" : "{ [" + String(e) + "] " + A.call(P.call("[cause]: " + X(e.cause), st), ", ") + " }"
                }
                if ("object" == typeof e && l) {
                    if (F && "function" == typeof e[F] && R) return R(e, {
                        depth: w - n
                    });
                    if ("symbol" !== l && "function" == typeof e.inspect) return e.inspect()
                }
                if (function (t) {
                    if (!o || !t || "object" != typeof t) return !1;
                    try {
                        o.call(t);
                        try {
                            h.call(t)
                        } catch (t) {
                            return !0
                        }
                        return t instanceof Map
                    } catch (t) { }
                    return !1
                }(e)) {
                    var at = [];
                    return s && s.call(e, (function (t, i) {
                        at.push(X(i, e, !0) + " => " + X(t, e))
                    })), $("Map", o.call(e), at, D)
                }
                if (function (t) {
                    if (!h || !t || "object" != typeof t) return !1;
                    try {
                        h.call(t);
                        try {
                            o.call(t)
                        } catch (t) {
                            return !0
                        }
                        return t instanceof Set
                    } catch (t) { }
                    return !1
                }(e)) {
                    var lt = [];
                    return u && u.call(e, (function (t) {
                        lt.push(X(t, e))
                    })), $("Set", h.call(e), lt, D)
                }
                if (function (t) {
                    if (!c || !t || "object" != typeof t) return !1;
                    try {
                        c.call(t, c);
                        try {
                            d.call(t, d)
                        } catch (t) {
                            return !0
                        }
                        return t instanceof WeakMap
                    } catch (t) { }
                    return !1
                }(e)) return Z("WeakMap");
                if (function (t) {
                    if (!d || !t || "object" != typeof t) return !1;
                    try {
                        d.call(t, d);
                        try {
                            c.call(t, c)
                        } catch (t) {
                            return !0
                        }
                        return t instanceof WeakSet
                    } catch (t) { }
                    return !1
                }(e)) return Z("WeakSet");
                if (function (t) {
                    if (!p || !t || "object" != typeof t) return !1;
                    try {
                        return p.call(t), !0
                    } catch (t) { }
                    return !1
                }(e)) return Z("WeakRef");
                if (function (t) {
                    return !("[object Number]" !== Y(t) || L && "object" == typeof t && L in t)
                }(e)) return q(X(Number(e)));
                if (function (t) {
                    if (!t || "object" != typeof t || !E) return !1;
                    try {
                        return E.call(t), !0
                    } catch (t) { }
                    return !1
                }(e)) return q(X(E.call(e)));
                if (function (t) {
                    return !("[object Boolean]" !== Y(t) || L && "object" == typeof t && L in t)
                }(e)) return q(f.call(e));
                if (function (t) {
                    return !("[object String]" !== Y(t) || L && "object" == typeof t && L in t)
                }(e)) return q(X(String(e)));
                if (! function (t) {
                    return !("[object Date]" !== Y(t) || L && "object" == typeof t && L in t)
                }(e) && !W(e)) {
                    var ht = Q(e, X),
                        ut = N ? N(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                        ct = e instanceof Object ? "" : "null prototype",
                        dt = !ut && L && Object(e) === e && L in e ? y.call(Y(e), 8, -1) : ct ? "Object" : "",
                        pt = (ut || "function" != typeof e.constructor ? "" : e.constructor.name ? e.constructor.name + " " : "") + (dt || ct ? "[" + A.call(P.call([], dt || [], ct || []), ": ") + "] " : "");
                    return 0 === ht.length ? pt + "{}" : D ? pt + "{" + J(ht, D) + "}" : pt + "{ " + A.call(ht, ", ") + " }"
                }
                return String(e)
            };
            var X = Object.prototype.hasOwnProperty || function (t) {
                return t in this
            };

            function H(t, e) {
                return X.call(t, e)
            }

            function Y(t) {
                return g.call(t)
            }

            function j(t, e) {
                if (t.indexOf) return t.indexOf(e);
                for (var i = 0, n = t.length; i < n; i++)
                    if (t[i] === e) return i;
                return -1
            }

            function z(t, e) {
                if (t.length > e.maxStringLength) {
                    var i = t.length - e.maxStringLength,
                        n = "... " + i + " more character" + (i > 1 ? "s" : "");
                    return z(y.call(t, 0, e.maxStringLength), e) + n
                }
                return k(S.call(S.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, K), "single", e)
            }

            function K(t) {
                var e = t.charCodeAt(0),
                    i = {
                        8: "b",
                        9: "t",
                        10: "n",
                        12: "f",
                        13: "r"
                    }[e];
                return i ? "\\" + i : "\\x" + (e < 16 ? "0" : "") + v.call(e.toString(16))
            }

            function q(t) {
                return "Object(" + t + ")"
            }

            function Z(t) {
                return t + " { ? }"
            }

            function $(t, e, i, n) {
                return t + " (" + e + ") {" + (n ? J(i, n) : A.call(i, ", ")) + "}"
            }

            function J(t, e) {
                if (0 === t.length) return "";
                var i = "\n" + e.prev + e.base;
                return i + A.call(t, "," + i) + "\n" + e.prev
            }

            function Q(t, e) {
                var i = G(t),
                    n = [];
                if (i) {
                    n.length = t.length;
                    for (var r = 0; r < t.length; r++) n[r] = H(t, r) ? e(t[r], t) : ""
                }
                var o, s = "function" == typeof C ? C(t) : [];
                if (B) {
                    o = {};
                    for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
                }
                for (var l in t) H(t, l) && (i && String(Number(l)) === l && l < t.length || B && o["$" + l] instanceof Symbol || (T.call(/[^\w$]/, l) ? n.push(e(l, t) + ": " + e(t[l], t)) : n.push(l + ": " + e(t[l], t))));
                if ("function" == typeof C)
                    for (var h = 0; h < s.length; h++) O.call(t, s[h]) && n.push("[" + e(s[h]) + "]: " + e(t[s[h]], t));
                return n
            }
        },
        5784: t => {
            "use strict";
            t.exports = (t, e = {}) => {
                if (!t) return;
                const i = {
                    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                    q: {
                        name: "queryKey",
                        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                    },
                    parser: {
                        strict: /^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                        loose: /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/
                    }
                },
                    n = i.parser[e.strictMode ? "strict" : "loose"].exec(t),
                    r = {};
                let o = 14;
                for (; o--;) r[i.key[o]] = n[o] || "";
                return r[i.q.name] = {}, r[i.key[12]].replace(i.q.parser, (function (t, e, n) {
                    e && (r[i.q.name][e] = n)
                })), r
            }
        },
        356: function () {
            var t, e, i, n = this && this.__extends || (t = function (e, i) {
                return t = Object.setPrototypeOf || {
                    __proto__: []
                }
                    instanceof Array && function (t, e) {
                        t.__proto__ = e
                    } || function (t, e) {
                        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                    }, t(e, i)
            }, function (e, i) {
                function n() {
                    this.constructor = e
                }
                t(e, i), e.prototype = null === i ? Object.create(i) : (n.prototype = i.prototype, new n)
            });
            ! function (t) {
                ! function (t) {
                    var e, i, r, o = function () {
                        function t(t, e, i) {
                            if (null == t) throw new Error("name cannot be null.");
                            if (null == e) throw new Error("timelines cannot be null.");
                            this.name = t, this.timelines = e, this.timelineIds = [];
                            for (var n = 0; n < e.length; n++) this.timelineIds[e[n].getPropertyId()] = !0;
                            this.duration = i
                        }
                        return t.prototype.hasTimeline = function (t) {
                            return 1 == this.timelineIds[t]
                        }, t.prototype.apply = function (t, e, i, n, r, o, s, a) {
                            if (null == t) throw new Error("skeleton cannot be null.");
                            n && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
                            for (var l = this.timelines, h = 0, u = l.length; h < u; h++) l[h].apply(t, e, i, r, o, s, a)
                        }, t.binarySearch = function (t, e, i) {
                            void 0 === i && (i = 1);
                            var n = 0,
                                r = t.length / i - 2;
                            if (0 == r) return i;
                            for (var o = r >>> 1; ;) {
                                if (t[(o + 1) * i] <= e ? n = o + 1 : r = o, n == r) return (n + 1) * i;
                                o = n + r >>> 1
                            }
                        }, t.linearSearch = function (t, e, i) {
                            for (var n = 0, r = t.length - i; n <= r; n += i)
                                if (t[n] > e) return n;
                            return -1
                        }, t
                    }();
                    t.Animation = o,
                        function (t) {
                            t[t.setup = 0] = "setup", t[t.first = 1] = "first", t[t.replace = 2] = "replace", t[t.add = 3] = "add"
                        }(e = t.MixBlend || (t.MixBlend = {})),
                        function (t) {
                            t[t.mixIn = 0] = "mixIn", t[t.mixOut = 1] = "mixOut"
                        }(i = t.MixDirection || (t.MixDirection = {})),
                        function (t) {
                            t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor"
                        }(r = t.TimelineType || (t.TimelineType = {}));
                    var s = function () {
                        function e(i) {
                            if (i <= 0) throw new Error("frameCount must be > 0: " + i);
                            this.curves = t.Utils.newFloatArray((i - 1) * e.BEZIER_SIZE)
                        }
                        return e.prototype.getFrameCount = function () {
                            return this.curves.length / e.BEZIER_SIZE + 1
                        }, e.prototype.setLinear = function (t) {
                            this.curves[t * e.BEZIER_SIZE] = e.LINEAR
                        }, e.prototype.setStepped = function (t) {
                            this.curves[t * e.BEZIER_SIZE] = e.STEPPED
                        }, e.prototype.getCurveType = function (t) {
                            var i = t * e.BEZIER_SIZE;
                            if (i == this.curves.length) return e.LINEAR;
                            var n = this.curves[i];
                            return n == e.LINEAR ? e.LINEAR : n == e.STEPPED ? e.STEPPED : e.BEZIER
                        }, e.prototype.setCurve = function (t, i, n, r, o) {
                            var s = .03 * (2 * -i + r),
                                a = .03 * (2 * -n + o),
                                l = .006 * (3 * (i - r) + 1),
                                h = .006 * (3 * (n - o) + 1),
                                u = 2 * s + l,
                                c = 2 * a + h,
                                d = .3 * i + s + .16666667 * l,
                                p = .3 * n + a + .16666667 * h,
                                f = t * e.BEZIER_SIZE,
                                g = this.curves;
                            g[f++] = e.BEZIER;
                            for (var m = d, _ = p, y = f + e.BEZIER_SIZE - 1; f < y; f += 2) g[f] = m, g[f + 1] = _, d += u, p += c, u += l, c += h, m += d, _ += p
                        }, e.prototype.getCurvePercent = function (i, n) {
                            n = t.MathUtils.clamp(n, 0, 1);
                            var r = this.curves,
                                o = i * e.BEZIER_SIZE,
                                s = r[o];
                            if (s == e.LINEAR) return n;
                            if (s == e.STEPPED) return 0;
                            for (var a = 0, l = ++o, h = o + e.BEZIER_SIZE - 1; o < h; o += 2)
                                if ((a = r[o]) >= n) {
                                    var u = void 0,
                                        c = void 0;
                                    return o == l ? (u = 0, c = 0) : (u = r[o - 2], c = r[o - 1]), c + (r[o + 1] - c) * (n - u) / (a - u)
                                } var d = r[o - 1];
                            return d + (1 - d) * (n - a) / (1 - a)
                        }, e.LINEAR = 0, e.STEPPED = 1, e.BEZIER = 2, e.BEZIER_SIZE = 19, e
                    }();
                    t.CurveTimeline = s;
                    var a = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e << 1), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.rotate << 24) + this.boneIndex
                        }, s.prototype.setFrame = function (t, e, i) {
                            t <<= 1, this.frames[t] = e, this.frames[t + s.ROTATION] = i
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = this.frames,
                                c = t.bones[this.boneIndex];
                            if (c.active)
                                if (n < u[0]) switch (l) {
                                    case e.setup:
                                        return void (c.rotation = c.data.rotation);
                                    case e.first:
                                        var d = c.data.rotation - c.rotation;
                                        c.rotation += (d - 360 * (16384 - (16384.499999999996 - d / 360 | 0))) * a
                                } else if (n >= u[u.length - s.ENTRIES]) {
                                    var p = u[u.length + s.PREV_ROTATION];
                                    switch (l) {
                                        case e.setup:
                                            c.rotation = c.data.rotation + p * a;
                                            break;
                                        case e.first:
                                        case e.replace:
                                            p += c.data.rotation - c.rotation, p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0));
                                        case e.add:
                                            c.rotation += p * a
                                    }
                                } else {
                                    var f = o.binarySearch(u, n, s.ENTRIES),
                                        g = u[f + s.PREV_ROTATION],
                                        m = u[f],
                                        _ = this.getCurvePercent((f >> 1) - 1, 1 - (n - m) / (u[f + s.PREV_TIME] - m)),
                                        y = u[f + s.ROTATION] - g;
                                    switch (y = g + (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * _, l) {
                                        case e.setup:
                                            c.rotation = c.data.rotation + (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * a;
                                            break;
                                        case e.first:
                                        case e.replace:
                                            y += c.data.rotation - c.rotation;
                                        case e.add:
                                            c.rotation += (y - 360 * (16384 - (16384.499999999996 - y / 360 | 0))) * a
                                    }
                                }
                        }, s.ENTRIES = 2, s.PREV_TIME = -2, s.PREV_ROTATION = -1, s.ROTATION = 1, s
                    }(s);
                    t.RotateTimeline = a;
                    var l = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.translate << 24) + this.boneIndex
                        }, s.prototype.setFrame = function (t, e, i, n) {
                            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.X] = i, this.frames[t + s.Y] = n
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = this.frames,
                                c = t.bones[this.boneIndex];
                            if (c.active)
                                if (n < u[0]) switch (l) {
                                    case e.setup:
                                        return c.x = c.data.x, void (c.y = c.data.y);
                                    case e.first:
                                        c.x += (c.data.x - c.x) * a, c.y += (c.data.y - c.y) * a
                                } else {
                                    var d = 0,
                                        p = 0;
                                    if (n >= u[u.length - s.ENTRIES]) d = u[u.length + s.PREV_X], p = u[u.length + s.PREV_Y];
                                    else {
                                        var f = o.binarySearch(u, n, s.ENTRIES);
                                        d = u[f + s.PREV_X], p = u[f + s.PREV_Y];
                                        var g = u[f],
                                            m = this.getCurvePercent(f / s.ENTRIES - 1, 1 - (n - g) / (u[f + s.PREV_TIME] - g));
                                        d += (u[f + s.X] - d) * m, p += (u[f + s.Y] - p) * m
                                    }
                                    switch (l) {
                                        case e.setup:
                                            c.x = c.data.x + d * a, c.y = c.data.y + p * a;
                                            break;
                                        case e.first:
                                        case e.replace:
                                            c.x += (c.data.x + d - c.x) * a, c.y += (c.data.y + p - c.y) * a;
                                            break;
                                        case e.add:
                                            c.x += d * a, c.y += p * a
                                    }
                                }
                        }, s.ENTRIES = 3, s.PREV_TIME = -3, s.PREV_X = -2, s.PREV_Y = -1, s.X = 1, s.Y = 2, s
                    }(s);
                    t.TranslateTimeline = l;
                    var h = function (s) {
                        function a(t) {
                            return s.call(this, t) || this
                        }
                        return n(a, s), a.prototype.getPropertyId = function () {
                            return (r.scale << 24) + this.boneIndex
                        }, a.prototype.apply = function (n, r, s, l, h, u, c) {
                            var d = this.frames,
                                p = n.bones[this.boneIndex];
                            if (p.active)
                                if (s < d[0]) switch (u) {
                                    case e.setup:
                                        return p.scaleX = p.data.scaleX, void (p.scaleY = p.data.scaleY);
                                    case e.first:
                                        p.scaleX += (p.data.scaleX - p.scaleX) * h, p.scaleY += (p.data.scaleY - p.scaleY) * h
                                } else {
                                    var f = 0,
                                        g = 0;
                                    if (s >= d[d.length - a.ENTRIES]) f = d[d.length + a.PREV_X] * p.data.scaleX, g = d[d.length + a.PREV_Y] * p.data.scaleY;
                                    else {
                                        var m = o.binarySearch(d, s, a.ENTRIES);
                                        f = d[m + a.PREV_X], g = d[m + a.PREV_Y];
                                        var _ = d[m],
                                            y = this.getCurvePercent(m / a.ENTRIES - 1, 1 - (s - _) / (d[m + a.PREV_TIME] - _));
                                        f = (f + (d[m + a.X] - f) * y) * p.data.scaleX, g = (g + (d[m + a.Y] - g) * y) * p.data.scaleY
                                    }
                                    if (1 == h) u == e.add ? (p.scaleX += f - p.data.scaleX, p.scaleY += g - p.data.scaleY) : (p.scaleX = f, p.scaleY = g);
                                    else {
                                        var S = 0,
                                            v = 0;
                                        if (c == i.mixOut) switch (u) {
                                            case e.setup:
                                                S = p.data.scaleX, v = p.data.scaleY, p.scaleX = S + (Math.abs(f) * t.MathUtils.signum(S) - S) * h, p.scaleY = v + (Math.abs(g) * t.MathUtils.signum(v) - v) * h;
                                                break;
                                            case e.first:
                                            case e.replace:
                                                S = p.scaleX, v = p.scaleY, p.scaleX = S + (Math.abs(f) * t.MathUtils.signum(S) - S) * h, p.scaleY = v + (Math.abs(g) * t.MathUtils.signum(v) - v) * h;
                                                break;
                                            case e.add:
                                                S = p.scaleX, v = p.scaleY, p.scaleX = S + (Math.abs(f) * t.MathUtils.signum(S) - p.data.scaleX) * h, p.scaleY = v + (Math.abs(g) * t.MathUtils.signum(v) - p.data.scaleY) * h
                                        } else switch (u) {
                                            case e.setup:
                                                S = Math.abs(p.data.scaleX) * t.MathUtils.signum(f), v = Math.abs(p.data.scaleY) * t.MathUtils.signum(g), p.scaleX = S + (f - S) * h, p.scaleY = v + (g - v) * h;
                                                break;
                                            case e.first:
                                            case e.replace:
                                                S = Math.abs(p.scaleX) * t.MathUtils.signum(f), v = Math.abs(p.scaleY) * t.MathUtils.signum(g), p.scaleX = S + (f - S) * h, p.scaleY = v + (g - v) * h;
                                                break;
                                            case e.add:
                                                S = t.MathUtils.signum(f), v = t.MathUtils.signum(g), p.scaleX = Math.abs(p.scaleX) * S + (f - Math.abs(p.data.scaleX) * S) * h, p.scaleY = Math.abs(p.scaleY) * v + (g - Math.abs(p.data.scaleY) * v) * h
                                        }
                                    }
                                }
                        }, a
                    }(l);
                    t.ScaleTimeline = h;
                    var u = function (t) {
                        function i(e) {
                            return t.call(this, e) || this
                        }
                        return n(i, t), i.prototype.getPropertyId = function () {
                            return (r.shear << 24) + this.boneIndex
                        }, i.prototype.apply = function (t, n, r, s, a, l, h) {
                            var u = this.frames,
                                c = t.bones[this.boneIndex];
                            if (c.active)
                                if (r < u[0]) switch (l) {
                                    case e.setup:
                                        return c.shearX = c.data.shearX, void (c.shearY = c.data.shearY);
                                    case e.first:
                                        c.shearX += (c.data.shearX - c.shearX) * a, c.shearY += (c.data.shearY - c.shearY) * a
                                } else {
                                    var d = 0,
                                        p = 0;
                                    if (r >= u[u.length - i.ENTRIES]) d = u[u.length + i.PREV_X], p = u[u.length + i.PREV_Y];
                                    else {
                                        var f = o.binarySearch(u, r, i.ENTRIES);
                                        d = u[f + i.PREV_X], p = u[f + i.PREV_Y];
                                        var g = u[f],
                                            m = this.getCurvePercent(f / i.ENTRIES - 1, 1 - (r - g) / (u[f + i.PREV_TIME] - g));
                                        d += (u[f + i.X] - d) * m, p += (u[f + i.Y] - p) * m
                                    }
                                    switch (l) {
                                        case e.setup:
                                            c.shearX = c.data.shearX + d * a, c.shearY = c.data.shearY + p * a;
                                            break;
                                        case e.first:
                                        case e.replace:
                                            c.shearX += (c.data.shearX + d - c.shearX) * a, c.shearY += (c.data.shearY + p - c.shearY) * a;
                                            break;
                                        case e.add:
                                            c.shearX += d * a, c.shearY += p * a
                                    }
                                }
                        }, i
                    }(l);
                    t.ShearTimeline = u;
                    var c = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.color << 24) + this.slotIndex
                        }, s.prototype.setFrame = function (t, e, i, n, r, o) {
                            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.R] = i, this.frames[t + s.G] = n, this.frames[t + s.B] = r, this.frames[t + s.A] = o
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = t.slots[this.slotIndex];
                            if (u.bone.active) {
                                var c = this.frames;
                                if (n < c[0]) switch (l) {
                                    case e.setup:
                                        return void u.color.setFromColor(u.data.color);
                                    case e.first:
                                        var d = u.color,
                                            p = u.data.color;
                                        d.add((p.r - d.r) * a, (p.g - d.g) * a, (p.b - d.b) * a, (p.a - d.a) * a)
                                } else {
                                    var f = 0,
                                        g = 0,
                                        m = 0,
                                        _ = 0;
                                    if (n >= c[c.length - s.ENTRIES]) {
                                        var y = c.length;
                                        f = c[y + s.PREV_R], g = c[y + s.PREV_G], m = c[y + s.PREV_B], _ = c[y + s.PREV_A]
                                    } else {
                                        var S = o.binarySearch(c, n, s.ENTRIES);
                                        f = c[S + s.PREV_R], g = c[S + s.PREV_G], m = c[S + s.PREV_B], _ = c[S + s.PREV_A];
                                        var v = c[S],
                                            b = this.getCurvePercent(S / s.ENTRIES - 1, 1 - (n - v) / (c[S + s.PREV_TIME] - v));
                                        f += (c[S + s.R] - f) * b, g += (c[S + s.G] - g) * b, m += (c[S + s.B] - m) * b, _ += (c[S + s.A] - _) * b
                                    }
                                    1 == a ? u.color.set(f, g, m, _) : (d = u.color, l == e.setup && d.setFromColor(u.data.color), d.add((f - d.r) * a, (g - d.g) * a, (m - d.b) * a, (_ - d.a) * a))
                                }
                            }
                        }, s.ENTRIES = 5, s.PREV_TIME = -5, s.PREV_R = -4, s.PREV_G = -3, s.PREV_B = -2, s.PREV_A = -1, s.R = 1, s.G = 2, s.B = 3, s.A = 4, s
                    }(s);
                    t.ColorTimeline = c;
                    var d = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.twoColor << 24) + this.slotIndex
                        }, s.prototype.setFrame = function (t, e, i, n, r, o, a, l, h) {
                            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.R] = i, this.frames[t + s.G] = n, this.frames[t + s.B] = r, this.frames[t + s.A] = o, this.frames[t + s.R2] = a, this.frames[t + s.G2] = l, this.frames[t + s.B2] = h
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = t.slots[this.slotIndex];
                            if (u.bone.active) {
                                var c = this.frames;
                                if (n < c[0]) switch (l) {
                                    case e.setup:
                                        return u.color.setFromColor(u.data.color), void u.darkColor.setFromColor(u.data.darkColor);
                                    case e.first:
                                        var d = u.color,
                                            p = u.darkColor,
                                            f = u.data.color,
                                            g = u.data.darkColor;
                                        d.add((f.r - d.r) * a, (f.g - d.g) * a, (f.b - d.b) * a, (f.a - d.a) * a), p.add((g.r - p.r) * a, (g.g - p.g) * a, (g.b - p.b) * a, 0)
                                } else {
                                    var m = 0,
                                        _ = 0,
                                        y = 0,
                                        S = 0,
                                        v = 0,
                                        b = 0,
                                        T = 0;
                                    if (n >= c[c.length - s.ENTRIES]) {
                                        var P = c.length;
                                        m = c[P + s.PREV_R], _ = c[P + s.PREV_G], y = c[P + s.PREV_B], S = c[P + s.PREV_A], v = c[P + s.PREV_R2], b = c[P + s.PREV_G2], T = c[P + s.PREV_B2]
                                    } else {
                                        var A = o.binarySearch(c, n, s.ENTRIES);
                                        m = c[A + s.PREV_R], _ = c[A + s.PREV_G], y = c[A + s.PREV_B], S = c[A + s.PREV_A], v = c[A + s.PREV_R2], b = c[A + s.PREV_G2], T = c[A + s.PREV_B2];
                                        var I = c[A],
                                            w = this.getCurvePercent(A / s.ENTRIES - 1, 1 - (n - I) / (c[A + s.PREV_TIME] - I));
                                        m += (c[A + s.R] - m) * w, _ += (c[A + s.G] - _) * w, y += (c[A + s.B] - y) * w, S += (c[A + s.A] - S) * w, v += (c[A + s.R2] - v) * w, b += (c[A + s.G2] - b) * w, T += (c[A + s.B2] - T) * w
                                    }
                                    1 == a ? (u.color.set(m, _, y, S), u.darkColor.set(v, b, T, 1)) : (d = u.color, p = u.darkColor, l == e.setup && (d.setFromColor(u.data.color), p.setFromColor(u.data.darkColor)), d.add((m - d.r) * a, (_ - d.g) * a, (y - d.b) * a, (S - d.a) * a), p.add((v - p.r) * a, (b - p.g) * a, (T - p.b) * a, 0))
                                }
                            }
                        }, s.ENTRIES = 8, s.PREV_TIME = -8, s.PREV_R = -7, s.PREV_G = -6, s.PREV_B = -5, s.PREV_A = -4, s.PREV_R2 = -3, s.PREV_G2 = -2, s.PREV_B2 = -1, s.R = 1, s.G = 2, s.B = 3, s.A = 4, s.R2 = 5, s.G2 = 6, s.B2 = 7, s
                    }(s);
                    t.TwoColorTimeline = d;
                    var p = function () {
                        function n(e) {
                            this.frames = t.Utils.newFloatArray(e), this.attachmentNames = new Array(e)
                        }
                        return n.prototype.getPropertyId = function () {
                            return (r.attachment << 24) + this.slotIndex
                        }, n.prototype.getFrameCount = function () {
                            return this.frames.length
                        }, n.prototype.setFrame = function (t, e, i) {
                            this.frames[t] = e, this.attachmentNames[t] = i
                        }, n.prototype.apply = function (t, n, r, s, a, l, h) {
                            var u = t.slots[this.slotIndex];
                            if (u.bone.active)
                                if (h != i.mixOut) {
                                    var c = this.frames;
                                    if (r < c[0]) l != e.setup && l != e.first || this.setAttachment(t, u, u.data.attachmentName);
                                    else {
                                        var d;
                                        d = r >= c[c.length - 1] ? c.length - 1 : o.binarySearch(c, r, 1) - 1;
                                        var p = this.attachmentNames[d];
                                        t.slots[this.slotIndex].setAttachment(null == p ? null : t.getAttachment(this.slotIndex, p))
                                    }
                                } else l == e.setup && this.setAttachment(t, u, u.data.attachmentName)
                        }, n.prototype.setAttachment = function (t, e, i) {
                            e.attachment = null == i ? null : t.getAttachment(this.slotIndex, i)
                        }, n
                    }();
                    t.AttachmentTimeline = p;
                    var f = null,
                        g = function (i) {
                            function s(e) {
                                var n = i.call(this, e) || this;
                                return n.frames = t.Utils.newFloatArray(e), n.frameVertices = new Array(e), null == f && (f = t.Utils.newFloatArray(64)), n
                            }
                            return n(s, i), s.prototype.getPropertyId = function () {
                                return (r.deform << 27) + +this.attachment.id + this.slotIndex
                            }, s.prototype.setFrame = function (t, e, i) {
                                this.frames[t] = e, this.frameVertices[t] = i
                            }, s.prototype.apply = function (i, n, r, s, a, l, h) {
                                var u = i.slots[this.slotIndex];
                                if (u.bone.active) {
                                    var c = u.getAttachment();
                                    if (c instanceof t.VertexAttachment && c.deformAttachment == this.attachment) {
                                        var d = u.deform;
                                        0 == d.length && (l = e.setup);
                                        var p = this.frameVertices,
                                            f = p[0].length,
                                            g = this.frames;
                                        if (r < g[0]) {
                                            var m = c;
                                            switch (l) {
                                                case e.setup:
                                                    return void (d.length = 0);
                                                case e.first:
                                                    if (1 == a) {
                                                        d.length = 0;
                                                        break
                                                    }
                                                    var _ = t.Utils.setArraySize(d, f);
                                                    if (null == m.bones)
                                                        for (var y = m.vertices, S = 0; S < f; S++) _[S] += (y[S] - _[S]) * a;
                                                    else
                                                        for (a = 1 - a, S = 0; S < f; S++) _[S] *= a
                                            }
                                        } else {
                                            var v = t.Utils.setArraySize(d, f);
                                            if (r >= g[g.length - 1]) {
                                                var b = p[g.length - 1];
                                                if (1 == a)
                                                    if (l == e.add)
                                                        if (null == (m = c).bones) {
                                                            y = m.vertices;
                                                            for (var T = 0; T < f; T++) v[T] += b[T] - y[T]
                                                        } else
                                                            for (var P = 0; P < f; P++) v[P] += b[P];
                                                    else t.Utils.arrayCopy(b, 0, v, 0, f);
                                                else switch (l) {
                                                    case e.setup:
                                                        var A = c;
                                                        if (null == A.bones) {
                                                            y = A.vertices;
                                                            for (var I = 0; I < f; I++) {
                                                                var w = y[I];
                                                                v[I] = w + (b[I] - w) * a
                                                            }
                                                        } else
                                                            for (var E = 0; E < f; E++) v[E] = b[E] * a;
                                                        break;
                                                    case e.first:
                                                    case e.replace:
                                                        for (var C = 0; C < f; C++) v[C] += (b[C] - v[C]) * a;
                                                        break;
                                                    case e.add:
                                                        if (null == (m = c).bones) {
                                                            y = m.vertices;
                                                            for (var x = 0; x < f; x++) v[x] += (b[x] - y[x]) * a
                                                        } else
                                                            for (var B = 0; B < f; B++) v[B] += b[B] * a
                                                }
                                            } else {
                                                var L = o.binarySearch(g, r),
                                                    O = p[L - 1],
                                                    N = p[L],
                                                    M = g[L],
                                                    R = this.getCurvePercent(L - 1, 1 - (r - M) / (g[L - 1] - M));
                                                if (1 == a)
                                                    if (l == e.add)
                                                        if (null == (m = c).bones) {
                                                            y = m.vertices;
                                                            for (var D = 0; D < f; D++) {
                                                                var F = O[D];
                                                                v[D] += F + (N[D] - F) * R - y[D]
                                                            }
                                                        } else
                                                            for (var k = 0; k < f; k++) F = O[k], v[k] += F + (N[k] - F) * R;
                                                    else
                                                        for (var U = 0; U < f; U++) F = O[U], v[U] = F + (N[U] - F) * R;
                                                else switch (l) {
                                                    case e.setup:
                                                        var G = c;
                                                        if (null == G.bones) {
                                                            y = G.vertices;
                                                            for (var W = 0; W < f; W++) F = O[W], w = y[W], v[W] = w + (F + (N[W] - F) * R - w) * a
                                                        } else
                                                            for (var V = 0; V < f; V++) F = O[V], v[V] = (F + (N[V] - F) * R) * a;
                                                        break;
                                                    case e.first:
                                                    case e.replace:
                                                        for (var X = 0; X < f; X++) F = O[X], v[X] += (F + (N[X] - F) * R - v[X]) * a;
                                                        break;
                                                    case e.add:
                                                        if (null == (m = c).bones) {
                                                            y = m.vertices;
                                                            for (var H = 0; H < f; H++) F = O[H], v[H] += (F + (N[H] - F) * R - y[H]) * a
                                                        } else
                                                            for (var Y = 0; Y < f; Y++) F = O[Y], v[Y] += (F + (N[Y] - F) * R) * a
                                                }
                                            }
                                        }
                                    }
                                }
                            }, s
                        }(s);
                    t.DeformTimeline = g;
                    var m = function () {
                        function e(e) {
                            this.frames = t.Utils.newFloatArray(e), this.events = new Array(e)
                        }
                        return e.prototype.getPropertyId = function () {
                            return r.event << 24
                        }, e.prototype.getFrameCount = function () {
                            return this.frames.length
                        }, e.prototype.setFrame = function (t, e) {
                            this.frames[t] = e.time, this.events[t] = e
                        }, e.prototype.apply = function (t, e, i, n, r, s, a) {
                            if (null != n) {
                                var l = this.frames,
                                    h = this.frames.length;
                                if (e > i) this.apply(t, e, Number.MAX_VALUE, n, r, s, a), e = -1;
                                else if (e >= l[h - 1]) return;
                                if (!(i < l[0])) {
                                    var u = 0;
                                    if (e < l[0]) u = 0;
                                    else
                                        for (var c = l[u = o.binarySearch(l, e)]; u > 0 && l[u - 1] == c;) u--;
                                    for (; u < h && i >= l[u]; u++) n.push(this.events[u])
                                }
                            }
                        }, e
                    }();
                    t.EventTimeline = m;
                    var _ = function () {
                        function n(e) {
                            this.frames = t.Utils.newFloatArray(e), this.drawOrders = new Array(e)
                        }
                        return n.prototype.getPropertyId = function () {
                            return r.drawOrder << 24
                        }, n.prototype.getFrameCount = function () {
                            return this.frames.length
                        }, n.prototype.setFrame = function (t, e, i) {
                            this.frames[t] = e, this.drawOrders[t] = i
                        }, n.prototype.apply = function (n, r, s, a, l, h, u) {
                            var c = n.drawOrder,
                                d = n.slots;
                            if (u != i.mixOut || h != e.setup) {
                                var p = this.frames;
                                if (s < p[0]) h != e.setup && h != e.first || t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length);
                                else {
                                    var f;
                                    f = s >= p[p.length - 1] ? p.length - 1 : o.binarySearch(p, s) - 1;
                                    var g = this.drawOrders[f];
                                    if (null == g) t.Utils.arrayCopy(d, 0, c, 0, d.length);
                                    else
                                        for (var m = 0, _ = g.length; m < _; m++) c[m] = d[g[m]]
                                }
                            } else t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length)
                        }, n
                    }();
                    t.DrawOrderTimeline = _;
                    var y = function (s) {
                        function a(e) {
                            var i = s.call(this, e) || this;
                            return i.frames = t.Utils.newFloatArray(e * a.ENTRIES), i
                        }
                        return n(a, s), a.prototype.getPropertyId = function () {
                            return (r.ikConstraint << 24) + this.ikConstraintIndex
                        }, a.prototype.setFrame = function (t, e, i, n, r, o, s) {
                            t *= a.ENTRIES, this.frames[t] = e, this.frames[t + a.MIX] = i, this.frames[t + a.SOFTNESS] = n, this.frames[t + a.BEND_DIRECTION] = r, this.frames[t + a.COMPRESS] = o ? 1 : 0, this.frames[t + a.STRETCH] = s ? 1 : 0
                        }, a.prototype.apply = function (t, n, r, s, l, h, u) {
                            var c = this.frames,
                                d = t.ikConstraints[this.ikConstraintIndex];
                            if (d.active)
                                if (r < c[0]) switch (h) {
                                    case e.setup:
                                        return d.mix = d.data.mix, d.softness = d.data.softness, d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, void (d.stretch = d.data.stretch);
                                    case e.first:
                                        d.mix += (d.data.mix - d.mix) * l, d.softness += (d.data.softness - d.softness) * l, d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch
                                } else if (r >= c[c.length - a.ENTRIES]) h == e.setup ? (d.mix = d.data.mix + (c[c.length + a.PREV_MIX] - d.data.mix) * l, d.softness = d.data.softness + (c[c.length + a.PREV_SOFTNESS] - d.data.softness) * l, u == i.mixOut ? (d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch) : (d.bendDirection = c[c.length + a.PREV_BEND_DIRECTION], d.compress = 0 != c[c.length + a.PREV_COMPRESS], d.stretch = 0 != c[c.length + a.PREV_STRETCH])) : (d.mix += (c[c.length + a.PREV_MIX] - d.mix) * l, d.softness += (c[c.length + a.PREV_SOFTNESS] - d.softness) * l, u == i.mixIn && (d.bendDirection = c[c.length + a.PREV_BEND_DIRECTION], d.compress = 0 != c[c.length + a.PREV_COMPRESS], d.stretch = 0 != c[c.length + a.PREV_STRETCH]));
                                else {
                                    var p = o.binarySearch(c, r, a.ENTRIES),
                                        f = c[p + a.PREV_MIX],
                                        g = c[p + a.PREV_SOFTNESS],
                                        m = c[p],
                                        _ = this.getCurvePercent(p / a.ENTRIES - 1, 1 - (r - m) / (c[p + a.PREV_TIME] - m));
                                    h == e.setup ? (d.mix = d.data.mix + (f + (c[p + a.MIX] - f) * _ - d.data.mix) * l, d.softness = d.data.softness + (g + (c[p + a.SOFTNESS] - g) * _ - d.data.softness) * l, u == i.mixOut ? (d.bendDirection = d.data.bendDirection, d.compress = d.data.compress, d.stretch = d.data.stretch) : (d.bendDirection = c[p + a.PREV_BEND_DIRECTION], d.compress = 0 != c[p + a.PREV_COMPRESS], d.stretch = 0 != c[p + a.PREV_STRETCH])) : (d.mix += (f + (c[p + a.MIX] - f) * _ - d.mix) * l, d.softness += (g + (c[p + a.SOFTNESS] - g) * _ - d.softness) * l, u == i.mixIn && (d.bendDirection = c[p + a.PREV_BEND_DIRECTION], d.compress = 0 != c[p + a.PREV_COMPRESS], d.stretch = 0 != c[p + a.PREV_STRETCH]))
                                }
                        }, a.ENTRIES = 6, a.PREV_TIME = -6, a.PREV_MIX = -5, a.PREV_SOFTNESS = -4, a.PREV_BEND_DIRECTION = -3, a.PREV_COMPRESS = -2, a.PREV_STRETCH = -1, a.MIX = 1, a.SOFTNESS = 2, a.BEND_DIRECTION = 3, a.COMPRESS = 4, a.STRETCH = 5, a
                    }(s);
                    t.IkConstraintTimeline = y;
                    var S = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.transformConstraint << 24) + this.transformConstraintIndex
                        }, s.prototype.setFrame = function (t, e, i, n, r, o) {
                            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.ROTATE] = i, this.frames[t + s.TRANSLATE] = n, this.frames[t + s.SCALE] = r, this.frames[t + s.SHEAR] = o
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = this.frames,
                                c = t.transformConstraints[this.transformConstraintIndex];
                            if (c.active)
                                if (n < u[0]) {
                                    var d = c.data;
                                    switch (l) {
                                        case e.setup:
                                            return c.rotateMix = d.rotateMix, c.translateMix = d.translateMix, c.scaleMix = d.scaleMix, void (c.shearMix = d.shearMix);
                                        case e.first:
                                            c.rotateMix += (d.rotateMix - c.rotateMix) * a, c.translateMix += (d.translateMix - c.translateMix) * a, c.scaleMix += (d.scaleMix - c.scaleMix) * a, c.shearMix += (d.shearMix - c.shearMix) * a
                                    }
                                } else {
                                    var p = 0,
                                        f = 0,
                                        g = 0,
                                        m = 0;
                                    if (n >= u[u.length - s.ENTRIES]) {
                                        var _ = u.length;
                                        p = u[_ + s.PREV_ROTATE], f = u[_ + s.PREV_TRANSLATE], g = u[_ + s.PREV_SCALE], m = u[_ + s.PREV_SHEAR]
                                    } else {
                                        var y = o.binarySearch(u, n, s.ENTRIES);
                                        p = u[y + s.PREV_ROTATE], f = u[y + s.PREV_TRANSLATE], g = u[y + s.PREV_SCALE], m = u[y + s.PREV_SHEAR];
                                        var S = u[y],
                                            v = this.getCurvePercent(y / s.ENTRIES - 1, 1 - (n - S) / (u[y + s.PREV_TIME] - S));
                                        p += (u[y + s.ROTATE] - p) * v, f += (u[y + s.TRANSLATE] - f) * v, g += (u[y + s.SCALE] - g) * v, m += (u[y + s.SHEAR] - m) * v
                                    }
                                    l == e.setup ? (d = c.data, c.rotateMix = d.rotateMix + (p - d.rotateMix) * a, c.translateMix = d.translateMix + (f - d.translateMix) * a, c.scaleMix = d.scaleMix + (g - d.scaleMix) * a, c.shearMix = d.shearMix + (m - d.shearMix) * a) : (c.rotateMix += (p - c.rotateMix) * a, c.translateMix += (f - c.translateMix) * a, c.scaleMix += (g - c.scaleMix) * a, c.shearMix += (m - c.shearMix) * a)
                                }
                        }, s.ENTRIES = 5, s.PREV_TIME = -5, s.PREV_ROTATE = -4, s.PREV_TRANSLATE = -3, s.PREV_SCALE = -2, s.PREV_SHEAR = -1, s.ROTATE = 1, s.TRANSLATE = 2, s.SCALE = 3, s.SHEAR = 4, s
                    }(s);
                    t.TransformConstraintTimeline = S;
                    var v = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.pathConstraintPosition << 24) + this.pathConstraintIndex
                        }, s.prototype.setFrame = function (t, e, i) {
                            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.VALUE] = i
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = this.frames,
                                c = t.pathConstraints[this.pathConstraintIndex];
                            if (c.active)
                                if (n < u[0]) switch (l) {
                                    case e.setup:
                                        return void (c.position = c.data.position);
                                    case e.first:
                                        c.position += (c.data.position - c.position) * a
                                } else {
                                    var d = 0;
                                    if (n >= u[u.length - s.ENTRIES]) d = u[u.length + s.PREV_VALUE];
                                    else {
                                        var p = o.binarySearch(u, n, s.ENTRIES);
                                        d = u[p + s.PREV_VALUE];
                                        var f = u[p],
                                            g = this.getCurvePercent(p / s.ENTRIES - 1, 1 - (n - f) / (u[p + s.PREV_TIME] - f));
                                        d += (u[p + s.VALUE] - d) * g
                                    }
                                    l == e.setup ? c.position = c.data.position + (d - c.data.position) * a : c.position += (d - c.position) * a
                                }
                        }, s.ENTRIES = 2, s.PREV_TIME = -2, s.PREV_VALUE = -1, s.VALUE = 1, s
                    }(s);
                    t.PathConstraintPositionTimeline = v;
                    var b = function (t) {
                        function i(e) {
                            return t.call(this, e) || this
                        }
                        return n(i, t), i.prototype.getPropertyId = function () {
                            return (r.pathConstraintSpacing << 24) + this.pathConstraintIndex
                        }, i.prototype.apply = function (t, n, r, s, a, l, h) {
                            var u = this.frames,
                                c = t.pathConstraints[this.pathConstraintIndex];
                            if (c.active)
                                if (r < u[0]) switch (l) {
                                    case e.setup:
                                        return void (c.spacing = c.data.spacing);
                                    case e.first:
                                        c.spacing += (c.data.spacing - c.spacing) * a
                                } else {
                                    var d = 0;
                                    if (r >= u[u.length - i.ENTRIES]) d = u[u.length + i.PREV_VALUE];
                                    else {
                                        var p = o.binarySearch(u, r, i.ENTRIES);
                                        d = u[p + i.PREV_VALUE];
                                        var f = u[p],
                                            g = this.getCurvePercent(p / i.ENTRIES - 1, 1 - (r - f) / (u[p + i.PREV_TIME] - f));
                                        d += (u[p + i.VALUE] - d) * g
                                    }
                                    l == e.setup ? c.spacing = c.data.spacing + (d - c.data.spacing) * a : c.spacing += (d - c.spacing) * a
                                }
                        }, i
                    }(v);
                    t.PathConstraintSpacingTimeline = b;
                    var T = function (i) {
                        function s(e) {
                            var n = i.call(this, e) || this;
                            return n.frames = t.Utils.newFloatArray(e * s.ENTRIES), n
                        }
                        return n(s, i), s.prototype.getPropertyId = function () {
                            return (r.pathConstraintMix << 24) + this.pathConstraintIndex
                        }, s.prototype.setFrame = function (t, e, i, n) {
                            t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.ROTATE] = i, this.frames[t + s.TRANSLATE] = n
                        }, s.prototype.apply = function (t, i, n, r, a, l, h) {
                            var u = this.frames,
                                c = t.pathConstraints[this.pathConstraintIndex];
                            if (c.active)
                                if (n < u[0]) switch (l) {
                                    case e.setup:
                                        return c.rotateMix = c.data.rotateMix, void (c.translateMix = c.data.translateMix);
                                    case e.first:
                                        c.rotateMix += (c.data.rotateMix - c.rotateMix) * a, c.translateMix += (c.data.translateMix - c.translateMix) * a
                                } else {
                                    var d = 0,
                                        p = 0;
                                    if (n >= u[u.length - s.ENTRIES]) d = u[u.length + s.PREV_ROTATE], p = u[u.length + s.PREV_TRANSLATE];
                                    else {
                                        var f = o.binarySearch(u, n, s.ENTRIES);
                                        d = u[f + s.PREV_ROTATE], p = u[f + s.PREV_TRANSLATE];
                                        var g = u[f],
                                            m = this.getCurvePercent(f / s.ENTRIES - 1, 1 - (n - g) / (u[f + s.PREV_TIME] - g));
                                        d += (u[f + s.ROTATE] - d) * m, p += (u[f + s.TRANSLATE] - p) * m
                                    }
                                    l == e.setup ? (c.rotateMix = c.data.rotateMix + (d - c.data.rotateMix) * a, c.translateMix = c.data.translateMix + (p - c.data.translateMix) * a) : (c.rotateMix += (d - c.rotateMix) * a, c.translateMix += (p - c.translateMix) * a)
                                }
                        }, s.ENTRIES = 3, s.PREV_TIME = -3, s.PREV_ROTATE = -2, s.PREV_TRANSLATE = -1, s.ROTATE = 1, s.TRANSLATE = 2, s
                    }(s);
                    t.PathConstraintMixTimeline = T
                }(t.core || (t.core = {}))
            }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e = function () {
                            function e(e) {
                                this.tracks = new Array, this.timeScale = 1, this.unkeyedState = 0, this.events = new Array, this.listeners = new Array, this.queue = new r(this), this.propertyIDs = new t.IntSet, this.animationsChanged = !1, this.trackEntryPool = new t.Pool((function () {
                                    return new i
                                })), this.data = e
                            }
                            return e.prototype.update = function (t) {
                                t *= this.timeScale;
                                for (var e = this.tracks, i = 0, n = e.length; i < n; i++) {
                                    var r = e[i];
                                    if (null != r) {
                                        r.animationLast = r.nextAnimationLast, r.trackLast = r.nextTrackLast;
                                        var o = t * r.timeScale;
                                        if (r.delay > 0) {
                                            if (r.delay -= o, r.delay > 0) continue;
                                            o = -r.delay, r.delay = 0
                                        }
                                        var s = r.next;
                                        if (null != s) {
                                            var a = r.trackLast - s.delay;
                                            if (a >= 0) {
                                                for (s.delay = 0, s.trackTime += 0 == r.timeScale ? 0 : (a / r.timeScale + t) * s.timeScale, r.trackTime += o, this.setCurrent(i, s, !0); null != s.mixingFrom;) s.mixTime += t, s = s.mixingFrom;
                                                continue
                                            }
                                        } else if (r.trackLast >= r.trackEnd && null == r.mixingFrom) {
                                            e[i] = null, this.queue.end(r), this.disposeNext(r);
                                            continue
                                        }
                                        if (null != r.mixingFrom && this.updateMixingFrom(r, t)) {
                                            var l = r.mixingFrom;
                                            for (r.mixingFrom = null, null != l && (l.mixingTo = null); null != l;) this.queue.end(l), l = l.mixingFrom
                                        }
                                        r.trackTime += o
                                    }
                                }
                                this.queue.drain()
                            }, e.prototype.updateMixingFrom = function (t, e) {
                                var i = t.mixingFrom;
                                if (null == i) return !0;
                                var n = this.updateMixingFrom(i, e);
                                return i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast, t.mixTime > 0 && t.mixTime >= t.mixDuration ? (0 != i.totalAlpha && 0 != t.mixDuration || (t.mixingFrom = i.mixingFrom, null != i.mixingFrom && (i.mixingFrom.mixingTo = t), t.interruptAlpha = i.interruptAlpha, this.queue.end(i)), n) : (i.trackTime += e * i.timeScale, t.mixTime += e, !1)
                            }, e.prototype.apply = function (i) {
                                if (null == i) throw new Error("skeleton cannot be null.");
                                this.animationsChanged && this._animationsChanged();
                                for (var n = this.events, r = this.tracks, o = !1, s = 0, a = r.length; s < a; s++) {
                                    var l = r[s];
                                    if (!(null == l || l.delay > 0)) {
                                        o = !0;
                                        var h = 0 == s ? t.MixBlend.first : l.mixBlend,
                                            u = l.alpha;
                                        null != l.mixingFrom ? u *= this.applyMixingFrom(l, i, h) : l.trackTime >= l.trackEnd && null == l.next && (u = 0);
                                        var c = l.animationLast,
                                            d = l.getAnimationTime(),
                                            p = l.animation.timelines.length,
                                            f = l.animation.timelines;
                                        if (0 == s && 1 == u || h == t.MixBlend.add)
                                            for (var g = 0; g < p; g++) {
                                                t.Utils.webkit602BugfixHelper(u, h);
                                                var m = f[g];
                                                m instanceof t.AttachmentTimeline ? this.applyAttachmentTimeline(m, i, d, h, !0) : m.apply(i, c, d, n, u, h, t.MixDirection.mixIn)
                                            } else {
                                            var _ = l.timelineMode,
                                                y = 0 == l.timelinesRotation.length;
                                            y && t.Utils.setArraySize(l.timelinesRotation, p << 1, null);
                                            var S = l.timelinesRotation;
                                            for (g = 0; g < p; g++) {
                                                var v = f[g],
                                                    b = _[g] == e.SUBSEQUENT ? h : t.MixBlend.setup;
                                                v instanceof t.RotateTimeline ? this.applyRotateTimeline(v, i, d, u, b, S, g << 1, y) : v instanceof t.AttachmentTimeline ? this.applyAttachmentTimeline(v, i, d, h, !0) : (t.Utils.webkit602BugfixHelper(u, h), v.apply(i, c, d, n, u, b, t.MixDirection.mixIn))
                                            }
                                        }
                                        this.queueEvents(l, d), n.length = 0, l.nextAnimationLast = d, l.nextTrackLast = l.trackTime
                                    }
                                }
                                for (var T = this.unkeyedState + e.SETUP, P = i.slots, A = 0, I = i.slots.length; A < I; A++) {
                                    var w = P[A];
                                    if (w.attachmentState == T) {
                                        var E = w.data.attachmentName;
                                        w.attachment = null == E ? null : i.getAttachment(w.data.index, E)
                                    }
                                }
                                return this.unkeyedState += 2, this.queue.drain(), o
                            }, e.prototype.applyMixingFrom = function (i, n, r) {
                                var o = i.mixingFrom;
                                null != o.mixingFrom && this.applyMixingFrom(o, n, r);
                                var s = 0;
                                0 == i.mixDuration ? (s = 1, r == t.MixBlend.first && (r = t.MixBlend.setup)) : ((s = i.mixTime / i.mixDuration) > 1 && (s = 1), r != t.MixBlend.first && (r = o.mixBlend));
                                var a = s < o.eventThreshold ? this.events : null,
                                    l = s < o.attachmentThreshold,
                                    h = s < o.drawOrderThreshold,
                                    u = o.animationLast,
                                    c = o.getAnimationTime(),
                                    d = o.animation.timelines.length,
                                    p = o.animation.timelines,
                                    f = o.alpha * i.interruptAlpha,
                                    g = f * (1 - s);
                                if (r == t.MixBlend.add)
                                    for (var m = 0; m < d; m++) p[m].apply(n, u, c, a, g, r, t.MixDirection.mixOut);
                                else {
                                    var _ = o.timelineMode,
                                        y = o.timelineHoldMix,
                                        S = 0 == o.timelinesRotation.length;
                                    S && t.Utils.setArraySize(o.timelinesRotation, d << 1, null);
                                    var v = o.timelinesRotation;
                                    for (o.totalAlpha = 0, m = 0; m < d; m++) {
                                        var b = p[m],
                                            T = t.MixDirection.mixOut,
                                            P = void 0,
                                            A = 0;
                                        switch (_[m]) {
                                            case e.SUBSEQUENT:
                                                if (!h && b instanceof t.DrawOrderTimeline) continue;
                                                P = r, A = g;
                                                break;
                                            case e.FIRST:
                                                P = t.MixBlend.setup, A = g;
                                                break;
                                            case e.HOLD_SUBSEQUENT:
                                                P = r, A = f;
                                                break;
                                            case e.HOLD_FIRST:
                                                P = t.MixBlend.setup, A = f;
                                                break;
                                            default:
                                                P = t.MixBlend.setup;
                                                var I = y[m];
                                                A = f * Math.max(0, 1 - I.mixTime / I.mixDuration)
                                        }
                                        o.totalAlpha += A, b instanceof t.RotateTimeline ? this.applyRotateTimeline(b, n, c, A, P, v, m << 1, S) : b instanceof t.AttachmentTimeline ? this.applyAttachmentTimeline(b, n, c, P, l) : (t.Utils.webkit602BugfixHelper(A, r), h && b instanceof t.DrawOrderTimeline && P == t.MixBlend.setup && (T = t.MixDirection.mixIn), b.apply(n, u, c, a, A, P, T))
                                    }
                                }
                                return i.mixDuration > 0 && this.queueEvents(o, c), this.events.length = 0, o.nextAnimationLast = c, o.nextTrackLast = o.trackTime, s
                            }, e.prototype.applyAttachmentTimeline = function (i, n, r, o, s) {
                                var a = n.slots[i.slotIndex];
                                if (a.bone.active) {
                                    var l, h = i.frames;
                                    r < h[0] ? o != t.MixBlend.setup && o != t.MixBlend.first || this.setAttachment(n, a, a.data.attachmentName, s) : (l = r >= h[h.length - 1] ? h.length - 1 : t.Animation.binarySearch(h, r) - 1, this.setAttachment(n, a, i.attachmentNames[l], s)), a.attachmentState <= this.unkeyedState && (a.attachmentState = this.unkeyedState + e.SETUP)
                                }
                            }, e.prototype.setAttachment = function (t, i, n, r) {
                                i.attachment = null == n ? null : t.getAttachment(i.data.index, n), r && (i.attachmentState = this.unkeyedState + e.CURRENT)
                            }, e.prototype.applyRotateTimeline = function (e, i, n, r, o, s, a, l) {
                                if (l && (s[a] = 0), 1 != r) {
                                    var h = e,
                                        u = h.frames,
                                        c = i.bones[h.boneIndex];
                                    if (c.active) {
                                        var d = 0,
                                            p = 0;
                                        if (n < u[0]) switch (o) {
                                            case t.MixBlend.setup:
                                                c.rotation = c.data.rotation;
                                            default:
                                                return;
                                            case t.MixBlend.first:
                                                d = c.rotation, p = c.data.rotation
                                        } else if (d = o == t.MixBlend.setup ? c.data.rotation : c.rotation, n >= u[u.length - t.RotateTimeline.ENTRIES]) p = c.data.rotation + u[u.length + t.RotateTimeline.PREV_ROTATION];
                                        else {
                                            var f = t.Animation.binarySearch(u, n, t.RotateTimeline.ENTRIES),
                                                g = u[f + t.RotateTimeline.PREV_ROTATION],
                                                m = u[f],
                                                _ = h.getCurvePercent((f >> 1) - 1, 1 - (n - m) / (u[f + t.RotateTimeline.PREV_TIME] - m));
                                            p = u[f + t.RotateTimeline.ROTATION] - g, p = g + (p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0))) * _ + c.data.rotation, p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0))
                                        } var y = 0,
                                            S = p - d;
                                        if (0 == (S -= 360 * (16384 - (16384.499999999996 - S / 360 | 0)))) y = s[a];
                                        else {
                                            var v = 0,
                                                b = 0;
                                            l ? (v = 0, b = S) : (v = s[a], b = s[a + 1]);
                                            var T = S > 0,
                                                P = v >= 0;
                                            t.MathUtils.signum(b) != t.MathUtils.signum(S) && Math.abs(b) <= 90 && (Math.abs(v) > 180 && (v += 360 * t.MathUtils.signum(v)), P = T), y = S + v - v % 360, P != T && (y += 360 * t.MathUtils.signum(v)), s[a] = y
                                        }
                                        s[a + 1] = S, d += y * r, c.rotation = d - 360 * (16384 - (16384.499999999996 - d / 360 | 0))
                                    }
                                } else e.apply(i, 0, n, null, 1, o, t.MixDirection.mixIn)
                            }, e.prototype.queueEvents = function (t, e) {
                                for (var i = t.animationStart, n = t.animationEnd, r = n - i, o = t.trackLast % r, s = this.events, a = 0, l = s.length; a < l; a++) {
                                    var h = s[a];
                                    if (h.time < o) break;
                                    h.time > n || this.queue.event(t, h)
                                }
                                for ((t.loop ? 0 == r || o > t.trackTime % r : e >= n && t.animationLast < n) && this.queue.complete(t); a < l; a++) s[a].time < i || this.queue.event(t, s[a])
                            }, e.prototype.clearTracks = function () {
                                var t = this.queue.drainDisabled;
                                this.queue.drainDisabled = !0;
                                for (var e = 0, i = this.tracks.length; e < i; e++) this.clearTrack(e);
                                this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain()
                            }, e.prototype.clearTrack = function (t) {
                                if (!(t >= this.tracks.length)) {
                                    var e = this.tracks[t];
                                    if (null != e) {
                                        this.queue.end(e), this.disposeNext(e);
                                        for (var i = e; ;) {
                                            var n = i.mixingFrom;
                                            if (null == n) break;
                                            this.queue.end(n), i.mixingFrom = null, i.mixingTo = null, i = n
                                        }
                                        this.tracks[e.trackIndex] = null, this.queue.drain()
                                    }
                                }
                            }, e.prototype.setCurrent = function (t, e, i) {
                                var n = this.expandToIndex(t);
                                this.tracks[t] = e, null != n && (i && this.queue.interrupt(n), e.mixingFrom = n, n.mixingTo = e, e.mixTime = 0, null != n.mixingFrom && n.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, n.mixTime / n.mixDuration)), n.timelinesRotation.length = 0), this.queue.start(e)
                            }, e.prototype.setAnimation = function (t, e, i) {
                                var n = this.data.skeletonData.findAnimation(e);
                                if (null == n) throw new Error("Animation not found: " + e);
                                return this.setAnimationWith(t, n, i)
                            }, e.prototype.setAnimationWith = function (t, e, i) {
                                if (null == e) throw new Error("animation cannot be null.");
                                var n = !0,
                                    r = this.expandToIndex(t);
                                null != r && (-1 == r.nextTrackLast ? (this.tracks[t] = r.mixingFrom, this.queue.interrupt(r), this.queue.end(r), this.disposeNext(r), r = r.mixingFrom, n = !1) : this.disposeNext(r));
                                var o = this.trackEntry(t, e, i, r);
                                return this.setCurrent(t, o, n), this.queue.drain(), o
                            }, e.prototype.addAnimation = function (t, e, i, n) {
                                var r = this.data.skeletonData.findAnimation(e);
                                if (null == r) throw new Error("Animation not found: " + e);
                                return this.addAnimationWith(t, r, i, n)
                            }, e.prototype.addAnimationWith = function (t, e, i, n) {
                                if (null == e) throw new Error("animation cannot be null.");
                                var r = this.expandToIndex(t);
                                if (null != r)
                                    for (; null != r.next;) r = r.next;
                                var o = this.trackEntry(t, e, i, r);
                                if (null == r) this.setCurrent(t, o, !0), this.queue.drain();
                                else if (r.next = o, n <= 0) {
                                    var s = r.animationEnd - r.animationStart;
                                    0 != s ? (r.loop ? n += s * (1 + (r.trackTime / s | 0)) : n += Math.max(s, r.trackTime), n -= this.data.getMix(r.animation, e)) : n = r.trackTime
                                }
                                return o.delay = n, o
                            }, e.prototype.setEmptyAnimation = function (t, i) {
                                var n = this.setAnimationWith(t, e.emptyAnimation, !1);
                                return n.mixDuration = i, n.trackEnd = i, n
                            }, e.prototype.addEmptyAnimation = function (t, i, n) {
                                n <= 0 && (n -= i);
                                var r = this.addAnimationWith(t, e.emptyAnimation, !1, n);
                                return r.mixDuration = i, r.trackEnd = i, r
                            }, e.prototype.setEmptyAnimations = function (t) {
                                var e = this.queue.drainDisabled;
                                this.queue.drainDisabled = !0;
                                for (var i = 0, n = this.tracks.length; i < n; i++) {
                                    var r = this.tracks[i];
                                    null != r && this.setEmptyAnimation(r.trackIndex, t)
                                }
                                this.queue.drainDisabled = e, this.queue.drain()
                            }, e.prototype.expandToIndex = function (e) {
                                return e < this.tracks.length ? this.tracks[e] : (t.Utils.ensureArrayCapacity(this.tracks, e + 1, null), this.tracks.length = e + 1, null)
                            }, e.prototype.trackEntry = function (e, i, n, r) {
                                var o = this.trackEntryPool.obtain();
                                return o.trackIndex = e, o.animation = i, o.loop = n, o.holdPrevious = !1, o.eventThreshold = 0, o.attachmentThreshold = 0, o.drawOrderThreshold = 0, o.animationStart = 0, o.animationEnd = i.duration, o.animationLast = -1, o.nextAnimationLast = -1, o.delay = 0, o.trackTime = 0, o.trackLast = -1, o.nextTrackLast = -1, o.trackEnd = Number.MAX_VALUE, o.timeScale = 1, o.alpha = 1, o.interruptAlpha = 1, o.mixTime = 0, o.mixDuration = null == r ? 0 : this.data.getMix(r.animation, i), o.mixBlend = t.MixBlend.replace, o
                            }, e.prototype.disposeNext = function (t) {
                                for (var e = t.next; null != e;) this.queue.dispose(e), e = e.next;
                                t.next = null
                            }, e.prototype._animationsChanged = function () {
                                this.animationsChanged = !1, this.propertyIDs.clear();
                                for (var e = 0, i = this.tracks.length; e < i; e++) {
                                    var n = this.tracks[e];
                                    if (null != n) {
                                        for (; null != n.mixingFrom;) n = n.mixingFrom;
                                        do {
                                            null != n.mixingFrom && n.mixBlend == t.MixBlend.add || this.computeHold(n), n = n.mixingTo
                                        } while (null != n)
                                    }
                                }
                            }, e.prototype.computeHold = function (i) {
                                var n = i.mixingTo,
                                    r = i.animation.timelines,
                                    o = i.animation.timelines.length,
                                    s = t.Utils.setArraySize(i.timelineMode, o);
                                i.timelineHoldMix.length = 0;
                                var a = t.Utils.setArraySize(i.timelineHoldMix, o),
                                    l = this.propertyIDs;
                                if (null != n && n.holdPrevious)
                                    for (var h = 0; h < o; h++) s[h] = l.add(r[h].getPropertyId()) ? e.HOLD_FIRST : e.HOLD_SUBSEQUENT;
                                else t: for (h = 0; h < o; h++) {
                                    var u = r[h],
                                        c = u.getPropertyId();
                                    if (l.add(c))
                                        if (null == n || u instanceof t.AttachmentTimeline || u instanceof t.DrawOrderTimeline || u instanceof t.EventTimeline || !n.animation.hasTimeline(c)) s[h] = e.FIRST;
                                        else {
                                            for (var d = n.mixingTo; null != d; d = d.mixingTo)
                                                if (!d.animation.hasTimeline(c)) {
                                                    if (i.mixDuration > 0) {
                                                        s[h] = e.HOLD_MIX, a[h] = d;
                                                        continue t
                                                    }
                                                    break
                                                } s[h] = e.HOLD_FIRST
                                        }
                                    else s[h] = e.SUBSEQUENT
                                }
                            }, e.prototype.getCurrent = function (t) {
                                return t >= this.tracks.length ? null : this.tracks[t]
                            }, e.prototype.addListener = function (t) {
                                if (null == t) throw new Error("listener cannot be null.");
                                this.listeners.push(t)
                            }, e.prototype.removeListener = function (t) {
                                var e = this.listeners.indexOf(t);
                                e >= 0 && this.listeners.splice(e, 1)
                            }, e.prototype.clearListeners = function () {
                                this.listeners.length = 0
                            }, e.prototype.clearListenerNotifications = function () {
                                this.queue.clear()
                            }, e.prototype.setAnimationByName = function (t, i, n) {
                                e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")), this.setAnimation(t, i, n)
                            }, e.prototype.addAnimationByName = function (t, i, n, r) {
                                e.deprecatedWarning2 || (e.deprecatedWarning2 = !0, console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")), this.addAnimation(t, i, n, r)
                            }, e.prototype.hasAnimation = function (t) {
                                return null !== this.data.skeletonData.findAnimation(t)
                            }, e.prototype.hasAnimationByName = function (t) {
                                return e.deprecatedWarning3 || (e.deprecatedWarning3 = !0, console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")), this.hasAnimation(t)
                            }, e.emptyAnimation = new t.Animation("<empty>", [], 0), e.SUBSEQUENT = 0, e.FIRST = 1, e.HOLD_SUBSEQUENT = 2, e.HOLD_FIRST = 3, e.HOLD_MIX = 4, e.SETUP = 1, e.CURRENT = 2, e.deprecatedWarning1 = !1, e.deprecatedWarning2 = !1, e.deprecatedWarning3 = !1, e
                        }();
                        t.AnimationState = e;
                        var i = function () {
                            function e() {
                                this.mixBlend = t.MixBlend.replace, this.timelineMode = new Array, this.timelineHoldMix = new Array, this.timelinesRotation = new Array
                            }
                            return e.prototype.reset = function () {
                                this.next = null, this.mixingFrom = null, this.mixingTo = null, this.animation = null, this.listener = null, this.timelineMode.length = 0, this.timelineHoldMix.length = 0, this.timelinesRotation.length = 0
                            }, e.prototype.getAnimationTime = function () {
                                if (this.loop) {
                                    var t = this.animationEnd - this.animationStart;
                                    return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart
                                }
                                return Math.min(this.trackTime + this.animationStart, this.animationEnd)
                            }, e.prototype.setAnimationLast = function (t) {
                                this.animationLast = t, this.nextAnimationLast = t
                            }, e.prototype.isComplete = function () {
                                return this.trackTime >= this.animationEnd - this.animationStart
                            }, e.prototype.resetRotationDirections = function () {
                                this.timelinesRotation.length = 0
                            }, Object.defineProperty(e.prototype, "time", {
                                get: function () {
                                    return e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")), this.trackTime
                                },
                                set: function (t) {
                                    e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")), this.trackTime = t
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(e.prototype, "endTime", {
                                get: function () {
                                    return e.deprecatedWarning2 || (e.deprecatedWarning2 = !0, console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")), this.trackTime
                                },
                                set: function (t) {
                                    e.deprecatedWarning2 || (e.deprecatedWarning2 = !0, console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")), this.trackTime = t
                                },
                                enumerable: !1,
                                configurable: !0
                            }), e.prototype.loopsCount = function () {
                                return Math.floor(this.trackTime / this.trackEnd)
                            }, e.deprecatedWarning1 = !1, e.deprecatedWarning2 = !1, e
                        }();
                        t.TrackEntry = i;
                        var n, r = function () {
                            function e(t) {
                                this.objects = [], this.drainDisabled = !1, this.animState = t
                            }
                            return e.prototype.start = function (t) {
                                this.objects.push(n.start), this.objects.push(t), this.animState.animationsChanged = !0
                            }, e.prototype.interrupt = function (t) {
                                this.objects.push(n.interrupt), this.objects.push(t)
                            }, e.prototype.end = function (t) {
                                this.objects.push(n.end), this.objects.push(t), this.animState.animationsChanged = !0
                            }, e.prototype.dispose = function (t) {
                                this.objects.push(n.dispose), this.objects.push(t)
                            }, e.prototype.complete = function (t) {
                                this.objects.push(n.complete), this.objects.push(t)
                            }, e.prototype.event = function (t, e) {
                                this.objects.push(n.event), this.objects.push(t), this.objects.push(e)
                            }, e.prototype.deprecateStuff = function () {
                                return e.deprecatedWarning1 || (e.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")), !0
                            }, e.prototype.drain = function () {
                                if (!this.drainDisabled) {
                                    this.drainDisabled = !0;
                                    for (var e = this.objects, i = this.animState.listeners, r = 0; r < e.length; r += 2) {
                                        var o = e[r],
                                            s = e[r + 1];
                                        switch (o) {
                                            case n.start:
                                                null != s.listener && s.listener.start && s.listener.start(s);
                                                for (var a = 0; a < i.length; a++) i[a].start && i[a].start(s);
                                                s.onStart && this.deprecateStuff() && s.onStart(s.trackIndex), this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(s.trackIndex);
                                                break;
                                            case n.interrupt:
                                                for (null != s.listener && s.listener.interrupt && s.listener.interrupt(s), a = 0; a < i.length; a++) i[a].interrupt && i[a].interrupt(s);
                                                break;
                                            case n.end:
                                                for (null != s.listener && s.listener.end && s.listener.end(s), a = 0; a < i.length; a++) i[a].end && i[a].end(s);
                                                s.onEnd && this.deprecateStuff() && s.onEnd(s.trackIndex), this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(s.trackIndex);
                                            case n.dispose:
                                                for (null != s.listener && s.listener.dispose && s.listener.dispose(s), a = 0; a < i.length; a++) i[a].dispose && i[a].dispose(s);
                                                this.animState.trackEntryPool.free(s);
                                                break;
                                            case n.complete:
                                                for (null != s.listener && s.listener.complete && s.listener.complete(s), a = 0; a < i.length; a++) i[a].complete && i[a].complete(s);
                                                var l = t.MathUtils.toInt(s.loopsCount());
                                                s.onComplete && this.deprecateStuff() && s.onComplete(s.trackIndex, l), this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(s.trackIndex, l);
                                                break;
                                            case n.event:
                                                var h = e[2 + r++];
                                                for (null != s.listener && s.listener.event && s.listener.event(s, h), a = 0; a < i.length; a++) i[a].event && i[a].event(s, h);
                                                s.onEvent && this.deprecateStuff() && s.onEvent(s.trackIndex, h), this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(s.trackIndex, h)
                                        }
                                    }
                                    this.clear(), this.drainDisabled = !1
                                }
                            }, e.prototype.clear = function () {
                                this.objects.length = 0
                            }, e.deprecatedWarning1 = !1, e
                        }();
                        t.EventQueue = r,
                            function (t) {
                                t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event"
                            }(n = t.EventType || (t.EventType = {}));
                        var o = function () {
                            function t() { }
                            return t.prototype.start = function (t) { }, t.prototype.interrupt = function (t) { }, t.prototype.end = function (t) { }, t.prototype.dispose = function (t) { }, t.prototype.complete = function (t) { }, t.prototype.event = function (t, e) { }, t
                        }();
                        t.AnimationStateAdapter = o
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t) {
                            if (this.animationToMixTime = {}, this.defaultMix = 0, null == t) throw new Error("skeletonData cannot be null.");
                            this.skeletonData = t
                        }
                        return t.prototype.setMix = function (t, e, i) {
                            var n = this.skeletonData.findAnimation(t);
                            if (null == n) throw new Error("Animation not found: " + t);
                            var r = this.skeletonData.findAnimation(e);
                            if (null == r) throw new Error("Animation not found: " + e);
                            this.setMixWith(n, r, i)
                        }, t.prototype.setMixByName = function (e, i, n) {
                            t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")), this.setMix(e, i, n)
                        }, t.prototype.setMixWith = function (t, e, i) {
                            if (null == t) throw new Error("from cannot be null.");
                            if (null == e) throw new Error("to cannot be null.");
                            var n = t.name + "." + e.name;
                            this.animationToMixTime[n] = i
                        }, t.prototype.getMix = function (t, e) {
                            var i = t.name + "." + e.name,
                                n = this.animationToMixTime[i];
                            return void 0 === n ? this.defaultMix : n
                        }, t.deprecatedWarning1 = !1, t
                    }(), e.AnimationStateData = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t) {
                            this.atlas = t
                        }
                        return t.prototype.newRegionAttachment = function (t, i, n) {
                            var r = this.atlas.findRegion(n);
                            if (null == r) throw new Error("Region not found in atlas: " + n + " (region attachment: " + i + ")");
                            var o = new e.RegionAttachment(i);
                            return o.region = r, o
                        }, t.prototype.newMeshAttachment = function (t, i, n) {
                            var r = this.atlas.findRegion(n);
                            if (null == r) throw new Error("Region not found in atlas: " + n + " (mesh attachment: " + i + ")");
                            var o = new e.MeshAttachment(i);
                            return o.region = r, o
                        }, t.prototype.newBoundingBoxAttachment = function (t, i) {
                            return new e.BoundingBoxAttachment(i)
                        }, t.prototype.newPathAttachment = function (t, i) {
                            return new e.PathAttachment(i)
                        }, t.prototype.newPointAttachment = function (t, i) {
                            return new e.PointAttachment(i)
                        }, t.prototype.newClippingAttachment = function (t, i) {
                            return new e.ClippingAttachment(i)
                        }, t
                    }(), e.AtlasAttachmentLoader = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), (i = e.BlendMode || (e.BlendMode = {}))[i.Normal = 0] = "Normal", i[i.Additive = 1] = "Additive", i[i.Multiply = 2] = "Multiply", i[i.Screen = 3] = "Screen"
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t, e, i) {
                            if (this.matrix = new PIXI.Matrix, this.children = new Array, this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.sorted = !1, this.active = !1, null == t) throw new Error("data cannot be null.");
                            if (null == e) throw new Error("skeleton cannot be null.");
                            this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose()
                        }
                        return Object.defineProperty(t.prototype, "worldX", {
                            get: function () {
                                return this.matrix.tx
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "worldY", {
                            get: function () {
                                return this.matrix.ty
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.prototype.isActive = function () {
                            return this.active
                        }, t.prototype.update = function () {
                            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
                        }, t.prototype.updateWorldTransform = function () {
                            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY)
                        }, t.prototype.updateWorldTransformWith = function (i, n, r, o, s, a, l) {
                            this.ax = i, this.ay = n, this.arotation = r, this.ascaleX = o, this.ascaleY = s, this.ashearX = a, this.ashearY = l, this.appliedValid = !0;
                            var h = this.parent,
                                u = this.matrix,
                                c = this.skeleton.scaleX,
                                d = t.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;
                            if (null == h) {
                                var p = this.skeleton,
                                    f = r + 90 + l;
                                return u.a = e.MathUtils.cosDeg(r + a) * o * c, u.c = e.MathUtils.cosDeg(f) * s * c, u.b = e.MathUtils.sinDeg(r + a) * o * d, u.d = e.MathUtils.sinDeg(f) * s * d, u.tx = i * c + p.x, void (u.ty = n * d + p.y)
                            }
                            var g = h.matrix.a,
                                m = h.matrix.c,
                                _ = h.matrix.b,
                                y = h.matrix.d;
                            switch (u.tx = g * i + m * n + h.matrix.tx, u.ty = _ * i + y * n + h.matrix.ty, this.data.transformMode) {
                                case e.TransformMode.Normal:
                                    f = r + 90 + l;
                                    var S = e.MathUtils.cosDeg(r + a) * o,
                                        v = e.MathUtils.cosDeg(f) * s,
                                        b = e.MathUtils.sinDeg(r + a) * o,
                                        T = e.MathUtils.sinDeg(f) * s;
                                    return u.a = g * S + m * b, u.c = g * v + m * T, u.b = _ * S + y * b, void (u.d = _ * v + y * T);
                                case e.TransformMode.OnlyTranslation:
                                    f = r + 90 + l, u.a = e.MathUtils.cosDeg(r + a) * o, u.c = e.MathUtils.cosDeg(f) * s, u.b = e.MathUtils.sinDeg(r + a) * o, u.d = e.MathUtils.sinDeg(f) * s;
                                    break;
                                case e.TransformMode.NoRotationOrReflection:
                                    var P = 0;
                                    (w = g * g + _ * _) > 1e-4 ? (w = Math.abs(g * y - m * _) / w, g /= this.skeleton.scaleX, m = (_ /= this.skeleton.scaleY) * w, y = g * w, P = Math.atan2(_, g) * e.MathUtils.radDeg) : (g = 0, _ = 0, P = 90 - Math.atan2(y, m) * e.MathUtils.radDeg);
                                    var A = r + a - P,
                                        I = r + l - P + 90;
                                    S = e.MathUtils.cosDeg(A) * o, v = e.MathUtils.cosDeg(I) * s, b = e.MathUtils.sinDeg(A) * o, T = e.MathUtils.sinDeg(I) * s, u.a = g * S - m * b, u.c = g * v - m * T, u.b = _ * S + y * b, u.d = _ * v + y * T;
                                    break;
                                case e.TransformMode.NoScale:
                                case e.TransformMode.NoScaleOrReflection:
                                    var w, E = e.MathUtils.cosDeg(r),
                                        C = e.MathUtils.sinDeg(r),
                                        x = (g * E + m * C) / c,
                                        B = (_ * E + y * C) / d;
                                    (w = Math.sqrt(x * x + B * B)) > 1e-5 && (w = 1 / w), x *= w, B *= w, w = Math.sqrt(x * x + B * B), this.data.transformMode == e.TransformMode.NoScale && g * y - m * _ < 0 != (t.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0) && (w = -w);
                                    var L = Math.PI / 2 + Math.atan2(B, x),
                                        O = Math.cos(L) * w,
                                        N = Math.sin(L) * w;
                                    S = e.MathUtils.cosDeg(a) * o, v = e.MathUtils.cosDeg(90 + l) * s, b = e.MathUtils.sinDeg(a) * o, T = e.MathUtils.sinDeg(90 + l) * s, u.a = x * S + O * b, u.c = x * v + O * T, u.b = B * S + N * b, u.d = B * v + N * T
                            }
                            u.a *= c, u.c *= c, u.b *= d, u.d *= d
                        }, t.prototype.setToSetupPose = function () {
                            var t = this.data;
                            this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY
                        }, t.prototype.getWorldRotationX = function () {
                            return Math.atan2(this.matrix.b, this.matrix.a) * e.MathUtils.radDeg
                        }, t.prototype.getWorldRotationY = function () {
                            return Math.atan2(this.matrix.d, this.matrix.c) * e.MathUtils.radDeg
                        }, t.prototype.getWorldScaleX = function () {
                            var t = this.matrix;
                            return Math.sqrt(t.a * t.a + t.c * t.c)
                        }, t.prototype.getWorldScaleY = function () {
                            var t = this.matrix;
                            return Math.sqrt(t.b * t.b + t.d * t.d)
                        }, t.prototype.updateAppliedTransform = function () {
                            this.appliedValid = !0;
                            var t = this.parent,
                                i = this.matrix;
                            if (null == t) return this.ax = i.tx, this.ay = i.ty, this.arotation = Math.atan2(i.b, i.a) * e.MathUtils.radDeg, this.ascaleX = Math.sqrt(i.a * i.a + i.b * i.b), this.ascaleY = Math.sqrt(i.c * i.c + i.d * i.d), this.ashearX = 0, void (this.ashearY = Math.atan2(i.a * i.c + i.b * i.d, i.a * i.d - i.b * i.c) * e.MathUtils.radDeg);
                            var n = t.matrix,
                                r = 1 / (n.a * n.d - n.b * n.c),
                                o = i.tx - n.tx,
                                s = i.ty - n.ty;
                            this.ax = o * n.d * r - s * n.c * r, this.ay = s * n.a * r - o * n.b * r;
                            var a = r * n.d,
                                l = r * n.a,
                                h = r * n.c,
                                u = r * n.b,
                                c = a * i.a - h * i.b,
                                d = a * i.c - h * i.d,
                                p = l * i.b - u * i.a,
                                f = l * i.d - u * i.c;
                            if (this.ashearX = 0, this.ascaleX = Math.sqrt(c * c + p * p), this.ascaleX > 1e-4) {
                                var g = c * f - d * p;
                                this.ascaleY = g / this.ascaleX, this.ashearY = Math.atan2(c * d + p * f, g) * e.MathUtils.radDeg, this.arotation = Math.atan2(p, c) * e.MathUtils.radDeg
                            } else this.ascaleX = 0, this.ascaleY = Math.sqrt(d * d + f * f), this.ashearY = 0, this.arotation = 90 - Math.atan2(f, d) * e.MathUtils.radDeg
                        }, t.prototype.worldToLocal = function (t) {
                            var e = this.matrix,
                                i = e.a,
                                n = e.c,
                                r = e.b,
                                o = e.d,
                                s = 1 / (i * o - n * r),
                                a = t.x - e.tx,
                                l = t.y - e.ty;
                            return t.x = a * o * s - l * n * s, t.y = l * i * s - a * r * s, t
                        }, t.prototype.localToWorld = function (t) {
                            var e = this.matrix,
                                i = t.x,
                                n = t.y;
                            return t.x = i * e.a + n * e.c + e.tx, t.y = i * e.b + n * e.d + e.ty, t
                        }, t.prototype.worldToLocalRotation = function (t) {
                            var i = e.MathUtils.sinDeg(t),
                                n = e.MathUtils.cosDeg(t),
                                r = this.matrix;
                            return Math.atan2(r.a * i - r.b * n, r.d * n - r.c * i) * e.MathUtils.radDeg
                        }, t.prototype.localToWorldRotation = function (t) {
                            var i = e.MathUtils.sinDeg(t),
                                n = e.MathUtils.cosDeg(t),
                                r = this.matrix;
                            return Math.atan2(n * r.b + i * r.d, n * r.a + i * r.c) * e.MathUtils.radDeg
                        }, t.prototype.rotateWorld = function (t) {
                            var i = this.matrix,
                                n = i.a,
                                r = i.c,
                                o = i.b,
                                s = i.d,
                                a = e.MathUtils.cosDeg(t),
                                l = e.MathUtils.sinDeg(t);
                            i.a = a * n - l * o, i.c = a * r - l * s, i.b = l * n + a * o, i.d = l * r + a * s, this.appliedValid = !1
                        }, t.yDown = !1, t
                    }(), e.Bone = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    (e = t.core || (t.core = {})).BoneData = function (t, n, r) {
                        if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = i.Normal, this.skinRequired = !1, this.color = new e.Color, t < 0) throw new Error("index must be >= 0.");
                        if (null == n) throw new Error("name cannot be null.");
                        this.index = t, this.name = n, this.parent = r
                    },
                        function (t) {
                            t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection"
                        }(i = e.TransformMode || (e.TransformMode = {}))
                }(i || (i = {})),
                function (t) {
                    (t.core || (t.core = {})).ConstraintData = function (t, e, i) {
                        this.name = t, this.order = e, this.skinRequired = i
                    }
                }(i || (i = {})),
                function (t) {
                    (t.core || (t.core = {})).Event = function (t, e) {
                        if (null == e) throw new Error("data cannot be null.");
                        this.time = t, this.data = e
                    }
                }(i || (i = {})),
                function (t) {
                    (t.core || (t.core = {})).EventData = function (t) {
                        this.name = t
                    }
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t, e) {
                            if (this.bendDirection = 0, this.compress = !1, this.stretch = !1, this.mix = 1, this.softness = 0, this.active = !1, null == t) throw new Error("data cannot be null.");
                            if (null == e) throw new Error("skeleton cannot be null.");
                            this.data = t, this.mix = t.mix, this.softness = t.softness, this.bendDirection = t.bendDirection, this.compress = t.compress, this.stretch = t.stretch, this.bones = new Array;
                            for (var i = 0; i < t.bones.length; i++) this.bones.push(e.findBone(t.bones[i].name));
                            this.target = e.findBone(t.target.name)
                        }
                        return t.prototype.isActive = function () {
                            return this.active
                        }, t.prototype.apply = function () {
                            this.update()
                        }, t.prototype.update = function () {
                            var t = this.target,
                                e = this.bones;
                            switch (e.length) {
                                case 1:
                                    this.apply1(e[0], t.worldX, t.worldY, this.compress, this.stretch, this.data.uniform, this.mix);
                                    break;
                                case 2:
                                    this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.stretch, this.softness, this.mix)
                            }
                        }, t.prototype.apply1 = function (t, i, n, r, o, s, a) {
                            t.appliedValid || t.updateAppliedTransform();
                            var l = t.parent.matrix,
                                h = l.a,
                                u = l.c,
                                c = l.b,
                                d = l.d,
                                p = -t.ashearX - t.arotation,
                                f = 0,
                                g = 0;
                            switch (t.data.transformMode) {
                                case e.TransformMode.OnlyTranslation:
                                    f = i - t.worldX, g = n - t.worldY;
                                    break;
                                case e.TransformMode.NoRotationOrReflection:
                                    var m = Math.abs(h * d - u * c) / (h * h + c * c),
                                        _ = h / t.skeleton.scaleX,
                                        y = c / t.skeleton.scaleY;
                                    u = -y * m * t.skeleton.scaleX, d = _ * m * t.skeleton.scaleY, p += Math.atan2(y, _) * e.MathUtils.radDeg;
                                default:
                                    var S = i - l.tx,
                                        v = n - l.ty,
                                        b = h * d - u * c;
                                    f = (S * d - v * u) / b - t.ax, g = (v * h - S * c) / b - t.ay
                            }
                            p += Math.atan2(g, f) * e.MathUtils.radDeg, t.ascaleX < 0 && (p += 180), p > 180 ? p -= 360 : p < -180 && (p += 360);
                            var T = t.ascaleX,
                                P = t.ascaleY;
                            if (r || o) {
                                switch (t.data.transformMode) {
                                    case e.TransformMode.NoScale:
                                    case e.TransformMode.NoScaleOrReflection:
                                        f = i - t.worldX, g = n - t.worldY
                                }
                                var A = t.data.length * T,
                                    I = Math.sqrt(f * f + g * g);
                                (r && I < A || o && I > A && A > 1e-4) && (T *= m = (I / A - 1) * a + 1, s && (P *= m))
                            }
                            t.updateWorldTransformWith(t.ax, t.ay, t.arotation + p * a, T, P, t.ashearX, t.ashearY)
                        }, t.prototype.apply2 = function (t, i, n, r, o, s, a, l) {
                            if (0 != l) {
                                t.appliedValid || t.updateAppliedTransform(), i.appliedValid || i.updateAppliedTransform();
                                var h = t.ax,
                                    u = t.ay,
                                    c = t.ascaleX,
                                    d = c,
                                    p = t.ascaleY,
                                    f = i.ascaleX,
                                    g = t.matrix,
                                    m = 0,
                                    _ = 0,
                                    y = 0;
                                c < 0 ? (c = -c, m = 180, y = -1) : (m = 0, y = 1), p < 0 && (p = -p, y = -y), f < 0 ? (f = -f, _ = 180) : _ = 0;
                                var S = i.ax,
                                    v = 0,
                                    b = 0,
                                    T = 0,
                                    P = g.a,
                                    A = g.c,
                                    I = g.b,
                                    w = g.d,
                                    E = Math.abs(c - p) <= 1e-4;
                                E ? (b = P * S + A * (v = i.ay) + g.tx, T = I * S + w * v + g.ty) : (v = 0, b = P * S + g.tx, T = I * S + g.ty);
                                var C = t.parent.matrix;
                                P = C.a, A = C.c, I = C.b;
                                var x, B, L = 1 / (P * (w = C.d) - A * I),
                                    O = b - C.tx,
                                    N = T - C.ty,
                                    M = (O * w - N * A) * L - h,
                                    R = (N * P - O * I) * L - u,
                                    D = Math.sqrt(M * M + R * R),
                                    F = i.data.length * f;
                                if (D < 1e-4) return this.apply1(t, n, r, !1, s, !1, l), void i.updateWorldTransformWith(S, v, 0, i.ascaleX, i.ascaleY, i.ashearX, i.ashearY);
                                var k = ((O = n - C.tx) * w - (N = r - C.ty) * A) * L - h,
                                    U = (N * P - O * I) * L - u,
                                    G = k * k + U * U;
                                if (0 != a) {
                                    a *= c * (f + 1) / 2;
                                    var W = Math.sqrt(G),
                                        V = W - D - F * c + a;
                                    if (V > 0) {
                                        var X = Math.min(1, V / (2 * a)) - 1;
                                        G = (k -= (X = (V - a * (1 - X * X)) / W) * k) * k + (U -= X * U) * U
                                    }
                                }
                                t: if (E) {
                                    var H = (G - D * D - (F *= c) * F) / (2 * D * F);
                                    H < -1 ? H = -1 : H > 1 && (H = 1, s && (d *= (Math.sqrt(G) / (D + F) - 1) * l + 1)), B = Math.acos(H) * o, P = D + F * H, A = F * Math.sin(B), x = Math.atan2(U * P - k * A, k * P + U * A)
                                } else {
                                    var Y = (P = c * F) * P,
                                        j = (A = p * F) * A,
                                        z = Math.atan2(U, k),
                                        K = -2 * j * D,
                                        q = j - Y;
                                    if ((w = K * K - 4 * q * (I = j * D * D + Y * G - Y * j)) >= 0) {
                                        var Z = Math.sqrt(w);
                                        K < 0 && (Z = -Z);
                                        var $ = (Z = -(K + Z) / 2) / q,
                                            J = I / Z,
                                            Q = Math.abs($) < Math.abs(J) ? $ : J;
                                        if (Q * Q <= G) {
                                            N = Math.sqrt(G - Q * Q) * o, x = z - Math.atan2(N, Q), B = Math.atan2(N / p, (Q - D) / c);
                                            break t
                                        }
                                    }
                                    var tt = e.MathUtils.PI,
                                        et = D - P,
                                        it = et * et,
                                        nt = 0,
                                        rt = 0,
                                        ot = D + P,
                                        st = ot * ot,
                                        at = 0;
                                    (I = -P * D / (Y - j)) >= -1 && I <= 1 && (I = Math.acos(I), (w = (O = P * Math.cos(I) + D) * O + (N = A * Math.sin(I)) * N) < it && (tt = I, it = w, et = O, nt = N), w > st && (rt = I, st = w, ot = O, at = N)), G <= (it + st) / 2 ? (x = z - Math.atan2(nt * o, et), B = tt * o) : (x = z - Math.atan2(at * o, ot), B = rt * o)
                                }
                                var lt = Math.atan2(v, S) * y,
                                    ht = t.arotation;
                                (x = (x - lt) * e.MathUtils.radDeg + m - ht) > 180 ? x -= 360 : x < -180 && (x += 360), t.updateWorldTransformWith(h, u, ht + x * l, d, t.ascaleY, 0, 0), ht = i.arotation, (B = ((B + lt) * e.MathUtils.radDeg - i.ashearX) * y + _ - ht) > 180 ? B -= 360 : B < -180 && (B += 360), i.updateWorldTransformWith(S, v, ht + B * l, i.ascaleX, i.ascaleY, i.ashearX, i.ashearY)
                            } else i.updateWorldTransform()
                        }, t
                    }(), e.IkConstraint = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function e(e) {
                            var i = t.call(this, e, 0, !1) || this;
                            return i.bones = new Array, i.bendDirection = 1, i.compress = !1, i.stretch = !1, i.uniform = !1, i.mix = 1, i.softness = 0, i
                        }
                        return n(e, t), e
                    }(e.ConstraintData), e.IkConstraintData = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t, e) {
                            if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array, this.positions = new Array, this.world = new Array, this.curves = new Array, this.lengths = new Array, this.segments = new Array, this.active = !1, null == t) throw new Error("data cannot be null.");
                            if (null == e) throw new Error("skeleton cannot be null.");
                            this.data = t, this.bones = new Array;
                            for (var i = 0, n = t.bones.length; i < n; i++) this.bones.push(e.findBone(t.bones[i].name));
                            this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix
                        }
                        return t.prototype.isActive = function () {
                            return this.active
                        }, t.prototype.apply = function () {
                            this.update()
                        }, t.prototype.update = function () {
                            var i = this.target.getAttachment();
                            if (i instanceof e.PathAttachment) {
                                var n = this.rotateMix,
                                    r = this.translateMix,
                                    o = n > 0;
                                if (r > 0 || o) {
                                    var s = this.data,
                                        a = s.spacingMode,
                                        l = a == e.SpacingMode.Length,
                                        h = s.rotateMode,
                                        u = h == e.RotateMode.Tangent,
                                        c = h == e.RotateMode.ChainScale,
                                        d = this.bones.length,
                                        p = u ? d : d + 1,
                                        f = this.bones,
                                        g = e.Utils.setArraySize(this.spaces, p),
                                        m = null,
                                        _ = this.spacing;
                                    if (c || l) {
                                        c && (m = e.Utils.setArraySize(this.lengths, d));
                                        for (var y = 0, S = p - 1; y < S;) {
                                            var v = (B = f[y]).data.length;
                                            if (v < t.epsilon) c && (m[y] = 0), g[++y] = 0;
                                            else {
                                                var b = v * B.matrix.a,
                                                    T = v * B.matrix.b,
                                                    P = Math.sqrt(b * b + T * T);
                                                c && (m[y] = P), g[++y] = (l ? v + _ : _) * P / v
                                            }
                                        }
                                    } else
                                        for (y = 1; y < p; y++) g[y] = _;
                                    var A = this.computeWorldPositions(i, p, u, s.positionMode == e.PositionMode.Percent, a == e.SpacingMode.Percent),
                                        I = A[0],
                                        w = A[1],
                                        E = s.offsetRotation,
                                        C = !1;
                                    0 == E ? C = h == e.RotateMode.Chain : (C = !1, E *= (x = this.target.bone.matrix).a * x.d - x.b * x.c > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad), y = 0;
                                    for (var x = 3; y < d; y++, x += 3) {
                                        var B, L = (B = f[y]).matrix;
                                        L.tx += (I - L.tx) * r, L.ty += (w - L.ty) * r;
                                        var O = (b = A[x]) - I,
                                            N = (T = A[x + 1]) - w;
                                        if (c) {
                                            var M = m[y];
                                            if (0 != M) {
                                                var R = (Math.sqrt(O * O + N * N) / M - 1) * n + 1;
                                                L.a *= R, L.b *= R
                                            }
                                        }
                                        if (I = b, w = T, o) {
                                            var D = L.a,
                                                F = L.c,
                                                k = L.b,
                                                U = L.d,
                                                G = 0,
                                                W = 0,
                                                V = 0;
                                            if (G = u ? A[x - 1] : 0 == g[y + 1] ? A[x + 2] : Math.atan2(N, O), G -= Math.atan2(k, D), C) {
                                                W = Math.cos(G), V = Math.sin(G);
                                                var X = B.data.length;
                                                I += (X * (W * D - V * k) - O) * n, w += (X * (V * D + W * k) - N) * n
                                            } else G += E;
                                            G > e.MathUtils.PI ? G -= e.MathUtils.PI2 : G < -e.MathUtils.PI && (G += e.MathUtils.PI2), G *= n, W = Math.cos(G), V = Math.sin(G), L.a = W * D - V * k, L.c = W * F - V * U, L.b = V * D + W * k, L.d = V * F + W * U
                                        }
                                        B.appliedValid = !1
                                    }
                                }
                            }
                        }, t.prototype.computeWorldPositions = function (i, n, r, o, s) {
                            var a = this.target,
                                l = this.position,
                                h = this.spaces,
                                u = e.Utils.setArraySize(this.positions, 3 * n + 2),
                                c = null,
                                d = i.closed,
                                p = i.worldVerticesLength,
                                f = p / 6,
                                g = t.NONE;
                            if (!i.constantSpeed) {
                                var m = i.lengths,
                                    _ = m[f -= d ? 1 : 2];
                                if (o && (l *= _), s)
                                    for (var y = 0; y < n; y++) h[y] *= _;
                                c = e.Utils.setArraySize(this.world, 8), y = 0;
                                for (var S = 0, v = 0; y < n; y++, S += 3) {
                                    var b = l += Y = h[y];
                                    if (d) (b %= _) < 0 && (b += _), v = 0;
                                    else {
                                        if (b < 0) {
                                            g != t.BEFORE && (g = t.BEFORE, i.computeWorldVertices(a, 2, 4, c, 0, 2)), this.addBeforePosition(b, c, 0, u, S);
                                            continue
                                        }
                                        if (b > _) {
                                            g != t.AFTER && (g = t.AFTER, i.computeWorldVertices(a, p - 6, 4, c, 0, 2)), this.addAfterPosition(b - _, c, 0, u, S);
                                            continue
                                        }
                                    }
                                    for (; ; v++) {
                                        var T = m[v];
                                        if (!(b > T)) {
                                            0 == v ? b /= T : b = (b - (q = m[v - 1])) / (T - q);
                                            break
                                        }
                                    }
                                    v != g && (g = v, d && v == f ? (i.computeWorldVertices(a, p - 4, 4, c, 0, 2), i.computeWorldVertices(a, 0, 4, c, 4, 2)) : i.computeWorldVertices(a, 6 * v + 2, 8, c, 0, 2)), this.addCurvePosition(b, c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], u, S, r || y > 0 && 0 == Y)
                                }
                                return u
                            }
                            d ? (p += 2, c = e.Utils.setArraySize(this.world, p), i.computeWorldVertices(a, 2, p - 4, c, 0, 2), i.computeWorldVertices(a, 0, 2, c, p - 4, 2), c[p - 2] = c[0], c[p - 1] = c[1]) : (f--, p -= 4, c = e.Utils.setArraySize(this.world, p), i.computeWorldVertices(a, 2, p, c, 0, 2));
                            for (var P = e.Utils.setArraySize(this.curves, f), A = 0, I = c[0], w = c[1], E = 0, C = 0, x = 0, B = 0, L = 0, O = 0, N = 0, M = 0, R = 0, D = 0, F = 0, k = 0, U = 0, G = 0, W = (y = 0, 2); y < f; y++, W += 6) E = c[W], C = c[W + 1], x = c[W + 2], B = c[W + 3], F = 2 * (N = .1875 * (I - 2 * E + x)) + (R = .09375 * (3 * (E - x) - I + (L = c[W + 4]))), k = 2 * (M = .1875 * (w - 2 * C + B)) + (D = .09375 * (3 * (C - B) - w + (O = c[W + 5]))), U = .75 * (E - I) + N + .16666667 * R, G = .75 * (C - w) + M + .16666667 * D, A += Math.sqrt(U * U + G * G), U += F, G += k, F += R, k += D, A += Math.sqrt(U * U + G * G), U += F, G += k, A += Math.sqrt(U * U + G * G), U += F + R, G += k + D, A += Math.sqrt(U * U + G * G), P[y] = A, I = L, w = O;
                            if (o && (l *= A), s)
                                for (y = 0; y < n; y++) h[y] *= A;
                            for (var V = this.segments, X = 0, H = (y = 0, S = 0, v = 0, 0); y < n; y++, S += 3) {
                                var Y;
                                if (b = l += Y = h[y], d) (b %= A) < 0 && (b += A), v = 0;
                                else {
                                    if (b < 0) {
                                        this.addBeforePosition(b, c, 0, u, S);
                                        continue
                                    }
                                    if (b > A) {
                                        this.addAfterPosition(b - A, c, p - 4, u, S);
                                        continue
                                    }
                                }
                                for (; ; v++) {
                                    var j = P[v];
                                    if (!(b > j)) {
                                        0 == v ? b /= j : b = (b - (q = P[v - 1])) / (j - q);
                                        break
                                    }
                                }
                                if (v != g) {
                                    g = v;
                                    var z = 6 * v;
                                    for (I = c[z], w = c[z + 1], E = c[z + 2], C = c[z + 3], x = c[z + 4], B = c[z + 5], F = 2 * (N = .03 * (I - 2 * E + x)) + (R = .006 * (3 * (E - x) - I + (L = c[z + 6]))), k = 2 * (M = .03 * (w - 2 * C + B)) + (D = .006 * (3 * (C - B) - w + (O = c[z + 7]))), U = .3 * (E - I) + N + .16666667 * R, G = .3 * (C - w) + M + .16666667 * D, X = Math.sqrt(U * U + G * G), V[0] = X, z = 1; z < 8; z++) U += F, G += k, F += R, k += D, X += Math.sqrt(U * U + G * G), V[z] = X;
                                    U += F, G += k, X += Math.sqrt(U * U + G * G), V[8] = X, U += F + R, G += k + D, X += Math.sqrt(U * U + G * G), V[9] = X, H = 0
                                }
                                for (b *= X; ; H++) {
                                    var K = V[H];
                                    if (!(b > K)) {
                                        var q;
                                        0 == H ? b /= K : b = H + (b - (q = V[H - 1])) / (K - q);
                                        break
                                    }
                                }
                                this.addCurvePosition(.1 * b, I, w, E, C, x, B, L, O, u, S, r || y > 0 && 0 == Y)
                            }
                            return u
                        }, t.prototype.addBeforePosition = function (t, e, i, n, r) {
                            var o = e[i],
                                s = e[i + 1],
                                a = e[i + 2] - o,
                                l = e[i + 3] - s,
                                h = Math.atan2(l, a);
                            n[r] = o + t * Math.cos(h), n[r + 1] = s + t * Math.sin(h), n[r + 2] = h
                        }, t.prototype.addAfterPosition = function (t, e, i, n, r) {
                            var o = e[i + 2],
                                s = e[i + 3],
                                a = o - e[i],
                                l = s - e[i + 1],
                                h = Math.atan2(l, a);
                            n[r] = o + t * Math.cos(h), n[r + 1] = s + t * Math.sin(h), n[r + 2] = h
                        }, t.prototype.addCurvePosition = function (t, e, i, n, r, o, s, a, l, h, u, c) {
                            (0 == t || isNaN(t)) && (t = 1e-4);
                            var d = t * t,
                                p = d * t,
                                f = 1 - t,
                                g = f * f,
                                m = g * f,
                                _ = f * t,
                                y = 3 * _,
                                S = f * y,
                                v = y * t,
                                b = e * m + n * S + o * v + a * p,
                                T = i * m + r * S + s * v + l * p;
                            h[u] = b, h[u + 1] = T, c && (h[u + 2] = Math.atan2(T - (i * g + r * _ * 2 + s * d), b - (e * g + n * _ * 2 + o * d)))
                        }, t.NONE = -1, t.BEFORE = -2, t.AFTER = -3, t.epsilon = 1e-5, t
                    }(), e.PathConstraint = i
                }(i || (i = {})),
                function (t) {
                    var e, i, r, o, s;
                    e = t.core || (t.core = {}), s = function (t) {
                        function e(e) {
                            var i = t.call(this, e, 0, !1) || this;
                            return i.bones = new Array, i
                        }
                        return n(e, t), e
                    }(e.ConstraintData), e.PathConstraintData = s, (o = e.PositionMode || (e.PositionMode = {}))[o.Fixed = 0] = "Fixed", o[o.Percent = 1] = "Percent", (r = e.SpacingMode || (e.SpacingMode = {}))[r.Length = 0] = "Length", r[r.Fixed = 1] = "Fixed", r[r.Percent = 2] = "Percent", (i = e.RotateMode || (e.RotateMode = {}))[i.Tangent = 0] = "Tangent", i[i.Chain = 1] = "Chain", i[i.ChainScale = 2] = "ChainScale"
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t) {
                            if (this._updateCache = new Array, this.updateCacheReset = new Array, this.time = 0, this.scaleX = 1, this.scaleY = 1, this.x = 0, this.y = 0, null == t) throw new Error("data cannot be null.");
                            this.data = t, this.bones = new Array;
                            for (var i = 0; i < t.bones.length; i++) {
                                var n = t.bones[i],
                                    r = void 0;
                                if (null == n.parent) r = new e.Bone(n, this, null);
                                else {
                                    var o = this.bones[n.parent.index];
                                    r = new e.Bone(n, this, o), o.children.push(r)
                                }
                                this.bones.push(r)
                            }
                            for (this.slots = new Array, this.drawOrder = new Array, i = 0; i < t.slots.length; i++) {
                                var s = t.slots[i],
                                    a = (r = this.bones[s.boneData.index], new e.Slot(s, r));
                                this.slots.push(a), this.drawOrder.push(a)
                            }
                            for (this.ikConstraints = new Array, i = 0; i < t.ikConstraints.length; i++) {
                                var l = t.ikConstraints[i];
                                this.ikConstraints.push(new e.IkConstraint(l, this))
                            }
                            for (this.transformConstraints = new Array, i = 0; i < t.transformConstraints.length; i++) {
                                var h = t.transformConstraints[i];
                                this.transformConstraints.push(new e.TransformConstraint(h, this))
                            }
                            for (this.pathConstraints = new Array, i = 0; i < t.pathConstraints.length; i++) {
                                var u = t.pathConstraints[i];
                                this.pathConstraints.push(new e.PathConstraint(u, this))
                            }
                            this.color = new e.Color(1, 1, 1, 1), this.updateCache()
                        }
                        return t.prototype.updateCache = function () {
                            this._updateCache.length = 0, this.updateCacheReset.length = 0;
                            for (var t = this.bones, e = 0, i = t.length; e < i; e++)(r = t[e]).sorted = r.data.skinRequired, r.active = !r.sorted;
                            if (null != this.skin) {
                                var n = this.skin.bones;
                                for (e = 0, i = this.skin.bones.length; e < i; e++) {
                                    var r = this.bones[n[e].index];
                                    do {
                                        r.sorted = !1, r.active = !0, r = r.parent
                                    } while (null != r)
                                }
                            }
                            var o = this.ikConstraints,
                                s = this.transformConstraints,
                                a = this.pathConstraints,
                                l = o.length,
                                h = s.length,
                                u = a.length,
                                c = l + h + u;
                            t: for (e = 0; e < c; e++) {
                                for (var d = 0; d < l; d++)
                                    if ((p = o[d]).data.order == e) {
                                        this.sortIkConstraint(p);
                                        continue t
                                    } for (d = 0; d < h; d++)
                                    if ((p = s[d]).data.order == e) {
                                        this.sortTransformConstraint(p);
                                        continue t
                                    } for (d = 0; d < u; d++) {
                                        var p;
                                        if ((p = a[d]).data.order == e) {
                                            this.sortPathConstraint(p);
                                            continue t
                                        }
                                    }
                            }
                            for (e = 0, i = t.length; e < i; e++) this.sortBone(t[e])
                        }, t.prototype.sortIkConstraint = function (t) {
                            if (t.active = t.target.isActive() && (!t.data.skinRequired || null != this.skin && e.Utils.contains(this.skin.constraints, t.data, !0)), t.active) {
                                var i = t.target;
                                this.sortBone(i);
                                var n = t.bones,
                                    r = n[0];
                                if (this.sortBone(r), n.length > 1) {
                                    var o = n[n.length - 1];
                                    this._updateCache.indexOf(o) > -1 || this.updateCacheReset.push(o)
                                }
                                this._updateCache.push(t), this.sortReset(r.children), n[n.length - 1].sorted = !0
                            }
                        }, t.prototype.sortPathConstraint = function (t) {
                            if (t.active = t.target.bone.isActive() && (!t.data.skinRequired || null != this.skin && e.Utils.contains(this.skin.constraints, t.data, !0)), t.active) {
                                var i = t.target,
                                    n = i.data.index,
                                    r = i.bone;
                                null != this.skin && this.sortPathConstraintAttachment(this.skin, n, r), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, n, r);
                                for (var o = 0, s = this.data.skins.length; o < s; o++) this.sortPathConstraintAttachment(this.data.skins[o], n, r);
                                var a = i.getAttachment();
                                a instanceof e.PathAttachment && this.sortPathConstraintAttachmentWith(a, r);
                                var l = t.bones,
                                    h = l.length;
                                for (o = 0; o < h; o++) this.sortBone(l[o]);
                                for (this._updateCache.push(t), o = 0; o < h; o++) this.sortReset(l[o].children);
                                for (o = 0; o < h; o++) l[o].sorted = !0
                            }
                        }, t.prototype.sortTransformConstraint = function (t) {
                            if (t.active = t.target.isActive() && (!t.data.skinRequired || null != this.skin && e.Utils.contains(this.skin.constraints, t.data, !0)), t.active) {
                                this.sortBone(t.target);
                                var i = t.bones,
                                    n = i.length;
                                if (t.data.local)
                                    for (var r = 0; r < n; r++) {
                                        var o = i[r];
                                        this.sortBone(o.parent), this._updateCache.indexOf(o) > -1 || this.updateCacheReset.push(o)
                                    } else
                                    for (r = 0; r < n; r++) this.sortBone(i[r]);
                                this._updateCache.push(t);
                                for (var s = 0; s < n; s++) this.sortReset(i[s].children);
                                for (s = 0; s < n; s++) i[s].sorted = !0
                            }
                        }, t.prototype.sortPathConstraintAttachment = function (t, e, i) {
                            var n = t.attachments[e];
                            if (n)
                                for (var r in n) this.sortPathConstraintAttachmentWith(n[r], i)
                        }, t.prototype.sortPathConstraintAttachmentWith = function (t, i) {
                            if (t instanceof e.PathAttachment) {
                                var n = t.bones;
                                if (null == n) this.sortBone(i);
                                else
                                    for (var r = this.bones, o = 0; o < n.length;)
                                        for (var s = n[o++], a = o + s; o < a; o++) {
                                            var l = n[o];
                                            this.sortBone(r[l])
                                        }
                            }
                        }, t.prototype.sortBone = function (t) {
                            if (!t.sorted) {
                                var e = t.parent;
                                null != e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t)
                            }
                        }, t.prototype.sortReset = function (t) {
                            for (var e = 0, i = t.length; e < i; e++) {
                                var n = t[e];
                                n.active && (n.sorted && this.sortReset(n.children), n.sorted = !1)
                            }
                        }, t.prototype.updateWorldTransform = function () {
                            for (var t = this.updateCacheReset, e = 0, i = t.length; e < i; e++) {
                                var n = t[e];
                                n.ax = n.x, n.ay = n.y, n.arotation = n.rotation, n.ascaleX = n.scaleX, n.ascaleY = n.scaleY, n.ashearX = n.shearX, n.ashearY = n.shearY, n.appliedValid = !0
                            }
                            var r = this._updateCache;
                            for (e = 0, i = r.length; e < i; e++) r[e].update()
                        }, t.prototype.setToSetupPose = function () {
                            this.setBonesToSetupPose(), this.setSlotsToSetupPose()
                        }, t.prototype.setBonesToSetupPose = function () {
                            for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].setToSetupPose();
                            var n = this.ikConstraints;
                            for (e = 0, i = n.length; e < i; e++)(a = n[e]).mix = a.data.mix, a.softness = a.data.softness, a.bendDirection = a.data.bendDirection, a.compress = a.data.compress, a.stretch = a.data.stretch;
                            var r = this.transformConstraints;
                            for (e = 0, i = r.length; e < i; e++) {
                                var o = (a = r[e]).data;
                                a.rotateMix = o.rotateMix, a.translateMix = o.translateMix, a.scaleMix = o.scaleMix, a.shearMix = o.shearMix
                            }
                            var s = this.pathConstraints;
                            for (e = 0, i = s.length; e < i; e++) {
                                var a;
                                o = (a = s[e]).data, a.position = o.position, a.spacing = o.spacing, a.rotateMix = o.rotateMix, a.translateMix = o.translateMix
                            }
                        }, t.prototype.setSlotsToSetupPose = function () {
                            var t = this.slots;
                            e.Utils.arrayCopy(t, 0, this.drawOrder, 0, t.length);
                            for (var i = 0, n = t.length; i < n; i++) t[i].setToSetupPose()
                        }, t.prototype.getRootBone = function () {
                            return 0 == this.bones.length ? null : this.bones[0]
                        }, t.prototype.findBone = function (t) {
                            if (null == t) throw new Error("boneName cannot be null.");
                            for (var e = this.bones, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.data.name == t) return r
                            }
                            return null
                        }, t.prototype.findBoneIndex = function (t) {
                            if (null == t) throw new Error("boneName cannot be null.");
                            for (var e = this.bones, i = 0, n = e.length; i < n; i++)
                                if (e[i].data.name == t) return i;
                            return -1
                        }, t.prototype.findSlot = function (t) {
                            if (null == t) throw new Error("slotName cannot be null.");
                            for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.data.name == t) return r
                            }
                            return null
                        }, t.prototype.findSlotIndex = function (t) {
                            if (null == t) throw new Error("slotName cannot be null.");
                            for (var e = this.slots, i = 0, n = e.length; i < n; i++)
                                if (e[i].data.name == t) return i;
                            return -1
                        }, t.prototype.setSkinByName = function (t) {
                            var e = this.data.findSkin(t);
                            if (null == e) throw new Error("Skin not found: " + t);
                            this.setSkin(e)
                        }, t.prototype.setSkin = function (t) {
                            if (t != this.skin) {
                                if (null != t)
                                    if (null != this.skin) t.attachAll(this, this.skin);
                                    else
                                        for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
                                            var r = e[i],
                                                o = r.data.attachmentName;
                                            if (null != o) {
                                                var s = t.getAttachment(i, o);
                                                null != s && r.setAttachment(s)
                                            }
                                        }
                                this.skin = t, this.updateCache()
                            }
                        }, t.prototype.getAttachmentByName = function (t, e) {
                            return this.getAttachment(this.data.findSlotIndex(t), e)
                        }, t.prototype.getAttachment = function (t, e) {
                            if (null == e) throw new Error("attachmentName cannot be null.");
                            if (null != this.skin) {
                                var i = this.skin.getAttachment(t, e);
                                if (null != i) return i
                            }
                            return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
                        }, t.prototype.setAttachment = function (t, e) {
                            if (null == t) throw new Error("slotName cannot be null.");
                            for (var i = this.slots, n = 0, r = i.length; n < r; n++) {
                                var o = i[n];
                                if (o.data.name == t) {
                                    var s = null;
                                    if (null != e && null == (s = this.getAttachment(n, e))) throw new Error("Attachment not found: " + e + ", for slot: " + t);
                                    return void o.setAttachment(s)
                                }
                            }
                            throw new Error("Slot not found: " + t)
                        }, t.prototype.findIkConstraint = function (t) {
                            if (null == t) throw new Error("constraintName cannot be null.");
                            for (var e = this.ikConstraints, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.data.name == t) return r
                            }
                            return null
                        }, t.prototype.findTransformConstraint = function (t) {
                            if (null == t) throw new Error("constraintName cannot be null.");
                            for (var e = this.transformConstraints, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.data.name == t) return r
                            }
                            return null
                        }, t.prototype.findPathConstraint = function (t) {
                            if (null == t) throw new Error("constraintName cannot be null.");
                            for (var e = this.pathConstraints, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.data.name == t) return r
                            }
                            return null
                        }, t.prototype.getBounds = function (t, i, n) {
                            if (void 0 === n && (n = new Array(2)), null == t) throw new Error("offset cannot be null.");
                            if (null == i) throw new Error("size cannot be null.");
                            for (var r = this.drawOrder, o = Number.POSITIVE_INFINITY, s = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, l = Number.NEGATIVE_INFINITY, h = 0, u = r.length; h < u; h++) {
                                var c = r[h];
                                if (c.bone.active) {
                                    var d = 0,
                                        p = null,
                                        f = c.getAttachment();
                                    if (f instanceof e.RegionAttachment) d = 8, p = e.Utils.setArraySize(n, d, 0), f.computeWorldVertices(c.bone, p, 0, 2);
                                    else if (f instanceof e.MeshAttachment) {
                                        var g = f;
                                        d = g.worldVerticesLength, p = e.Utils.setArraySize(n, d, 0), g.computeWorldVertices(c, 0, d, p, 0, 2)
                                    }
                                    if (null != p)
                                        for (var m = 0, _ = p.length; m < _; m += 2) {
                                            var y = p[m],
                                                S = p[m + 1];
                                            o = Math.min(o, y), s = Math.min(s, S), a = Math.max(a, y), l = Math.max(l, S)
                                        }
                                }
                            }
                            t.set(o, s), i.set(a - o, l - s)
                        }, t.prototype.update = function (t) {
                            this.time += t
                        }, Object.defineProperty(t.prototype, "flipX", {
                            get: function () {
                                return -1 == this.scaleX
                            },
                            set: function (e) {
                                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")), this.scaleX = e ? 1 : -1
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "flipY", {
                            get: function () {
                                return -1 == this.scaleY
                            },
                            set: function (e) {
                                t.deprecatedWarning1 || (t.deprecatedWarning1 = !0, console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")), this.scaleY = e ? 1 : -1
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.deprecatedWarning1 = !1, t
                    }(), e.Skeleton = i
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e = function () {
                            function e(t) {
                                this.scale = 1, this.linkedMeshes = new Array, this.attachmentLoader = t
                            }
                            return e.prototype.readSkeletonData = function (n) {
                                var r = this.scale,
                                    o = new t.SkeletonData;
                                o.name = "";
                                var s = new i(n);
                                o.hash = s.readString(), o.version = s.readString(), "3.8.75" === o.version && console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."), o.x = s.readFloat(), o.y = s.readFloat(), o.width = s.readFloat(), o.height = s.readFloat();
                                var a = s.readBoolean();
                                a && (o.fps = s.readFloat(), o.imagesPath = s.readString(), o.audioPath = s.readString());
                                var l = 0;
                                l = s.readInt(!0);
                                for (var h = 0; h < l; h++) s.strings.push(s.readString());
                                for (l = s.readInt(!0), h = 0; h < l; h++) {
                                    var u = s.readString(),
                                        c = 0 == h ? null : o.bones[s.readInt(!0)];
                                    (f = new t.BoneData(h, u, c)).rotation = s.readFloat(), f.x = s.readFloat() * r, f.y = s.readFloat() * r, f.scaleX = s.readFloat(), f.scaleY = s.readFloat(), f.shearX = s.readFloat(), f.shearY = s.readFloat(), f.length = s.readFloat() * r, f.transformMode = e.TransformModeValues[s.readInt(!0)], f.skinRequired = s.readBoolean(), a && t.Color.rgba8888ToColor(f.color, s.readInt32()), o.bones.push(f)
                                }
                                for (l = s.readInt(!0), h = 0; h < l; h++) {
                                    var d = s.readString(),
                                        p = o.bones[s.readInt(!0)],
                                        f = new t.SlotData(h, d, p);
                                    t.Color.rgba8888ToColor(f.color, s.readInt32());
                                    var g = s.readInt32(); - 1 != g && t.Color.rgb888ToColor(f.darkColor = new t.Color, g), f.attachmentName = s.readStringRef(), f.blendMode = e.BlendModeValues[s.readInt(!0)], o.slots.push(f)
                                }
                                l = s.readInt(!0), h = 0;
                                for (var m = void 0; h < l; h++) {
                                    (f = new t.IkConstraintData(s.readString())).order = s.readInt(!0), f.skinRequired = s.readBoolean(), m = s.readInt(!0);
                                    for (var _ = 0; _ < m; _++) f.bones.push(o.bones[s.readInt(!0)]);
                                    f.target = o.bones[s.readInt(!0)], f.mix = s.readFloat(), f.softness = s.readFloat() * r, f.bendDirection = s.readByte(), f.compress = s.readBoolean(), f.stretch = s.readBoolean(), f.uniform = s.readBoolean(), o.ikConstraints.push(f)
                                }
                                for (l = s.readInt(!0), h = 0, m = void 0; h < l; h++) {
                                    for ((f = new t.TransformConstraintData(s.readString())).order = s.readInt(!0), f.skinRequired = s.readBoolean(), m = s.readInt(!0), _ = 0; _ < m; _++) f.bones.push(o.bones[s.readInt(!0)]);
                                    f.target = o.bones[s.readInt(!0)], f.local = s.readBoolean(), f.relative = s.readBoolean(), f.offsetRotation = s.readFloat(), f.offsetX = s.readFloat() * r, f.offsetY = s.readFloat() * r, f.offsetScaleX = s.readFloat(), f.offsetScaleY = s.readFloat(), f.offsetShearY = s.readFloat(), f.rotateMix = s.readFloat(), f.translateMix = s.readFloat(), f.scaleMix = s.readFloat(), f.shearMix = s.readFloat(), o.transformConstraints.push(f)
                                }
                                for (l = s.readInt(!0), h = 0, m = void 0; h < l; h++) {
                                    for ((f = new t.PathConstraintData(s.readString())).order = s.readInt(!0), f.skinRequired = s.readBoolean(), m = s.readInt(!0), _ = 0; _ < m; _++) f.bones.push(o.bones[s.readInt(!0)]);
                                    f.target = o.slots[s.readInt(!0)], f.positionMode = e.PositionModeValues[s.readInt(!0)], f.spacingMode = e.SpacingModeValues[s.readInt(!0)], f.rotateMode = e.RotateModeValues[s.readInt(!0)], f.offsetRotation = s.readFloat(), f.position = s.readFloat(), f.positionMode == t.PositionMode.Fixed && (f.position *= r), f.spacing = s.readFloat(), f.spacingMode != t.SpacingMode.Length && f.spacingMode != t.SpacingMode.Fixed || (f.spacing *= r), f.rotateMix = s.readFloat(), f.translateMix = s.readFloat(), o.pathConstraints.push(f)
                                }
                                var y = this.readSkin(s, o, !0, a);
                                for (null != y && (o.defaultSkin = y, o.skins.push(y)), h = o.skins.length, t.Utils.setArraySize(o.skins, l = h + s.readInt(!0)); h < l; h++) o.skins[h] = this.readSkin(s, o, !1, a);
                                for (l = this.linkedMeshes.length, h = 0; h < l; h++) {
                                    var S = this.linkedMeshes[h],
                                        v = null == S.skin ? o.defaultSkin : o.findSkin(S.skin);
                                    if (null == v) throw new Error("Skin not found: " + S.skin);
                                    var b = v.getAttachment(S.slotIndex, S.parent);
                                    if (null == b) throw new Error("Parent mesh not found: " + S.parent);
                                    S.mesh.deformAttachment = S.inheritDeform ? b : S.mesh, S.mesh.setParentMesh(b)
                                }
                                for (this.linkedMeshes.length = 0, l = s.readInt(!0), h = 0; h < l; h++)(f = new t.EventData(s.readStringRef())).intValue = s.readInt(!1), f.floatValue = s.readFloat(), f.stringValue = s.readString(), f.audioPath = s.readString(), null != f.audioPath && (f.volume = s.readFloat(), f.balance = s.readFloat()), o.events.push(f);
                                for (l = s.readInt(!0), h = 0; h < l; h++) o.animations.push(this.readAnimation(s, s.readString(), o));
                                return o
                            }, e.prototype.readSkin = function (e, i, n, r) {
                                var o = null,
                                    s = 0;
                                if (n) {
                                    if (0 == (s = e.readInt(!0))) return null;
                                    o = new t.Skin("default")
                                } else {
                                    (o = new t.Skin(e.readStringRef())).bones.length = e.readInt(!0);
                                    for (var a = 0, l = o.bones.length; a < l; a++) o.bones[a] = i.bones[e.readInt(!0)];
                                    for (a = 0, l = e.readInt(!0); a < l; a++) o.constraints.push(i.ikConstraints[e.readInt(!0)]);
                                    for (a = 0, l = e.readInt(!0); a < l; a++) o.constraints.push(i.transformConstraints[e.readInt(!0)]);
                                    for (a = 0, l = e.readInt(!0); a < l; a++) o.constraints.push(i.pathConstraints[e.readInt(!0)]);
                                    s = e.readInt(!0)
                                }
                                for (a = 0; a < s; a++)
                                    for (var h = e.readInt(!0), u = 0, c = e.readInt(!0); u < c; u++) {
                                        var d = e.readStringRef(),
                                            p = this.readAttachment(e, i, o, h, d, r);
                                        null != p && o.setAttachment(h, d, p)
                                    }
                                return o
                            }, e.prototype.readAttachment = function (i, r, o, s, a, l) {
                                var h = this.scale,
                                    u = i.readStringRef();
                                null == u && (u = a);
                                var c = i.readByte();
                                switch (e.AttachmentTypeValues[c]) {
                                    case t.AttachmentType.Region:
                                        var d = i.readStringRef(),
                                            p = i.readFloat(),
                                            f = i.readFloat(),
                                            g = i.readFloat(),
                                            m = i.readFloat(),
                                            _ = i.readFloat(),
                                            y = i.readFloat(),
                                            S = i.readFloat(),
                                            v = i.readInt32();
                                        null == d && (d = u);
                                        var b = this.attachmentLoader.newRegionAttachment(o, u, d);
                                        return null == b ? null : (b.path = d, b.x = f * h, b.y = g * h, b.scaleX = m, b.scaleY = _, b.rotation = p, b.width = y * h, b.height = S * h, t.Color.rgba8888ToColor(b.color, v), b);
                                    case t.AttachmentType.BoundingBox:
                                        var T = i.readInt(!0),
                                            P = this.readVertices(i, T),
                                            A = (v = l ? i.readInt32() : 0, this.attachmentLoader.newBoundingBoxAttachment(o, u));
                                        return null == A ? null : (A.worldVerticesLength = T << 1, A.vertices = P.vertices, A.bones = P.bones, l && t.Color.rgba8888ToColor(A.color, v), A);
                                    case t.AttachmentType.Mesh:
                                        d = i.readStringRef(), v = i.readInt32(), T = i.readInt(!0);
                                        var I = this.readFloatArray(i, T << 1, 1),
                                            w = this.readShortArray(i),
                                            E = (P = this.readVertices(i, T), i.readInt(!0)),
                                            C = null;
                                        return y = 0, S = 0, l && (C = this.readShortArray(i), y = i.readFloat(), S = i.readFloat()), null == d && (d = u), null == (x = this.attachmentLoader.newMeshAttachment(o, u, d)) ? null : (x.path = d, t.Color.rgba8888ToColor(x.color, v), x.bones = P.bones, x.vertices = P.vertices, x.worldVerticesLength = T << 1, x.triangles = w, x.regionUVs = new Float32Array(I), x.hullLength = E << 1, l && (x.edges = C, x.width = y * h, x.height = S * h), x);
                                    case t.AttachmentType.LinkedMesh:
                                        d = i.readStringRef(), v = i.readInt32();
                                        var x, B = i.readStringRef(),
                                            L = i.readStringRef(),
                                            O = i.readBoolean();
                                        return y = 0, S = 0, l && (y = i.readFloat(), S = i.readFloat()), null == d && (d = u), null == (x = this.attachmentLoader.newMeshAttachment(o, u, d)) ? null : (x.path = d, t.Color.rgba8888ToColor(x.color, v), l && (x.width = y * h, x.height = S * h), this.linkedMeshes.push(new n(x, B, s, L, O)), x);
                                    case t.AttachmentType.Path:
                                        for (var N = i.readBoolean(), M = i.readBoolean(), R = (T = i.readInt(!0), P = this.readVertices(i, T), t.Utils.newArray(T / 3, 0)), D = 0, F = R.length; D < F; D++) R[D] = i.readFloat() * h;
                                        return v = l ? i.readInt32() : 0, null == (d = this.attachmentLoader.newPathAttachment(o, u)) ? null : (d.closed = N, d.constantSpeed = M, d.worldVerticesLength = T << 1, d.vertices = P.vertices, d.bones = P.bones, d.lengths = R, l && t.Color.rgba8888ToColor(d.color, v), d);
                                    case t.AttachmentType.Point:
                                        p = i.readFloat(), f = i.readFloat(), g = i.readFloat(), v = l ? i.readInt32() : 0;
                                        var k = this.attachmentLoader.newPointAttachment(o, u);
                                        return null == k ? null : (k.x = f * h, k.y = g * h, k.rotation = p, l && t.Color.rgba8888ToColor(k.color, v), k);
                                    case t.AttachmentType.Clipping:
                                        var U = i.readInt(!0),
                                            G = (T = i.readInt(!0), P = this.readVertices(i, T), v = l ? i.readInt32() : 0, this.attachmentLoader.newClippingAttachment(o, u));
                                        return null == G ? null : (G.endSlot = r.slots[U], G.worldVerticesLength = T << 1, G.vertices = P.vertices, G.bones = P.bones, l && t.Color.rgba8888ToColor(G.color, v), G)
                                }
                                return null
                            }, e.prototype.readVertices = function (e, i) {
                                var n = i << 1,
                                    o = new r,
                                    s = this.scale;
                                if (!e.readBoolean()) return o.vertices = this.readFloatArray(e, n, s), o;
                                for (var a = new Array, l = new Array, h = 0; h < i; h++) {
                                    var u = e.readInt(!0);
                                    l.push(u);
                                    for (var c = 0; c < u; c++) l.push(e.readInt(!0)), a.push(e.readFloat() * s), a.push(e.readFloat() * s), a.push(e.readFloat())
                                }
                                return o.vertices = t.Utils.toFloatArray(a), o.bones = l, o
                            }, e.prototype.readFloatArray = function (t, e, i) {
                                var n = new Array(e);
                                if (1 == i)
                                    for (var r = 0; r < e; r++) n[r] = t.readFloat();
                                else
                                    for (r = 0; r < e; r++) n[r] = t.readFloat() * i;
                                return n
                            }, e.prototype.readShortArray = function (t) {
                                for (var e = t.readInt(!0), i = new Array(e), n = 0; n < e; n++) i[n] = t.readShort();
                                return i
                            }, e.prototype.readAnimation = function (i, n, r) {
                                for (var o = new Array, s = this.scale, a = 0, l = new t.Color, h = new t.Color, u = 0, c = i.readInt(!0); u < c; u++)
                                    for (var d = i.readInt(!0), p = 0, f = i.readInt(!0); p < f; p++) {
                                        var g = i.readByte(),
                                            m = i.readInt(!0);
                                        switch (g) {
                                            case e.SLOT_ATTACHMENT:
                                                (v = new t.AttachmentTimeline(m)).slotIndex = d;
                                                for (var _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readStringRef());
                                                o.push(v), a = Math.max(a, v.frames[m - 1]);
                                                break;
                                            case e.SLOT_COLOR:
                                                for ((v = new t.ColorTimeline(m)).slotIndex = d, _ = 0; _ < m; _++) {
                                                    var y = i.readFloat();
                                                    t.Color.rgba8888ToColor(l, i.readInt32()), v.setFrame(_, y, l.r, l.g, l.b, l.a), _ < m - 1 && this.readCurve(i, _, v)
                                                }
                                                o.push(v), a = Math.max(a, v.frames[(m - 1) * t.ColorTimeline.ENTRIES]);
                                                break;
                                            case e.SLOT_TWO_COLOR:
                                                for ((v = new t.TwoColorTimeline(m)).slotIndex = d, _ = 0; _ < m; _++) y = i.readFloat(), t.Color.rgba8888ToColor(l, i.readInt32()), t.Color.rgb888ToColor(h, i.readInt32()), v.setFrame(_, y, l.r, l.g, l.b, l.a, h.r, h.g, h.b), _ < m - 1 && this.readCurve(i, _, v);
                                                o.push(v), a = Math.max(a, v.frames[(m - 1) * t.TwoColorTimeline.ENTRIES])
                                        }
                                    }
                                for (u = 0, c = i.readInt(!0); u < c; u++) {
                                    var S = i.readInt(!0);
                                    for (p = 0, f = i.readInt(!0); p < f; p++) switch (g = i.readByte(), m = i.readInt(!0), g) {
                                        case e.BONE_ROTATE:
                                            for ((v = new t.RotateTimeline(m)).boneIndex = S, _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readFloat()), _ < m - 1 && this.readCurve(i, _, v);
                                            o.push(v), a = Math.max(a, v.frames[(m - 1) * t.RotateTimeline.ENTRIES]);
                                            break;
                                        case e.BONE_TRANSLATE:
                                        case e.BONE_SCALE:
                                        case e.BONE_SHEAR:
                                            var v = void 0,
                                                b = 1;
                                            for (g == e.BONE_SCALE ? v = new t.ScaleTimeline(m) : g == e.BONE_SHEAR ? v = new t.ShearTimeline(m) : (v = new t.TranslateTimeline(m), b = s), v.boneIndex = S, _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readFloat() * b, i.readFloat() * b), _ < m - 1 && this.readCurve(i, _, v);
                                            o.push(v), a = Math.max(a, v.frames[(m - 1) * t.TranslateTimeline.ENTRIES])
                                    }
                                }
                                for (u = 0, c = i.readInt(!0); u < c; u++) {
                                    var T = i.readInt(!0);
                                    for (m = i.readInt(!0), (v = new t.IkConstraintTimeline(m)).ikConstraintIndex = T, _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readFloat(), i.readFloat() * s, i.readByte(), i.readBoolean(), i.readBoolean()), _ < m - 1 && this.readCurve(i, _, v);
                                    o.push(v), a = Math.max(a, v.frames[(m - 1) * t.IkConstraintTimeline.ENTRIES])
                                }
                                for (u = 0, c = i.readInt(!0); u < c; u++) {
                                    for (T = i.readInt(!0), m = i.readInt(!0), (v = new t.TransformConstraintTimeline(m)).transformConstraintIndex = T, _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readFloat(), i.readFloat(), i.readFloat(), i.readFloat()), _ < m - 1 && this.readCurve(i, _, v);
                                    o.push(v), a = Math.max(a, v.frames[(m - 1) * t.TransformConstraintTimeline.ENTRIES])
                                }
                                for (u = 0, c = i.readInt(!0); u < c; u++) {
                                    T = i.readInt(!0);
                                    var P = r.pathConstraints[T];
                                    for (p = 0, f = i.readInt(!0); p < f; p++) switch (g = i.readByte(), m = i.readInt(!0), g) {
                                        case e.PATH_POSITION:
                                        case e.PATH_SPACING:
                                            for (v = void 0, b = 1, g == e.PATH_SPACING ? (v = new t.PathConstraintSpacingTimeline(m), P.spacingMode != t.SpacingMode.Length && P.spacingMode != t.SpacingMode.Fixed || (b = s)) : (v = new t.PathConstraintPositionTimeline(m), P.positionMode == t.PositionMode.Fixed && (b = s)), v.pathConstraintIndex = T, _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readFloat() * b), _ < m - 1 && this.readCurve(i, _, v);
                                            o.push(v), a = Math.max(a, v.frames[(m - 1) * t.PathConstraintPositionTimeline.ENTRIES]);
                                            break;
                                        case e.PATH_MIX:
                                            for ((v = new t.PathConstraintMixTimeline(m)).pathConstraintIndex = T, _ = 0; _ < m; _++) v.setFrame(_, i.readFloat(), i.readFloat(), i.readFloat()), _ < m - 1 && this.readCurve(i, _, v);
                                            o.push(v), a = Math.max(a, v.frames[(m - 1) * t.PathConstraintMixTimeline.ENTRIES])
                                    }
                                }
                                for (u = 0, c = i.readInt(!0); u < c; u++) {
                                    var A = r.skins[i.readInt(!0)];
                                    for (p = 0, f = i.readInt(!0); p < f; p++) {
                                        d = i.readInt(!0);
                                        for (var I = 0, w = i.readInt(!0); I < w; I++) {
                                            var E = A.getAttachment(d, i.readStringRef()),
                                                C = null != E.bones,
                                                x = E.vertices,
                                                B = C ? x.length / 3 * 2 : x.length;
                                            for (m = i.readInt(!0), (v = new t.DeformTimeline(m)).slotIndex = d, v.attachment = E, _ = 0; _ < m; _++) {
                                                y = i.readFloat();
                                                var L = void 0,
                                                    O = i.readInt(!0);
                                                if (0 == O) L = C ? t.Utils.newFloatArray(B) : x;
                                                else {
                                                    L = t.Utils.newFloatArray(B);
                                                    var N = i.readInt(!0);
                                                    if (O += N, 1 == s)
                                                        for (var M = N; M < O; M++) L[M] = i.readFloat();
                                                    else
                                                        for (M = N; M < O; M++) L[M] = i.readFloat() * s;
                                                    if (!C) {
                                                        M = 0;
                                                        for (var R = L.length; M < R; M++) L[M] += x[M]
                                                    }
                                                }
                                                v.setFrame(_, y, L), _ < m - 1 && this.readCurve(i, _, v)
                                            }
                                            o.push(v), a = Math.max(a, v.frames[m - 1])
                                        }
                                    }
                                }
                                var D = i.readInt(!0);
                                if (D > 0) {
                                    v = new t.DrawOrderTimeline(D);
                                    var F = r.slots.length;
                                    for (u = 0; u < D; u++) {
                                        y = i.readFloat();
                                        var k = i.readInt(!0),
                                            U = t.Utils.newArray(F, 0);
                                        for (p = F - 1; p >= 0; p--) U[p] = -1;
                                        var G = t.Utils.newArray(F - k, 0),
                                            W = 0,
                                            V = 0;
                                        for (p = 0; p < k; p++) {
                                            for (d = i.readInt(!0); W != d;) G[V++] = W++;
                                            U[W + i.readInt(!0)] = W++
                                        }
                                        for (; W < F;) G[V++] = W++;
                                        for (p = F - 1; p >= 0; p--) - 1 == U[p] && (U[p] = G[--V]);
                                        v.setFrame(u, y, U)
                                    }
                                    o.push(v), a = Math.max(a, v.frames[D - 1])
                                }
                                var X = i.readInt(!0);
                                if (X > 0) {
                                    for (v = new t.EventTimeline(X), u = 0; u < X; u++) {
                                        y = i.readFloat();
                                        var H = r.events[i.readInt(!0)],
                                            Y = new t.Event(y, H);
                                        Y.intValue = i.readInt(!1), Y.floatValue = i.readFloat(), Y.stringValue = i.readBoolean() ? i.readString() : H.stringValue, null != Y.data.audioPath && (Y.volume = i.readFloat(), Y.balance = i.readFloat()), v.setFrame(u, Y)
                                    }
                                    o.push(v), a = Math.max(a, v.frames[X - 1])
                                }
                                return new t.Animation(n, o, a)
                            }, e.prototype.readCurve = function (t, i, n) {
                                switch (t.readByte()) {
                                    case e.CURVE_STEPPED:
                                        n.setStepped(i);
                                        break;
                                    case e.CURVE_BEZIER:
                                        this.setCurve(n, i, t.readFloat(), t.readFloat(), t.readFloat(), t.readFloat())
                                }
                            }, e.prototype.setCurve = function (t, e, i, n, r, o) {
                                t.setCurve(e, i, n, r, o)
                            }, e.AttachmentTypeValues = [0, 1, 2, 3, 4, 5, 6], e.TransformModeValues = [t.TransformMode.Normal, t.TransformMode.OnlyTranslation, t.TransformMode.NoRotationOrReflection, t.TransformMode.NoScale, t.TransformMode.NoScaleOrReflection], e.PositionModeValues = [t.PositionMode.Fixed, t.PositionMode.Percent], e.SpacingModeValues = [t.SpacingMode.Length, t.SpacingMode.Fixed, t.SpacingMode.Percent], e.RotateModeValues = [t.RotateMode.Tangent, t.RotateMode.Chain, t.RotateMode.ChainScale], e.BlendModeValues = [t.BlendMode.Normal, t.BlendMode.Additive, t.BlendMode.Multiply, t.BlendMode.Screen], e.BONE_ROTATE = 0, e.BONE_TRANSLATE = 1, e.BONE_SCALE = 2, e.BONE_SHEAR = 3, e.SLOT_ATTACHMENT = 0, e.SLOT_COLOR = 1, e.SLOT_TWO_COLOR = 2, e.PATH_POSITION = 0, e.PATH_SPACING = 1, e.PATH_MIX = 2, e.CURVE_LINEAR = 0, e.CURVE_STEPPED = 1, e.CURVE_BEZIER = 2, e
                        }();
                        t.SkeletonBinary = e;
                        var i = function () {
                            function t(t, e, i, n) {
                                void 0 === e && (e = new Array), void 0 === i && (i = 0), void 0 === n && (n = new DataView(t.buffer)), this.strings = e, this.index = i, this.buffer = n
                            }
                            return t.prototype.readByte = function () {
                                return this.buffer.getInt8(this.index++)
                            }, t.prototype.readShort = function () {
                                var t = this.buffer.getInt16(this.index);
                                return this.index += 2, t
                            }, t.prototype.readInt32 = function () {
                                var t = this.buffer.getInt32(this.index);
                                return this.index += 4, t
                            }, t.prototype.readInt = function (t) {
                                var e = this.readByte(),
                                    i = 127 & e;
                                return 0 != (128 & e) && (i |= (127 & (e = this.readByte())) << 7, 0 != (128 & e) && (i |= (127 & (e = this.readByte())) << 14, 0 != (128 & e) && (i |= (127 & (e = this.readByte())) << 21, 0 != (128 & e) && (i |= (127 & (e = this.readByte())) << 28)))), t ? i : i >>> 1 ^ -(1 & i)
                            }, t.prototype.readStringRef = function () {
                                var t = this.readInt(!0);
                                return 0 == t ? null : this.strings[t - 1]
                            }, t.prototype.readString = function () {
                                var t = this.readInt(!0);
                                switch (t) {
                                    case 0:
                                        return null;
                                    case 1:
                                        return ""
                                }
                                t--;
                                for (var e = "", i = 0; i < t;) {
                                    var n = this.readByte();
                                    switch (n >> 4) {
                                        case 12:
                                        case 13:
                                            e += String.fromCharCode((31 & n) << 6 | 63 & this.readByte()), i += 2;
                                            break;
                                        case 14:
                                            e += String.fromCharCode((15 & n) << 12 | (63 & this.readByte()) << 6 | 63 & this.readByte()), i += 3;
                                            break;
                                        default:
                                            e += String.fromCharCode(n), i++
                                    }
                                }
                                return e
                            }, t.prototype.readFloat = function () {
                                var t = this.buffer.getFloat32(this.index);
                                return this.index += 4, t
                            }, t.prototype.readBoolean = function () {
                                return 0 != this.readByte()
                            }, t
                        }(),
                            n = function (t, e, i, n, r) {
                                this.mesh = t, this.skin = e, this.slotIndex = i, this.parent = n, this.inheritDeform = r
                            },
                            r = function (t, e) {
                                void 0 === t && (t = null), void 0 === e && (e = null), this.bones = t, this.vertices = e
                            }
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t() {
                            this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array, this.polygons = new Array, this.polygonPool = new e.Pool((function () {
                                return e.Utils.newFloatArray(16)
                            }))
                        }
                        return t.prototype.update = function (t, i) {
                            if (null == t) throw new Error("skeleton cannot be null.");
                            var n = this.boundingBoxes,
                                r = this.polygons,
                                o = this.polygonPool,
                                s = t.slots,
                                a = s.length;
                            n.length = 0, o.freeAll(r), r.length = 0;
                            for (var l = 0; l < a; l++) {
                                var h = s[l];
                                if (h.bone.active) {
                                    var u = h.getAttachment();
                                    if (u instanceof e.BoundingBoxAttachment) {
                                        var c = u;
                                        n.push(c);
                                        var d = o.obtain();
                                        d.length != c.worldVerticesLength && (d = e.Utils.newFloatArray(c.worldVerticesLength)), r.push(d), c.computeWorldVertices(h, 0, c.worldVerticesLength, d, 0, 2)
                                    }
                                }
                            }
                            i ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY)
                        }, t.prototype.aabbCompute = function () {
                            for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, n = Number.NEGATIVE_INFINITY, r = this.polygons, o = 0, s = r.length; o < s; o++)
                                for (var a = r[o], l = a, h = 0, u = a.length; h < u; h += 2) {
                                    var c = l[h],
                                        d = l[h + 1];
                                    t = Math.min(t, c), e = Math.min(e, d), i = Math.max(i, c), n = Math.max(n, d)
                                }
                            this.minX = t, this.minY = e, this.maxX = i, this.maxY = n
                        }, t.prototype.aabbContainsPoint = function (t, e) {
                            return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
                        }, t.prototype.aabbIntersectsSegment = function (t, e, i, n) {
                            var r = this.minX,
                                o = this.minY,
                                s = this.maxX,
                                a = this.maxY;
                            if (t <= r && i <= r || e <= o && n <= o || t >= s && i >= s || e >= a && n >= a) return !1;
                            var l = (n - e) / (i - t),
                                h = l * (r - t) + e;
                            if (h > o && h < a) return !0;
                            if ((h = l * (s - t) + e) > o && h < a) return !0;
                            var u = (o - e) / l + t;
                            return u > r && u < s || (u = (a - e) / l + t) > r && u < s
                        }, t.prototype.aabbIntersectsSkeleton = function (t) {
                            return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
                        }, t.prototype.containsPoint = function (t, e) {
                            for (var i = this.polygons, n = 0, r = i.length; n < r; n++)
                                if (this.containsPointPolygon(i[n], t, e)) return this.boundingBoxes[n];
                            return null
                        }, t.prototype.containsPointPolygon = function (t, e, i) {
                            for (var n = t, r = t.length, o = r - 2, s = !1, a = 0; a < r; a += 2) {
                                var l = n[a + 1],
                                    h = n[o + 1];
                                if (l < i && h >= i || h < i && l >= i) {
                                    var u = n[a];
                                    u + (i - l) / (h - l) * (n[o] - u) < e && (s = !s)
                                }
                                o = a
                            }
                            return s
                        }, t.prototype.intersectsSegment = function (t, e, i, n) {
                            for (var r = this.polygons, o = 0, s = r.length; o < s; o++)
                                if (this.intersectsSegmentPolygon(r[o], t, e, i, n)) return this.boundingBoxes[o];
                            return null
                        }, t.prototype.intersectsSegmentPolygon = function (t, e, i, n, r) {
                            for (var o = t, s = t.length, a = e - n, l = i - r, h = e * r - i * n, u = o[s - 2], c = o[s - 1], d = 0; d < s; d += 2) {
                                var p = o[d],
                                    f = o[d + 1],
                                    g = u * f - c * p,
                                    m = u - p,
                                    _ = c - f,
                                    y = a * _ - l * m,
                                    S = (h * m - a * g) / y;
                                if ((S >= u && S <= p || S >= p && S <= u) && (S >= e && S <= n || S >= n && S <= e)) {
                                    var v = (h * _ - l * g) / y;
                                    if ((v >= c && v <= f || v >= f && v <= c) && (v >= i && v <= r || v >= r && v <= i)) return !0
                                }
                                u = p, c = f
                            }
                            return !1
                        }, t.prototype.getPolygon = function (t) {
                            if (null == t) throw new Error("boundingBox cannot be null.");
                            var e = this.boundingBoxes.indexOf(t);
                            return -1 == e ? null : this.polygons[e]
                        }, t.prototype.getWidth = function () {
                            return this.maxX - this.minX
                        }, t.prototype.getHeight = function () {
                            return this.maxY - this.minY
                        }, t
                    }(), e.SkeletonBounds = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t() {
                            this.triangulator = new e.Triangulator, this.clippingPolygon = new Array, this.clipOutput = new Array, this.clippedVertices = new Array, this.clippedTriangles = new Array, this.scratch = new Array
                        }
                        return t.prototype.clipStart = function (i, n) {
                            if (null != this.clipAttachment) return 0;
                            this.clipAttachment = n;
                            var r = n.worldVerticesLength,
                                o = e.Utils.setArraySize(this.clippingPolygon, r);
                            n.computeWorldVertices(i, 0, r, o, 0, 2);
                            var s = this.clippingPolygon;
                            t.makeClockwise(s);
                            for (var a = this.clippingPolygons = this.triangulator.decompose(s, this.triangulator.triangulate(s)), l = 0, h = a.length; l < h; l++) {
                                var u = a[l];
                                t.makeClockwise(u), u.push(u[0]), u.push(u[1])
                            }
                            return a.length
                        }, t.prototype.clipEndWithSlot = function (t) {
                            null != this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd()
                        }, t.prototype.clipEnd = function () {
                            null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0)
                        }, t.prototype.isClipping = function () {
                            return null != this.clipAttachment
                        }, t.prototype.clipTriangles = function (t, i, n, r, o, s, a, l) {
                            var h = this.clipOutput,
                                u = this.clippedVertices,
                                c = this.clippedTriangles,
                                d = this.clippingPolygons,
                                p = this.clippingPolygons.length,
                                f = l ? 12 : 8,
                                g = 0;
                            u.length = 0, c.length = 0;
                            t: for (var m = 0; m < r; m += 3)
                                for (var _ = n[m] << 1, y = t[_], S = t[_ + 1], v = o[_], b = o[_ + 1], T = t[_ = n[m + 1] << 1], P = t[_ + 1], A = o[_], I = o[_ + 1], w = t[_ = n[m + 2] << 1], E = t[_ + 1], C = o[_], x = o[_ + 1], B = 0; B < p; B++) {
                                    var L = u.length;
                                    if (!this.clip(y, S, T, P, w, E, d[B], h)) {
                                        (G = e.Utils.setArraySize(u, L + 3 * f))[L] = y, G[L + 1] = S, G[L + 2] = s.r, G[L + 3] = s.g, G[L + 4] = s.b, G[L + 5] = s.a, l ? (G[L + 6] = v, G[L + 7] = b, G[L + 8] = a.r, G[L + 9] = a.g, G[L + 10] = a.b, G[L + 11] = a.a, G[L + 12] = T, G[L + 13] = P, G[L + 14] = s.r, G[L + 15] = s.g, G[L + 16] = s.b, G[L + 17] = s.a, G[L + 18] = A, G[L + 19] = I, G[L + 20] = a.r, G[L + 21] = a.g, G[L + 22] = a.b, G[L + 23] = a.a, G[L + 24] = w, G[L + 25] = E, G[L + 26] = s.r, G[L + 27] = s.g, G[L + 28] = s.b, G[L + 29] = s.a, G[L + 30] = C, G[L + 31] = x, G[L + 32] = a.r, G[L + 33] = a.g, G[L + 34] = a.b, G[L + 35] = a.a) : (G[L + 6] = v, G[L + 7] = b, G[L + 8] = T, G[L + 9] = P, G[L + 10] = s.r, G[L + 11] = s.g, G[L + 12] = s.b, G[L + 13] = s.a, G[L + 14] = A, G[L + 15] = I, G[L + 16] = w, G[L + 17] = E, G[L + 18] = s.r, G[L + 19] = s.g, G[L + 20] = s.b, G[L + 21] = s.a, G[L + 22] = C, G[L + 23] = x), L = c.length, (q = e.Utils.setArraySize(c, L + 3))[L] = g, q[L + 1] = g + 1, q[L + 2] = g + 2, g += 3;
                                        continue t
                                    }
                                    var O = h.length;
                                    if (0 != O) {
                                        for (var N = P - E, M = w - T, R = y - w, D = E - S, F = 1 / (N * R + M * (S - E)), k = O >> 1, U = this.clipOutput, G = e.Utils.setArraySize(u, L + k * f), W = 0; W < O; W += 2) {
                                            var V = U[W],
                                                X = U[W + 1];
                                            G[L] = V, G[L + 1] = X, G[L + 2] = s.r, G[L + 3] = s.g, G[L + 4] = s.b, G[L + 5] = s.a;
                                            var H = V - w,
                                                Y = X - E,
                                                j = (N * H + M * Y) * F,
                                                z = (D * H + R * Y) * F,
                                                K = 1 - j - z;
                                            G[L + 6] = v * j + A * z + C * K, G[L + 7] = b * j + I * z + x * K, l && (G[L + 8] = a.r, G[L + 9] = a.g, G[L + 10] = a.b, G[L + 11] = a.a), L += f
                                        }
                                        L = c.length;
                                        var q = e.Utils.setArraySize(c, L + 3 * (k - 2));
                                        for (k--, W = 1; W < k; W++) q[L] = g, q[L + 1] = g + W, q[L + 2] = g + W + 1, L += 3;
                                        g += k + 1
                                    }
                                }
                        }, t.prototype.clip = function (t, e, i, n, r, o, s, a) {
                            var l = a,
                                h = !1,
                                u = null;
                            s.length % 4 >= 2 ? (u = a, a = this.scratch) : u = this.scratch, u.length = 0, u.push(t), u.push(e), u.push(i), u.push(n), u.push(r), u.push(o), u.push(t), u.push(e), a.length = 0;
                            for (var c = s, d = s.length - 4, p = 0; ; p += 2) {
                                for (var f = c[p], g = c[p + 1], m = c[p + 2], _ = c[p + 3], y = f - m, S = g - _, v = u, b = u.length - 2, T = a.length, P = 0; P < b; P += 2) {
                                    var A = v[P],
                                        I = v[P + 1],
                                        w = v[P + 2],
                                        E = v[P + 3],
                                        C = y * (E - _) - S * (w - m) > 0;
                                    if (y * (I - _) - S * (A - m) > 0) {
                                        if (C) {
                                            a.push(w), a.push(E);
                                            continue
                                        }
                                        var x = ((L = w - A) * (g - I) - (B = E - I) * (f - A)) / (B * (m - f) - L * (_ - g));
                                        a.push(f + (m - f) * x), a.push(g + (_ - g) * x)
                                    } else if (C) {
                                        var B, L;
                                        x = ((L = w - A) * (g - I) - (B = E - I) * (f - A)) / (B * (m - f) - L * (_ - g)), a.push(f + (m - f) * x), a.push(g + (_ - g) * x), a.push(w), a.push(E)
                                    }
                                    h = !0
                                }
                                if (T == a.length) return l.length = 0, !0;
                                if (a.push(a[0]), a.push(a[1]), p == d) break;
                                var O = a;
                                (a = u).length = 0, u = O
                            }
                            if (l != a) {
                                l.length = 0, p = 0;
                                for (var N = a.length - 2; p < N; p++) l[p] = a[p]
                            } else l.length = l.length - 2;
                            return h
                        }, t.makeClockwise = function (t) {
                            for (var e = t, i = t.length, n = e[i - 2] * e[1] - e[0] * e[i - 1], r = 0, o = 0, s = 0, a = 0, l = i - 3; a < l; a += 2) r = e[a], o = e[a + 1], s = e[a + 2], n += r * e[a + 3] - s * o;
                            if (!(n < 0)) {
                                a = 0;
                                var h = i - 2;
                                for (l = i >> 1; a < l; a += 2) {
                                    var u = e[a],
                                        c = e[a + 1],
                                        d = h - a;
                                    e[a] = e[d], e[a + 1] = e[d + 1], e[d] = u, e[d + 1] = c
                                }
                            }
                        }, t
                    }(), e.SkeletonClipping = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t() {
                            this.bones = new Array, this.slots = new Array, this.skins = new Array, this.events = new Array, this.animations = new Array, this.ikConstraints = new Array, this.transformConstraints = new Array, this.pathConstraints = new Array, this.fps = 0
                        }
                        return t.prototype.findBone = function (t) {
                            if (null == t) throw new Error("boneName cannot be null.");
                            for (var e = this.bones, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findBoneIndex = function (t) {
                            if (null == t) throw new Error("boneName cannot be null.");
                            for (var e = this.bones, i = 0, n = e.length; i < n; i++)
                                if (e[i].name == t) return i;
                            return -1
                        }, t.prototype.findSlot = function (t) {
                            if (null == t) throw new Error("slotName cannot be null.");
                            for (var e = this.slots, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findSlotIndex = function (t) {
                            if (null == t) throw new Error("slotName cannot be null.");
                            for (var e = this.slots, i = 0, n = e.length; i < n; i++)
                                if (e[i].name == t) return i;
                            return -1
                        }, t.prototype.findSkin = function (t) {
                            if (null == t) throw new Error("skinName cannot be null.");
                            for (var e = this.skins, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findEvent = function (t) {
                            if (null == t) throw new Error("eventDataName cannot be null.");
                            for (var e = this.events, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findAnimation = function (t) {
                            if (null == t) throw new Error("animationName cannot be null.");
                            for (var e = this.animations, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findIkConstraint = function (t) {
                            if (null == t) throw new Error("constraintName cannot be null.");
                            for (var e = this.ikConstraints, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findTransformConstraint = function (t) {
                            if (null == t) throw new Error("constraintName cannot be null.");
                            for (var e = this.transformConstraints, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findPathConstraint = function (t) {
                            if (null == t) throw new Error("constraintName cannot be null.");
                            for (var e = this.pathConstraints, i = 0, n = e.length; i < n; i++) {
                                var r = e[i];
                                if (r.name == t) return r
                            }
                            return null
                        }, t.prototype.findPathConstraintIndex = function (t) {
                            if (null == t) throw new Error("pathConstraintName cannot be null.");
                            for (var e = this.pathConstraints, i = 0, n = e.length; i < n; i++)
                                if (e[i].name == t) return i;
                            return -1
                        }, t
                    }(), e.SkeletonData = i
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        t.FAIL_ON_NON_EXISTING_SKIN = !1;
                        var e = function () {
                            function e(t) {
                                this.scale = 1, this.linkedMeshes = new Array, this.attachmentLoader = t
                            }
                            return e.prototype.readSkeletonData = function (i) {
                                var n = this.scale,
                                    r = new t.SkeletonData,
                                    o = "string" == typeof i ? JSON.parse(i) : i,
                                    s = o.skeleton;
                                if (null != s) {
                                    if (r.hash = s.hash, r.version = s.spine, "3.8" !== r.version.substr(0, 3)) {
                                        var a = "PixiJS Spine plugin supports only format for Spine 3.8. Your model has version " + s.spine + ". Please look in pixi-spine repository README for another branch.";
                                        console.error(a)
                                    }
                                    "3.8.75" === r.version && (a = "Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.", console.error(a)), r.x = s.x, r.y = s.y, r.width = s.width, r.height = s.height, r.fps = s.fps, r.imagesPath = s.images
                                }
                                if (o.bones)
                                    for (var l = 0; l < o.bones.length; l++) {
                                        var h = o.bones[l],
                                            u = null,
                                            c = this.getValue(h, "parent", null);
                                        if (null != c && null == (u = r.findBone(c))) throw new Error("Parent bone not found: " + c);
                                        (g = new t.BoneData(r.bones.length, h.name, u)).length = this.getValue(h, "length", 0) * n, g.x = this.getValue(h, "x", 0) * n, g.y = this.getValue(h, "y", 0) * n, g.rotation = this.getValue(h, "rotation", 0), g.scaleX = this.getValue(h, "scaleX", 1), g.scaleY = this.getValue(h, "scaleY", 1), g.shearX = this.getValue(h, "shearX", 0), g.shearY = this.getValue(h, "shearY", 0), g.transformMode = e.transformModeFromString(this.getValue(h, "transform", "normal")), g.skinRequired = this.getValue(h, "skin", !1), r.bones.push(g)
                                    }
                                if (o.slots)
                                    for (l = 0; l < o.slots.length; l++) {
                                        var d = (E = o.slots[l]).name,
                                            p = E.bone,
                                            f = r.findBone(p);
                                        if (null == f) throw new Error("Slot bone not found: " + p);
                                        var g = new t.SlotData(r.slots.length, d, f),
                                            m = this.getValue(E, "color", null);
                                        null != m && g.color.setFromString(m);
                                        var _ = this.getValue(E, "dark", null);
                                        null != _ && (g.darkColor = new t.Color(1, 1, 1, 1), g.darkColor.setFromString(_)), g.attachmentName = this.getValue(E, "attachment", null), g.blendMode = e.blendModeFromString(this.getValue(E, "blend", "normal")), r.slots.push(g)
                                    }
                                if (o.ik)
                                    for (l = 0; l < o.ik.length; l++) {
                                        var y = o.ik[l];
                                        (g = new t.IkConstraintData(y.name)).order = this.getValue(y, "order", 0), g.skinRequired = this.getValue(y, "skin", !1);
                                        for (var S = 0; S < y.bones.length; S++) {
                                            if (p = y.bones[S], null == (A = r.findBone(p))) throw new Error("IK bone not found: " + p);
                                            g.bones.push(A)
                                        }
                                        var v = y.target;
                                        if (g.target = r.findBone(v), null == g.target) throw new Error("IK target bone not found: " + v);
                                        g.mix = this.getValue(y, "mix", 1), g.softness = this.getValue(y, "softness", 0) * n, g.bendDirection = this.getValue(y, "bendPositive", !0) ? 1 : -1, g.compress = this.getValue(y, "compress", !1), g.stretch = this.getValue(y, "stretch", !1), g.uniform = this.getValue(y, "uniform", !1), r.ikConstraints.push(g)
                                    }
                                if (o.transform)
                                    for (l = 0; l < o.transform.length; l++) {
                                        for (y = o.transform[l], (g = new t.TransformConstraintData(y.name)).order = this.getValue(y, "order", 0), g.skinRequired = this.getValue(y, "skin", !1), S = 0; S < y.bones.length; S++) {
                                            if (p = y.bones[S], null == (A = r.findBone(p))) throw new Error("Transform constraint bone not found: " + p);
                                            g.bones.push(A)
                                        }
                                        if (v = y.target, g.target = r.findBone(v), null == g.target) throw new Error("Transform constraint target bone not found: " + v);
                                        g.local = this.getValue(y, "local", !1), g.relative = this.getValue(y, "relative", !1), g.offsetRotation = this.getValue(y, "rotation", 0), g.offsetX = this.getValue(y, "x", 0) * n, g.offsetY = this.getValue(y, "y", 0) * n, g.offsetScaleX = this.getValue(y, "scaleX", 0), g.offsetScaleY = this.getValue(y, "scaleY", 0), g.offsetShearY = this.getValue(y, "shearY", 0), g.rotateMix = this.getValue(y, "rotateMix", 1), g.translateMix = this.getValue(y, "translateMix", 1), g.scaleMix = this.getValue(y, "scaleMix", 1), g.shearMix = this.getValue(y, "shearMix", 1), r.transformConstraints.push(g)
                                    }
                                if (o.path)
                                    for (l = 0; l < o.path.length; l++) {
                                        for (y = o.path[l], (g = new t.PathConstraintData(y.name)).order = this.getValue(y, "order", 0), g.skinRequired = this.getValue(y, "skin", !1), S = 0; S < y.bones.length; S++) {
                                            if (p = y.bones[S], null == (A = r.findBone(p))) throw new Error("Transform constraint bone not found: " + p);
                                            g.bones.push(A)
                                        }
                                        if (v = y.target, g.target = r.findSlot(v), null == g.target) throw new Error("Path target slot not found: " + v);
                                        g.positionMode = e.positionModeFromString(this.getValue(y, "positionMode", "percent")), g.spacingMode = e.spacingModeFromString(this.getValue(y, "spacingMode", "length")), g.rotateMode = e.rotateModeFromString(this.getValue(y, "rotateMode", "tangent")), g.offsetRotation = this.getValue(y, "rotation", 0), g.position = this.getValue(y, "position", 0), g.positionMode == t.PositionMode.Fixed && (g.position *= n), g.spacing = this.getValue(y, "spacing", 0), g.spacingMode != t.SpacingMode.Length && g.spacingMode != t.SpacingMode.Fixed || (g.spacing *= n), g.rotateMix = this.getValue(y, "rotateMix", 1), g.translateMix = this.getValue(y, "translateMix", 1), r.pathConstraints.push(g)
                                    }
                                if (o.skins)
                                    for (l = 0; l < o.skins.length; l++) {
                                        var b = o.skins[l],
                                            T = new t.Skin(b.name);
                                        if (b.bones)
                                            for (var P = 0; P < b.bones.length; P++) {
                                                var A;
                                                if (null == (A = r.findBone(b.bones[P]))) throw new Error("Skin bone not found: " + b.bones[l]);
                                                T.bones.push(A)
                                            }
                                        if (b.ik)
                                            for (P = 0; P < b.ik.length; P++) {
                                                if (null == (I = r.findIkConstraint(b.ik[P]))) throw new Error("Skin IK constraint not found: " + b.ik[l]);
                                                T.constraints.push(I)
                                            }
                                        if (b.transform)
                                            for (P = 0; P < b.transform.length; P++) {
                                                if (null == (I = r.findTransformConstraint(b.transform[P]))) throw new Error("Skin transform constraint not found: " + b.transform[l]);
                                                T.constraints.push(I)
                                            }
                                        if (b.path)
                                            for (P = 0; P < b.path.length; P++) {
                                                var I;
                                                if (null == (I = r.findPathConstraint(b.path[P]))) throw new Error("Skin path constraint not found: " + b.path[l]);
                                                T.constraints.push(I)
                                            }
                                        for (var d in b.attachments) {
                                            var w = r.findSlot(d);
                                            if (null == w) throw new Error("Slot not found: " + d);
                                            var E = b.attachments[d];
                                            for (var C in E) {
                                                var x = this.readAttachment(E[C], T, w.index, C, r);
                                                null != x && T.setAttachment(w.index, C, x)
                                            }
                                        }
                                        r.skins.push(T), "default" == T.name && (r.defaultSkin = T)
                                    }
                                l = 0;
                                for (var B = this.linkedMeshes.length; l < B; l++) {
                                    var L = this.linkedMeshes[l];
                                    if (null == (T = null == L.skin ? r.defaultSkin : r.findSkin(L.skin))) throw new Error("Skin not found: " + L.skin);
                                    var O = T.getAttachment(L.slotIndex, L.parent);
                                    if (null == O) throw new Error("Parent mesh not found: " + L.parent);
                                    L.mesh.deformAttachment = L.inheritDeform ? O : L.mesh, L.mesh.setParentMesh(O)
                                }
                                if (this.linkedMeshes.length = 0, o.events)
                                    for (var N in o.events) {
                                        var M = o.events[N];
                                        (g = new t.EventData(N)).intValue = this.getValue(M, "int", 0), g.floatValue = this.getValue(M, "float", 0), g.stringValue = this.getValue(M, "string", ""), g.audioPath = this.getValue(M, "audio", null), null != g.audioPath && (g.volume = this.getValue(M, "volume", 1), g.balance = this.getValue(M, "balance", 0)), r.events.push(g)
                                    }
                                if (o.animations)
                                    for (var R in o.animations) {
                                        var D = o.animations[R];
                                        this.readAnimation(D, R, r)
                                    }
                                return r
                            }, e.prototype.readAttachment = function (e, n, r, o, s) {
                                var a = this.scale;
                                switch (o = this.getValue(e, "name", o), this.getValue(e, "type", "region")) {
                                    case "region":
                                        var l = this.getValue(e, "path", o),
                                            h = this.attachmentLoader.newRegionAttachment(n, o, l);
                                        return null == h ? null : (h.path = l, h.x = this.getValue(e, "x", 0) * a, h.y = this.getValue(e, "y", 0) * a, h.scaleX = this.getValue(e, "scaleX", 1), h.scaleY = this.getValue(e, "scaleY", 1), h.rotation = this.getValue(e, "rotation", 0), h.width = e.width * a, h.height = e.height * a, null != (S = this.getValue(e, "color", null)) && h.color.setFromString(S), h);
                                    case "boundingbox":
                                        var u = this.attachmentLoader.newBoundingBoxAttachment(n, o);
                                        return null == u ? null : (this.readVertices(e, u, e.vertexCount << 1), null != (S = this.getValue(e, "color", null)) && u.color.setFromString(S), u);
                                    case "mesh":
                                    case "linkedmesh":
                                        l = this.getValue(e, "path", o);
                                        var c = this.attachmentLoader.newMeshAttachment(n, o, l);
                                        if (null == c) return null;
                                        c.path = l, null != (S = this.getValue(e, "color", null)) && c.color.setFromString(S), c.width = this.getValue(e, "width", 0) * a, c.height = this.getValue(e, "height", 0) * a;
                                        var d = this.getValue(e, "parent", null);
                                        if (null != d) return this.linkedMeshes.push(new i(c, this.getValue(e, "skin", null), r, d, this.getValue(e, "deform", !0))), c;
                                        var p = e.uvs;
                                        return this.readVertices(e, c, p.length), c.triangles = e.triangles, c.regionUVs = new Float32Array(p), c.edges = this.getValue(e, "edges", null), c.hullLength = 2 * this.getValue(e, "hull", 0), c;
                                    case "path":
                                        if (null == (l = this.attachmentLoader.newPathAttachment(n, o))) return null;
                                        l.closed = this.getValue(e, "closed", !1), l.constantSpeed = this.getValue(e, "constantSpeed", !0);
                                        var f = e.vertexCount;
                                        this.readVertices(e, l, f << 1);
                                        for (var g = t.Utils.newArray(f / 3, 0), m = 0; m < e.lengths.length; m++) g[m] = e.lengths[m] * a;
                                        return l.lengths = g, null != (S = this.getValue(e, "color", null)) && l.color.setFromString(S), l;
                                    case "point":
                                        var _ = this.attachmentLoader.newPointAttachment(n, o);
                                        return null == _ ? null : (_.x = this.getValue(e, "x", 0) * a, _.y = this.getValue(e, "y", 0) * a, _.rotation = this.getValue(e, "rotation", 0), null != (S = this.getValue(e, "color", null)) && _.color.setFromString(S), _);
                                    case "clipping":
                                        var y = this.attachmentLoader.newClippingAttachment(n, o);
                                        if (null == y) return null;
                                        var S, v = this.getValue(e, "end", null);
                                        if (null != v) {
                                            var b = s.findSlot(v);
                                            if (null == b) throw new Error("Clipping end slot not found: " + v);
                                            y.endSlot = b
                                        }
                                        return f = e.vertexCount, this.readVertices(e, y, f << 1), null != (S = this.getValue(e, "color", null)) && y.color.setFromString(S), y
                                }
                                return null
                            }, e.prototype.readVertices = function (e, i, n) {
                                var r = this.scale;
                                i.worldVerticesLength = n;
                                var o = e.vertices;
                                if (n != o.length) {
                                    var s = new Array,
                                        a = new Array;
                                    for (c = 0, d = o.length; c < d;) {
                                        var l = o[c++];
                                        a.push(l);
                                        for (var h = c + 4 * l; c < h; c += 4) a.push(o[c]), s.push(o[c + 1] * r), s.push(o[c + 2] * r), s.push(o[c + 3])
                                    }
                                    i.bones = a, i.vertices = t.Utils.toFloatArray(s)
                                } else {
                                    var u = t.Utils.toFloatArray(o);
                                    if (1 != r)
                                        for (var c = 0, d = o.length; c < d; c++) u[c] *= r;
                                    i.vertices = u
                                }
                            }, e.prototype.readAnimation = function (e, i, n) {
                                var r = this.scale,
                                    o = new Array,
                                    s = 0;
                                if (e.slots)
                                    for (var a in e.slots) {
                                        var l = e.slots[a];
                                        if (-1 == (Z = n.findSlotIndex(a))) throw new Error("Slot not found: " + a);
                                        for (var h in l) {
                                            var u = l[h];
                                            if ("attachment" == h) {
                                                (v = new t.AttachmentTimeline(u.length)).slotIndex = Z;
                                                for (var c = 0, d = 0; d < u.length; d++) {
                                                    var p = u[d];
                                                    v.setFrame(c++, this.getValue(p, "time", 0), p.name)
                                                }
                                                o.push(v), s = Math.max(s, v.frames[v.getFrameCount() - 1])
                                            } else if ("color" == h) {
                                                for ((v = new t.ColorTimeline(u.length)).slotIndex = Z, c = 0, d = 0; d < u.length; d++) {
                                                    p = u[d];
                                                    var f = new t.Color;
                                                    f.setFromString(p.color || "ffffffff"), v.setFrame(c, this.getValue(p, "time", 0), f.r, f.g, f.b, f.a), this.readCurve(p, v, c), c++
                                                }
                                                o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.ColorTimeline.ENTRIES])
                                            } else {
                                                if ("twoColor" != h) throw new Error("Invalid timeline type for a slot: " + h + " (" + a + ")");
                                                for ((v = new t.TwoColorTimeline(u.length)).slotIndex = Z, c = 0, d = 0; d < u.length; d++) {
                                                    p = u[d];
                                                    var g = new t.Color,
                                                        m = new t.Color;
                                                    g.setFromString(p.light), m.setFromString(p.dark), v.setFrame(c, this.getValue(p, "time", 0), g.r, g.g, g.b, g.a, m.r, m.g, m.b), this.readCurve(p, v, c), c++
                                                }
                                                o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.TwoColorTimeline.ENTRIES])
                                            }
                                        }
                                    }
                                if (e.bones)
                                    for (var _ in e.bones) {
                                        var y = e.bones[_],
                                            S = n.findBoneIndex(_);
                                        if (-1 == S) throw new Error("Bone not found: " + _);
                                        for (var h in y)
                                            if (u = y[h], "rotate" === h) {
                                                for ((v = new t.RotateTimeline(u.length)).boneIndex = S, c = 0, d = 0; d < u.length; d++) p = u[d], v.setFrame(c, this.getValue(p, "time", 0), this.getValue(p, "angle", 0)), this.readCurve(p, v, c), c++;
                                                o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.RotateTimeline.ENTRIES])
                                            } else {
                                                if ("translate" !== h && "scale" !== h && "shear" !== h) throw new Error("Invalid timeline type for a bone: " + h + " (" + _ + ")");
                                                var v = null,
                                                    b = 1,
                                                    T = 0;
                                                for ("scale" === h ? (v = new t.ScaleTimeline(u.length), T = 1) : "shear" === h ? v = new t.ShearTimeline(u.length) : (v = new t.TranslateTimeline(u.length), b = r), v.boneIndex = S, c = 0, d = 0; d < u.length; d++) {
                                                    p = u[d];
                                                    var P = this.getValue(p, "x", T),
                                                        A = this.getValue(p, "y", T);
                                                    v.setFrame(c, this.getValue(p, "time", 0), P * b, A * b), this.readCurve(p, v, c), c++
                                                }
                                                o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.TranslateTimeline.ENTRIES])
                                            }
                                    }
                                if (e.ik)
                                    for (var I in e.ik) {
                                        var w = e.ik[I],
                                            E = n.findIkConstraint(I);
                                        for ((v = new t.IkConstraintTimeline(w.length)).ikConstraintIndex = n.ikConstraints.indexOf(E), c = 0, d = 0; d < w.length; d++) p = w[d], v.setFrame(c, this.getValue(p, "time", 0), this.getValue(p, "mix", 1), this.getValue(p, "softness", 0) * r, this.getValue(p, "bendPositive", !0) ? 1 : -1, this.getValue(p, "compress", !1), this.getValue(p, "stretch", !1)), this.readCurve(p, v, c), c++;
                                        o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.IkConstraintTimeline.ENTRIES])
                                    }
                                if (e.transform)
                                    for (var I in e.transform) {
                                        for (w = e.transform[I], E = n.findTransformConstraint(I), (v = new t.TransformConstraintTimeline(w.length)).transformConstraintIndex = n.transformConstraints.indexOf(E), c = 0, d = 0; d < w.length; d++) p = w[d], v.setFrame(c, this.getValue(p, "time", 0), this.getValue(p, "rotateMix", 1), this.getValue(p, "translateMix", 1), this.getValue(p, "scaleMix", 1), this.getValue(p, "shearMix", 1)), this.readCurve(p, v, c), c++;
                                        o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.TransformConstraintTimeline.ENTRIES])
                                    }
                                if (e.path)
                                    for (var I in e.path) {
                                        w = e.path[I];
                                        var C = n.findPathConstraintIndex(I);
                                        if (-1 == C) throw new Error("Path constraint not found: " + I);
                                        var x = n.pathConstraints[C];
                                        for (var h in w)
                                            if (u = w[h], "position" === h || "spacing" === h) {
                                                for (v = null, b = 1, "spacing" === h ? (v = new t.PathConstraintSpacingTimeline(u.length), x.spacingMode != t.SpacingMode.Length && x.spacingMode != t.SpacingMode.Fixed || (b = r)) : (v = new t.PathConstraintPositionTimeline(u.length), x.positionMode == t.PositionMode.Fixed && (b = r)), v.pathConstraintIndex = C, c = 0, d = 0; d < u.length; d++) p = u[d], v.setFrame(c, this.getValue(p, "time", 0), this.getValue(p, h, 0) * b), this.readCurve(p, v, c), c++;
                                                o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.PathConstraintPositionTimeline.ENTRIES])
                                            } else if ("mix" === h) {
                                                for ((v = new t.PathConstraintMixTimeline(u.length)).pathConstraintIndex = C, c = 0, d = 0; d < u.length; d++) p = u[d], v.setFrame(c, this.getValue(p, "time", 0), this.getValue(p, "rotateMix", 1), this.getValue(p, "translateMix", 1)), this.readCurve(p, v, c), c++;
                                                o.push(v), s = Math.max(s, v.frames[(v.getFrameCount() - 1) * t.PathConstraintMixTimeline.ENTRIES])
                                            }
                                    }
                                if (e.deform)
                                    for (var B in e.deform) {
                                        var L = e.deform[B],
                                            O = n.findSkin(B);
                                        if (null != O)
                                            for (var a in L) {
                                                if (l = L[a], -1 == (Z = n.findSlotIndex(a))) throw new Error("Slot not found: " + l.name);
                                                for (var h in l) {
                                                    u = l[h];
                                                    var N = O.getAttachment(Z, h);
                                                    if (null == N) throw new Error("Deform attachment not found: " + u.name);
                                                    var M = null != N.bones,
                                                        R = N.vertices,
                                                        D = M ? R.length / 3 * 2 : R.length;
                                                    (v = new t.DeformTimeline(u.length)).slotIndex = Z, v.attachment = N, c = 0;
                                                    for (var F = 0; F < u.length; F++) {
                                                        p = u[F];
                                                        var k = void 0,
                                                            U = this.getValue(p, "vertices", null);
                                                        if (null == U) k = M ? t.Utils.newFloatArray(D) : R;
                                                        else {
                                                            k = t.Utils.newFloatArray(D);
                                                            var G = this.getValue(p, "offset", 0);
                                                            if (t.Utils.arrayCopy(U, 0, k, G, U.length), 1 != r)
                                                                for (var W = (d = G) + U.length; d < W; d++) k[d] *= r;
                                                            if (!M)
                                                                for (d = 0; d < D; d++) k[d] += R[d]
                                                        }
                                                        v.setFrame(c, this.getValue(p, "time", 0), k), this.readCurve(p, v, c), c++
                                                    }
                                                    o.push(v), s = Math.max(s, v.frames[v.getFrameCount() - 1])
                                                }
                                            } else if (t.FAIL_ON_NON_EXISTING_SKIN) throw new Error("Skin not found: " + B)
                                    }
                                var V = e.drawOrder;
                                if (null == V && (V = e.draworder), null != V) {
                                    v = new t.DrawOrderTimeline(V.length);
                                    var X = n.slots.length;
                                    for (c = 0, F = 0; F < V.length; F++) {
                                        var H = V[F],
                                            Y = null,
                                            j = this.getValue(H, "offsets", null);
                                        if (null != j) {
                                            Y = t.Utils.newArray(X, -1);
                                            var z = t.Utils.newArray(X - j.length, 0),
                                                K = 0,
                                                q = 0;
                                            for (d = 0; d < j.length; d++) {
                                                var Z, $ = j[d];
                                                if (-1 == (Z = n.findSlotIndex($.slot))) throw new Error("Slot not found: " + $.slot);
                                                for (; K != Z;) z[q++] = K++;
                                                Y[K + $.offset] = K++
                                            }
                                            for (; K < X;) z[q++] = K++;
                                            for (d = X - 1; d >= 0; d--) - 1 == Y[d] && (Y[d] = z[--q])
                                        }
                                        v.setFrame(c++, this.getValue(H, "time", 0), Y)
                                    }
                                    o.push(v), s = Math.max(s, v.frames[v.getFrameCount() - 1])
                                }
                                if (e.events) {
                                    for (v = new t.EventTimeline(e.events.length), c = 0, d = 0; d < e.events.length; d++) {
                                        var J = e.events[d],
                                            Q = n.findEvent(J.name);
                                        if (null == Q) throw new Error("Event not found: " + J.name);
                                        var tt = new t.Event(t.Utils.toSinglePrecision(this.getValue(J, "time", 0)), Q);
                                        tt.intValue = this.getValue(J, "int", Q.intValue), tt.floatValue = this.getValue(J, "float", Q.floatValue), tt.stringValue = this.getValue(J, "string", Q.stringValue), null != tt.data.audioPath && (tt.volume = this.getValue(J, "volume", 1), tt.balance = this.getValue(J, "balance", 0)), v.setFrame(c++, tt)
                                    }
                                    o.push(v), s = Math.max(s, v.frames[v.getFrameCount() - 1])
                                }
                                if (isNaN(s)) throw new Error("Error while parsing animation, duration is NaN");
                                n.animations.push(new t.Animation(i, o, s))
                            }, e.prototype.readCurve = function (t, e, i) {
                                if (t.hasOwnProperty("curve"))
                                    if ("stepped" === t.curve) e.setStepped(i);
                                    else {
                                        var n = t.curve;
                                        e.setCurve(i, n, this.getValue(t, "c2", 0), this.getValue(t, "c3", 1), this.getValue(t, "c4", 1))
                                    }
                            }, e.prototype.getValue = function (t, e, i) {
                                return void 0 !== t[e] ? t[e] : i
                            }, e.blendModeFromString = function (e) {
                                if ("normal" == (e = e.toLowerCase())) return t.BlendMode.Normal;
                                if ("additive" == e) return t.BlendMode.Additive;
                                if ("multiply" == e) return t.BlendMode.Multiply;
                                if ("screen" == e) return t.BlendMode.Screen;
                                throw new Error("Unknown blend mode: " + e)
                            }, e.positionModeFromString = function (e) {
                                if ("fixed" == (e = e.toLowerCase())) return t.PositionMode.Fixed;
                                if ("percent" == e) return t.PositionMode.Percent;
                                throw new Error("Unknown position mode: " + e)
                            }, e.spacingModeFromString = function (e) {
                                if ("length" == (e = e.toLowerCase())) return t.SpacingMode.Length;
                                if ("fixed" == e) return t.SpacingMode.Fixed;
                                if ("percent" == e) return t.SpacingMode.Percent;
                                throw new Error("Unknown position mode: " + e)
                            }, e.rotateModeFromString = function (e) {
                                if ("tangent" == (e = e.toLowerCase())) return t.RotateMode.Tangent;
                                if ("chain" == e) return t.RotateMode.Chain;
                                if ("chainscale" == e) return t.RotateMode.ChainScale;
                                throw new Error("Unknown rotate mode: " + e)
                            }, e.transformModeFromString = function (e) {
                                if ("normal" == (e = e.toLowerCase())) return t.TransformMode.Normal;
                                if ("onlytranslation" == e) return t.TransformMode.OnlyTranslation;
                                if ("norotationorreflection" == e) return t.TransformMode.NoRotationOrReflection;
                                if ("noscale" == e) return t.TransformMode.NoScale;
                                if ("noscaleorreflection" == e) return t.TransformMode.NoScaleOrReflection;
                                throw new Error("Unknown transform mode: " + e)
                            }, e
                        }();
                        t.SkeletonJson = e;
                        var i = function (t, e, i, n, r) {
                            this.mesh = t, this.skin = e, this.slotIndex = i, this.parent = n, this.inheritDeform = r
                        }
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e = function (t, e, i) {
                            this.slotIndex = t, this.name = e, this.attachment = i
                        };
                        t.SkinEntry = e;
                        var i = function () {
                            function i(t) {
                                if (this.attachments = new Array, this.bones = Array(), this.constraints = new Array, null == t) throw new Error("name cannot be null.");
                                this.name = t
                            }
                            return i.prototype.setAttachment = function (t, e, i) {
                                if (null == i) throw new Error("attachment cannot be null.");
                                var n = this.attachments;
                                t >= n.length && (n.length = t + 1), n[t] || (n[t] = {}), n[t][e] = i
                            }, i.prototype.addSkin = function (t) {
                                for (var e = 0; e < t.bones.length; e++) {
                                    for (var i = t.bones[e], n = !1, r = 0; r < this.bones.length; r++)
                                        if (this.bones[r] == i) {
                                            n = !0;
                                            break
                                        } n || this.bones.push(i)
                                }
                                for (e = 0; e < t.constraints.length; e++) {
                                    var o = t.constraints[e];
                                    for (n = !1, r = 0; r < this.constraints.length; r++)
                                        if (this.constraints[r] == o) {
                                            n = !0;
                                            break
                                        } n || this.constraints.push(o)
                                }
                                var s = t.getAttachments();
                                for (e = 0; e < s.length; e++) {
                                    var a = s[e];
                                    this.setAttachment(a.slotIndex, a.name, a.attachment)
                                }
                            }, i.prototype.copySkin = function (e) {
                                for (var i = 0; i < e.bones.length; i++) {
                                    for (var n = e.bones[i], r = !1, o = 0; o < this.bones.length; o++)
                                        if (this.bones[o] == n) {
                                            r = !0;
                                            break
                                        } r || this.bones.push(n)
                                }
                                for (i = 0; i < e.constraints.length; i++) {
                                    var s = e.constraints[i];
                                    for (r = !1, o = 0; o < this.constraints.length; o++)
                                        if (this.constraints[o] == s) {
                                            r = !0;
                                            break
                                        } r || this.constraints.push(s)
                                }
                                var a = e.getAttachments();
                                for (i = 0; i < a.length; i++) {
                                    var l = a[i];
                                    null != l.attachment && (l.attachment instanceof t.MeshAttachment ? (l.attachment = l.attachment.newLinkedMesh(), this.setAttachment(l.slotIndex, l.name, l.attachment)) : (l.attachment = l.attachment.copy(), this.setAttachment(l.slotIndex, l.name, l.attachment)))
                                }
                            }, i.prototype.getAttachment = function (t, e) {
                                var i = this.attachments[t];
                                return i ? i[e] : null
                            }, i.prototype.removeAttachment = function (t, e) {
                                var i = this.attachments[t];
                                i && (i[e] = null)
                            }, i.prototype.getAttachments = function () {
                                for (var t = new Array, i = 0; i < this.attachments.length; i++) {
                                    var n = this.attachments[i];
                                    if (n)
                                        for (var r in n) {
                                            var o = n[r];
                                            o && t.push(new e(i, r, o))
                                        }
                                }
                                return t
                            }, i.prototype.getAttachmentsForSlot = function (t, i) {
                                var n = this.attachments[t];
                                if (n)
                                    for (var r in n) {
                                        var o = n[r];
                                        o && i.push(new e(t, r, o))
                                    }
                            }, i.prototype.clear = function () {
                                this.attachments.length = 0, this.bones.length = 0, this.constraints.length = 0
                            }, i.prototype.attachAll = function (t, e) {
                                for (var i = 0, n = 0; n < t.slots.length; n++) {
                                    var r = t.slots[n],
                                        o = r.getAttachment();
                                    if (o && i < e.attachments.length) {
                                        var s = e.attachments[i];
                                        for (var a in s)
                                            if (o == s[a]) {
                                                var l = this.getAttachment(i, a);
                                                null != l && r.setAttachment(l);
                                                break
                                            }
                                    }
                                    i++
                                }
                            }, i
                        }();
                        t.Skin = i
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t, i) {
                            if (this.deform = new Array, null == t) throw new Error("data cannot be null.");
                            if (null == i) throw new Error("bone cannot be null.");
                            this.data = t, this.bone = i, this.color = new e.Color, this.darkColor = null == t.darkColor ? null : new e.Color, this.setToSetupPose(), this.blendMode = this.data.blendMode
                        }
                        return t.prototype.getAttachment = function () {
                            return this.attachment
                        }, t.prototype.setAttachment = function (t) {
                            this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.deform.length = 0)
                        }, t.prototype.setAttachmentTime = function (t) {
                            this.attachmentTime = this.bone.skeleton.time - t
                        }, t.prototype.getAttachmentTime = function () {
                            return this.bone.skeleton.time - this.attachmentTime
                        }, t.prototype.setToSetupPose = function () {
                            this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName)))
                        }, t
                    }(), e.Slot = i
                }(i || (i = {})),
                function (t) {
                    var e;
                    (e = t.core || (t.core = {})).SlotData = function (t, i, n) {
                        if (this.color = new e.Color(1, 1, 1, 1), t < 0) throw new Error("index must be >= 0.");
                        if (null == i) throw new Error("name cannot be null.");
                        if (null == n) throw new Error("boneData cannot be null.");
                        this.index = t, this.name = i, this.boneData = n
                    }
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e, i, n = function () {
                            function t(t) {
                                this._image = t
                            }
                            return t.prototype.getImage = function () {
                                return this._image
                            }, t.filterFromString = function (t) {
                                switch (t.toLowerCase()) {
                                    case "nearest":
                                        return e.Nearest;
                                    case "linear":
                                        return e.Linear;
                                    case "mipmap":
                                        return e.MipMap;
                                    case "mipmapnearestnearest":
                                        return e.MipMapNearestNearest;
                                    case "mipmaplinearnearest":
                                        return e.MipMapLinearNearest;
                                    case "mipmapnearestlinear":
                                        return e.MipMapNearestLinear;
                                    case "mipmaplinearlinear":
                                        return e.MipMapLinearLinear;
                                    default:
                                        throw new Error("Unknown texture filter " + t)
                                }
                            }, t.wrapFromString = function (t) {
                                switch (t.toLowerCase()) {
                                    case "mirroredtepeat":
                                        return i.MirroredRepeat;
                                    case "clamptoedge":
                                        return i.ClampToEdge;
                                    case "repeat":
                                        return i.Repeat;
                                    default:
                                        throw new Error("Unknown texture wrap " + t)
                                }
                            }, t
                        }();
                        t.Texture = n,
                            function (t) {
                                t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear"
                            }(e = t.TextureFilter || (t.TextureFilter = {})),
                            function (t) {
                                t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat"
                            }(i = t.TextureWrap || (t.TextureWrap = {}));
                        var r = function () {
                            function t() {
                                this.size = null
                            }
                            return Object.defineProperty(t.prototype, "width", {
                                get: function () {
                                    var t = this.texture;
                                    return "3" == PIXI.VERSION[0] ? t.crop.width : t.trim ? t.trim.width : t.orig.width
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "height", {
                                get: function () {
                                    var t = this.texture;
                                    return "3" == PIXI.VERSION[0] ? t.crop.height : t.trim ? t.trim.height : t.orig.height
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "u", {
                                get: function () {
                                    return this.texture._uvs.x0
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "v", {
                                get: function () {
                                    return this.texture._uvs.y0
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "u2", {
                                get: function () {
                                    return this.texture._uvs.x2
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "v2", {
                                get: function () {
                                    return this.texture._uvs.y2
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "offsetX", {
                                get: function () {
                                    var t = this.texture;
                                    return t.trim ? t.trim.x : 0
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "offsetY", {
                                get: function () {
                                    return console.warn("Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on."), this.spineOffsetY
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "pixiOffsetY", {
                                get: function () {
                                    var t = this.texture;
                                    return t.trim ? t.trim.y : 0
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "spineOffsetY", {
                                get: function () {
                                    var t = this.texture;
                                    return this.originalHeight - this.height - (t.trim ? t.trim.y : 0)
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "originalWidth", {
                                get: function () {
                                    var t = this.texture;
                                    return "3" == PIXI.VERSION[0] ? t.trim ? t.trim.width : t.crop.width : t.orig.width
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "originalHeight", {
                                get: function () {
                                    var t = this.texture;
                                    return "3" == PIXI.VERSION[0] ? t.trim ? t.trim.height : t.crop.height : t.orig.height
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "x", {
                                get: function () {
                                    return this.texture.frame.x
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "y", {
                                get: function () {
                                    return this.texture.frame.y
                                },
                                enumerable: !1,
                                configurable: !0
                            }), Object.defineProperty(t.prototype, "rotate", {
                                get: function () {
                                    return 0 !== this.texture.rotate
                                },
                                enumerable: !1,
                                configurable: !0
                            }), t
                        }();
                        t.TextureRegion = r
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e = function () {
                            function e(t, e, i) {
                                this.pages = new Array, this.regions = new Array, t && this.addSpineAtlas(t, e, i)
                            }
                            return e.prototype.addTexture = function (e, i) {
                                for (var n = this.pages, s = null, a = 0; a < n.length; a++)
                                    if (n[a].baseTexture === i.baseTexture) {
                                        s = n[a];
                                        break
                                    } if (null === s) {
                                        (s = new r).name = "texturePage";
                                        var l = i.baseTexture;
                                        s.width = l.realWidth, s.height = l.realHeight, s.baseTexture = l, s.minFilter = s.magFilter = t.TextureFilter.Nearest, s.uWrap = t.TextureWrap.ClampToEdge, s.vWrap = t.TextureWrap.ClampToEdge, n.push(s)
                                    }
                                var h = new o;
                                return h.name = e, h.page = s, h.texture = i, h.index = -1, this.regions.push(h), h
                            }, e.prototype.addTextureHash = function (t, e) {
                                for (var i in t) t.hasOwnProperty(i) && this.addTexture(e && -1 !== i.indexOf(".") ? i.substr(0, i.lastIndexOf(".")) : i, t[i])
                            }, e.prototype.addSpineAtlas = function (t, e, i) {
                                return this.load(t, e, i)
                            }, e.prototype.load = function (e, n, s) {
                                var a = this;
                                if (null == n) throw new Error("textureLoader cannot be null.");
                                var l = new i(e),
                                    h = new Array(4),
                                    u = null,
                                    c = function () {
                                        for (; ;) {
                                            var e = l.readLine();
                                            if (null == e) return s && s(a);
                                            if (0 == (e = e.trim()).length) u = null;
                                            else {
                                                if (!u) {
                                                    (u = new r).name = e, 2 == l.readTuple(h) && (u.width = parseInt(h[0]), u.height = parseInt(h[1]), l.readTuple(h)), l.readTuple(h), u.minFilter = t.Texture.filterFromString(h[0]), u.magFilter = t.Texture.filterFromString(h[1]);
                                                    var i = l.readValue();
                                                    u.uWrap = t.TextureWrap.ClampToEdge, u.vWrap = t.TextureWrap.ClampToEdge, "x" == i ? u.uWrap = t.TextureWrap.Repeat : "y" == i ? u.vWrap = t.TextureWrap.Repeat : "xy" == i && (u.uWrap = u.vWrap = t.TextureWrap.Repeat), n(e, (function (t) {
                                                        if (null === t) return a.pages.splice(a.pages.indexOf(u), 1), s && s(null);
                                                        u.baseTexture = t, t.valid || t.setSize(u.width, u.height), a.pages.push(u), u.setFilters(), u.width && u.height || (u.width = t.realWidth, u.height = t.realHeight, u.width && u.height || console.log("ERROR spine atlas page " + u.name + ": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)")), c()
                                                    })), a.pages.push(u);
                                                    break
                                                }
                                                var d = new o;
                                                d.name = e, d.page = u;
                                                var p, f = l.readValue();
                                                p = "true" == f.toLocaleLowerCase() ? 6 : "false" == f.toLocaleLowerCase() ? 0 : (720 - parseFloat(f)) % 360 / 45, l.readTuple(h);
                                                var g = parseInt(h[0]),
                                                    m = parseInt(h[1]);
                                                l.readTuple(h);
                                                var _ = parseInt(h[0]),
                                                    y = parseInt(h[1]),
                                                    S = u.baseTexture.resolution;
                                                g /= S, m /= S, _ /= S, y /= S;
                                                var v = p % 4 != 0,
                                                    b = new PIXI.Rectangle(g, m, v ? y : _, v ? _ : y);
                                                4 == l.readTuple(h) && 4 == l.readTuple(h) && l.readTuple(h);
                                                var T = parseInt(h[0]) / S,
                                                    P = parseInt(h[1]) / S;
                                                l.readTuple(h);
                                                var A = parseInt(h[0]) / S,
                                                    I = parseInt(h[1]) / S,
                                                    w = new PIXI.Rectangle(0, 0, T, P),
                                                    E = new PIXI.Rectangle(A, P - y - I, _, y);
                                                if ("3" != PIXI.VERSION[0]) d.texture = new PIXI.Texture(d.page.baseTexture, b, w, E, p);
                                                else {
                                                    var C = new PIXI.Rectangle(g, m, _, y),
                                                        x = C.clone();
                                                    E.width = T, E.height = P, d.texture = new PIXI.Texture(d.page.baseTexture, C, x, E, p)
                                                }
                                                d.index = parseInt(l.readValue()), d.texture.updateUvs(), a.regions.push(d)
                                            }
                                        }
                                    };
                                c()
                            }, e.prototype.findRegion = function (t) {
                                for (var e = 0; e < this.regions.length; e++)
                                    if (this.regions[e].name == t) return this.regions[e];
                                return null
                            }, e.prototype.dispose = function () {
                                for (var t = 0; t < this.pages.length; t++) this.pages[t].baseTexture.dispose()
                            }, e
                        }();
                        t.TextureAtlas = e;
                        var i = function () {
                            function t(t) {
                                this.index = 0, this.lines = t.split(/\r\n|\r|\n/)
                            }
                            return t.prototype.readLine = function () {
                                return this.index >= this.lines.length ? null : this.lines[this.index++]
                            }, t.prototype.readValue = function () {
                                var t = this.readLine(),
                                    e = t.indexOf(":");
                                if (-1 == e) throw new Error("Invalid line: " + t);
                                return t.substring(e + 1).trim()
                            }, t.prototype.readTuple = function (t) {
                                var e = this.readLine(),
                                    i = e.indexOf(":");
                                if (-1 == i) throw new Error("Invalid line: " + e);
                                for (var n = 0, r = i + 1; n < 3; n++) {
                                    var o = e.indexOf(",", r);
                                    if (-1 == o) break;
                                    t[n] = e.substr(r, o - r).trim(), r = o + 1
                                }
                                return t[n] = e.substring(r).trim(), n + 1
                            }, t
                        }(),
                            r = function () {
                                function e() { }
                                return e.prototype.setFilters = function () {
                                    var e = this.baseTexture,
                                        i = this.minFilter;
                                    i == t.TextureFilter.Linear ? e.scaleMode = PIXI.SCALE_MODES.LINEAR : this.minFilter == t.TextureFilter.Nearest ? e.scaleMode = PIXI.SCALE_MODES.NEAREST : (e.mipmap = PIXI.MIPMAP_MODES.POW2, i == t.TextureFilter.MipMapNearestNearest ? e.scaleMode = PIXI.SCALE_MODES.NEAREST : e.scaleMode = PIXI.SCALE_MODES.LINEAR)
                                }, e
                            }();
                        t.TextureAtlasPage = r;
                        var o = function (t) {
                            function e() {
                                return null !== t && t.apply(this, arguments) || this
                            }
                            return n(e, t), e
                        }(t.TextureRegion);
                        t.TextureAtlasRegion = o
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t, i) {
                            if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new e.Vector2, this.active = !1, null == t) throw new Error("data cannot be null.");
                            if (null == i) throw new Error("skeleton cannot be null.");
                            this.data = t, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix, this.scaleMix = t.scaleMix, this.shearMix = t.shearMix, this.bones = new Array;
                            for (var n = 0; n < t.bones.length; n++) this.bones.push(i.findBone(t.bones[n].name));
                            this.target = i.findBone(t.target.name)
                        }
                        return t.prototype.isActive = function () {
                            return this.active
                        }, t.prototype.apply = function () {
                            this.update()
                        }, t.prototype.update = function () {
                            this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld()
                        }, t.prototype.applyAbsoluteWorld = function () {
                            for (var t = this.rotateMix, i = this.translateMix, n = this.scaleMix, r = this.shearMix, o = this.target, s = o.matrix, a = s.a, l = s.c, h = s.b, u = s.d, c = a * u - l * h > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad, d = this.data.offsetRotation * c, p = this.data.offsetShearY * c, f = this.bones, g = 0, m = f.length; g < m; g++) {
                                var _ = f[g],
                                    y = !1,
                                    S = _.matrix;
                                if (0 != t) {
                                    var v = S.a,
                                        b = S.c,
                                        T = S.b,
                                        P = S.d;
                                    (x = Math.atan2(h, a) - Math.atan2(T, v) + d) > e.MathUtils.PI ? x -= e.MathUtils.PI2 : x < -e.MathUtils.PI && (x += e.MathUtils.PI2), x *= t;
                                    var A = Math.cos(x),
                                        I = Math.sin(x);
                                    S.a = A * v - I * T, S.c = A * b - I * P, S.b = I * v + A * T, S.d = I * b + A * P, y = !0
                                }
                                if (0 != i) {
                                    var w = this.temp;
                                    o.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), S.tx += (w.x - S.tx) * i, S.ty += (w.y - S.ty) * i, y = !0
                                }
                                if (n > 0) {
                                    var E = Math.sqrt(S.a * S.a + S.b * S.b),
                                        C = Math.sqrt(a * a + h * h);
                                    E > 1e-5 && (E = (E + (C - E + this.data.offsetScaleX) * n) / E), S.a *= E, S.b *= E, E = Math.sqrt(S.c * S.c + S.d * S.d), C = Math.sqrt(l * l + u * u), E > 1e-5 && (E = (E + (C - E + this.data.offsetScaleY) * n) / E), S.c *= E, S.d *= E, y = !0
                                }
                                if (r > 0) {
                                    b = S.c, P = S.d;
                                    var x, B = Math.atan2(P, b);
                                    (x = Math.atan2(u, l) - Math.atan2(h, a) - (B - Math.atan2(S.b, S.a))) > e.MathUtils.PI ? x -= e.MathUtils.PI2 : x < -e.MathUtils.PI && (x += e.MathUtils.PI2), x = B + (x + p) * r, E = Math.sqrt(b * b + P * P), S.c = Math.cos(x) * E, S.d = Math.sin(x) * E, y = !0
                                }
                                y && (_.appliedValid = !1)
                            }
                        }, t.prototype.applyRelativeWorld = function () {
                            for (var t = this.rotateMix, i = this.translateMix, n = this.scaleMix, r = this.shearMix, o = this.target, s = o.matrix, a = s.a, l = s.c, h = s.b, u = s.d, c = a * u - l * h > 0 ? e.MathUtils.degRad : -e.MathUtils.degRad, d = this.data.offsetRotation * c, p = this.data.offsetShearY * c, f = this.bones, g = 0, m = f.length; g < m; g++) {
                                var _, y = f[g],
                                    S = !1,
                                    v = y.matrix;
                                if (0 != t) {
                                    var b = v.a,
                                        T = v.c,
                                        P = v.b,
                                        A = v.d;
                                    (_ = Math.atan2(h, a) + d) > e.MathUtils.PI ? _ -= e.MathUtils.PI2 : _ < -e.MathUtils.PI && (_ += e.MathUtils.PI2), _ *= t;
                                    var I = Math.cos(_),
                                        w = Math.sin(_);
                                    v.a = I * b - w * P, v.c = I * T - w * A, v.b = w * b + I * P, v.d = w * T + I * A, S = !0
                                }
                                if (0 != i) {
                                    var E = this.temp;
                                    o.localToWorld(E.set(this.data.offsetX, this.data.offsetY)), v.tx += E.x * i, v.ty += E.y * i, S = !0
                                }
                                if (n > 0) {
                                    var C = (Math.sqrt(a * a + h * h) - 1 + this.data.offsetScaleX) * n + 1;
                                    v.a *= C, v.b *= C, C = (Math.sqrt(l * l + u * u) - 1 + this.data.offsetScaleY) * n + 1, v.c *= C, v.d *= C, S = !0
                                }
                                r > 0 && ((_ = Math.atan2(u, l) - Math.atan2(h, a)) > e.MathUtils.PI ? _ -= e.MathUtils.PI2 : _ < -e.MathUtils.PI && (_ += e.MathUtils.PI2), T = v.c, A = v.d, _ = Math.atan2(A, T) + (_ - e.MathUtils.PI / 2 + p) * r, C = Math.sqrt(T * T + A * A), v.c = Math.cos(_) * C, v.d = Math.sin(_) * C, S = !0), S && (y.appliedValid = !1)
                            }
                        }, t.prototype.applyAbsoluteLocal = function () {
                            var t = this.rotateMix,
                                e = this.translateMix,
                                i = this.scaleMix,
                                n = this.shearMix,
                                r = this.target;
                            r.appliedValid || r.updateAppliedTransform();
                            for (var o = this.bones, s = 0, a = o.length; s < a; s++) {
                                var l = o[s];
                                l.appliedValid || l.updateAppliedTransform();
                                var h = l.arotation;
                                if (0 != t) {
                                    var u = r.arotation - h + this.data.offsetRotation;
                                    h += (u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * t
                                }
                                var c = l.ax,
                                    d = l.ay;
                                0 != e && (c += (r.ax - c + this.data.offsetX) * e, d += (r.ay - d + this.data.offsetY) * e);
                                var p = l.ascaleX,
                                    f = l.ascaleY;
                                i > 0 && (p > 1e-5 && (p = (p + (r.ascaleX - p + this.data.offsetScaleX) * i) / p), f > 1e-5 && (f = (f + (r.ascaleY - f + this.data.offsetScaleY) * i) / f));
                                var g = l.ashearY;
                                n > 0 && (u = r.ashearY - g + this.data.offsetShearY, u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0)), l.shearY += u * n), l.updateWorldTransformWith(c, d, h, p, f, l.ashearX, g)
                            }
                        }, t.prototype.applyRelativeLocal = function () {
                            var t = this.rotateMix,
                                e = this.translateMix,
                                i = this.scaleMix,
                                n = this.shearMix,
                                r = this.target;
                            r.appliedValid || r.updateAppliedTransform();
                            for (var o = this.bones, s = 0, a = o.length; s < a; s++) {
                                var l = o[s];
                                l.appliedValid || l.updateAppliedTransform();
                                var h = l.arotation;
                                0 != t && (h += (r.arotation + this.data.offsetRotation) * t);
                                var u = l.ax,
                                    c = l.ay;
                                0 != e && (u += (r.ax + this.data.offsetX) * e, c += (r.ay + this.data.offsetY) * e);
                                var d = l.ascaleX,
                                    p = l.ascaleY;
                                i > 0 && (d > 1e-5 && (d *= (r.ascaleX - 1 + this.data.offsetScaleX) * i + 1), p > 1e-5 && (p *= (r.ascaleY - 1 + this.data.offsetScaleY) * i + 1));
                                var f = l.ashearY;
                                n > 0 && (f += (r.ashearY + this.data.offsetShearY) * n), l.updateWorldTransformWith(u, c, h, d, p, l.ashearX, f)
                            }
                        }, t
                    }(), e.TransformConstraint = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function e(e) {
                            var i = t.call(this, e, 0, !1) || this;
                            return i.bones = new Array, i.rotateMix = 0, i.translateMix = 0, i.scaleMix = 0, i.shearMix = 0, i.offsetRotation = 0, i.offsetX = 0, i.offsetY = 0, i.offsetScaleX = 0, i.offsetScaleY = 0, i.offsetShearY = 0, i.relative = !1, i.local = !1, i
                        }
                        return n(e, t), e
                    }(e.ConstraintData), e.TransformConstraintData = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t() {
                            this.convexPolygons = new Array, this.convexPolygonsIndices = new Array, this.indicesArray = new Array, this.isConcaveArray = new Array, this.triangles = new Array, this.polygonPool = new e.Pool((function () {
                                return new Array
                            })), this.polygonIndicesPool = new e.Pool((function () {
                                return new Array
                            }))
                        }
                        return t.prototype.triangulate = function (e) {
                            var i = e,
                                n = e.length >> 1,
                                r = this.indicesArray;
                            r.length = 0;
                            for (var o = 0; o < n; o++) r[o] = o;
                            var s = this.isConcaveArray;
                            s.length = 0, o = 0;
                            for (var a = n; o < a; ++o) s[o] = t.isConcave(o, n, i, r);
                            var l = this.triangles;
                            for (l.length = 0; n > 3;) {
                                for (var h = n - 1, u = (o = 0, 1); ;) {
                                    t: if (!s[o]) {
                                        for (var c = r[h] << 1, d = r[o] << 1, p = r[u] << 1, f = i[c], g = i[c + 1], m = i[d], _ = i[d + 1], y = i[p], S = i[p + 1], v = (u + 1) % n; v != h; v = (v + 1) % n)
                                            if (s[v]) {
                                                var b = r[v] << 1,
                                                    T = i[b],
                                                    P = i[b + 1];
                                                if (t.positiveArea(y, S, f, g, T, P) && t.positiveArea(f, g, m, _, T, P) && t.positiveArea(m, _, y, S, T, P)) break t
                                            } break
                                    } if (0 == u) {
                                        do {
                                            if (!s[o]) break;
                                            o--
                                        } while (o > 0);
                                        break
                                    }
                                    h = o,
                                        o = u,
                                        u = (u + 1) % n
                                }
                                l.push(r[(n + o - 1) % n]), l.push(r[o]), l.push(r[(o + 1) % n]), r.splice(o, 1), s.splice(o, 1);
                                var A = (--n + o - 1) % n,
                                    I = o == n ? 0 : o;
                                s[A] = t.isConcave(A, n, i, r), s[I] = t.isConcave(I, n, i, r)
                            }
                            return 3 == n && (l.push(r[2]), l.push(r[0]), l.push(r[1])), l
                        }, t.prototype.decompose = function (e, i) {
                            var n = e,
                                r = this.convexPolygons;
                            this.polygonPool.freeAll(r), r.length = 0;
                            var o = this.convexPolygonsIndices;
                            this.polygonIndicesPool.freeAll(o), o.length = 0;
                            var s = this.polygonIndicesPool.obtain();
                            s.length = 0;
                            var a = this.polygonPool.obtain();
                            a.length = 0;
                            for (var l = -1, h = 0, u = 0, c = i.length; u < c; u += 3) {
                                var d = i[u] << 1,
                                    p = i[u + 1] << 1,
                                    f = i[u + 2] << 1,
                                    g = n[d],
                                    m = n[d + 1],
                                    _ = n[p],
                                    y = n[p + 1],
                                    S = n[f],
                                    v = n[f + 1],
                                    b = !1;
                                if (l == d) {
                                    var T = a.length - 4,
                                        P = t.winding(a[T], a[T + 1], a[T + 2], a[T + 3], S, v),
                                        A = t.winding(S, v, a[0], a[1], a[2], a[3]);
                                    P == h && A == h && (a.push(S), a.push(v), s.push(f), b = !0)
                                }
                                b || (a.length > 0 ? (r.push(a), o.push(s)) : (this.polygonPool.free(a), this.polygonIndicesPool.free(s)), (a = this.polygonPool.obtain()).length = 0, a.push(g), a.push(m), a.push(_), a.push(y), a.push(S), a.push(v), (s = this.polygonIndicesPool.obtain()).length = 0, s.push(d), s.push(p), s.push(f), h = t.winding(g, m, _, y, S, v), l = d)
                            }
                            for (a.length > 0 && (r.push(a), o.push(s)), u = 0, c = r.length; u < c; u++)
                                if (0 != (s = o[u]).length)
                                    for (var I = s[0], w = s[s.length - 1], E = (a = r[u])[T = a.length - 4], C = a[T + 1], x = a[T + 2], B = a[T + 3], L = a[0], O = a[1], N = a[2], M = a[3], R = t.winding(E, C, x, B, L, O), D = 0; D < c; D++)
                                        if (D != u) {
                                            var F = o[D];
                                            if (3 == F.length) {
                                                var k = F[0],
                                                    U = F[1],
                                                    G = F[2],
                                                    W = r[D];
                                                S = W[W.length - 2], v = W[W.length - 1], k == I && U == w && (P = t.winding(E, C, x, B, S, v), A = t.winding(S, v, L, O, N, M), P == R && A == R && (W.length = 0, F.length = 0, a.push(S), a.push(v), s.push(G), E = x, C = B, x = S, B = v, D = 0))
                                            }
                                        } for (u = r.length - 1; u >= 0; u--) 0 == (a = r[u]).length && (r.splice(u, 1), this.polygonPool.free(a), s = o[u], o.splice(u, 1), this.polygonIndicesPool.free(s));
                            return r
                        }, t.isConcave = function (t, e, i, n) {
                            var r = n[(e + t - 1) % e] << 1,
                                o = n[t] << 1,
                                s = n[(t + 1) % e] << 1;
                            return !this.positiveArea(i[r], i[r + 1], i[o], i[o + 1], i[s], i[s + 1])
                        }, t.positiveArea = function (t, e, i, n, r, o) {
                            return t * (o - n) + i * (e - o) + r * (n - e) >= 0
                        }, t.winding = function (t, e, i, n, r, o) {
                            var s = i - t,
                                a = n - e;
                            return r * a - o * s + s * e - t * a >= 0 ? 1 : -1
                        }, t
                    }(), e.Triangulator = i
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e = function () {
                            function t() {
                                this.array = new Array
                            }
                            return t.prototype.add = function (t) {
                                var e = this.contains(t);
                                return this.array[0 | t] = 0 | t, !e
                            }, t.prototype.contains = function (t) {
                                return null != this.array[0 | t]
                            }, t.prototype.remove = function (t) {
                                this.array[0 | t] = void 0
                            }, t.prototype.clear = function () {
                                this.array.length = 0
                            }, t
                        }();
                        t.IntSet = e;
                        var i = function () {
                            function t(t, e, i, n) {
                                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.r = t, this.g = e, this.b = i, this.a = n
                            }
                            return t.prototype.set = function (t, e, i, n) {
                                return this.r = t, this.g = e, this.b = i, this.a = n, this.clamp(), this
                            }, t.prototype.setFromColor = function (t) {
                                return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this
                            }, t.prototype.setFromString = function (t) {
                                return t = "#" == t.charAt(0) ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = (8 != t.length ? 255 : parseInt(t.substr(6, 2), 16)) / 255, this
                            }, t.prototype.add = function (t, e, i, n) {
                                return this.r += t, this.g += e, this.b += i, this.a += n, this.clamp(), this
                            }, t.prototype.clamp = function () {
                                return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this
                            }, t.rgba8888ToColor = function (t, e) {
                                t.r = ((4278190080 & e) >>> 24) / 255, t.g = ((16711680 & e) >>> 16) / 255, t.b = ((65280 & e) >>> 8) / 255, t.a = (255 & e) / 255
                            }, t.rgb888ToColor = function (t, e) {
                                t.r = ((16711680 & e) >>> 16) / 255, t.g = ((65280 & e) >>> 8) / 255, t.b = (255 & e) / 255
                            }, t.WHITE = new t(1, 1, 1, 1), t.RED = new t(1, 0, 0, 1), t.GREEN = new t(0, 1, 0, 1), t.BLUE = new t(0, 0, 1, 1), t.MAGENTA = new t(1, 0, 1, 1), t
                        }();
                        t.Color = i;
                        var r = function () {
                            function t() { }
                            return t.clamp = function (t, e, i) {
                                return t < e ? e : t > i ? i : t
                            }, t.cosDeg = function (e) {
                                return Math.cos(e * t.degRad)
                            }, t.sinDeg = function (e) {
                                return Math.sin(e * t.degRad)
                            }, t.signum = function (t) {
                                return t > 0 ? 1 : t < 0 ? -1 : 0
                            }, t.toInt = function (t) {
                                return t > 0 ? Math.floor(t) : Math.ceil(t)
                            }, t.cbrt = function (t) {
                                var e = Math.pow(Math.abs(t), 1 / 3);
                                return t < 0 ? -e : e
                            }, t.randomTriangular = function (e, i) {
                                return t.randomTriangularWith(e, i, .5 * (e + i))
                            }, t.randomTriangularWith = function (t, e, i) {
                                var n = Math.random(),
                                    r = e - t;
                                return n <= (i - t) / r ? t + Math.sqrt(n * r * (i - t)) : e - Math.sqrt((1 - n) * r * (e - i))
                            }, t.PI = 3.1415927, t.PI2 = 2 * t.PI, t.radiansToDegrees = 180 / t.PI, t.radDeg = t.radiansToDegrees, t.degreesToRadians = t.PI / 180, t.degRad = t.degreesToRadians, t
                        }();
                        t.MathUtils = r;
                        var o = function () {
                            function t() { }
                            return t.prototype.apply = function (t, e, i) {
                                return t + (e - t) * this.applyInternal(i)
                            }, t
                        }();
                        t.Interpolation = o;
                        var s = function (t) {
                            function e(e) {
                                var i = t.call(this) || this;
                                return i.power = 2, i.power = e, i
                            }
                            return n(e, t), e.prototype.applyInternal = function (t) {
                                return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1
                            }, e
                        }(o);
                        t.Pow = s;
                        var a = function (t) {
                            function e(e) {
                                return t.call(this, e) || this
                            }
                            return n(e, t), e.prototype.applyInternal = function (t) {
                                return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1
                            }, e
                        }(s);
                        t.PowOut = a;
                        var l = function () {
                            function t() { }
                            return t.arrayCopy = function (t, e, i, n, r) {
                                for (var o = e, s = n; o < e + r; o++, s++) i[s] = t[o]
                            }, t.setArraySize = function (t, e, i) {
                                void 0 === i && (i = 0);
                                var n = t.length;
                                if (n == e) return t;
                                if (t.length = e, n < e)
                                    for (var r = n; r < e; r++) t[r] = i;
                                return t
                            }, t.ensureArrayCapacity = function (e, i, n) {
                                return void 0 === n && (n = 0), e.length >= i ? e : t.setArraySize(e, i, n)
                            }, t.newArray = function (t, e) {
                                for (var i = new Array(t), n = 0; n < t; n++) i[n] = e;
                                return i
                            }, t.newFloatArray = function (e) {
                                if (t.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e);
                                for (var i = new Array(e), n = 0; n < i.length; n++) i[n] = 0;
                                return i
                            }, t.newShortArray = function (e) {
                                if (t.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e);
                                for (var i = new Array(e), n = 0; n < i.length; n++) i[n] = 0;
                                return i
                            }, t.toFloatArray = function (e) {
                                return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e
                            }, t.toSinglePrecision = function (e) {
                                return t.SUPPORTS_TYPED_ARRAYS ? Math.fround(e) : e
                            }, t.webkit602BugfixHelper = function (t, e) { }, t.contains = function (t, e, i) {
                                void 0 === i && (i = !0);
                                for (var n = 0; n < t.length; n++)
                                    if (t[n] == e) return !0;
                                return !1
                            }, t.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, t
                        }();
                        t.Utils = l;
                        var h = function () {
                            function t() { }
                            return t.logBones = function (t) {
                                for (var e = 0; e < t.bones.length; e++) {
                                    var i = t.bones[e],
                                        n = i.matrix;
                                    console.log(i.data.name + ", " + n.a + ", " + n.b + ", " + n.c + ", " + n.d + ", " + n.tx + ", " + n.ty)
                                }
                            }, t
                        }();
                        t.DebugUtils = h;
                        var u = function () {
                            function t(t) {
                                this.items = new Array, this.instantiator = t
                            }
                            return t.prototype.obtain = function () {
                                return this.items.length > 0 ? this.items.pop() : this.instantiator()
                            }, t.prototype.free = function (t) {
                                t.reset && t.reset(), this.items.push(t)
                            }, t.prototype.freeAll = function (t) {
                                for (var e = 0; e < t.length; e++) this.free(t[e])
                            }, t.prototype.clear = function () {
                                this.items.length = 0
                            }, t
                        }();
                        t.Pool = u;
                        var c = function () {
                            function t(t, e) {
                                void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
                            }
                            return t.prototype.set = function (t, e) {
                                return this.x = t, this.y = e, this
                            }, t.prototype.length = function () {
                                var t = this.x,
                                    e = this.y;
                                return Math.sqrt(t * t + e * e)
                            }, t.prototype.normalize = function () {
                                var t = this.length();
                                return 0 != t && (this.x /= t, this.y /= t), this
                            }, t
                        }();
                        t.Vector2 = c;
                        var d = function () {
                            function t() {
                                this.maxDelta = .064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0
                            }
                            return t.prototype.update = function () {
                                var t = Date.now() / 1e3;
                                this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0)
                            }, t
                        }();
                        t.TimeKeeper = d;
                        var p = function () {
                            function t(t) {
                                void 0 === t && (t = 32), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, this.values = new Array(t)
                            }
                            return t.prototype.hasEnoughData = function () {
                                return this.addedValues >= this.values.length
                            }, t.prototype.addValue = function (t) {
                                this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0
                            }, t.prototype.getMean = function () {
                                if (this.hasEnoughData()) {
                                    if (this.dirty) {
                                        for (var t = 0, e = 0; e < this.values.length; e++) t += this.values[e];
                                        this.mean = t / this.values.length, this.dirty = !1
                                    }
                                    return this.mean
                                }
                                return 0
                            }, t
                        }();
                        t.WindowedMean = p
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    ! function (t) {
                        var e = function (t) {
                            if (null == t) throw new Error("name cannot be null.");
                            this.name = t
                        };
                        t.Attachment = e;
                        var i = function (e) {
                            function i(t) {
                                var n = e.call(this, t) || this;
                                return n.id = (65535 & i.nextID++) << 11, n.worldVerticesLength = 0, n.deformAttachment = n, n
                            }
                            return n(i, e), i.prototype.computeWorldVerticesOld = function (t, e) {
                                this.computeWorldVertices(t, 0, this.worldVerticesLength, e, 0, 2)
                            }, i.prototype.computeWorldVertices = function (t, e, i, n, r, o) {
                                i = r + (i >> 1) * o;
                                var s = t.bone.skeleton,
                                    a = t.deform,
                                    l = this.vertices,
                                    h = this.bones;
                                if (null != h) {
                                    for (var u = 0, c = 0, d = 0; d < e; d += 2) u += (m = h[u]) + 1, c += m;
                                    var p = s.bones;
                                    if (0 == a.length)
                                        for (C = r, A = 3 * c; C < i; C += o) {
                                            var f = 0,
                                                g = 0,
                                                m = h[u++];
                                            for (m += u; u < m; u++, A += 3) {
                                                v = p[h[u]].matrix, x = l[A], B = l[A + 1];
                                                var _ = l[A + 2];
                                                f += (x * v.a + B * v.c + v.tx) * _, g += (x * v.b + B * v.d + v.ty) * _
                                            }
                                            n[C] = f, n[C + 1] = g
                                        } else
                                        for (var y = a, S = (C = r, A = 3 * c, c << 1); C < i; C += o) {
                                            for (f = 0, g = 0, m = h[u++], m += u; u < m; u++, A += 3, S += 2) v = p[h[u]].matrix, x = l[A] + y[S], B = l[A + 1] + y[S + 1], _ = l[A + 2], f += (x * v.a + B * v.c + v.tx) * _, g += (x * v.b + B * v.d + v.ty) * _;
                                            n[C] = f, n[C + 1] = g
                                        }
                                } else {
                                    a.length > 0 && (l = a);
                                    for (var v, b = (v = t.bone.matrix).tx, T = v.ty, P = v.a, A = v.c, I = v.b, w = v.d, E = e, C = r; C < i; E += 2, C += o) {
                                        var x = l[E],
                                            B = l[E + 1];
                                        n[C] = x * P + B * A + b, n[C + 1] = x * I + B * w + T
                                    }
                                }
                            }, i.prototype.copyTo = function (e) {
                                null != this.bones ? (e.bones = new Array(this.bones.length), t.Utils.arrayCopy(this.bones, 0, e.bones, 0, this.bones.length)) : e.bones = null, null != this.vertices ? (e.vertices = t.Utils.newFloatArray(this.vertices.length), t.Utils.arrayCopy(this.vertices, 0, e.vertices, 0, this.vertices.length)) : e.vertices = null, e.worldVerticesLength = this.worldVerticesLength, e.deformAttachment = this.deformAttachment
                            }, i.nextID = 0, i
                        }(e);
                        t.VertexAttachment = i
                    }(t.core || (t.core = {}))
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), (i = e.AttachmentType || (e.AttachmentType = {}))[i.Region = 0] = "Region", i[i.BoundingBox = 1] = "BoundingBox", i[i.Mesh = 2] = "Mesh", i[i.LinkedMesh = 3] = "LinkedMesh", i[i.Path = 4] = "Path", i[i.Point = 5] = "Point", i[i.Clipping = 6] = "Clipping"
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function i(i) {
                            var n = t.call(this, i) || this;
                            return n.color = new e.Color(1, 1, 1, 1), n
                        }
                        return n(i, t), i.prototype.copy = function () {
                            var t = new i(this.name);
                            return this.copyTo(t), t.color.setFromColor(this.color), t
                        }, i
                    }(e.VertexAttachment), e.BoundingBoxAttachment = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function i(i) {
                            var n = t.call(this, i) || this;
                            return n.color = new e.Color(.2275, .2275, .8078, 1), n
                        }
                        return n(i, t), i.prototype.copy = function () {
                            var t = new i(this.name);
                            return this.copyTo(t), t.endSlot = this.endSlot, t.color.setFromColor(this.color), t
                        }, i
                    }(e.VertexAttachment), e.ClippingAttachment = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function i(i) {
                            var n = t.call(this, i) || this;
                            return n.color = new e.Color(1, 1, 1, 1), n.tempColor = new e.Color(0, 0, 0, 0), n
                        }
                        return n(i, t), i.prototype.getParentMesh = function () {
                            return this.parentMesh
                        }, i.prototype.setParentMesh = function (t) {
                            this.parentMesh = t, null != t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength)
                        }, i.prototype.copy = function () {
                            if (null != this.parentMesh) return this.newLinkedMesh();
                            var t = new i(this.name);
                            return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), this.copyTo(t), t.regionUVs = new Float32Array(this.regionUVs.length), e.Utils.arrayCopy(this.regionUVs, 0, t.regionUVs, 0, this.regionUVs.length), t.uvs = new Array(this.uvs.length), e.Utils.arrayCopy(this.uvs, 0, t.uvs, 0, this.uvs.length), t.triangles = new Array(this.triangles.length), e.Utils.arrayCopy(this.triangles, 0, t.triangles, 0, this.triangles.length), t.hullLength = this.hullLength, null != this.edges && (t.edges = new Array(this.edges.length), e.Utils.arrayCopy(this.edges, 0, t.edges, 0, this.edges.length)), t.width = this.width, t.height = this.height, t
                        }, i.prototype.newLinkedMesh = function () {
                            var t = new i(this.name);
                            return t.region = this.region, t.path = this.path, t.color.setFromColor(this.color), t.deformAttachment = this.deformAttachment, t.setParentMesh(null != this.parentMesh ? this.parentMesh : this), t
                        }, i
                    }(e.VertexAttachment), e.MeshAttachment = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function i(i) {
                            var n = t.call(this, i) || this;
                            return n.closed = !1, n.constantSpeed = !1, n.color = new e.Color(1, 1, 1, 1), n
                        }
                        return n(i, t), i.prototype.copy = function () {
                            var t = new i(this.name);
                            return this.copyTo(t), t.lengths = new Array(this.lengths.length), e.Utils.arrayCopy(this.lengths, 0, t.lengths, 0, this.lengths.length), t.closed = closed, t.constantSpeed = this.constantSpeed, t.color.setFromColor(this.color), t
                        }, i
                    }(e.VertexAttachment), e.PathAttachment = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function i(i) {
                            var n = t.call(this, i) || this;
                            return n.color = new e.Color(.38, .94, 0, 1), n
                        }
                        return n(i, t), i.prototype.computeWorldPosition = function (t, e) {
                            var i = t.matrix;
                            return e.x = this.x * i.a + this.y * i.c + t.worldX, e.y = this.x * i.b + this.y * i.d + t.worldY, e
                        }, i.prototype.computeWorldRotation = function (t) {
                            var i = t.matrix,
                                n = e.MathUtils.cosDeg(this.rotation),
                                r = e.MathUtils.sinDeg(this.rotation),
                                o = n * i.a + r * i.c,
                                s = n * i.b + r * i.d;
                            return Math.atan2(s, o) * e.MathUtils.radDeg
                        }, i.prototype.copy = function () {
                            var t = new i(this.name);
                            return t.x = this.x, t.y = this.y, t.rotation = this.rotation, t.color.setFromColor(this.color), t
                        }, i
                    }(e.VertexAttachment), e.PointAttachment = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function (t) {
                        function i(i) {
                            var n = t.call(this, i) || this;
                            return n.x = 0, n.y = 0, n.scaleX = 1, n.scaleY = 1, n.rotation = 0, n.width = 0, n.height = 0, n.color = new e.Color(1, 1, 1, 1), n.offset = e.Utils.newFloatArray(8), n.uvs = e.Utils.newFloatArray(8), n.tempColor = new e.Color(1, 1, 1, 1), n
                        }
                        return n(i, t), i.prototype.updateOffset = function () {
                            var t = this.width / this.region.originalWidth * this.scaleX,
                                e = this.height / this.region.originalHeight * this.scaleY,
                                n = -this.width / 2 * this.scaleX + this.region.offsetX * t,
                                r = -this.height / 2 * this.scaleY + this.region.offsetY * e,
                                o = n + this.region.width * t,
                                s = r + this.region.height * e,
                                a = this.rotation * Math.PI / 180,
                                l = Math.cos(a),
                                h = Math.sin(a),
                                u = n * l + this.x,
                                c = n * h,
                                d = r * l + this.y,
                                p = r * h,
                                f = o * l + this.x,
                                g = o * h,
                                m = s * l + this.y,
                                _ = s * h,
                                y = this.offset;
                            y[i.OX1] = u - p, y[i.OY1] = d + c, y[i.OX2] = u - _, y[i.OY2] = m + c, y[i.OX3] = f - _, y[i.OY3] = m + g, y[i.OX4] = f - p, y[i.OY4] = d + g
                        }, i.prototype.setRegion = function (t) {
                            this.region = t;
                            var e = this.uvs;
                            t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2)
                        }, i.prototype.computeWorldVertices = function (t, e, n, r) {
                            var o = this.offset,
                                s = t.matrix,
                                a = s.tx,
                                l = s.ty,
                                h = s.a,
                                u = s.c,
                                c = s.b,
                                d = s.d,
                                p = 0,
                                f = 0;
                            p = o[i.OX1], f = o[i.OY1], e[n] = p * h + f * u + a, e[n + 1] = p * c + f * d + l, n += r, p = o[i.OX2], f = o[i.OY2], e[n] = p * h + f * u + a, e[n + 1] = p * c + f * d + l, n += r, p = o[i.OX3], f = o[i.OY3], e[n] = p * h + f * u + a, e[n + 1] = p * c + f * d + l, n += r, p = o[i.OX4], f = o[i.OY4], e[n] = p * h + f * u + a, e[n + 1] = p * c + f * d + l
                        }, i.prototype.copy = function () {
                            var t = new i(this.name);
                            return t.region = this.region, t.rendererObject = this.rendererObject, t.path = this.path, t.x = this.x, t.y = this.y, t.scaleX = this.scaleX, t.scaleY = this.scaleY, t.rotation = this.rotation, t.width = this.width, t.height = this.height, e.Utils.arrayCopy(this.uvs, 0, t.uvs, 0, 8), e.Utils.arrayCopy(this.offset, 0, t.offset, 0, 8), t.color.setFromColor(this.color), t
                        }, i.OX1 = 0, i.OY1 = 1, i.OX2 = 2, i.OY2 = 3, i.OX3 = 4, i.OY3 = 5, i.OX4 = 6, i.OY4 = 7, i.X1 = 0, i.Y1 = 1, i.C1R = 2, i.C1G = 3, i.C1B = 4, i.C1A = 5, i.U1 = 6, i.V1 = 7, i.X2 = 8, i.Y2 = 9, i.C2R = 10, i.C2G = 11, i.C2B = 12, i.C2A = 13, i.U2 = 14, i.V2 = 15, i.X3 = 16, i.Y3 = 17, i.C3R = 18, i.C3G = 19, i.C3B = 20, i.C3A = 21, i.U3 = 22, i.V3 = 23, i.X4 = 24, i.Y4 = 25, i.C4R = 26, i.C4G = 27, i.C4B = 28, i.C4A = 29, i.U4 = 30, i.V4 = 31, i
                    }(e.Attachment), e.RegionAttachment = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t, e) {
                            this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e
                        }
                        return t.prototype.begin = function (t) { }, t.prototype.transform = function (t, i, n, r) {
                            t.x += e.MathUtils.randomTriangular(-this.jitterX, this.jitterY), t.y += e.MathUtils.randomTriangular(-this.jitterX, this.jitterY)
                        }, t.prototype.end = function () { }, t
                    }(), e.JitterEffect = i
                }(i || (i = {})),
                function (t) {
                    var e, i;
                    e = t.core || (t.core = {}), i = function () {
                        function t(t) {
                            this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t
                        }
                        return t.prototype.begin = function (t) {
                            this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY
                        }, t.prototype.transform = function (i, n, r, o) {
                            var s = this.angle * e.MathUtils.degreesToRadians,
                                a = i.x - this.worldX,
                                l = i.y - this.worldY,
                                h = Math.sqrt(a * a + l * l);
                            if (h < this.radius) {
                                var u = t.interpolation.apply(0, s, (this.radius - h) / this.radius),
                                    c = Math.cos(u),
                                    d = Math.sin(u);
                                i.x = c * a - d * l + this.worldX, i.y = d * a + c * l + this.worldY
                            }
                        }, t.prototype.end = function () { }, t.interpolation = new e.PowOut(2), t
                    }(), e.SwirlEffect = i
                }(i || (i = {})), Math.fround || (Math.fround = Math.fround = (e = new Float32Array(1), function (t) {
                    return e[0] = t, e[0]
                })),
                function (t) {
                    t.core.Bone.yDown = !0;
                    var e = [0, 0, 0],
                        i = function (t) {
                            function e() {
                                var e = null !== t && t.apply(this, arguments) || this;
                                return e.region = null, e.attachment = null, e
                            }
                            return n(e, t), e
                        }(PIXI.Sprite);
                    t.SpineSprite = i;
                    var r = PIXI.GraphicsGeometry.prototype;
                    if (!r.invalidate) {
                        var o = [];
                        r.invalidate = function () {
                            var t = this.graphicsData;
                            o.push(0), this.graphicsData = o, this.clear(), this.graphicsData = t
                        }
                    }
                    var s = function (t) {
                        function e(e, i, n, r, o) {
                            var s = t.call(this, e, i, n, r, o) || this;
                            return s.region = null, s.attachment = null, s
                        }
                        return n(e, t), e
                    }(PIXI.SimpleMesh);
                    t.SpineMesh = s;
                    var a = function (r) {
                        function o(e) {
                            var i = r.call(this) || this;
                            if (!e) throw new Error("The spineData param is required.");
                            if ("string" == typeof e) throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');
                            i.spineData = e, i.skeleton = new t.core.Skeleton(e), i.skeleton.updateWorldTransform(), i.stateData = new t.core.AnimationStateData(e), i.state = new t.core.AnimationState(i.stateData), i.slotContainers = [], i.tempClipContainers = [];
                            for (var n = 0, o = i.skeleton.slots.length; n < o; n++) {
                                var s = i.skeleton.slots[n],
                                    a = s.getAttachment(),
                                    l = i.newContainer();
                                if (i.slotContainers.push(l), i.addChild(l), i.tempClipContainers.push(null), a instanceof t.core.RegionAttachment) {
                                    var h = a.region.name,
                                        u = i.createSprite(s, a, h);
                                    s.currentSprite = u, s.currentSpriteName = h, l.addChild(u)
                                } else if (a instanceof t.core.MeshAttachment) {
                                    var c = i.createMesh(s, a);
                                    s.currentMesh = c, s.currentMeshId = a.id, l.addChild(c)
                                } else {
                                    if (!(a instanceof t.core.ClippingAttachment)) continue;
                                    i.createGraphics(s, a), l.addChild(s.clippingContainer), l.addChild(s.currentGraphics)
                                }
                            }
                            return i.tintRgb = new Float32Array([1, 1, 1]), i.autoUpdate = !0, i.visible = !0, i
                        }
                        return n(o, r), Object.defineProperty(o.prototype, "autoUpdate", {
                            get: function () {
                                return this._autoUpdate
                            },
                            set: function (t) {
                                t !== this._autoUpdate && (this._autoUpdate = t, this.updateTransform = t ? o.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(o.prototype, "visible", {
                            get: function () {
                                return this._visible
                            },
                            set: function (t) {
                                t !== this._visible && (this._visible = t, t && (this.lastTime = 0))
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(o.prototype, "tint", {
                            get: function () {
                                return PIXI.utils.rgb2hex(this.tintRgb)
                            },
                            set: function (t) {
                                this.tintRgb = PIXI.utils.hex2rgb(t, this.tintRgb)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(o.prototype, "delayLimit", {
                            get: function () {
                                return (void 0 !== this.localDelayLimit ? this.localDelayLimit : o.globalDelayLimit) || Number.MAX_VALUE
                            },
                            enumerable: !1,
                            configurable: !0
                        }), o.prototype.update = function (i) {
                            var n = this.delayLimit;
                            if (i > n && (i = n), this.state.update(i), this.state.apply(this.skeleton), this.skeleton) {
                                this.skeleton.updateWorldTransform();
                                var r = this.skeleton.slots,
                                    o = this.color,
                                    s = null,
                                    a = null;
                                o ? (s = o.light, a = o.dark) : s = this.tintRgb;
                                for (var l = 0, h = r.length; l < h; l++) {
                                    var u = (E = r[l]).getAttachment(),
                                        c = this.slotContainers[l];
                                    if (u) {
                                        var d = null,
                                            p = u.color;
                                        if (u instanceof t.core.RegionAttachment) {
                                            var f = u.region;
                                            if (f) {
                                                E.currentMesh && (E.currentMesh.visible = !1, E.currentMesh = null, E.currentMeshId = void 0, E.currentMeshName = void 0);
                                                var g = f;
                                                if (E.currentSpriteName && E.currentSpriteName === g.name) E.currentSpriteName !== g.name || E.hackRegion || this.setSpriteRegion(u, E.currentSprite, f);
                                                else {
                                                    var m = g.name;
                                                    if (E.currentSprite && (E.currentSprite.visible = !1), E.sprites = E.sprites || {}, void 0 !== E.sprites[m]) E.sprites[m].visible = !0;
                                                    else {
                                                        var _ = this.createSprite(E, u, m);
                                                        c.addChild(_)
                                                    }
                                                    E.currentSprite = E.sprites[m], E.currentSpriteName = m
                                                }
                                            } (y = c.transform).setFromMatrix(E.bone.matrix), E.currentSprite.color ? d = E.currentSprite.color : (e[0] = s[0] * E.color.r * p.r, e[1] = s[1] * E.color.g * p.g, e[2] = s[2] * E.color.b * p.b, E.currentSprite.tint = PIXI.utils.rgb2hex(e)), E.currentSprite.blendMode = E.blendMode
                                        } else {
                                            if (!(u instanceof t.core.MeshAttachment)) {
                                                if (u instanceof t.core.ClippingAttachment) {
                                                    E.currentGraphics || (this.createGraphics(E, u), c.addChild(E.clippingContainer), c.addChild(E.currentGraphics)), this.updateGraphics(E, u), c.alpha = 1, c.visible = !0;
                                                    continue
                                                }
                                                c.visible = !1;
                                                continue
                                            }
                                            var y;
                                            if (E.currentSprite && (E.currentSprite.visible = !1, E.currentSprite = null, E.currentSpriteName = void 0, (y = new PIXI.Transform)._parentID = -1, y._worldID = c.transform._worldID, c.transform = y), !E.currentMeshId || E.currentMeshId !== u.id) {
                                                var S = u.id;
                                                if (E.currentMesh && (E.currentMesh.visible = !1), E.meshes = E.meshes || {}, void 0 !== E.meshes[S]) E.meshes[S].visible = !0;
                                                else {
                                                    var v = this.createMesh(E, u);
                                                    c.addChild(v)
                                                }
                                                E.currentMesh = E.meshes[S], E.currentMeshName = u.name, E.currentMeshId = S
                                            }
                                            u.computeWorldVerticesOld(E, E.currentMesh.vertices), E.currentMesh.color ? d = E.currentMesh.color : (e[0] = s[0] * E.color.r * p.r, e[1] = s[1] * E.color.g * p.g, e[2] = s[2] * E.color.b * p.b, E.currentMesh.tint = PIXI.utils.rgb2hex(e)), E.currentMesh.blendMode = E.blendMode
                                        }
                                        if (c.visible = !0, d) {
                                            var b = E.color.r * p.r,
                                                T = E.color.g * p.g,
                                                P = E.color.b * p.b;
                                            d.setLight(s[0] * b + a[0] * (1 - b), s[1] * T + a[1] * (1 - T), s[2] * P + a[2] * (1 - P)), E.darkColor ? (b = E.darkColor.r, T = E.darkColor.g, P = E.darkColor.b) : (b = 0, T = 0, P = 0), d.setDark(s[0] * b + a[0] * (1 - b), s[1] * T + a[1] * (1 - T), s[2] * P + a[2] * (1 - P))
                                        }
                                        c.alpha = E.color.a
                                    } else c.visible = !1
                                }
                                var A = this.skeleton.drawOrder,
                                    I = null,
                                    w = null;
                                for (l = 0, h = A.length; l < h; l++) {
                                    var E = r[A[l].data.index];
                                    if (c = this.slotContainers[A[l].data.index], w || null !== c.parent && c.parent !== this && (c.parent.removeChild(c), c.parent = this), E.currentGraphics && E.getAttachment()) w = E.clippingContainer, I = E.getAttachment(), w.children.length = 0, this.children[l] = c, I.endSlot == E.data && (I.endSlot = null);
                                    else if (w) {
                                        var C = this.tempClipContainers[l];
                                        C || ((C = this.tempClipContainers[l] = this.newContainer()).visible = !1), this.children[l] = C, c.parent = null, w.addChild(c), I.endSlot == E.data && (w.renderable = !0, w = null, I = null)
                                    } else this.children[l] = c
                                }
                            }
                        }, o.prototype.setSpriteRegion = function (e, i, n) {
                            i.attachment === e && i.region === n || (i.region = n, i.attachment = e, i.texture = n.texture, i.rotation = e.rotation * t.core.MathUtils.degRad, i.position.x = e.x, i.position.y = e.y, i.alpha = e.color.a, n.size ? (i.scale.x = n.size.width / n.originalWidth, i.scale.y = -n.size.height / n.originalHeight) : (i.scale.x = e.scaleX * e.width / n.originalWidth, i.scale.y = -e.scaleY * e.height / n.originalHeight))
                        }, o.prototype.setMeshRegion = function (t, e, i) {
                            e.attachment === t && e.region === i || (e.region = i, e.attachment = t, e.texture = i.texture, i.texture.updateUvs(), e.uvBuffer.update(t.regionUVs))
                        }, o.prototype.autoUpdateTransform = function () {
                            if (o.globalAutoUpdate) {
                                this.lastTime = this.lastTime || Date.now();
                                var t = .001 * (Date.now() - this.lastTime);
                                this.lastTime = Date.now(), this.update(t)
                            } else this.lastTime = 0;
                            PIXI.Container.prototype.updateTransform.call(this)
                        }, o.prototype.createSprite = function (t, e, i) {
                            var n = e.region;
                            t.hackAttachment === e && (n = t.hackRegion);
                            var r = n.texture,
                                o = this.newSprite(r);
                            return o.anchor.set(.5), this.setSpriteRegion(e, o, e.region), t.sprites = t.sprites || {}, t.sprites[i] = o, o
                        }, o.prototype.createMesh = function (t, e) {
                            var i = e.region;
                            t.hackAttachment === e && (i = t.hackRegion, t.hackAttachment = null, t.hackRegion = null);
                            var n = this.newMesh(i.texture, new Float32Array(e.regionUVs.length), e.regionUVs, new Uint16Array(e.triangles), PIXI.DRAW_MODES.TRIANGLES);
                            return void 0 !== n._canvasPadding && (n._canvasPadding = 1.5), n.alpha = e.color.a, n.region = e.region, this.setMeshRegion(e, n, i), t.meshes = t.meshes || {}, t.meshes[e.id] = n, n
                        }, o.prototype.createGraphics = function (t, e) {
                            var i = this.newGraphics(),
                                n = new PIXI.Polygon([]);
                            return i.clear(), i.beginFill(16777215, 1), i.drawPolygon(n), i.renderable = !1, t.currentGraphics = i, t.clippingContainer = this.newContainer(), t.clippingContainer.mask = t.currentGraphics, i
                        }, o.prototype.updateGraphics = function (t, e) {
                            var i = t.currentGraphics.geometry,
                                n = i.graphicsData[0].shape.points,
                                r = e.worldVerticesLength;
                            n.length = r, e.computeWorldVertices(t, 0, r, n, 0, 2), i.invalidate()
                        }, o.prototype.hackTextureBySlotIndex = function (e, i, n) {
                            void 0 === i && (i = null), void 0 === n && (n = null);
                            var r = this.skeleton.slots[e];
                            if (!r) return !1;
                            var o = r.getAttachment(),
                                s = o.region;
                            return i ? ((s = new t.core.TextureRegion).texture = i, s.size = n, r.hackRegion = s, r.hackAttachment = o) : (r.hackRegion = null, r.hackAttachment = null), r.currentSprite && r.currentSprite.region != s ? (this.setSpriteRegion(o, r.currentSprite, s), r.currentSprite.region = s) : r.currentMesh && r.currentMesh.region != s && this.setMeshRegion(o, r.currentMesh, s), !0
                        }, o.prototype.hackTextureBySlotName = function (t, e, i) {
                            void 0 === e && (e = null), void 0 === i && (i = null);
                            var n = this.skeleton.findSlotIndex(t);
                            return -1 != n && this.hackTextureBySlotIndex(n, e, i)
                        }, o.prototype.hackTextureAttachment = function (e, i, n, r) {
                            void 0 === r && (r = null);
                            var o = this.skeleton.findSlotIndex(e),
                                s = this.skeleton.getAttachmentByName(e, i);
                            s.region.texture = n;
                            var a = this.skeleton.slots[o];
                            if (!a) return !1;
                            var l = a.getAttachment();
                            if (i === l.name) {
                                var h = s.region;
                                return n ? ((h = new t.core.TextureRegion).texture = n, h.size = r, a.hackRegion = h, a.hackAttachment = l) : (a.hackRegion = null, a.hackAttachment = null), a.currentSprite && a.currentSprite.region != h ? (this.setSpriteRegion(l, a.currentSprite, h), a.currentSprite.region = h) : a.currentMesh && a.currentMesh.region != h && this.setMeshRegion(l, a.currentMesh, h), !0
                            }
                            return !1
                        }, o.prototype.newContainer = function () {
                            return new PIXI.Container
                        }, o.prototype.newSprite = function (t) {
                            return new i(t)
                        }, o.prototype.newGraphics = function () {
                            return new PIXI.Graphics
                        }, o.prototype.newMesh = function (t, e, i, n, r) {
                            return new s(t, e, i, n, r)
                        }, o.prototype.transformHack = function () {
                            return 1
                        }, o.prototype.hackAttachmentGroups = function (t, e, i) {
                            if (t) {
                                for (var n = [], r = [], o = 0, s = this.skeleton.slots.length; o < s; o++) {
                                    var a = this.skeleton.slots[o],
                                        l = a.currentSpriteName || a.currentMeshName || "",
                                        h = a.currentSprite || a.currentMesh;
                                    l.endsWith(t) ? (h.parentGroup = e, r.push(h)) : i && h && (h.parentGroup = i, n.push(h))
                                }
                                return [n, r]
                            }
                        }, o.prototype.destroy = function (t) {
                            for (var e = 0, i = this.skeleton.slots.length; e < i; e++) {
                                var n = this.skeleton.slots[e];
                                for (var o in n.meshes) n.meshes[o].destroy(t);
                                for (var s in n.meshes = null, n.sprites) n.sprites[s].destroy(t);
                                n.sprites = null
                            }
                            for (e = 0, i = this.slotContainers.length; e < i; e++) this.slotContainers[e].destroy(t);
                            this.spineData = null, this.skeleton = null, this.slotContainers = null, this.stateData = null, this.state = null, this.tempClipContainers = null, r.prototype.destroy.call(this, t)
                        }, o.globalAutoUpdate = !0, o.globalDelayLimit = 0, o.clippingPolygon = [], o
                    }(PIXI.Container);
                    t.Spine = a
                }(i || (i = {})),
                function (t) {
                    PIXI.spine = t;
                    var e = PIXI.Texture.prototype;
                    e._updateUvs || (e._updateUvs = e.updateUvs)
                }(i || (i = {})),
                function (t) {
                    PIXI.LoaderResource.setExtensionXhrType("skel", PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);
                    var e = function () {
                        function e() { }
                        return e.use = function (e, r) {
                            if (!e.data) return r();
                            var o = function (t) {
                                return t.type === PIXI.LoaderResource.TYPE.JSON
                            }(e) && e.data.bones,
                                s = function (t) {
                                    return t.xhrType === PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER
                                }(e) && ("skel" === e.extension || e.metadata.spineMetadata);
                            if (!o && !s) return r();
                            var a = null,
                                l = e.data;
                            o ? a = new t.core.SkeletonJson(null) : (a = new t.core.SkeletonBinary(null), e.data instanceof ArrayBuffer && (l = new Uint8Array(e.data)));
                            var h = e.metadata || {},
                                u = h ? e.metadata.spineSkeletonScale : null;
                            u && (a.scale = u);
                            var c = h ? e.metadata.spineAtlas : null;
                            if (!1 === c) return r();
                            if (c && c.pages) return a.attachmentLoader = new t.core.AtlasAttachmentLoader(c), e.spineData = a.readSkeletonData(l), e.spineAtlas = c, r();
                            var d = h.spineAtlasSuffix || ".atlas",
                                p = e.url,
                                f = p.indexOf("?");
                            f > 0 && (p = p.substr(0, f)), p = p.substr(0, p.lastIndexOf(".")) + d, e.metadata && e.metadata.spineAtlasFile && (p = e.metadata.spineAtlasFile), p = p.replace(this.baseUrl, "");
                            var g = {
                                crossOrigin: e.crossOrigin,
                                xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT,
                                metadata: h.spineMetadata || null,
                                parentResource: e
                            },
                                m = {
                                    crossOrigin: e.crossOrigin,
                                    metadata: h.imageMetadata || null,
                                    parentResource: e
                                },
                                _ = e.url.substr(0, e.url.lastIndexOf("/") + 1);
                            _ = _.replace(this.baseUrl, "");
                            var y = h.imageNamePrefix || e.name + "_atlas_page_",
                                S = h.images ? n(h.images) : h.image ? n({
                                    default: h.image
                                }) : h.imageLoader ? h.imageLoader(this, y, _, m) : i(this, y, _, m),
                                v = function (i) {
                                    new t.core.TextureAtlas(i, S, (function (i) {
                                        i && (a.attachmentLoader = new t.core.AtlasAttachmentLoader(i), e.spineData = a.readSkeletonData(l), e.spineAtlas = i), r()
                                    }))
                                };
                            e.metadata && e.metadata.atlasRawData ? v(e.metadata.atlasRawData) : this.add(e.name + "_atlas", p, g, (function (t) {
                                t.error ? r() : v(t.data)
                            }))
                        }, e
                    }();

                    function i(t, e, i, n) {
                        return i && i.lastIndexOf("/") !== i.length - 1 && (i += "/"),
                            function (r, o) {
                                var s = e + r,
                                    a = i + r,
                                    l = t.resources[s];
                                if (l) {
                                    var h = function () {
                                        o(l.texture.baseTexture)
                                    };
                                    l.texture ? h() : l.onAfterMiddleware.add(h)
                                } else t.add(s, a, n, (function (t) {
                                    t.error ? o(null) : o(t.texture.baseTexture)
                                }))
                            }
                    }

                    function n(t) {
                        return function (e, i) {
                            var n = t[e] || t.default;
                            n && n.baseTexture ? i(n.baseTexture) : i(n)
                        }
                    }
                    t.AtlasParser = e, t.imageLoaderAdapter = i, t.syncImageLoaderAdapter = function (t, e) {
                        return t && t.lastIndexOf("/") !== t.length - 1 && (t += "/"),
                            function (t, i) {
                                i(PIXI.BaseTexture.from(t, e))
                            }
                    }, t.staticImageLoader = n, PIXI.Loader && PIXI.Loader.registerPlugin(e)
                }(i || (i = {}))
        },
        3832: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                ALPHA_MODES: () => P,
                AbstractBatchRenderer: () => Nn,
                AbstractRenderer: () => In,
                AccessibilityManager: () => ge,
                AnimatedSprite: () => $s,
                AppLoaderPlugin: () => fr,
                Application: () => Gn,
                Attribute: () => ii,
                BLEND_MODES: () => g,
                BUFFER_BITS: () => f,
                BasePrepare: () => Io,
                BaseRenderTexture: () => qe,
                BaseTexture: () => Re,
                BatchDrawCall: () => Bn,
                BatchGeometry: () => Rn,
                BatchPluginFactory: () => kn,
                BatchRenderer: () => Un,
                BatchShaderGenerator: () => Mn,
                BatchTextureArray: () => Ln,
                BitmapFont: () => is,
                BitmapFontData: () => qo,
                BitmapFontLoader: () => ss,
                BitmapText: () => os,
                Bounds: () => oe,
                Buffer: () => ri,
                CLEAR_MODES: () => A,
                Circle: () => Xt,
                Container: () => ce,
                CountLimiter: () => _o,
                DEG_TO_RAD: () => Wt,
                DRAW_MODES: () => m,
                DisplayObject: () => le,
                ENV: () => d,
                Ellipse: () => Ht,
                Extract: () => Xn,
                FORMATS: () => _,
                FillStyle: () => Pr,
                Filter: () => tn,
                FilterState: () => gi,
                Framebuffer: () => Ke,
                GC_MODES: () => I,
                GLFramebuffer: () => bi,
                GLProgram: () => gn,
                GLTexture: () => bn,
                GRAPHICS_CURVES: () => Tr,
                Geometry: () => ui,
                Graphics: () => Qr,
                GraphicsData: () => jr,
                GraphicsGeometry: () => qr,
                IGLUniformData: () => fn,
                InteractionData: () => Se,
                InteractionEvent: () => be,
                InteractionManager: () => we,
                InteractionTrackingData: () => Te,
                LINE_CAP: () => yr,
                LINE_JOIN: () => _r,
                LineStyle: () => Zr,
                Loader: () => pr,
                LoaderResource: () => ur,
                MASK_TYPES: () => E,
                MIPMAP_MODES: () => T,
                MSAA_QUALITY: () => C,
                MaskData: () => Ei,
                Matrix: () => qt,
                Mesh: () => Yo,
                MeshBatchUvs: () => Vo,
                MeshGeometry: () => zo,
                MeshMaterial: () => jo,
                NineSlicePlane: () => qs,
                ObjectRenderer: () => _i,
                ObservablePoint: () => Kt,
                PI_2: () => Ut,
                PRECISION: () => w,
                ParticleContainer: () => Sr,
                ParticleRenderer: () => br,
                PlaneGeometry: () => Hs,
                Point: () => zt,
                Polygon: () => Yt,
                Prepare: () => xo,
                Program: () => $i,
                Quad: () => ci,
                QuadUv: () => di,
                RAD_TO_DEG: () => Gt,
                RENDERER_TYPE: () => p,
                Rectangle: () => Vt,
                RenderTexture: () => ti,
                RenderTexturePool: () => ei,
                Renderer: () => wn,
                RopeGeometry: () => Ys,
                RoundedRectangle: () => jt,
                Runner: () => Ee,
                SCALE_MODES: () => v,
                SHAPES: () => kt,
                Shader: () => Ji,
                SimpleMesh: () => Ks,
                SimplePlane: () => zs,
                SimpleRope: () => js,
                Sprite: () => no,
                SpriteMaskFilter: () => rn,
                Spritesheet: () => Lo,
                SpritesheetLoader: () => Oo,
                State: () => Qi,
                System: () => je,
                TARGETS: () => y,
                TEXT_GRADIENT: () => Dr,
                TYPES: () => S,
                TemporaryDisplayObject: () => he,
                Text: () => go,
                TextMetrics: () => co,
                TextStyle: () => ao,
                Texture: () => Je,
                TextureLoader: () => dr,
                TextureMatrix: () => nn,
                TextureUvs: () => Ze,
                Ticker: () => _e,
                TickerPlugin: () => ye,
                TilingSprite: () => Do,
                TilingSpriteRenderer: () => Uo,
                TimeLimiter: () => Bo,
                Transform: () => re,
                UPDATE_PRIORITY: () => pe,
                UniformGroup: () => fi,
                VERSION: () => ia,
                ViewableBuffer: () => On,
                WRAP_MODES: () => b,
                accessibleTarget: () => de,
                autoDetectRenderer: () => En,
                checkMaxIfStatementsInShader: () => Ki,
                defaultFilterVertex: () => xn,
                defaultVertex: () => Cn,
                filters: () => na,
                graphicsUtils: () => Yr,
                groupD8: () => ne,
                interactiveTarget: () => Ae,
                isMobile: () => Y,
                resources: () => Ye,
                settings: () => j,
                systems: () => Pn,
                uniformParsers: () => Xi,
                useDeprecated: () => ea,
                utils: () => n
            });
            var n = {};
            i.r(n), i.d(n, {
                BaseTextureCache: () => Ct,
                CanvasRenderTarget: () => Lt,
                DATA_URI: () => Mt,
                EventEmitter: () => K(),
                ProgramCache: () => wt,
                TextureCache: () => Et,
                clearTextureCache: () => Bt,
                correctBlendMode: () => ht,
                createIndicesForQuads: () => pt,
                decomposeDataUri: () => Rt,
                deprecation: () => It,
                destroyTextureCache: () => xt,
                determineCrossOrigin: () => Dt,
                earcut: () => Z(),
                getBufferType: () => ft,
                getResolutionOfUrl: () => Ft,
                hex2rgb: () => rt,
                hex2string: () => ot,
                interleaveTypedArrays: () => mt,
                isMobile: () => Y,
                isPow2: () => yt,
                isWebGLSupported: () => nt,
                log2: () => St,
                nextPow2: () => _t,
                premultiplyBlendMode: () => lt,
                premultiplyRgba: () => ut,
                premultiplyTint: () => ct,
                premultiplyTintToRgba: () => dt,
                removeItems: () => vt,
                rgb2hex: () => at,
                sayHello: () => it,
                sign: () => bt,
                skipHello: () => et,
                string2hex: () => st,
                trimCanvas: () => Ot,
                uid: () => Pt,
                url: () => $
            });
            var r = i(6713),
                o = i(7418),
                s = i.n(o);
            if (window.Promise || (window.Promise = r.Polyfill), Object.assign || (Object.assign = s()), Date.now && Date.prototype.getTime || (Date.now = function () {
                return (new Date).getTime()
            }), !window.performance || !window.performance.now) {
                var a = Date.now();
                window.performance || (window.performance = {}), window.performance.now = function () {
                    return Date.now() - a
                }
            }
            for (var l = Date.now(), h = ["ms", "moz", "webkit", "o"], u = 0; u < h.length && !window.requestAnimationFrame; ++u) {
                var c = h[u];
                window.requestAnimationFrame = window[c + "RequestAnimationFrame"], window.cancelAnimationFrame = window[c + "CancelAnimationFrame"] || window[c + "CancelRequestAnimationFrame"]
            }
            window.requestAnimationFrame || (window.requestAnimationFrame = function (t) {
                if ("function" != typeof t) throw new TypeError(t + "is not a function");
                var e = Date.now(),
                    i = 16 + l - e;
                return i < 0 && (i = 0), l = e, window.setTimeout((function () {
                    l = Date.now(), t(performance.now())
                }), i)
            }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) {
                return clearTimeout(t)
            }), Math.sign || (Math.sign = function (t) {
                return 0 === (t = Number(t)) || isNaN(t) ? t : t > 0 ? 1 : -1
            }), Number.isInteger || (Number.isInteger = function (t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), window.ArrayBuffer || (window.ArrayBuffer = Array), window.Float32Array || (window.Float32Array = Array), window.Uint32Array || (window.Uint32Array = Array), window.Uint16Array || (window.Uint16Array = Array), window.Uint8Array || (window.Uint8Array = Array), window.Int32Array || (window.Int32Array = Array);
            var d, p, f, g, m, _, y, S, v, b, T, P, A, I, w, E, C, x = /iPhone/i,
                B = /iPod/i,
                L = /iPad/i,
                O = /\biOS-universal(?:.+)Mac\b/i,
                N = /\bAndroid(?:.+)Mobile\b/i,
                M = /Android/i,
                R = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
                D = /Silk/i,
                F = /Windows Phone/i,
                k = /\bWindows(?:.+)ARM\b/i,
                U = /BlackBerry/i,
                G = /BB10/i,
                W = /Opera Mini/i,
                V = /\b(CriOS|Chrome)(?:.+)Mobile/i,
                X = /Mobile(?:.+)Firefox\b/i,
                H = function (t) {
                    return void 0 !== t && "MacIntel" === t.platform && "number" == typeof t.maxTouchPoints && t.maxTouchPoints > 1 && "undefined" == typeof MSStream
                },
                Y = function (t) {
                    var e = {
                        userAgent: "",
                        platform: "",
                        maxTouchPoints: 0
                    };
                    t || "undefined" == typeof navigator ? "string" == typeof t ? e.userAgent = t : t && t.userAgent && (e = {
                        userAgent: t.userAgent,
                        platform: t.platform,
                        maxTouchPoints: t.maxTouchPoints || 0
                    }) : e = {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        maxTouchPoints: navigator.maxTouchPoints || 0
                    };
                    var i = e.userAgent,
                        n = i.split("[FBAN");
                    void 0 !== n[1] && (i = n[0]), void 0 !== (n = i.split("Twitter"))[1] && (i = n[0]);
                    var r = function (t) {
                        return function (e) {
                            return e.test(t)
                        }
                    }(i),
                        o = {
                            apple: {
                                phone: r(x) && !r(F),
                                ipod: r(B),
                                tablet: !r(x) && (r(L) || H(e)) && !r(F),
                                universal: r(O),
                                device: (r(x) || r(B) || r(L) || r(O) || H(e)) && !r(F)
                            },
                            amazon: {
                                phone: r(R),
                                tablet: !r(R) && r(D),
                                device: r(R) || r(D)
                            },
                            android: {
                                phone: !r(F) && r(R) || !r(F) && r(N),
                                tablet: !r(F) && !r(R) && !r(N) && (r(D) || r(M)),
                                device: !r(F) && (r(R) || r(D) || r(N) || r(M)) || r(/\bokhttp\b/i)
                            },
                            windows: {
                                phone: r(F),
                                tablet: r(k),
                                device: r(F) || r(k)
                            },
                            other: {
                                blackberry: r(U),
                                blackberry10: r(G),
                                opera: r(W),
                                firefox: r(X),
                                chrome: r(V),
                                device: r(U) || r(G) || r(W) || r(X) || r(V)
                            },
                            any: !1,
                            phone: !1,
                            tablet: !1
                        };
                    return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o
                }(window.navigator),
                j = {
                    MIPMAP_TEXTURES: 1,
                    ANISOTROPIC_LEVEL: 0,
                    RESOLUTION: 1,
                    FILTER_RESOLUTION: 1,
                    SPRITE_MAX_TEXTURES: function (t) {
                        var e, i = !0;
                        (Y.tablet || Y.phone) && (Y.apple.device && (e = navigator.userAgent.match(/OS (\d+)_(\d+)?/)) && parseInt(e[1], 10) < 11 && (i = !1), Y.android.device && (e = navigator.userAgent.match(/Android\s([0-9.]*)/)) && parseInt(e[1], 10) < 7 && (i = !1));
                        return i ? 32 : 4
                    }(),
                    SPRITE_BATCH_SIZE: 4096,
                    RENDER_OPTIONS: {
                        view: null,
                        antialias: !1,
                        autoDensity: !1,
                        transparent: !1,
                        backgroundColor: 0,
                        clearBeforeRender: !0,
                        preserveDrawingBuffer: !1,
                        width: 800,
                        height: 600,
                        legacy: !1
                    },
                    GC_MODE: 0,
                    GC_MAX_IDLE: 3600,
                    GC_MAX_CHECK_COUNT: 600,
                    WRAP_MODE: 33071,
                    SCALE_MODE: 1,
                    PRECISION_VERTEX: "highp",
                    PRECISION_FRAGMENT: Y.apple.device ? "highp" : "mediump",
                    CAN_UPLOAD_SAME_BUFFER: !Y.apple.device,
                    CREATE_IMAGE_BITMAP: !1,
                    ROUND_PIXELS: !1
                },
                z = i(6729),
                K = i.n(z),
                q = i(9187),
                Z = i.n(q),
                $ = i(8575);
            ! function (t) {
                t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
            }(d || (d = {})),
                function (t) {
                    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
                }(p || (p = {})),
                function (t) {
                    t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
                }(f || (f = {})),
                function (t) {
                    t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
                }(g || (g = {})),
                function (t) {
                    t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
                }(m || (m = {})),
                function (t) {
                    t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
                }(_ || (_ = {})),
                function (t) {
                    t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
                }(y || (y = {})),
                function (t) {
                    t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.FLOAT = 5126] = "FLOAT", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
                }(S || (S = {})),
                function (t) {
                    t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
                }(v || (v = {})),
                function (t) {
                    t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
                }(b || (b = {})),
                function (t) {
                    t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON"
                }(T || (T = {})),
                function (t) {
                    t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA"
                }(P || (P = {})),
                function (t) {
                    t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
                }(A || (A = {})),
                function (t) {
                    t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
                }(I || (I = {})),
                function (t) {
                    t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
                }(w || (w = {})),
                function (t) {
                    t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
                }(E || (E = {})),
                function (t) {
                    t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
                }(C || (C = {})), j.RETINA_PREFIX = /@([0-9\.]+)x/, j.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !0;
            var J, Q = !1,
                tt = "5.3.12";

            function et() {
                Q = !0
            }

            function it(t) {
                var e;
                if (!Q) {
                    if (navigator.userAgent.toLowerCase().indexOf("chrome") > -1) {
                        var i = ["\n %c %c %c PixiJS " + tt + " -  " + t + "   %c  %c  http://www.pixijs.com/  %c %c %c%c \n\n", "background: #ff66a5; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff66a5; background: #030307; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "background: #ffc3dc; padding:5px 0;", "background: #ff66a5; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;", "color: #ff2424; background: #fff; padding:5px 0;"];
                        (e = window.console).log.apply(e, i)
                    } else window.console && window.console.log("PixiJS " + tt + " - " + t + " - http://www.pixijs.com/");
                    Q = !0
                }
            }

            function nt() {
                return void 0 === J && (J = function () {
                    var t = {
                        stencil: !0,
                        failIfMajorPerformanceCaveat: j.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
                    };
                    try {
                        if (!window.WebGLRenderingContext) return !1;
                        var e = document.createElement("canvas"),
                            i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t),
                            n = !(!i || !i.getContextAttributes().stencil);
                        if (i) {
                            var r = i.getExtension("WEBGL_lose_context");
                            r && r.loseContext()
                        }
                        return i = null, n
                    } catch (t) {
                        return !1
                    }
                }()), J
            }

            function rt(t, e) {
                return void 0 === e && (e = []), e[0] = (t >> 16 & 255) / 255, e[1] = (t >> 8 & 255) / 255, e[2] = (255 & t) / 255, e
            }

            function ot(t) {
                var e = t.toString(16);
                return "#" + ("000000".substr(0, 6 - e.length) + e)
            }

            function st(t) {
                return "string" == typeof t && "#" === t[0] && (t = t.substr(1)), parseInt(t, 16)
            }

            function at(t) {
                return (255 * t[0] << 16) + (255 * t[1] << 8) + (255 * t[2] | 0)
            }
            var lt = function () {
                for (var t = [], e = [], i = 0; i < 32; i++) t[i] = i, e[i] = i;
                t[g.NORMAL_NPM] = g.NORMAL, t[g.ADD_NPM] = g.ADD, t[g.SCREEN_NPM] = g.SCREEN, e[g.NORMAL] = g.NORMAL_NPM, e[g.ADD] = g.ADD_NPM, e[g.SCREEN] = g.SCREEN_NPM;
                var n = [];
                return n.push(e), n.push(t), n
            }();

            function ht(t, e) {
                return lt[e ? 1 : 0][t]
            }

            function ut(t, e, i, n) {
                return i = i || new Float32Array(4), n || void 0 === n ? (i[0] = t[0] * e, i[1] = t[1] * e, i[2] = t[2] * e) : (i[0] = t[0], i[1] = t[1], i[2] = t[2]), i[3] = e, i
            }

            function ct(t, e) {
                if (1 === e) return (255 * e << 24) + t;
                if (0 === e) return 0;
                var i = t >> 16 & 255,
                    n = t >> 8 & 255,
                    r = 255 & t;
                return (255 * e << 24) + ((i = i * e + .5 | 0) << 16) + ((n = n * e + .5 | 0) << 8) + (r * e + .5 | 0)
            }

            function dt(t, e, i, n) {
                return (i = i || new Float32Array(4))[0] = (t >> 16 & 255) / 255, i[1] = (t >> 8 & 255) / 255, i[2] = (255 & t) / 255, (n || void 0 === n) && (i[0] *= e, i[1] *= e, i[2] *= e), i[3] = e, i
            }

            function pt(t, e) {
                void 0 === e && (e = null);
                var i = 6 * t;
                if ((e = e || new Uint16Array(i)).length !== i) throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + i);
                for (var n = 0, r = 0; n < i; n += 6, r += 4) e[n + 0] = r + 0, e[n + 1] = r + 1, e[n + 2] = r + 2, e[n + 3] = r + 0, e[n + 4] = r + 2, e[n + 5] = r + 3;
                return e
            }

            function ft(t) {
                if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
                if (2 === t.BYTES_PER_ELEMENT) {
                    if (t instanceof Uint16Array) return "Uint16Array"
                } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
                return null
            }
            var gt = {
                Float32Array,
                Uint32Array,
                Int32Array,
                Uint8Array
            };

            function mt(t, e) {
                for (var i = 0, n = 0, r = {}, o = 0; o < t.length; o++) n += e[o], i += t[o].length;
                var s = new ArrayBuffer(4 * i),
                    a = null,
                    l = 0;
                for (o = 0; o < t.length; o++) {
                    var h = e[o],
                        u = t[o],
                        c = ft(u);
                    r[c] || (r[c] = new gt[c](s)), a = r[c];
                    for (var d = 0; d < u.length; d++) a[(d / h | 0) * n + l + d % h] = u[d];
                    l += h
                }
                return new Float32Array(s)
            }

            function _t(t) {
                return t += 0 === t ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, 1 + (t |= t >>> 16)
            }

            function yt(t) {
                return !(t & t - 1 || !t)
            }

            function St(t) {
                var e = (t > 65535 ? 1 : 0) << 4,
                    i = ((t >>>= e) > 255 ? 1 : 0) << 3;
                return e |= i, e |= i = ((t >>>= i) > 15 ? 1 : 0) << 2, (e |= i = ((t >>>= i) > 3 ? 1 : 0) << 1) | (t >>>= i) >> 1
            }

            function vt(t, e, i) {
                var n, r = t.length;
                if (!(e >= r || 0 === i)) {
                    var o = r - (i = e + i > r ? r - e : i);
                    for (n = e; n < o; ++n) t[n] = t[n + i];
                    t.length = o
                }
            }

            function bt(t) {
                return 0 === t ? 0 : t < 0 ? -1 : 1
            }
            var Tt = 0;

            function Pt() {
                return ++Tt
            }
            var At = {};

            function It(t, e, i) {
                if (void 0 === i && (i = 3), !At[e]) {
                    var n = (new Error).stack;
                    void 0 === n ? console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t) : (n = n.split("\n").splice(i).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + "\nDeprecated since v" + t), console.warn(n), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + "\nDeprecated since v" + t), console.warn(n))), At[e] = !0
                }
            }
            var wt = {},
                Et = Object.create(null),
                Ct = Object.create(null);

            function xt() {
                var t;
                for (t in Et) Et[t].destroy();
                for (t in Ct) Ct[t].destroy()
            }

            function Bt() {
                var t;
                for (t in Et) delete Et[t];
                for (t in Ct) delete Ct[t]
            }
            var Lt = function () {
                function t(t, e, i) {
                    this.canvas = document.createElement("canvas"), this.context = this.canvas.getContext("2d"), this.resolution = i || j.RESOLUTION, this.resize(t, e)
                }
                return t.prototype.clear = function () {
                    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
                }, t.prototype.resize = function (t, e) {
                    this.canvas.width = t * this.resolution, this.canvas.height = e * this.resolution
                }, t.prototype.destroy = function () {
                    this.context = null, this.canvas = null
                }, Object.defineProperty(t.prototype, "width", {
                    get: function () {
                        return this.canvas.width
                    },
                    set: function (t) {
                        this.canvas.width = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "height", {
                    get: function () {
                        return this.canvas.height
                    },
                    set: function (t) {
                        this.canvas.height = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), t
            }();

            function Ot(t) {
                var e, i, n, r = t.width,
                    o = t.height,
                    s = t.getContext("2d"),
                    a = s.getImageData(0, 0, r, o).data,
                    l = a.length,
                    h = {
                        top: null,
                        left: null,
                        right: null,
                        bottom: null
                    },
                    u = null;
                for (e = 0; e < l; e += 4) 0 !== a[e + 3] && (i = e / 4 % r, n = ~~(e / 4 / r), null === h.top && (h.top = n), (null === h.left || i < h.left) && (h.left = i), (null === h.right || h.right < i) && (h.right = i + 1), (null === h.bottom || h.bottom < n) && (h.bottom = n));
                return null !== h.top && (r = h.right - h.left, o = h.bottom - h.top + 1, u = s.getImageData(h.left, h.top, r, o)), {
                    height: o,
                    width: r,
                    data: u
                }
            }
            var Nt, Mt = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

            function Rt(t) {
                var e = Mt.exec(t);
                if (e) return {
                    mediaType: e[1] ? e[1].toLowerCase() : void 0,
                    subType: e[2] ? e[2].toLowerCase() : void 0,
                    charset: e[3] ? e[3].toLowerCase() : void 0,
                    encoding: e[4] ? e[4].toLowerCase() : void 0,
                    data: e[5]
                }
            }

            function Dt(t, e) {
                if (void 0 === e && (e = window.location), 0 === t.indexOf("data:")) return "";
                e = e || window.location, Nt || (Nt = document.createElement("a")), Nt.href = t;
                var i = (0, $.parse)(Nt.href),
                    n = !i.port && "" === e.port || i.port === e.port;
                return i.hostname === e.hostname && n && i.protocol === e.protocol ? "" : "anonymous"
            }

            function Ft(t, e) {
                var i = j.RETINA_PREFIX.exec(t);
                return i ? parseFloat(i[1]) : void 0 !== e ? e : 1
            }
            var kt, Ut = 2 * Math.PI,
                Gt = 180 / Math.PI,
                Wt = Math.PI / 180;
            ! function (t) {
                t[t.POLY = 0] = "POLY", t[t.RECT = 1] = "RECT", t[t.CIRC = 2] = "CIRC", t[t.ELIP = 3] = "ELIP", t[t.RREC = 4] = "RREC"
            }(kt || (kt = {}));
            var Vt = function () {
                function t(t, e, i, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = Number(t), this.y = Number(e), this.width = Number(i), this.height = Number(n), this.type = kt.RECT
                }
                return Object.defineProperty(t.prototype, "left", {
                    get: function () {
                        return this.x
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "right", {
                    get: function () {
                        return this.x + this.width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "top", {
                    get: function () {
                        return this.y
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "bottom", {
                    get: function () {
                        return this.y + this.height
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t, "EMPTY", {
                    get: function () {
                        return new t(0, 0, 0, 0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.clone = function () {
                    return new t(this.x, this.y, this.width, this.height)
                }, t.prototype.copyFrom = function (t) {
                    return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
                }, t.prototype.copyTo = function (t) {
                    return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                }, t.prototype.contains = function (t, e) {
                    return !(this.width <= 0 || this.height <= 0) && t >= this.x && t < this.x + this.width && e >= this.y && e < this.y + this.height
                }, t.prototype.pad = function (t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = t), this.x -= t, this.y -= e, this.width += 2 * t, this.height += 2 * e, this
                }, t.prototype.fit = function (t) {
                    var e = Math.max(this.x, t.x),
                        i = Math.min(this.x + this.width, t.x + t.width),
                        n = Math.max(this.y, t.y),
                        r = Math.min(this.y + this.height, t.y + t.height);
                    return this.x = e, this.width = Math.max(i - e, 0), this.y = n, this.height = Math.max(r - n, 0), this
                }, t.prototype.ceil = function (t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = .001);
                    var i = Math.ceil((this.x + this.width - e) * t) / t,
                        n = Math.ceil((this.y + this.height - e) * t) / t;
                    return this.x = Math.floor((this.x + e) * t) / t, this.y = Math.floor((this.y + e) * t) / t, this.width = i - this.x, this.height = n - this.y, this
                }, t.prototype.enlarge = function (t) {
                    var e = Math.min(this.x, t.x),
                        i = Math.max(this.x + this.width, t.x + t.width),
                        n = Math.min(this.y, t.y),
                        r = Math.max(this.y + this.height, t.y + t.height);
                    return this.x = e, this.width = i - e, this.y = n, this.height = r - n, this
                }, t
            }(),
                Xt = function () {
                    function t(t, e, i) {
                        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = t, this.y = e, this.radius = i, this.type = kt.CIRC
                    }
                    return t.prototype.clone = function () {
                        return new t(this.x, this.y, this.radius)
                    }, t.prototype.contains = function (t, e) {
                        if (this.radius <= 0) return !1;
                        var i = this.radius * this.radius,
                            n = this.x - t,
                            r = this.y - e;
                        return (n *= n) + (r *= r) <= i
                    }, t.prototype.getBounds = function () {
                        return new Vt(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
                    }, t
                }(),
                Ht = function () {
                    function t(t, e, i, n) {
                        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.width = i, this.height = n, this.type = kt.ELIP
                    }
                    return t.prototype.clone = function () {
                        return new t(this.x, this.y, this.width, this.height)
                    }, t.prototype.contains = function (t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = (t - this.x) / this.width,
                            n = (e - this.y) / this.height;
                        return (i *= i) + (n *= n) <= 1
                    }, t.prototype.getBounds = function () {
                        return new Vt(this.x - this.width, this.y - this.height, this.width, this.height)
                    }, t
                }(),
                Yt = function () {
                    function t() {
                        for (var t = arguments, e = [], i = 0; i < arguments.length; i++) e[i] = t[i];
                        var n = Array.isArray(e[0]) ? e[0] : e;
                        if ("number" != typeof n[0]) {
                            for (var r = [], o = 0, s = n.length; o < s; o++) r.push(n[o].x, n[o].y);
                            n = r
                        }
                        this.points = n, this.type = kt.POLY, this.closeStroke = !0
                    }
                    return t.prototype.clone = function () {
                        var e = new t(this.points.slice());
                        return e.closeStroke = this.closeStroke, e
                    }, t.prototype.contains = function (t, e) {
                        for (var i = !1, n = this.points.length / 2, r = 0, o = n - 1; r < n; o = r++) {
                            var s = this.points[2 * r],
                                a = this.points[2 * r + 1],
                                l = this.points[2 * o],
                                h = this.points[2 * o + 1];
                            a > e != h > e && t < (e - a) / (h - a) * (l - s) + s && (i = !i)
                        }
                        return i
                    }, t
                }(),
                jt = function () {
                    function t(t, e, i, n, r) {
                        void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === r && (r = 20), this.x = t, this.y = e, this.width = i, this.height = n, this.radius = r, this.type = kt.RREC
                    }
                    return t.prototype.clone = function () {
                        return new t(this.x, this.y, this.width, this.height, this.radius)
                    }, t.prototype.contains = function (t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        if (t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height) {
                            if (e >= this.y + this.radius && e <= this.y + this.height - this.radius || t >= this.x + this.radius && t <= this.x + this.width - this.radius) return !0;
                            var i = t - (this.x + this.radius),
                                n = e - (this.y + this.radius),
                                r = this.radius * this.radius;
                            if (i * i + n * n <= r) return !0;
                            if ((i = t - (this.x + this.width - this.radius)) * i + n * n <= r) return !0;
                            if (i * i + (n = e - (this.y + this.height - this.radius)) * n <= r) return !0;
                            if ((i = t - (this.x + this.radius)) * i + n * n <= r) return !0
                        }
                        return !1
                    }, t
                }(),
                zt = function () {
                    function t(t, e) {
                        void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e
                    }
                    return t.prototype.clone = function () {
                        return new t(this.x, this.y)
                    }, t.prototype.copyFrom = function (t) {
                        return this.set(t.x, t.y), this
                    }, t.prototype.copyTo = function (t) {
                        return t.set(this.x, this.y), t
                    }, t.prototype.equals = function (t) {
                        return t.x === this.x && t.y === this.y
                    }, t.prototype.set = function (t, e) {
                        return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this
                    }, t
                }(),
                Kt = function () {
                    function t(t, e, i, n) {
                        void 0 === i && (i = 0), void 0 === n && (n = 0), this._x = i, this._y = n, this.cb = t, this.scope = e
                    }
                    return t.prototype.clone = function (e, i) {
                        return void 0 === e && (e = this.cb), void 0 === i && (i = this.scope), new t(e, i, this._x, this._y)
                    }, t.prototype.set = function (t, e) {
                        return void 0 === t && (t = 0), void 0 === e && (e = t), this._x === t && this._y === e || (this._x = t, this._y = e, this.cb.call(this.scope)), this
                    }, t.prototype.copyFrom = function (t) {
                        return this._x === t.x && this._y === t.y || (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
                    }, t.prototype.copyTo = function (t) {
                        return t.set(this._x, this._y), t
                    }, t.prototype.equals = function (t) {
                        return t.x === this._x && t.y === this._y
                    }, Object.defineProperty(t.prototype, "x", {
                        get: function () {
                            return this._x
                        },
                        set: function (t) {
                            this._x !== t && (this._x = t, this.cb.call(this.scope))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "y", {
                        get: function () {
                            return this._y
                        },
                        set: function (t) {
                            this._y !== t && (this._y = t, this.cb.call(this.scope))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(),
                qt = function () {
                    function t(t, e, i, n, r, o) {
                        void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === o && (o = 0), this.array = null, this.a = t, this.b = e, this.c = i, this.d = n, this.tx = r, this.ty = o
                    }
                    return t.prototype.fromArray = function (t) {
                        this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
                    }, t.prototype.set = function (t, e, i, n, r, o) {
                        return this.a = t, this.b = e, this.c = i, this.d = n, this.tx = r, this.ty = o, this
                    }, t.prototype.toArray = function (t, e) {
                        this.array || (this.array = new Float32Array(9));
                        var i = e || this.array;
                        return t ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i
                    }, t.prototype.apply = function (t, e) {
                        e = e || new zt;
                        var i = t.x,
                            n = t.y;
                        return e.x = this.a * i + this.c * n + this.tx, e.y = this.b * i + this.d * n + this.ty, e
                    }, t.prototype.applyInverse = function (t, e) {
                        e = e || new zt;
                        var i = 1 / (this.a * this.d + this.c * -this.b),
                            n = t.x,
                            r = t.y;
                        return e.x = this.d * i * n + -this.c * i * r + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * r + -this.b * i * n + (-this.ty * this.a + this.tx * this.b) * i, e
                    }, t.prototype.translate = function (t, e) {
                        return this.tx += t, this.ty += e, this
                    }, t.prototype.scale = function (t, e) {
                        return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                    }, t.prototype.rotate = function (t) {
                        var e = Math.cos(t),
                            i = Math.sin(t),
                            n = this.a,
                            r = this.c,
                            o = this.tx;
                        return this.a = n * e - this.b * i, this.b = n * i + this.b * e, this.c = r * e - this.d * i, this.d = r * i + this.d * e, this.tx = o * e - this.ty * i, this.ty = o * i + this.ty * e, this
                    }, t.prototype.append = function (t) {
                        var e = this.a,
                            i = this.b,
                            n = this.c,
                            r = this.d;
                        return this.a = t.a * e + t.b * n, this.b = t.a * i + t.b * r, this.c = t.c * e + t.d * n, this.d = t.c * i + t.d * r, this.tx = t.tx * e + t.ty * n + this.tx, this.ty = t.tx * i + t.ty * r + this.ty, this
                    }, t.prototype.setTransform = function (t, e, i, n, r, o, s, a, l) {
                        return this.a = Math.cos(s + l) * r, this.b = Math.sin(s + l) * r, this.c = -Math.sin(s - a) * o, this.d = Math.cos(s - a) * o, this.tx = t - (i * this.a + n * this.c), this.ty = e - (i * this.b + n * this.d), this
                    }, t.prototype.prepend = function (t) {
                        var e = this.tx;
                        if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
                            var i = this.a,
                                n = this.c;
                            this.a = i * t.a + this.b * t.c, this.b = i * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d
                        }
                        return this.tx = e * t.a + this.ty * t.c + t.tx, this.ty = e * t.b + this.ty * t.d + t.ty, this
                    }, t.prototype.decompose = function (t) {
                        var e = this.a,
                            i = this.b,
                            n = this.c,
                            r = this.d,
                            o = -Math.atan2(-n, r),
                            s = Math.atan2(i, e),
                            a = Math.abs(o + s);
                        return a < 1e-5 || Math.abs(Ut - a) < 1e-5 ? (t.rotation = s, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = o, t.skew.y = s), t.scale.x = Math.sqrt(e * e + i * i), t.scale.y = Math.sqrt(n * n + r * r), t.position.x = this.tx, t.position.y = this.ty, t
                    }, t.prototype.invert = function () {
                        var t = this.a,
                            e = this.b,
                            i = this.c,
                            n = this.d,
                            r = this.tx,
                            o = t * n - e * i;
                        return this.a = n / o, this.b = -e / o, this.c = -i / o, this.d = t / o, this.tx = (i * this.ty - n * r) / o, this.ty = -(t * this.ty - e * r) / o, this
                    }, t.prototype.identity = function () {
                        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
                    }, t.prototype.clone = function () {
                        var e = new t;
                        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
                    }, t.prototype.copyTo = function (t) {
                        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
                    }, t.prototype.copyFrom = function (t) {
                        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                    }, Object.defineProperty(t, "IDENTITY", {
                        get: function () {
                            return new t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t, "TEMP_MATRIX", {
                        get: function () {
                            return new t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(),
                Zt = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
                $t = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
                Jt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
                Qt = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
                te = [],
                ee = [],
                ie = Math.sign;
            ! function () {
                for (var t = 0; t < 16; t++) {
                    var e = [];
                    te.push(e);
                    for (var i = 0; i < 16; i++)
                        for (var n = ie(Zt[t] * Zt[i] + Jt[t] * $t[i]), r = ie($t[t] * Zt[i] + Qt[t] * $t[i]), o = ie(Zt[t] * Jt[i] + Jt[t] * Qt[i]), s = ie($t[t] * Jt[i] + Qt[t] * Qt[i]), a = 0; a < 16; a++)
                            if (Zt[a] === n && $t[a] === r && Jt[a] === o && Qt[a] === s) {
                                e.push(a);
                                break
                            }
                }
                for (t = 0; t < 16; t++) {
                    var l = new qt;
                    l.set(Zt[t], $t[t], Jt[t], Qt[t], 0, 0), ee.push(l)
                }
            }();
            var ne = {
                E: 0,
                SE: 1,
                S: 2,
                SW: 3,
                W: 4,
                NW: 5,
                N: 6,
                NE: 7,
                MIRROR_VERTICAL: 8,
                MAIN_DIAGONAL: 10,
                MIRROR_HORIZONTAL: 12,
                REVERSE_DIAGONAL: 14,
                uX: function (t) {
                    return Zt[t]
                },
                uY: function (t) {
                    return $t[t]
                },
                vX: function (t) {
                    return Jt[t]
                },
                vY: function (t) {
                    return Qt[t]
                },
                inv: function (t) {
                    return 8 & t ? 15 & t : 7 & -t
                },
                add: function (t, e) {
                    return te[t][e]
                },
                sub: function (t, e) {
                    return te[t][ne.inv(e)]
                },
                rotate180: function (t) {
                    return 4 ^ t
                },
                isVertical: function (t) {
                    return 2 == (3 & t)
                },
                byDirection: function (t, e) {
                    return 2 * Math.abs(t) <= Math.abs(e) ? e >= 0 ? ne.S : ne.N : 2 * Math.abs(e) <= Math.abs(t) ? t > 0 ? ne.E : ne.W : e > 0 ? t > 0 ? ne.SE : ne.SW : t > 0 ? ne.NE : ne.NW
                },
                matrixAppendRotationInv: function (t, e, i, n) {
                    void 0 === i && (i = 0), void 0 === n && (n = 0);
                    var r = ee[ne.inv(e)];
                    r.tx = i, r.ty = n, t.append(r)
                }
            },
                re = function () {
                    function t() {
                        this.worldTransform = new qt, this.localTransform = new qt, this.position = new Kt(this.onChange, this, 0, 0), this.scale = new Kt(this.onChange, this, 1, 1), this.pivot = new Kt(this.onChange, this, 0, 0), this.skew = new Kt(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
                    }
                    return t.prototype.onChange = function () {
                        this._localID++
                    }, t.prototype.updateSkew = function () {
                        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
                    }, t.prototype.updateLocalTransform = function () {
                        var t = this.localTransform;
                        this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1)
                    }, t.prototype.updateTransform = function (t) {
                        var e = this.localTransform;
                        if (this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== t._worldID) {
                            var i = t.worldTransform,
                                n = this.worldTransform;
                            n.a = e.a * i.a + e.b * i.c, n.b = e.a * i.b + e.b * i.d, n.c = e.c * i.a + e.d * i.c, n.d = e.c * i.b + e.d * i.d, n.tx = e.tx * i.a + e.ty * i.c + i.tx, n.ty = e.tx * i.b + e.ty * i.d + i.ty, this._parentID = t._worldID, this._worldID++
                        }
                    }, t.prototype.setFromMatrix = function (t) {
                        t.decompose(this), this._localID++
                    }, Object.defineProperty(t.prototype, "rotation", {
                        get: function () {
                            return this._rotation
                        },
                        set: function (t) {
                            this._rotation !== t && (this._rotation = t, this.updateSkew())
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.IDENTITY = new t, t
                }();
            j.SORTABLE_CHILDREN = !1;
            var oe = function () {
                function t() {
                    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
                }
                return t.prototype.isEmpty = function () {
                    return this.minX > this.maxX || this.minY > this.maxY
                }, t.prototype.clear = function () {
                    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
                }, t.prototype.getRectangle = function (t) {
                    return this.minX > this.maxX || this.minY > this.maxY ? Vt.EMPTY : ((t = t || new Vt(0, 0, 1, 1)).x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
                }, t.prototype.addPoint = function (t) {
                    this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
                }, t.prototype.addQuad = function (t) {
                    var e = this.minX,
                        i = this.minY,
                        n = this.maxX,
                        r = this.maxY,
                        o = t[0],
                        s = t[1];
                    e = o < e ? o : e, i = s < i ? s : i, n = o > n ? o : n, r = s > r ? s : r, e = (o = t[2]) < e ? o : e, i = (s = t[3]) < i ? s : i, n = o > n ? o : n, r = s > r ? s : r, e = (o = t[4]) < e ? o : e, i = (s = t[5]) < i ? s : i, n = o > n ? o : n, r = s > r ? s : r, e = (o = t[6]) < e ? o : e, i = (s = t[7]) < i ? s : i, n = o > n ? o : n, r = s > r ? s : r, this.minX = e, this.minY = i, this.maxX = n, this.maxY = r
                }, t.prototype.addFrame = function (t, e, i, n, r) {
                    this.addFrameMatrix(t.worldTransform, e, i, n, r)
                }, t.prototype.addFrameMatrix = function (t, e, i, n, r) {
                    var o = t.a,
                        s = t.b,
                        a = t.c,
                        l = t.d,
                        h = t.tx,
                        u = t.ty,
                        c = this.minX,
                        d = this.minY,
                        p = this.maxX,
                        f = this.maxY,
                        g = o * e + a * i + h,
                        m = s * e + l * i + u;
                    c = g < c ? g : c, d = m < d ? m : d, p = g > p ? g : p, f = m > f ? m : f, c = (g = o * n + a * i + h) < c ? g : c, d = (m = s * n + l * i + u) < d ? m : d, p = g > p ? g : p, f = m > f ? m : f, c = (g = o * e + a * r + h) < c ? g : c, d = (m = s * e + l * r + u) < d ? m : d, p = g > p ? g : p, f = m > f ? m : f, c = (g = o * n + a * r + h) < c ? g : c, d = (m = s * n + l * r + u) < d ? m : d, p = g > p ? g : p, f = m > f ? m : f, this.minX = c, this.minY = d, this.maxX = p, this.maxY = f
                }, t.prototype.addVertexData = function (t, e, i) {
                    for (var n = this.minX, r = this.minY, o = this.maxX, s = this.maxY, a = e; a < i; a += 2) {
                        var l = t[a],
                            h = t[a + 1];
                        n = l < n ? l : n, r = h < r ? h : r, o = l > o ? l : o, s = h > s ? h : s
                    }
                    this.minX = n, this.minY = r, this.maxX = o, this.maxY = s
                }, t.prototype.addVertices = function (t, e, i, n) {
                    this.addVerticesMatrix(t.worldTransform, e, i, n)
                }, t.prototype.addVerticesMatrix = function (t, e, i, n, r, o) {
                    void 0 === r && (r = 0), void 0 === o && (o = r);
                    for (var s = t.a, a = t.b, l = t.c, h = t.d, u = t.tx, c = t.ty, d = this.minX, p = this.minY, f = this.maxX, g = this.maxY, m = i; m < n; m += 2) {
                        var _ = e[m],
                            y = e[m + 1],
                            S = s * _ + l * y + u,
                            v = h * y + a * _ + c;
                        d = Math.min(d, S - r), f = Math.max(f, S + r), p = Math.min(p, v - o), g = Math.max(g, v + o)
                    }
                    this.minX = d, this.minY = p, this.maxX = f, this.maxY = g
                }, t.prototype.addBounds = function (t) {
                    var e = this.minX,
                        i = this.minY,
                        n = this.maxX,
                        r = this.maxY;
                    this.minX = t.minX < e ? t.minX : e, this.minY = t.minY < i ? t.minY : i, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > r ? t.maxY : r
                }, t.prototype.addBoundsMask = function (t, e) {
                    var i = t.minX > e.minX ? t.minX : e.minX,
                        n = t.minY > e.minY ? t.minY : e.minY,
                        r = t.maxX < e.maxX ? t.maxX : e.maxX,
                        o = t.maxY < e.maxY ? t.maxY : e.maxY;
                    if (i <= r && n <= o) {
                        var s = this.minX,
                            a = this.minY,
                            l = this.maxX,
                            h = this.maxY;
                        this.minX = i < s ? i : s, this.minY = n < a ? n : a, this.maxX = r > l ? r : l, this.maxY = o > h ? o : h
                    }
                }, t.prototype.addBoundsMatrix = function (t, e) {
                    this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
                }, t.prototype.addBoundsArea = function (t, e) {
                    var i = t.minX > e.x ? t.minX : e.x,
                        n = t.minY > e.y ? t.minY : e.y,
                        r = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
                        o = t.maxY < e.y + e.height ? t.maxY : e.y + e.height;
                    if (i <= r && n <= o) {
                        var s = this.minX,
                            a = this.minY,
                            l = this.maxX,
                            h = this.maxY;
                        this.minX = i < s ? i : s, this.minY = n < a ? n : a, this.maxX = r > l ? r : l, this.maxY = o > h ? o : h
                    }
                }, t.prototype.pad = function (t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = t), this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= e, this.maxY += e)
                }, t.prototype.addFramePad = function (t, e, i, n, r, o) {
                    t -= r, e -= o, i += r, n += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > i ? this.maxX : i, this.minY = this.minY < e ? this.minY : e, this.maxY = this.maxY > n ? this.maxY : n
                }, t
            }(),
                se = function (t, e) {
                    return se = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, se(t, e)
                };

            function ae(t, e) {
                function i() {
                    this.constructor = t
                }
                se(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var le = function (t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.tempDisplayObjectParent = null, e.transform = new re, e.alpha = 1, e.visible = !0, e.renderable = !0, e.parent = null, e.worldAlpha = 1, e._lastSortedIndex = 0, e._zIndex = 0, e.filterArea = null, e.filters = null, e._enabledFilters = null, e._bounds = new oe, e._localBounds = null, e._boundsID = 0, e._boundsRect = null, e._localBoundsRect = null, e._mask = null, e._destroyed = !1, e.isSprite = !1, e.isMask = !1, e
                }
                return ae(e, t), e.mixin = function (t) {
                    for (var i = Object.keys(t), n = 0; n < i.length; ++n) {
                        var r = i[n];
                        Object.defineProperty(e.prototype, r, Object.getOwnPropertyDescriptor(t, r))
                    }
                }, e.prototype._recursivePostUpdateTransform = function () {
                    this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
                }, e.prototype.updateTransform = function () {
                    this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
                }, e.prototype.getBounds = function (t, e) {
                    return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), e || (this._boundsRect || (this._boundsRect = new Vt), e = this._boundsRect), this._bounds.getRectangle(e)
                }, e.prototype.getLocalBounds = function (t) {
                    t || (this._localBoundsRect || (this._localBoundsRect = new Vt), t = this._localBoundsRect), this._localBounds || (this._localBounds = new oe);
                    var e = this.transform,
                        i = this.parent;
                    this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
                    var n = this._bounds,
                        r = this._boundsID;
                    this._bounds = this._localBounds;
                    var o = this.getBounds(!1, t);
                    return this.parent = i, this.transform = e, this._bounds = n, this._bounds.updateID += this._boundsID - r, o
                }, e.prototype.toGlobal = function (t, e, i) {
                    return void 0 === i && (i = !1), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, e)
                }, e.prototype.toLocal = function (t, e, i, n) {
                    return e && (t = e.toGlobal(t, i, n)), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, i)
                }, e.prototype.setParent = function (t) {
                    if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
                    return t.addChild(this), t
                }, e.prototype.setTransform = function (t, e, i, n, r, o, s, a, l) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 1), void 0 === n && (n = 1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === s && (s = 0), void 0 === a && (a = 0), void 0 === l && (l = 0), this.position.x = t, this.position.y = e, this.scale.x = i || 1, this.scale.y = n || 1, this.rotation = r, this.skew.x = o, this.skew.y = s, this.pivot.x = a, this.pivot.y = l, this
                }, e.prototype.destroy = function (t) {
                    this.parent && this.parent.removeChild(this), this.removeAllListeners(), this.transform = null, this.parent = null, this._bounds = null, this._mask = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this._destroyed = !0
                }, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", {
                    get: function () {
                        return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new he), this.tempDisplayObjectParent
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.enableTempParent = function () {
                    var t = this.parent;
                    return this.parent = this._tempDisplayObjectParent, t
                }, e.prototype.disableTempParent = function (t) {
                    this.parent = t
                }, Object.defineProperty(e.prototype, "x", {
                    get: function () {
                        return this.position.x
                    },
                    set: function (t) {
                        this.transform.position.x = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "y", {
                    get: function () {
                        return this.position.y
                    },
                    set: function (t) {
                        this.transform.position.y = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "worldTransform", {
                    get: function () {
                        return this.transform.worldTransform
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "localTransform", {
                    get: function () {
                        return this.transform.localTransform
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "position", {
                    get: function () {
                        return this.transform.position
                    },
                    set: function (t) {
                        this.transform.position.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "scale", {
                    get: function () {
                        return this.transform.scale
                    },
                    set: function (t) {
                        this.transform.scale.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "pivot", {
                    get: function () {
                        return this.transform.pivot
                    },
                    set: function (t) {
                        this.transform.pivot.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "skew", {
                    get: function () {
                        return this.transform.skew
                    },
                    set: function (t) {
                        this.transform.skew.copyFrom(t)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "rotation", {
                    get: function () {
                        return this.transform.rotation
                    },
                    set: function (t) {
                        this.transform.rotation = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "angle", {
                    get: function () {
                        return this.transform.rotation * Gt
                    },
                    set: function (t) {
                        this.transform.rotation = t * Wt
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "zIndex", {
                    get: function () {
                        return this._zIndex
                    },
                    set: function (t) {
                        this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "worldVisible", {
                    get: function () {
                        var t = this;
                        do {
                            if (!t.visible) return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "mask", {
                    get: function () {
                        return this._mask
                    },
                    set: function (t) {
                        var e;
                        this._mask && ((e = this._mask.maskObject || this._mask).renderable = !0, e.isMask = !1), this._mask = t, this._mask && ((e = this._mask.maskObject || this._mask).renderable = !1, e.isMask = !0)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(K()),
                he = function (t) {
                    function e() {
                        var e = null !== t && t.apply(this, arguments) || this;
                        return e.sortDirty = null, e
                    }
                    return ae(e, t), e
                }(le);

            function ue(t, e) {
                return t.zIndex === e.zIndex ? t._lastSortedIndex - e._lastSortedIndex : t.zIndex - e.zIndex
            }
            le.prototype.displayObjectUpdateTransform = le.prototype.updateTransform;
            var ce = function (t) {
                function e() {
                    var e = t.call(this) || this;
                    return e.children = [], e.sortableChildren = j.SORTABLE_CHILDREN, e.sortDirty = !1, e
                }
                return ae(e, t), e.prototype.onChildrenChange = function (t) { }, e.prototype.addChild = function () {
                    for (var t = arguments, e = [], i = 0; i < arguments.length; i++) e[i] = t[i];
                    if (e.length > 1)
                        for (var n = 0; n < e.length; n++) this.addChild(e[n]);
                    else {
                        var r = e[0];
                        r.parent && r.parent.removeChild(r), r.parent = this, this.sortDirty = !0, r.transform._parentID = -1, this.children.push(r), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", r, this, this.children.length - 1), r.emit("added", this)
                    }
                    return e[0]
                }, e.prototype.addChildAt = function (t, e) {
                    if (e < 0 || e > this.children.length) throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length);
                    return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(e, 0, t), this._boundsID++, this.onChildrenChange(e), t.emit("added", this), this.emit("childAdded", t, this, e), t
                }, e.prototype.swapChildren = function (t, e) {
                    if (t !== e) {
                        var i = this.getChildIndex(t),
                            n = this.getChildIndex(e);
                        this.children[i] = e, this.children[n] = t, this.onChildrenChange(i < n ? i : n)
                    }
                }, e.prototype.getChildIndex = function (t) {
                    var e = this.children.indexOf(t);
                    if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
                    return e
                }, e.prototype.setChildIndex = function (t, e) {
                    if (e < 0 || e >= this.children.length) throw new Error("The index " + e + " supplied is out of bounds " + this.children.length);
                    var i = this.getChildIndex(t);
                    vt(this.children, i, 1), this.children.splice(e, 0, t), this.onChildrenChange(e)
                }, e.prototype.getChildAt = function (t) {
                    if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Index (" + t + ") does not exist.");
                    return this.children[t]
                }, e.prototype.removeChild = function () {
                    for (var t = arguments, e = [], i = 0; i < arguments.length; i++) e[i] = t[i];
                    if (e.length > 1)
                        for (var n = 0; n < e.length; n++) this.removeChild(e[n]);
                    else {
                        var r = e[0],
                            o = this.children.indexOf(r);
                        if (-1 === o) return null;
                        r.parent = null, r.transform._parentID = -1, vt(this.children, o, 1), this._boundsID++, this.onChildrenChange(o), r.emit("removed", this), this.emit("childRemoved", r, this, o)
                    }
                    return e[0]
                }, e.prototype.removeChildAt = function (t) {
                    var e = this.getChildAt(t);
                    return e.parent = null, e.transform._parentID = -1, vt(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), e.emit("removed", this), this.emit("childRemoved", e, this, t), e
                }, e.prototype.removeChildren = function (t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
                    var i, n = t,
                        r = e - n;
                    if (r > 0 && r <= e) {
                        i = this.children.splice(n, r);
                        for (var o = 0; o < i.length; ++o) i[o].parent = null, i[o].transform && (i[o].transform._parentID = -1);
                        for (this._boundsID++, this.onChildrenChange(t), o = 0; o < i.length; ++o) i[o].emit("removed", this), this.emit("childRemoved", i[o], this, o);
                        return i
                    }
                    if (0 === r && 0 === this.children.length) return [];
                    throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
                }, e.prototype.sortChildren = function () {
                    for (var t = !1, e = 0, i = this.children.length; e < i; ++e) {
                        var n = this.children[e];
                        n._lastSortedIndex = e, t || 0 === n.zIndex || (t = !0)
                    }
                    t && this.children.length > 1 && this.children.sort(ue), this.sortDirty = !1
                }, e.prototype.updateTransform = function () {
                    this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
                    for (var t = 0, e = this.children.length; t < e; ++t) {
                        var i = this.children[t];
                        i.visible && i.updateTransform()
                    }
                }, e.prototype.calculateBounds = function () {
                    this._bounds.clear(), this._calculateBounds();
                    for (var t = 0; t < this.children.length; t++) {
                        var e = this.children[t];
                        if (e.visible && e.renderable)
                            if (e.calculateBounds(), e._mask) {
                                var i = e._mask.maskObject || e._mask;
                                i.calculateBounds(), this._bounds.addBoundsMask(e._bounds, i._bounds)
                            } else e.filterArea ? this._bounds.addBoundsArea(e._bounds, e.filterArea) : this._bounds.addBounds(e._bounds)
                    }
                    this._bounds.updateID = this._boundsID
                }, e.prototype.getLocalBounds = function (e, i) {
                    void 0 === i && (i = !1);
                    var n = t.prototype.getLocalBounds.call(this, e);
                    if (!i)
                        for (var r = 0, o = this.children.length; r < o; ++r) {
                            var s = this.children[r];
                            s.visible && s.updateTransform()
                        }
                    return n
                }, e.prototype._calculateBounds = function () { }, e.prototype.render = function (t) {
                    if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
                        if (this._mask || this.filters && this.filters.length) this.renderAdvanced(t);
                        else {
                            this._render(t);
                            for (var e = 0, i = this.children.length; e < i; ++e) this.children[e].render(t)
                        }
                }, e.prototype.renderAdvanced = function (t) {
                    t.batch.flush();
                    var e = this.filters,
                        i = this._mask;
                    if (e) {
                        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
                        for (var n = 0; n < e.length; n++) e[n].enabled && this._enabledFilters.push(e[n]);
                        this._enabledFilters.length && t.filter.push(this, this._enabledFilters)
                    }
                    i && t.mask.push(this, this._mask), this._render(t), n = 0;
                    for (var r = this.children.length; n < r; n++) this.children[n].render(t);
                    t.batch.flush(), i && t.mask.pop(this), e && this._enabledFilters && this._enabledFilters.length && t.filter.pop()
                }, e.prototype._render = function (t) { }, e.prototype.destroy = function (e) {
                    t.prototype.destroy.call(this), this.sortDirty = !1;
                    var i = "boolean" == typeof e ? e : e && e.children,
                        n = this.removeChildren(0, this.children.length);
                    if (i)
                        for (var r = 0; r < n.length; ++r) n[r].destroy(e)
                }, Object.defineProperty(e.prototype, "width", {
                    get: function () {
                        return this.scale.x * this.getLocalBounds().width
                    },
                    set: function (t) {
                        var e = this.getLocalBounds().width;
                        this.scale.x = 0 !== e ? t / e : 1, this._width = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "height", {
                    get: function () {
                        return this.scale.y * this.getLocalBounds().height
                    },
                    set: function (t) {
                        var e = this.getLocalBounds().height;
                        this.scale.y = 0 !== e ? t / e : 1, this._height = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(le);
            ce.prototype.containerUpdateTransform = ce.prototype.updateTransform;
            var de = {
                accessible: !1,
                accessibleTitle: null,
                accessibleHint: null,
                tabIndex: 0,
                _accessibleActive: !1,
                _accessibleDiv: null,
                accessibleType: "button",
                accessiblePointerEvents: "auto",
                accessibleChildren: !0,
                renderId: -1
            };
            le.mixin(de);
            var pe, fe = 100,
                ge = function () {
                    function t(t) {
                        this._hookDiv = null, (Y.tablet || Y.phone) && this.createTouchHook();
                        var e = document.createElement("div");
                        e.style.width = fe + "px", e.style.height = fe + "px", e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.style.zIndex = 2..toString(), this.div = e, this.pool = [], this.renderId = 0, this.debug = !1, this.renderer = t, this.children = [], this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._isActive = !1, this._isMobileAccessibility = !1, this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, window.addEventListener("keydown", this._onKeyDown, !1)
                    }
                    return Object.defineProperty(t.prototype, "isActive", {
                        get: function () {
                            return this._isActive
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "isMobileAccessibility", {
                        get: function () {
                            return this._isMobileAccessibility
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.createTouchHook = function () {
                        var t = this,
                            e = document.createElement("button");
                        e.style.width = "1px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.style.zIndex = 2..toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessability for this content", e.addEventListener("focus", (function () {
                            t._isMobileAccessibility = !0, t.activate(), t.destroyTouchHook()
                        })), document.body.appendChild(e), this._hookDiv = e
                    }, t.prototype.destroyTouchHook = function () {
                        this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
                    }, t.prototype.activate = function () {
                        this._isActive || (this._isActive = !0, window.document.addEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode && this.renderer.view.parentNode.appendChild(this.div))
                    }, t.prototype.deactivate = function () {
                        this._isActive && !this._isMobileAccessibility && (this._isActive = !1, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode && this.div.parentNode.removeChild(this.div))
                    }, t.prototype.updateAccessibleObjects = function (t) {
                        if (t.visible && t.accessibleChildren) {
                            t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
                            for (var e = t.children, i = 0; i < e.length; i++) this.updateAccessibleObjects(e[i])
                        }
                    }, t.prototype.update = function () {
                        var t = performance.now();
                        if (!(Y.android.device && t < this.androidUpdateCount) && (this.androidUpdateCount = t + this.androidUpdateFrequency, this.renderer.renderingToScreen)) {
                            this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
                            var e = this.renderer.view.getBoundingClientRect(),
                                i = this.renderer.resolution,
                                n = e.width / this.renderer.width * i,
                                r = e.height / this.renderer.height * i,
                                o = this.div;
                            o.style.left = e.left + "px", o.style.top = e.top + "px", o.style.width = this.renderer.width + "px", o.style.height = this.renderer.height + "px";
                            for (var s = 0; s < this.children.length; s++) {
                                var a = this.children[s];
                                if (a.renderId !== this.renderId) a._accessibleActive = !1, vt(this.children, s, 1), this.div.removeChild(a._accessibleDiv), this.pool.push(a._accessibleDiv), a._accessibleDiv = null, s--;
                                else {
                                    o = a._accessibleDiv;
                                    var l = a.hitArea,
                                        h = a.worldTransform;
                                    a.hitArea ? (o.style.left = (h.tx + l.x * h.a) * n + "px", o.style.top = (h.ty + l.y * h.d) * r + "px", o.style.width = l.width * h.a * n + "px", o.style.height = l.height * h.d * r + "px") : (l = a.getBounds(), this.capHitArea(l), o.style.left = l.x * n + "px", o.style.top = l.y * r + "px", o.style.width = l.width * n + "px", o.style.height = l.height * r + "px", o.title !== a.accessibleTitle && null !== a.accessibleTitle && (o.title = a.accessibleTitle), o.getAttribute("aria-label") !== a.accessibleHint && null !== a.accessibleHint && o.setAttribute("aria-label", a.accessibleHint)), a.accessibleTitle === o.title && a.tabIndex === o.tabIndex || (o.title = a.accessibleTitle, o.tabIndex = a.tabIndex, this.debug && this.updateDebugHTML(o))
                                }
                            }
                            this.renderId++
                        }
                    }, t.prototype.updateDebugHTML = function (t) {
                        t.innerHTML = "type: " + t.type + "</br> title : " + t.title + "</br> tabIndex: " + t.tabIndex
                    }, t.prototype.capHitArea = function (t) {
                        t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0), t.x + t.width > this.renderer.width && (t.width = this.renderer.width - t.x), t.y + t.height > this.renderer.height && (t.height = this.renderer.height - t.y)
                    }, t.prototype.addChild = function (t) {
                        var e = this.pool.pop();
                        e || ((e = document.createElement("button")).style.width = fe + "px", e.style.height = fe + "px", e.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", e.style.position = "absolute", e.style.zIndex = 2..toString(), e.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? e.setAttribute("aria-live", "off") : e.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? e.setAttribute("aria-relevant", "additions") : e.setAttribute("aria-relevant", "text"), e.addEventListener("click", this._onClick.bind(this)), e.addEventListener("focus", this._onFocus.bind(this)), e.addEventListener("focusout", this._onFocusOut.bind(this))), e.style.pointerEvents = t.accessiblePointerEvents, e.type = t.accessibleType, t.accessibleTitle && null !== t.accessibleTitle ? e.title = t.accessibleTitle : t.accessibleHint && null !== t.accessibleHint || (e.title = "displayObject " + t.tabIndex), t.accessibleHint && null !== t.accessibleHint && e.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(e), t._accessibleActive = !0, t._accessibleDiv = e, e.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
                    }, t.prototype._onClick = function (t) {
                        var e = this.renderer.plugins.interaction;
                        e.dispatchEvent(t.target.displayObject, "click", e.eventData), e.dispatchEvent(t.target.displayObject, "pointertap", e.eventData), e.dispatchEvent(t.target.displayObject, "tap", e.eventData)
                    }, t.prototype._onFocus = function (t) {
                        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive");
                        var e = this.renderer.plugins.interaction;
                        e.dispatchEvent(t.target.displayObject, "mouseover", e.eventData)
                    }, t.prototype._onFocusOut = function (t) {
                        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite");
                        var e = this.renderer.plugins.interaction;
                        e.dispatchEvent(t.target.displayObject, "mouseout", e.eventData)
                    }, t.prototype._onKeyDown = function (t) {
                        9 === t.keyCode && this.activate()
                    }, t.prototype._onMouseMove = function (t) {
                        0 === t.movementX && 0 === t.movementY || this.deactivate()
                    }, t.prototype.destroy = function () {
                        this.destroyTouchHook(), this.div = null, window.document.removeEventListener("mousemove", this._onMouseMove, !0), window.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
                    }, t
                }();
            j.TARGET_FPMS = .06,
                function (t) {
                    t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY"
                }(pe || (pe = {}));
            var me = function () {
                function t(t, e, i, n) {
                    void 0 === e && (e = null), void 0 === i && (i = 0), void 0 === n && (n = !1), this.fn = t, this.context = e, this.priority = i, this.once = n, this.next = null, this.previous = null, this._destroyed = !1
                }
                return t.prototype.match = function (t, e) {
                    return void 0 === e && (e = null), this.fn === t && this.context === e
                }, t.prototype.emit = function (t) {
                    this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
                    var e = this.next;
                    return this.once && this.destroy(!0), this._destroyed && (this.next = null), e
                }, t.prototype.connect = function (t) {
                    this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
                }, t.prototype.destroy = function (t) {
                    void 0 === t && (t = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
                    var e = this.next;
                    return this.next = t ? null : e, this.previous = null, e
                }, t
            }(),
                _e = function () {
                    function t() {
                        var t = this;
                        this._head = new me(null, null, 1 / 0), this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this.autoStart = !1, this.deltaTime = 1, this.deltaMS = 1 / j.TARGET_FPMS, this.elapsedMS = 1 / j.TARGET_FPMS, this.lastTime = -1, this.speed = 1, this.started = !1, this._protected = !1, this._lastFrame = -1, this._tick = function (e) {
                            t._requestId = null, t.started && (t.update(e), t.started && null === t._requestId && t._head.next && (t._requestId = requestAnimationFrame(t._tick)))
                        }
                    }
                    return t.prototype._requestIfNeeded = function () {
                        null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
                    }, t.prototype._cancelIfNeeded = function () {
                        null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null)
                    }, t.prototype._startIfPossible = function () {
                        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
                    }, t.prototype.add = function (t, e, i) {
                        return void 0 === i && (i = pe.NORMAL), this._addListener(new me(t, e, i))
                    }, t.prototype.addOnce = function (t, e, i) {
                        return void 0 === i && (i = pe.NORMAL), this._addListener(new me(t, e, i, !0))
                    }, t.prototype._addListener = function (t) {
                        var e = this._head.next,
                            i = this._head;
                        if (e) {
                            for (; e;) {
                                if (t.priority > e.priority) {
                                    t.connect(i);
                                    break
                                }
                                i = e, e = e.next
                            }
                            t.previous || t.connect(i)
                        } else t.connect(i);
                        return this._startIfPossible(), this
                    }, t.prototype.remove = function (t, e) {
                        for (var i = this._head.next; i;) i = i.match(t, e) ? i.destroy() : i.next;
                        return this._head.next || this._cancelIfNeeded(), this
                    }, Object.defineProperty(t.prototype, "count", {
                        get: function () {
                            if (!this._head) return 0;
                            for (var t = 0, e = this._head; e = e.next;) t++;
                            return t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.start = function () {
                        this.started || (this.started = !0, this._requestIfNeeded())
                    }, t.prototype.stop = function () {
                        this.started && (this.started = !1, this._cancelIfNeeded())
                    }, t.prototype.destroy = function () {
                        if (!this._protected) {
                            this.stop();
                            for (var t = this._head.next; t;) t = t.destroy(!0);
                            this._head.destroy(), this._head = null
                        }
                    }, t.prototype.update = function (t) {
                        var e;
                        if (void 0 === t && (t = performance.now()), t > this.lastTime) {
                            if ((e = this.elapsedMS = t - this.lastTime) > this._maxElapsedMS && (e = this._maxElapsedMS), e *= this.speed, this._minElapsedMS) {
                                var i = t - this._lastFrame | 0;
                                if (i < this._minElapsedMS) return;
                                this._lastFrame = t - i % this._minElapsedMS
                            }
                            this.deltaMS = e, this.deltaTime = this.deltaMS * j.TARGET_FPMS;
                            for (var n = this._head, r = n.next; r;) r = r.emit(this.deltaTime);
                            n.next || this._cancelIfNeeded()
                        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
                        this.lastTime = t
                    }, Object.defineProperty(t.prototype, "FPS", {
                        get: function () {
                            return 1e3 / this.elapsedMS
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "minFPS", {
                        get: function () {
                            return 1e3 / this._maxElapsedMS
                        },
                        set: function (t) {
                            var e = Math.min(this.maxFPS, t),
                                i = Math.min(Math.max(0, e) / 1e3, j.TARGET_FPMS);
                            this._maxElapsedMS = 1 / i
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "maxFPS", {
                        get: function () {
                            return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
                        },
                        set: function (t) {
                            if (0 === t) this._minElapsedMS = 0;
                            else {
                                var e = Math.max(this.minFPS, t);
                                this._minElapsedMS = 1 / (e / 1e3)
                            }
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t, "shared", {
                        get: function () {
                            if (!t._shared) {
                                var e = t._shared = new t;
                                e.autoStart = !0, e._protected = !0
                            }
                            return t._shared
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t, "system", {
                        get: function () {
                            if (!t._system) {
                                var e = t._system = new t;
                                e.autoStart = !0, e._protected = !0
                            }
                            return t._system
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(),
                ye = function () {
                    function t() { }
                    return t.init = function (t) {
                        var e = this;
                        t = Object.assign({
                            autoStart: !0,
                            sharedTicker: !1
                        }, t), Object.defineProperty(this, "ticker", {
                            set: function (t) {
                                this._ticker && this._ticker.remove(this.render, this), this._ticker = t, t && t.add(this.render, this, pe.LOW)
                            },
                            get: function () {
                                return this._ticker
                            }
                        }), this.stop = function () {
                            e._ticker.stop()
                        }, this.start = function () {
                            e._ticker.start()
                        }, this._ticker = null, this.ticker = t.sharedTicker ? _e.shared : new _e, t.autoStart && this.start()
                    }, t.destroy = function () {
                        if (this._ticker) {
                            var t = this._ticker;
                            this.ticker = null, t.destroy()
                        }
                    }, t
                }(),
                Se = function () {
                    function t() {
                        this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new zt, this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0
                    }
                    return Object.defineProperty(t.prototype, "pointerId", {
                        get: function () {
                            return this.identifier
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.getLocalPosition = function (t, e, i) {
                        return t.worldTransform.applyInverse(i || this.global, e)
                    }, t.prototype.copyEvent = function (t) {
                        "isPrimary" in t && t.isPrimary && (this.isPrimary = !0), this.button = "button" in t && t.button;
                        var e = "buttons" in t && t.buttons;
                        this.buttons = Number.isInteger(e) ? e : "which" in t && t.which, this.width = "width" in t && t.width, this.height = "height" in t && t.height, this.tiltX = "tiltX" in t && t.tiltX, this.tiltY = "tiltY" in t && t.tiltY, this.pointerType = "pointerType" in t && t.pointerType, this.pressure = "pressure" in t && t.pressure, this.rotationAngle = "rotationAngle" in t && t.rotationAngle, this.twist = "twist" in t && t.twist || 0, this.tangentialPressure = "tangentialPressure" in t && t.tangentialPressure || 0
                    }, t.prototype.reset = function () {
                        this.isPrimary = !1
                    }, t
                }(),
                ve = function (t, e) {
                    return ve = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, ve(t, e)
                },
                be = function () {
                    function t() {
                        this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null
                    }
                    return t.prototype.stopPropagation = function () {
                        this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget
                    }, t.prototype.reset = function () {
                        this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null
                    }, t
                }(),
                Te = function () {
                    function t(e) {
                        this._pointerId = e, this._flags = t.FLAGS.NONE
                    }
                    return t.prototype._doSet = function (t, e) {
                        this._flags = e ? this._flags | t : this._flags & ~t
                    }, Object.defineProperty(t.prototype, "pointerId", {
                        get: function () {
                            return this._pointerId
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "flags", {
                        get: function () {
                            return this._flags
                        },
                        set: function (t) {
                            this._flags = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "none", {
                        get: function () {
                            return this._flags === t.FLAGS.NONE
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "over", {
                        get: function () {
                            return 0 != (this._flags & t.FLAGS.OVER)
                        },
                        set: function (e) {
                            this._doSet(t.FLAGS.OVER, e)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "rightDown", {
                        get: function () {
                            return 0 != (this._flags & t.FLAGS.RIGHT_DOWN)
                        },
                        set: function (e) {
                            this._doSet(t.FLAGS.RIGHT_DOWN, e)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "leftDown", {
                        get: function () {
                            return 0 != (this._flags & t.FLAGS.LEFT_DOWN)
                        },
                        set: function (e) {
                            this._doSet(t.FLAGS.LEFT_DOWN, e)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.FLAGS = Object.freeze({
                        NONE: 0,
                        OVER: 1,
                        LEFT_DOWN: 2,
                        RIGHT_DOWN: 4
                    }), t
                }(),
                Pe = function () {
                    function t() {
                        this._tempPoint = new zt
                    }
                    return t.prototype.recursiveFindHit = function (t, e, i, n, r) {
                        if (!e || !e.visible) return !1;
                        var o = t.data.global,
                            s = !1,
                            a = r = e.interactive || r,
                            l = !0;
                        if (e.hitArea ? (n && (e.worldTransform.applyInverse(o, this._tempPoint), e.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? s = !0 : (n = !1, l = !1)), a = !1) : e._mask && n && (e._mask.containsPoint && e._mask.containsPoint(o) || (n = !1)), l && e.interactiveChildren && e.children)
                            for (var h = e.children, u = h.length - 1; u >= 0; u--) {
                                var c = h[u],
                                    d = this.recursiveFindHit(t, c, i, n, a);
                                if (d) {
                                    if (!c.parent) continue;
                                    a = !1, d && (t.target && (n = !1), s = !0)
                                }
                            }
                        return r && (n && !t.target && !e.hitArea && e.containsPoint && e.containsPoint(o) && (s = !0), e.interactive && (s && !t.target && (t.target = e), i && i(t, e, !!s))), s
                    }, t.prototype.findHit = function (t, e, i, n) {
                        this.recursiveFindHit(t, e, i, n, !1)
                    }, t
                }(),
                Ae = {
                    interactive: !1,
                    interactiveChildren: !0,
                    hitArea: null,
                    get buttonMode() {
                        return "pointer" === this.cursor
                    },
                    set buttonMode(t) {
                        t ? this.cursor = "pointer" : "pointer" === this.cursor && (this.cursor = null)
                    },
                    cursor: null,
                    get trackedPointers() {
                        return void 0 === this._trackedPointers && (this._trackedPointers = {}), this._trackedPointers
                    },
                    _trackedPointers: void 0
                };
            le.mixin(Ae);
            var Ie = {
                target: null,
                data: {
                    global: null
                }
            },
                we = function (t) {
                    function e(e, i) {
                        var n = t.call(this) || this;
                        return i = i || {}, n.renderer = e, n.autoPreventDefault = void 0 === i.autoPreventDefault || i.autoPreventDefault, n.interactionFrequency = i.interactionFrequency || 10, n.mouse = new Se, n.mouse.identifier = 1, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[1] = n.mouse, n.interactionDataPool = [], n.eventData = new be, n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !1, n.supportsTouchEvents = "ontouchstart" in window, n.supportsPointerEvents = !!window.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {
                            default: "inherit",
                            pointer: "pointer"
                        }, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new Pe, n._tempDisplayObject = new he, n._useSystemTicker = void 0 === i.useSystemTicker || i.useSystemTicker, n.setTargetElement(n.renderer.view, n.renderer.resolution), n
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        ve(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), Object.defineProperty(e.prototype, "useSystemTicker", {
                        get: function () {
                            return this._useSystemTicker
                        },
                        set: function (t) {
                            this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "lastObjectRendered", {
                        get: function () {
                            return this.renderer._lastObjectRendered || this._tempDisplayObject
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.hitTest = function (t, e) {
                        return Ie.target = null, Ie.data.global = t, e || (e = this.lastObjectRendered), this.processInteractive(Ie, e, null, !0), Ie.target
                    }, e.prototype.setTargetElement = function (t, e) {
                        void 0 === e && (e = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = e, this.addEvents(), this.addTickerListener()
                    }, e.prototype.addTickerListener = function () {
                        !this.tickerAdded && this.interactionDOMElement && this._useSystemTicker && (_e.system.add(this.tickerUpdate, this, pe.INTERACTION), this.tickerAdded = !0)
                    }, e.prototype.removeTickerListener = function () {
                        this.tickerAdded && (_e.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
                    }, e.prototype.addEvents = function () {
                        if (!this.eventsAdded && this.interactionDOMElement) {
                            var t = this.interactionDOMElement.style;
                            window.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (window.document.addEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, !0), window.addEventListener("pointercancel", this.onPointerCancel, !0), window.addEventListener("pointerup", this.onPointerUp, !0)) : (window.document.addEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, !0), window.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, !0)), this.eventsAdded = !0
                        }
                    }, e.prototype.removeEvents = function () {
                        if (this.eventsAdded && this.interactionDOMElement) {
                            var t = this.interactionDOMElement.style;
                            window.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (window.document.removeEventListener("pointermove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, !0), window.removeEventListener("pointercancel", this.onPointerCancel, !0), window.removeEventListener("pointerup", this.onPointerUp, !0)) : (window.document.removeEventListener("mousemove", this.onPointerMove, !0), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, !0), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, !0), window.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, !0), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, !0), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, !0), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.interactionDOMElement = null, this.eventsAdded = !1
                        }
                    }, e.prototype.tickerUpdate = function (t) {
                        this._deltaTime += t, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update())
                    }, e.prototype.update = function () {
                        if (this.interactionDOMElement)
                            if (this._didMove) this._didMove = !1;
                            else {
                                for (var t in this.cursor = null, this.activeInteractionData)
                                    if (this.activeInteractionData.hasOwnProperty(t)) {
                                        var e = this.activeInteractionData[t];
                                        if (e.originalEvent && "touch" !== e.pointerType) {
                                            var i = this.configureInteractionEventForDOMEvent(this.eventData, e.originalEvent, e);
                                            this.processInteractive(i, this.lastObjectRendered, this.processPointerOverOut, !0)
                                        }
                                    } this.setCursorMode(this.cursor)
                            }
                    }, e.prototype.setCursorMode = function (t) {
                        if (t = t || "default", this.currentCursorMode !== t) {
                            this.currentCursorMode = t;
                            var e = this.cursorStyles[t];
                            if (e) switch (typeof e) {
                                case "string":
                                    this.interactionDOMElement.style.cursor = e;
                                    break;
                                case "function":
                                    e(t);
                                    break;
                                case "object":
                                    Object.assign(this.interactionDOMElement.style, e)
                            } else "string" != typeof t || Object.prototype.hasOwnProperty.call(this.cursorStyles, t) || (this.interactionDOMElement.style.cursor = t)
                        }
                    }, e.prototype.dispatchEvent = function (t, e, i) {
                        i.stopPropagationHint && t !== i.stopsPropagatingAt || (i.currentTarget = t, i.type = e, t.emit(e, i), t[e] && t[e](i))
                    }, e.prototype.delayDispatchEvent = function (t, e, i) {
                        this.delayedEvents.push({
                            displayObject: t,
                            eventString: e,
                            eventData: i
                        })
                    }, e.prototype.mapPositionToPoint = function (t, e, i) {
                        var n;
                        n = this.interactionDOMElement.parentElement ? this.interactionDOMElement.getBoundingClientRect() : {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        };
                        var r = 1 / this.resolution;
                        t.x = (e - n.left) * (this.interactionDOMElement.width / n.width) * r, t.y = (i - n.top) * (this.interactionDOMElement.height / n.height) * r
                    }, e.prototype.processInteractive = function (t, e, i, n) {
                        var r = this.search.findHit(t, e, i, n),
                            o = this.delayedEvents;
                        if (!o.length) return r;
                        t.stopPropagationHint = !1;
                        var s = o.length;
                        this.delayedEvents = [];
                        for (var a = 0; a < s; a++) {
                            var l = o[a],
                                h = l.displayObject,
                                u = l.eventString,
                                c = l.eventData;
                            c.stopsPropagatingAt === h && (c.stopPropagationHint = !0), this.dispatchEvent(h, u, c)
                        }
                        return r
                    }, e.prototype.onPointerDown = function (t) {
                        if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
                            var e = this.normalizeToPointerData(t);
                            this.autoPreventDefault && e[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
                            for (var i = e.length, n = 0; n < i; n++) {
                                var r = e[n],
                                    o = this.getInteractionDataForPointerId(r),
                                    s = this.configureInteractionEventForDOMEvent(this.eventData, r, o);
                                if (s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", s), "touch" === r.pointerType) this.emit("touchstart", s);
                                else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                                    var a = 2 === r.button;
                                    this.emit(a ? "rightdown" : "mousedown", this.eventData)
                                }
                            }
                        }
                    }, e.prototype.processPointerDown = function (t, e, i) {
                        var n = t.data,
                            r = t.data.identifier;
                        if (i)
                            if (e.trackedPointers[r] || (e.trackedPointers[r] = new Te(r)), this.dispatchEvent(e, "pointerdown", t), "touch" === n.pointerType) this.dispatchEvent(e, "touchstart", t);
                            else if ("mouse" === n.pointerType || "pen" === n.pointerType) {
                                var o = 2 === n.button;
                                o ? e.trackedPointers[r].rightDown = !0 : e.trackedPointers[r].leftDown = !0, this.dispatchEvent(e, o ? "rightdown" : "mousedown", t)
                            }
                    }, e.prototype.onPointerComplete = function (t, e, i) {
                        for (var n = this.normalizeToPointerData(t), r = n.length, o = t.target !== this.interactionDOMElement ? "outside" : "", s = 0; s < r; s++) {
                            var a = n[s],
                                l = this.getInteractionDataForPointerId(a),
                                h = this.configureInteractionEventForDOMEvent(this.eventData, a, l);
                            if (h.data.originalEvent = t, this.processInteractive(h, this.lastObjectRendered, i, e || !o), this.emit(e ? "pointercancel" : "pointerup" + o, h), "mouse" === a.pointerType || "pen" === a.pointerType) {
                                var u = 2 === a.button;
                                this.emit(u ? "rightup" + o : "mouseup" + o, h)
                            } else "touch" === a.pointerType && (this.emit(e ? "touchcancel" : "touchend" + o, h), this.releaseInteractionDataForPointerId(a.pointerId))
                        }
                    }, e.prototype.onPointerCancel = function (t) {
                        this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !0, this.processPointerCancel)
                    }, e.prototype.processPointerCancel = function (t, e) {
                        var i = t.data,
                            n = t.data.identifier;
                        void 0 !== e.trackedPointers[n] && (delete e.trackedPointers[n], this.dispatchEvent(e, "pointercancel", t), "touch" === i.pointerType && this.dispatchEvent(e, "touchcancel", t))
                    }, e.prototype.onPointerUp = function (t) {
                        this.supportsTouchEvents && "touch" === t.pointerType || this.onPointerComplete(t, !1, this.processPointerUp)
                    }, e.prototype.processPointerUp = function (t, e, i) {
                        var n = t.data,
                            r = t.data.identifier,
                            o = e.trackedPointers[r],
                            s = "touch" === n.pointerType,
                            a = "mouse" === n.pointerType || "pen" === n.pointerType,
                            l = !1;
                        if (a) {
                            var h = 2 === n.button,
                                u = Te.FLAGS,
                                c = h ? u.RIGHT_DOWN : u.LEFT_DOWN,
                                d = void 0 !== o && o.flags & c;
                            i ? (this.dispatchEvent(e, h ? "rightup" : "mouseup", t), d && (this.dispatchEvent(e, h ? "rightclick" : "click", t), l = !0)) : d && this.dispatchEvent(e, h ? "rightupoutside" : "mouseupoutside", t), o && (h ? o.rightDown = !1 : o.leftDown = !1)
                        }
                        i ? (this.dispatchEvent(e, "pointerup", t), s && this.dispatchEvent(e, "touchend", t), o && (a && !l || this.dispatchEvent(e, "pointertap", t), s && (this.dispatchEvent(e, "tap", t), o.over = !1))) : o && (this.dispatchEvent(e, "pointerupoutside", t), s && this.dispatchEvent(e, "touchendoutside", t)), o && o.none && delete e.trackedPointers[r]
                    }, e.prototype.onPointerMove = function (t) {
                        if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
                            var e = this.normalizeToPointerData(t);
                            "mouse" !== e[0].pointerType && "pen" !== e[0].pointerType || (this._didMove = !0, this.cursor = null);
                            for (var i = e.length, n = 0; n < i; n++) {
                                var r = e[n],
                                    o = this.getInteractionDataForPointerId(r),
                                    s = this.configureInteractionEventForDOMEvent(this.eventData, r, o);
                                s.data.originalEvent = t, this.processInteractive(s, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", s), "touch" === r.pointerType && this.emit("touchmove", s), "mouse" !== r.pointerType && "pen" !== r.pointerType || this.emit("mousemove", s)
                            }
                            "mouse" === e[0].pointerType && this.setCursorMode(this.cursor)
                        }
                    }, e.prototype.processPointerMove = function (t, e, i) {
                        var n = t.data,
                            r = "touch" === n.pointerType,
                            o = "mouse" === n.pointerType || "pen" === n.pointerType;
                        o && this.processPointerOverOut(t, e, i), this.moveWhenInside && !i || (this.dispatchEvent(e, "pointermove", t), r && this.dispatchEvent(e, "touchmove", t), o && this.dispatchEvent(e, "mousemove", t))
                    }, e.prototype.onPointerOut = function (t) {
                        if (!this.supportsTouchEvents || "touch" !== t.pointerType) {
                            var e = this.normalizeToPointerData(t)[0];
                            "mouse" === e.pointerType && (this.mouseOverRenderer = !1, this.setCursorMode(null));
                            var i = this.getInteractionDataForPointerId(e),
                                n = this.configureInteractionEventForDOMEvent(this.eventData, e, i);
                            n.data.originalEvent = e, this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", n), "mouse" === e.pointerType || "pen" === e.pointerType ? this.emit("mouseout", n) : this.releaseInteractionDataForPointerId(i.identifier)
                        }
                    }, e.prototype.processPointerOverOut = function (t, e, i) {
                        var n = t.data,
                            r = t.data.identifier,
                            o = "mouse" === n.pointerType || "pen" === n.pointerType,
                            s = e.trackedPointers[r];
                        i && !s && (s = e.trackedPointers[r] = new Te(r)), void 0 !== s && (i && this.mouseOverRenderer ? (s.over || (s.over = !0, this.delayDispatchEvent(e, "pointerover", t), o && this.delayDispatchEvent(e, "mouseover", t)), o && null === this.cursor && (this.cursor = e.cursor)) : s.over && (s.over = !1, this.dispatchEvent(e, "pointerout", this.eventData), o && this.dispatchEvent(e, "mouseout", t), s.none && delete e.trackedPointers[r]))
                    }, e.prototype.onPointerOver = function (t) {
                        var e = this.normalizeToPointerData(t)[0],
                            i = this.getInteractionDataForPointerId(e),
                            n = this.configureInteractionEventForDOMEvent(this.eventData, e, i);
                        n.data.originalEvent = e, "mouse" === e.pointerType && (this.mouseOverRenderer = !0), this.emit("pointerover", n), "mouse" !== e.pointerType && "pen" !== e.pointerType || this.emit("mouseover", n)
                    }, e.prototype.getInteractionDataForPointerId = function (t) {
                        var e, i = t.pointerId;
                        return 1 === i || "mouse" === t.pointerType ? e = this.mouse : this.activeInteractionData[i] ? e = this.activeInteractionData[i] : ((e = this.interactionDataPool.pop() || new Se).identifier = i, this.activeInteractionData[i] = e), e.copyEvent(t), e
                    }, e.prototype.releaseInteractionDataForPointerId = function (t) {
                        var e = this.activeInteractionData[t];
                        e && (delete this.activeInteractionData[t], e.reset(), this.interactionDataPool.push(e))
                    }, e.prototype.configureInteractionEventForDOMEvent = function (t, e, i) {
                        return t.data = i, this.mapPositionToPoint(i.global, e.clientX, e.clientY), "touch" === e.pointerType && (e.globalX = i.global.x, e.globalY = i.global.y), i.originalEvent = e, t.reset(), t
                    }, e.prototype.normalizeToPointerData = function (t) {
                        var e = [];
                        if (this.supportsTouchEvents && t instanceof TouchEvent)
                            for (var i = 0, n = t.changedTouches.length; i < n; i++) {
                                var r = t.changedTouches[i];
                                void 0 === r.button && (r.button = t.touches.length ? 1 : 0), void 0 === r.buttons && (r.buttons = t.touches.length ? 1 : 0), void 0 === r.isPrimary && (r.isPrimary = 1 === t.touches.length && "touchstart" === t.type), void 0 === r.width && (r.width = r.radiusX || 1), void 0 === r.height && (r.height = r.radiusY || 1), void 0 === r.tiltX && (r.tiltX = 0), void 0 === r.tiltY && (r.tiltY = 0), void 0 === r.pointerType && (r.pointerType = "touch"), void 0 === r.pointerId && (r.pointerId = r.identifier || 0), void 0 === r.pressure && (r.pressure = r.force || .5), void 0 === r.twist && (r.twist = 0), void 0 === r.tangentialPressure && (r.tangentialPressure = 0), void 0 === r.layerX && (r.layerX = r.offsetX = r.clientX), void 0 === r.layerY && (r.layerY = r.offsetY = r.clientY), r.isNormalized = !0, e.push(r)
                            } else if (!(t instanceof MouseEvent) || this.supportsPointerEvents && t instanceof window.PointerEvent) e.push(t);
                        else {
                            var o = t;
                            void 0 === o.isPrimary && (o.isPrimary = !0), void 0 === o.width && (o.width = 1), void 0 === o.height && (o.height = 1), void 0 === o.tiltX && (o.tiltX = 0), void 0 === o.tiltY && (o.tiltY = 0), void 0 === o.pointerType && (o.pointerType = "mouse"), void 0 === o.pointerId && (o.pointerId = 1), void 0 === o.pressure && (o.pressure = .5), void 0 === o.twist && (o.twist = 0), void 0 === o.tangentialPressure && (o.tangentialPressure = 0), o.isNormalized = !0, e.push(o)
                        } return e
                    }, e.prototype.destroy = function () {
                        this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null
                    }, e
                }(K()),
                Ee = function () {
                    function t(t) {
                        this.items = [], this._name = t, this._aliasCount = 0
                    }
                    return t.prototype.emit = function (t, e, i, n, r, o, s, a) {
                        if (arguments.length > 8) throw new Error("max arguments reached");
                        var l = this.name,
                            h = this.items;
                        this._aliasCount++;
                        for (var u = 0, c = h.length; u < c; u++) h[u][l](t, e, i, n, r, o, s, a);
                        return h === this.items && this._aliasCount--, this
                    }, t.prototype.ensureNonAliasedItems = function () {
                        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
                    }, t.prototype.add = function (t) {
                        return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
                    }, t.prototype.remove = function (t) {
                        var e = this.items.indexOf(t);
                        return -1 !== e && (this.ensureNonAliasedItems(), this.items.splice(e, 1)), this
                    }, t.prototype.contains = function (t) {
                        return -1 !== this.items.indexOf(t)
                    }, t.prototype.removeAll = function () {
                        return this.ensureNonAliasedItems(), this.items.length = 0, this
                    }, t.prototype.destroy = function () {
                        this.removeAll(), this.items = null, this._name = null
                    }, Object.defineProperty(t.prototype, "empty", {
                        get: function () {
                            return 0 === this.items.length
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "name", {
                        get: function () {
                            return this._name
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }();
            Object.defineProperties(Ee.prototype, {
                dispatch: {
                    value: Ee.prototype.emit
                },
                run: {
                    value: Ee.prototype.emit
                }
            }), j.PREFER_ENV = Y.any ? d.WEBGL : d.WEBGL2, j.STRICT_TEXTURE_CACHE = !1;
            var Ce = [];

            function xe(t, e) {
                if (!t) return null;
                var i = "";
                if ("string" == typeof t) {
                    var n = /\.(\w{3,4})(?:$|\?|#)/i.exec(t);
                    n && (i = n[1].toLowerCase())
                }
                for (var r = Ce.length - 1; r >= 0; --r) {
                    var o = Ce[r];
                    if (o.test && o.test(t, i)) return new o(t, e)
                }
                throw new Error("Unrecognized source type to auto-detect Resource")
            }
            var Be = function (t, e) {
                return Be = Object.setPrototypeOf || {
                    __proto__: []
                }
                    instanceof Array && function (t, e) {
                        t.__proto__ = e
                    } || function (t, e) {
                        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                    }, Be(t, e)
            };

            function Le(t, e) {
                function i() {
                    this.constructor = t
                }
                Be(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var Oe = function () {
                function t(t, e) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), this._width = t, this._height = e, this.destroyed = !1, this.internal = !1, this.onResize = new Ee("setRealSize"), this.onUpdate = new Ee("update"), this.onError = new Ee("onError")
                }
                return t.prototype.bind = function (t) {
                    this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
                }, t.prototype.unbind = function (t) {
                    this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
                }, t.prototype.resize = function (t, e) {
                    t === this._width && e === this._height || (this._width = t, this._height = e, this.onResize.emit(t, e))
                }, Object.defineProperty(t.prototype, "valid", {
                    get: function () {
                        return !!this._width && !!this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.update = function () {
                    this.destroyed || this.onUpdate.emit()
                }, t.prototype.load = function () {
                    return Promise.resolve(this)
                }, Object.defineProperty(t.prototype, "width", {
                    get: function () {
                        return this._width
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(t.prototype, "height", {
                    get: function () {
                        return this._height
                    },
                    enumerable: !1,
                    configurable: !0
                }), t.prototype.style = function (t, e, i) {
                    return !1
                }, t.prototype.dispose = function () { }, t.prototype.destroy = function () {
                    this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
                }, t.test = function (t, e) {
                    return !1
                }, t
            }(),
                Ne = function (t) {
                    function e(e, i) {
                        var n = this,
                            r = i || {},
                            o = r.width,
                            s = r.height;
                        if (!o || !s) throw new Error("BufferResource width or height invalid");
                        return (n = t.call(this, o, s) || this).data = e, n
                    }
                    return Le(e, t), e.prototype.upload = function (t, e, i) {
                        var n = t.gl;
                        return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === P.UNPACK), i.width === e.width && i.height === e.height ? n.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.type, this.data) : (i.width = e.width, i.height = e.height, n.texImage2D(e.target, 0, i.internalFormat, e.width, e.height, 0, e.format, i.type, this.data)), !0
                    }, e.prototype.dispose = function () {
                        this.data = null
                    }, e.test = function (t) {
                        return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
                    }, e
                }(Oe),
                Me = {
                    scaleMode: v.NEAREST,
                    format: _.RGBA,
                    alphaMode: P.NPM
                },
                Re = function (t) {
                    function e(e, i) {
                        void 0 === e && (e = null), void 0 === i && (i = null);
                        var n = t.call(this) || this,
                            r = (i = i || {}).alphaMode,
                            o = i.mipmap,
                            s = i.anisotropicLevel,
                            a = i.scaleMode,
                            l = i.width,
                            h = i.height,
                            u = i.wrapMode,
                            c = i.format,
                            d = i.type,
                            p = i.target,
                            f = i.resolution,
                            g = i.resourceOptions;
                        return !e || e instanceof Oe || ((e = xe(e, g)).internal = !0), n.width = l || 0, n.height = h || 0, n.resolution = f || j.RESOLUTION, n.mipmap = void 0 !== o ? o : j.MIPMAP_TEXTURES, n.anisotropicLevel = void 0 !== s ? s : j.ANISOTROPIC_LEVEL, n.wrapMode = u || j.WRAP_MODE, n.scaleMode = void 0 !== a ? a : j.SCALE_MODE, n.format = c || _.RGBA, n.type = d || S.UNSIGNED_BYTE, n.target = p || y.TEXTURE_2D, n.alphaMode = void 0 !== r ? r : P.UNPACK, void 0 !== i.premultiplyAlpha && (n.premultiplyAlpha = i.premultiplyAlpha), n.uid = Pt(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = l > 0 && h > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(e), n
                    }
                    return Le(e, t), Object.defineProperty(e.prototype, "realWidth", {
                        get: function () {
                            return Math.ceil(this.width * this.resolution - 1e-4)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "realHeight", {
                        get: function () {
                            return Math.ceil(this.height * this.resolution - 1e-4)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.setStyle = function (t, e) {
                        var i;
                        return void 0 !== t && t !== this.scaleMode && (this.scaleMode = t, i = !0), void 0 !== e && e !== this.mipmap && (this.mipmap = e, i = !0), i && this.dirtyStyleId++, this
                    }, e.prototype.setSize = function (t, e, i) {
                        return this.resolution = i || this.resolution, this.width = t, this.height = e, this._refreshPOT(), this.update(), this
                    }, e.prototype.setRealSize = function (t, e, i) {
                        return this.resolution = i || this.resolution, this.width = t / this.resolution, this.height = e / this.resolution, this._refreshPOT(), this.update(), this
                    }, e.prototype._refreshPOT = function () {
                        this.isPowerOfTwo = yt(this.realWidth) && yt(this.realHeight)
                    }, e.prototype.setResolution = function (t) {
                        var e = this.resolution;
                        return e === t || (this.resolution = t, this.valid && (this.width = this.width * e / t, this.height = this.height * e / t, this.emit("update", this)), this._refreshPOT()), this
                    }, e.prototype.setResource = function (t) {
                        if (this.resource === t) return this;
                        if (this.resource) throw new Error("Resource can be set only once");
                        return t.bind(this), this.resource = t, this
                    }, e.prototype.update = function () {
                        this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
                    }, e.prototype.onError = function (t) {
                        this.emit("error", this, t)
                    }, e.prototype.destroy = function () {
                        this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Ct[this.cacheId], delete Et[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
                    }, e.prototype.dispose = function () {
                        this.emit("dispose", this)
                    }, e.prototype.castToBaseTexture = function () {
                        return this
                    }, e.from = function (t, i, n) {
                        void 0 === n && (n = j.STRICT_TEXTURE_CACHE);
                        var r = "string" == typeof t,
                            o = null;
                        r ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + Pt()), o = t._pixiId);
                        var s = Ct[o];
                        if (r && n && !s) throw new Error('The cacheId "' + o + '" does not exist in BaseTextureCache.');
                        return s || ((s = new e(t, i)).cacheId = o, e.addToCache(s, o)), s
                    }, e.fromBuffer = function (t, i, n, r) {
                        t = t || new Float32Array(i * n * 4);
                        var o = new Ne(t, {
                            width: i,
                            height: n
                        }),
                            s = t instanceof Float32Array ? S.FLOAT : S.UNSIGNED_BYTE;
                        return new e(o, Object.assign(Me, r || {
                            width: i,
                            height: n,
                            type: s
                        }))
                    }, e.addToCache = function (t, e) {
                        e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), Ct[e] && console.warn("BaseTexture added to the cache with an id [" + e + "] that already had an entry"), Ct[e] = t)
                    }, e.removeFromCache = function (t) {
                        if ("string" == typeof t) {
                            var e = Ct[t];
                            if (e) {
                                var i = e.textureCacheIds.indexOf(t);
                                return i > -1 && e.textureCacheIds.splice(i, 1), delete Ct[t], e
                            }
                        } else if (t && t.textureCacheIds) {
                            for (var n = 0; n < t.textureCacheIds.length; ++n) delete Ct[t.textureCacheIds[n]];
                            return t.textureCacheIds.length = 0, t
                        }
                        return null
                    }, e._globalBatch = 0, e
                }(K()),
                De = function (t) {
                    function e(e, i) {
                        var n = this,
                            r = i || {},
                            o = r.width,
                            s = r.height;
                        (n = t.call(this, o, s) || this).items = [], n.itemDirtyIds = [];
                        for (var a = 0; a < e; a++) {
                            var l = new Re;
                            n.items.push(l), n.itemDirtyIds.push(-2)
                        }
                        return n.length = e, n._load = null, n.baseTexture = null, n
                    }
                    return Le(e, t), e.prototype.initFromArray = function (t, e) {
                        for (var i = 0; i < this.length; i++) t[i] && (t[i].castToBaseTexture ? this.addBaseTextureAt(t[i].castToBaseTexture(), i) : t[i] instanceof Oe ? this.addResourceAt(t[i], i) : this.addResourceAt(xe(t[i], e), i))
                    }, e.prototype.dispose = function () {
                        for (var t = 0, e = this.length; t < e; t++) this.items[t].destroy();
                        this.items = null, this.itemDirtyIds = null, this._load = null
                    }, e.prototype.addResourceAt = function (t, e) {
                        if (!this.items[e]) throw new Error("Index " + e + " is out of bounds");
                        return t.valid && !this.valid && this.resize(t.width, t.height), this.items[e].setResource(t), this
                    }, e.prototype.bind = function (e) {
                        if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
                        t.prototype.bind.call(this, e);
                        for (var i = 0; i < this.length; i++) this.items[i].parentTextureArray = e, this.items[i].on("update", e.update, e)
                    }, e.prototype.unbind = function (e) {
                        t.prototype.unbind.call(this, e);
                        for (var i = 0; i < this.length; i++) this.items[i].parentTextureArray = null, this.items[i].off("update", e.update, e)
                    }, e.prototype.load = function () {
                        var t = this;
                        if (this._load) return this._load;
                        var e = this.items.map((function (t) {
                            return t.resource
                        })).filter((function (t) {
                            return t
                        })).map((function (t) {
                            return t.load()
                        }));
                        return this._load = Promise.all(e).then((function () {
                            var e = t.items[0],
                                i = e.realWidth,
                                n = e.realHeight;
                            return t.resize(i, n), Promise.resolve(t)
                        })), this._load
                    }, e
                }(Oe),
                Fe = function (t) {
                    function e(e, i) {
                        var n, r, o = this,
                            s = i || {},
                            a = s.width,
                            l = s.height;
                        return Array.isArray(e) ? (n = e, r = e.length) : r = e, o = t.call(this, r, {
                            width: a,
                            height: l
                        }) || this, n && o.initFromArray(n, i), o
                    }
                    return Le(e, t), e.prototype.addBaseTextureAt = function (t, e) {
                        if (!t.resource) throw new Error("ArrayResource does not support RenderTexture");
                        return this.addResourceAt(t.resource, e), this
                    }, e.prototype.bind = function (e) {
                        t.prototype.bind.call(this, e), e.target = y.TEXTURE_2D_ARRAY
                    }, e.prototype.upload = function (t, e, i) {
                        var n = this,
                            r = n.length,
                            o = n.itemDirtyIds,
                            s = n.items,
                            a = t.gl;
                        i.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, e.format, this._width, this._height, r, 0, e.format, e.type, null);
                        for (var l = 0; l < r; l++) {
                            var h = s[l];
                            o[l] < h.dirtyId && (o[l] = h.dirtyId, h.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, h.resource.width, h.resource.height, 1, e.format, e.type, h.resource.source))
                        }
                        return !0
                    }, e
                }(De),
                ke = function (t) {
                    function e(e) {
                        var i = this,
                            n = e,
                            r = n.naturalWidth || n.videoWidth || n.width,
                            o = n.naturalHeight || n.videoHeight || n.height;
                        return (i = t.call(this, r, o) || this).source = e, i.noSubImage = !1, i
                    }
                    return Le(e, t), e.crossOrigin = function (t, e, i) {
                        void 0 === i && 0 !== e.indexOf("data:") ? t.crossOrigin = Dt(e) : !1 !== i && (t.crossOrigin = "string" == typeof i ? i : "anonymous")
                    }, e.prototype.upload = function (t, e, i, n) {
                        var r = t.gl,
                            o = e.realWidth,
                            s = e.realHeight;
                        return n = n || this.source, r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === P.UNPACK), this.noSubImage || e.target !== r.TEXTURE_2D || i.width !== o || i.height !== s ? (i.width = o, i.height = s, r.texImage2D(e.target, 0, e.format, e.format, e.type, n)) : r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, e.format, e.type, n), !0
                    }, e.prototype.update = function () {
                        if (!this.destroyed) {
                            var e = this.source,
                                i = e.naturalWidth || e.videoWidth || e.width,
                                n = e.naturalHeight || e.videoHeight || e.height;
                            this.resize(i, n), t.prototype.update.call(this)
                        }
                    }, e.prototype.dispose = function () {
                        this.source = null
                    }, e
                }(Oe),
                Ue = function (t) {
                    function e() {
                        return null !== t && t.apply(this, arguments) || this
                    }
                    return Le(e, t), e.test = function (t) {
                        var e = window.OffscreenCanvas;
                        return !!(e && t instanceof e) || t instanceof HTMLCanvasElement
                    }, e
                }(ke),
                Ge = function (t) {
                    function e(i, n) {
                        var r = this,
                            o = n || {},
                            s = o.width,
                            a = o.height,
                            l = o.autoLoad,
                            h = o.linkBaseTexture;
                        if (i && i.length !== e.SIDES) throw new Error("Invalid length. Got " + i.length + ", expected 6");
                        r = t.call(this, 6, {
                            width: s,
                            height: a
                        }) || this;
                        for (var u = 0; u < e.SIDES; u++) r.items[u].target = y.TEXTURE_CUBE_MAP_POSITIVE_X + u;
                        return r.linkBaseTexture = !1 !== h, i && r.initFromArray(i, n), !1 !== l && r.load(), r
                    }
                    return Le(e, t), e.prototype.bind = function (e) {
                        t.prototype.bind.call(this, e), e.target = y.TEXTURE_CUBE_MAP
                    }, e.prototype.addBaseTextureAt = function (t, e, i) {
                        if (void 0 === i && (i = this.linkBaseTexture), !this.items[e]) throw new Error("Index " + e + " is out of bounds");
                        if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0) {
                            if (!t.resource) throw new Error("CubeResource does not support copying of renderTexture.");
                            this.addResourceAt(t.resource, e)
                        } else t.target = y.TEXTURE_CUBE_MAP_POSITIVE_X + e, t.parentTextureArray = this.baseTexture, this.items[e] = t;
                        return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[e] = t, this
                    }, e.prototype.upload = function (t, i, n) {
                        for (var r = this.itemDirtyIds, o = 0; o < e.SIDES; o++) {
                            var s = this.items[o];
                            r[o] < s.dirtyId && (s.valid && s.resource ? (s.resource.upload(t, s, n), r[o] = s.dirtyId) : r[o] < -1 && (t.gl.texImage2D(s.target, 0, n.internalFormat, i.realWidth, i.realHeight, 0, i.format, n.type, null), r[o] = -1))
                        }
                        return !0
                    }, e.test = function (t) {
                        return Array.isArray(t) && t.length === e.SIDES
                    }, e.SIDES = 6, e
                }(De),
                We = function (t) {
                    function e(e, i) {
                        var n = this;
                        if (i = i || {}, !(e instanceof HTMLImageElement)) {
                            var r = new Image;
                            ke.crossOrigin(r, e, i.crossorigin), r.src = e, e = r
                        }
                        return n = t.call(this, e) || this, !e.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = e.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (void 0 !== i.createBitmap ? i.createBitmap : j.CREATE_IMAGE_BITMAP) && !!window.createImageBitmap, n.alphaMode = "number" == typeof i.alphaMode ? i.alphaMode : null, void 0 !== i.premultiplyAlpha && (n.premultiplyAlpha = i.premultiplyAlpha), n.bitmap = null, n._load = null, !1 !== i.autoLoad && n.load(), n
                    }
                    return Le(e, t), e.prototype.load = function (t) {
                        var e = this;
                        return this._load || (void 0 !== t && (this.createBitmap = t), this._load = new Promise((function (t, i) {
                            var n = e.source;
                            e.url = n.src;
                            var r = function () {
                                e.destroyed || (n.onload = null, n.onerror = null, e.resize(n.width, n.height), e._load = null, e.createBitmap ? t(e.process()) : t(e))
                            };
                            n.complete && n.src ? r() : (n.onload = r, n.onerror = function (t) {
                                i(t), e.onError.emit(t)
                            })
                        }))), this._load
                    }, e.prototype.process = function () {
                        var t = this,
                            e = this.source;
                        return null !== this._process ? this._process : null === this.bitmap && window.createImageBitmap ? (this._process = window.createImageBitmap(e, 0, 0, e.width, e.height, {
                            premultiplyAlpha: this.alphaMode === P.UNPACK ? "premultiply" : "none"
                        }).then((function (e) {
                            return t.destroyed ? Promise.reject() : (t.bitmap = e, t.update(), t._process = null, Promise.resolve(t))
                        })), this._process) : Promise.resolve(this)
                    }, e.prototype.upload = function (e, i, n) {
                        if ("number" == typeof this.alphaMode && (i.alphaMode = this.alphaMode), !this.createBitmap) return t.prototype.upload.call(this, e, i, n);
                        if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
                        if (t.prototype.upload.call(this, e, i, n, this.bitmap), !this.preserveBitmap) {
                            var r = !0,
                                o = i._glTextures;
                            for (var s in o) {
                                var a = o[s];
                                if (a !== n && a.dirtyId !== i.dirtyId) {
                                    r = !1;
                                    break
                                }
                            }
                            r && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
                        }
                        return !0
                    }, e.prototype.dispose = function () {
                        this.source.onload = null, this.source.onerror = null, t.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
                    }, e.test = function (t) {
                        return "string" == typeof t || t instanceof HTMLImageElement
                    }, e
                }(ke),
                Ve = function (t) {
                    function e(e, i) {
                        var n = this;
                        return i = i || {}, (n = t.call(this, document.createElement("canvas")) || this)._width = 0, n._height = 0, n.svg = e, n.scale = i.scale || 1, n._overrideWidth = i.width, n._overrideHeight = i.height, n._resolve = null, n._crossorigin = i.crossorigin, n._load = null, !1 !== i.autoLoad && n.load(), n
                    }
                    return Le(e, t), e.prototype.load = function () {
                        var t = this;
                        return this._load || (this._load = new Promise((function (e) {
                            if (t._resolve = function () {
                                t.resize(t.source.width, t.source.height), e(t)
                            }, /^\<svg/.test(t.svg.trim())) {
                                if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                                t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg)))
                            }
                            t._loadSvg()
                        }))), this._load
                    }, e.prototype._loadSvg = function () {
                        var t = this,
                            e = new Image;
                        ke.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = function (i) {
                            t._resolve && (e.onerror = null, t.onError.emit(i))
                        }, e.onload = function () {
                            if (t._resolve) {
                                var i = e.width,
                                    n = e.height;
                                if (!i || !n) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                                var r = i * t.scale,
                                    o = n * t.scale;
                                (t._overrideWidth || t._overrideHeight) && (r = t._overrideWidth || t._overrideHeight / n * i, o = t._overrideHeight || t._overrideWidth / i * n), r = Math.round(r), o = Math.round(o);
                                var s = t.source;
                                s.width = r, s.height = o, s._pixiId = "canvas_" + Pt(), s.getContext("2d").drawImage(e, 0, 0, i, n, 0, 0, r, o), t._resolve(), t._resolve = null
                            }
                        }
                    }, e.getSize = function (t) {
                        var i = e.SVG_SIZE.exec(t),
                            n = {};
                        return i && (n[i[1]] = Math.round(parseFloat(i[3])), n[i[5]] = Math.round(parseFloat(i[7]))), n
                    }, e.prototype.dispose = function () {
                        t.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null
                    }, e.test = function (t, e) {
                        return "svg" === e || "string" == typeof t && /^data:image\/svg\+xml(;(charset=utf8|utf8))?;base64/.test(t) || "string" == typeof t && 0 === t.indexOf("<svg")
                    }, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e
                }(ke),
                Xe = function (t) {
                    function e(i, n) {
                        var r = this;
                        if (n = n || {}, !(i instanceof HTMLVideoElement)) {
                            var o = document.createElement("video");
                            o.setAttribute("preload", "auto"), o.setAttribute("webkit-playsinline", ""), o.setAttribute("playsinline", ""), "string" == typeof i && (i = [i]);
                            var s = i[0].src || i[0];
                            ke.crossOrigin(o, s, n.crossorigin);
                            for (var a = 0; a < i.length; ++a) {
                                var l = document.createElement("source"),
                                    h = i[a],
                                    u = h.src,
                                    c = h.mime,
                                    d = (u = u || i[a]).split("?").shift().toLowerCase(),
                                    p = d.substr(d.lastIndexOf(".") + 1);
                                c = c || e.MIME_TYPES[p] || "video/" + p, l.src = u, l.type = c, o.appendChild(l)
                            }
                            i = o
                        }
                        return (r = t.call(this, i) || this).noSubImage = !0, r._autoUpdate = !0, r._isConnectedToTicker = !1, r._updateFPS = n.updateFPS || 0, r._msToNextUpdate = 0, r.autoPlay = !1 !== n.autoPlay, r._load = null, r._resolve = null, r._onCanPlay = r._onCanPlay.bind(r), r._onError = r._onError.bind(r), !1 !== n.autoLoad && r.load(), r
                    }
                    return Le(e, t), e.prototype.update = function (e) {
                        if (void 0 === e && (e = 0), !this.destroyed) {
                            var i = _e.shared.elapsedMS * this.source.playbackRate;
                            this._msToNextUpdate = Math.floor(this._msToNextUpdate - i), (!this._updateFPS || this._msToNextUpdate <= 0) && (t.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
                        }
                    }, e.prototype.load = function () {
                        var t = this;
                        if (this._load) return this._load;
                        var e = this.source;
                        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise((function (i) {
                            t.valid ? i(t) : (t._resolve = i, e.load())
                        })), this._load
                    }, e.prototype._onError = function (t) {
                        this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t)
                    }, e.prototype._isSourcePlaying = function () {
                        var t = this.source;
                        return t.currentTime > 0 && !1 === t.paused && !1 === t.ended && t.readyState > 2
                    }, e.prototype._isSourceReady = function () {
                        var t = this.source;
                        return 3 === t.readyState || 4 === t.readyState
                    }, e.prototype._onPlayStart = function () {
                        this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (_e.shared.add(this.update, this), this._isConnectedToTicker = !0)
                    }, e.prototype._onPlayStop = function () {
                        this._isConnectedToTicker && (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1)
                    }, e.prototype._onCanPlay = function () {
                        var t = this.source;
                        t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
                        var e = this.valid;
                        this.resize(t.videoWidth, t.videoHeight), !e && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play()
                    }, e.prototype.dispose = function () {
                        this._isConnectedToTicker && _e.shared.remove(this.update, this);
                        var e = this.source;
                        e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), t.prototype.dispose.call(this)
                    }, Object.defineProperty(e.prototype, "autoUpdate", {
                        get: function () {
                            return this._autoUpdate
                        },
                        set: function (t) {
                            t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (_e.shared.add(this.update, this), this._isConnectedToTicker = !0))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "updateFPS", {
                        get: function () {
                            return this._updateFPS
                        },
                        set: function (t) {
                            t !== this._updateFPS && (this._updateFPS = t)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.test = function (t, i) {
                        return t instanceof HTMLVideoElement || e.TYPES.indexOf(i) > -1
                    }, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = {
                        ogv: "video/ogg",
                        mov: "video/quicktime",
                        m4v: "video/mp4"
                    }, e
                }(ke),
                He = function (t) {
                    function e() {
                        return null !== t && t.apply(this, arguments) || this
                    }
                    return Le(e, t), e.test = function (t) {
                        return !!window.createImageBitmap && t instanceof ImageBitmap
                    }, e
                }(ke);
            Ce.push(We, He, Ue, Xe, Ve, Ne, Ge, Fe);
            var Ye = {
                Resource: Oe,
                BaseImageResource: ke,
                INSTALLED: Ce,
                autoDetectResource: xe,
                AbstractMultiResource: De,
                ArrayResource: Fe,
                BufferResource: Ne,
                CanvasResource: Ue,
                CubeResource: Ge,
                ImageResource: We,
                SVGResource: Ve,
                VideoResource: Xe,
                ImageBitmapResource: He
            },
                je = function () {
                    function t(t) {
                        this.renderer = t
                    }
                    return t.prototype.destroy = function () {
                        this.renderer = null
                    }, t
                }(),
                ze = function (t) {
                    function e() {
                        return null !== t && t.apply(this, arguments) || this
                    }
                    return Le(e, t), e.prototype.upload = function (t, e, i) {
                        var n = t.gl;
                        return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.alphaMode === P.UNPACK), i.width === e.width && i.height === e.height ? n.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.type, this.data) : (i.width = e.width, i.height = e.height, n.texImage2D(e.target, 0, 1 === t.context.webGLVersion ? n.DEPTH_COMPONENT : n.DEPTH_COMPONENT16, e.width, e.height, 0, e.format, e.type, this.data)), !0
                    }, e
                }(Ne),
                Ke = function () {
                    function t(t, e) {
                        this.width = Math.ceil(t || 100), this.height = Math.ceil(e || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Ee("disposeFramebuffer"), this.multisample = C.NONE
                    }
                    return Object.defineProperty(t.prototype, "colorTexture", {
                        get: function () {
                            return this.colorTextures[0]
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.addColorTexture = function (t, e) {
                        return void 0 === t && (t = 0), this.colorTextures[t] = e || new Re(null, {
                            scaleMode: v.NEAREST,
                            resolution: 1,
                            mipmap: T.OFF,
                            width: this.width,
                            height: this.height
                        }), this.dirtyId++, this.dirtyFormat++, this
                    }, t.prototype.addDepthTexture = function (t) {
                        return this.depthTexture = t || new Re(new ze(null, {
                            width: this.width,
                            height: this.height
                        }), {
                            scaleMode: v.NEAREST,
                            resolution: 1,
                            width: this.width,
                            height: this.height,
                            mipmap: T.OFF,
                            format: _.DEPTH_COMPONENT,
                            type: S.UNSIGNED_SHORT
                        }), this.dirtyId++, this.dirtyFormat++, this
                    }, t.prototype.enableDepth = function () {
                        return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
                    }, t.prototype.enableStencil = function () {
                        return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
                    }, t.prototype.resize = function (t, e) {
                        if (t = Math.ceil(t), e = Math.ceil(e), t !== this.width || e !== this.height) {
                            this.width = t, this.height = e, this.dirtyId++, this.dirtySize++;
                            for (var i = 0; i < this.colorTextures.length; i++) {
                                var n = this.colorTextures[i],
                                    r = n.resolution;
                                n.setSize(t / r, e / r)
                            }
                            this.depthTexture && (r = this.depthTexture.resolution, this.depthTexture.setSize(t / r, e / r))
                        }
                    }, t.prototype.dispose = function () {
                        this.disposeRunner.emit(this, !1)
                    }, t.prototype.destroyDepthTexture = function () {
                        this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
                    }, t
                }(),
                qe = function (t) {
                    function e(e) {
                        var i = this;
                        "number" == typeof e && (e = {
                            width: arguments[0],
                            height: arguments[1],
                            scaleMode: arguments[2],
                            resolution: arguments[3]
                        }), i = t.call(this, null, e) || this;
                        var n = e || {},
                            r = n.width,
                            o = n.height;
                        return i.mipmap = 0, i.width = Math.ceil(r) || 100, i.height = Math.ceil(o) || 100, i.valid = !0, i.clearColor = [0, 0, 0, 0], i.framebuffer = new Ke(i.width * i.resolution, i.height * i.resolution).addColorTexture(0, i), i.maskStack = [], i.filterStack = [{}], i
                    }
                    return Le(e, t), e.prototype.resize = function (t, e) {
                        t = Math.ceil(t), e = Math.ceil(e), this.framebuffer.resize(t * this.resolution, e * this.resolution)
                    }, e.prototype.dispose = function () {
                        this.framebuffer.dispose(), t.prototype.dispose.call(this)
                    }, e.prototype.destroy = function () {
                        t.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
                    }, e
                }(Re),
                Ze = function () {
                    function t() {
                        this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
                    }
                    return t.prototype.set = function (t, e, i) {
                        var n = e.width,
                            r = e.height;
                        if (i) {
                            var o = t.width / 2 / n,
                                s = t.height / 2 / r,
                                a = t.x / n + o,
                                l = t.y / r + s;
                            i = ne.add(i, ne.NW), this.x0 = a + o * ne.uX(i), this.y0 = l + s * ne.uY(i), i = ne.add(i, 2), this.x1 = a + o * ne.uX(i), this.y1 = l + s * ne.uY(i), i = ne.add(i, 2), this.x2 = a + o * ne.uX(i), this.y2 = l + s * ne.uY(i), i = ne.add(i, 2), this.x3 = a + o * ne.uX(i), this.y3 = l + s * ne.uY(i)
                        } else this.x0 = t.x / n, this.y0 = t.y / r, this.x1 = (t.x + t.width) / n, this.y1 = t.y / r, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / r, this.x3 = t.x / n, this.y3 = (t.y + t.height) / r;
                        this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
                    }, t
                }(),
                $e = new Ze,
                Je = function (t) {
                    function e(i, n, r, o, s, a) {
                        var l = t.call(this) || this;
                        if (l.noFrame = !1, n || (l.noFrame = !0, n = new Vt(0, 0, 1, 1)), i instanceof e && (i = i.baseTexture), l.baseTexture = i, l._frame = n, l.trim = o, l.valid = !1, l._uvs = $e, l.uvMatrix = null, l.orig = r || n, l._rotate = Number(s || 0), !0 === s) l._rotate = 2;
                        else if (l._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
                        return l.defaultAnchor = a ? new zt(a.x, a.y) : new zt(0, 0), l._updateID = 0, l.textureCacheIds = [], i.valid ? l.noFrame ? i.valid && l.onBaseTextureUpdated(i) : l.frame = n : i.once("loaded", l.onBaseTextureUpdated, l), l.noFrame && i.on("update", l.onBaseTextureUpdated, l), l
                    }
                    return Le(e, t), e.prototype.update = function () {
                        this.baseTexture.resource && this.baseTexture.resource.update()
                    }, e.prototype.onBaseTextureUpdated = function (t) {
                        if (this.noFrame) {
                            if (!this.baseTexture.valid) return;
                            this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
                        } else this.frame = this._frame;
                        this.emit("update", this)
                    }, e.prototype.destroy = function (t) {
                        if (this.baseTexture) {
                            if (t) {
                                var i = this.baseTexture;
                                i && i.url && Et[i.url] && e.removeFromCache(i.url), this.baseTexture.destroy()
                            }
                            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
                        }
                        this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null
                    }, e.prototype.clone = function () {
                        return new e(this.baseTexture, this.frame.clone(), this.orig.clone(), this.trim && this.trim.clone(), this.rotate, this.defaultAnchor)
                    }, e.prototype.updateUvs = function () {
                        this._uvs === $e && (this._uvs = new Ze), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
                    }, e.from = function (t, i, n) {
                        void 0 === i && (i = {}), void 0 === n && (n = j.STRICT_TEXTURE_CACHE);
                        var r = "string" == typeof t,
                            o = null;
                        r ? o = t : (t._pixiId || (t._pixiId = "pixiid_" + Pt()), o = t._pixiId);
                        var s = Et[o];
                        if (r && n && !s) throw new Error('The cacheId "' + o + '" does not exist in TextureCache.');
                        return s || (i.resolution || (i.resolution = Ft(t)), (s = new e(new Re(t, i))).baseTexture.cacheId = o, Re.addToCache(s.baseTexture, o), e.addToCache(s, o)), s
                    }, e.fromURL = function (t, i) {
                        var n = Object.assign({
                            autoLoad: !1
                        }, null == i ? void 0 : i.resourceOptions),
                            r = e.from(t, Object.assign({
                                resourceOptions: n
                            }, i), !1),
                            o = r.baseTexture.resource;
                        return r.baseTexture.valid ? Promise.resolve(r) : o.load().then((function () {
                            return Promise.resolve(r)
                        }))
                    }, e.fromBuffer = function (t, i, n, r) {
                        return new e(Re.fromBuffer(t, i, n, r))
                    }, e.fromLoader = function (t, i, n) {
                        var r = new We(t);
                        r.url = i;
                        var o = new e(new Re(r, {
                            scaleMode: j.SCALE_MODE,
                            resolution: Ft(i)
                        }));
                        return n || (n = i), Re.addToCache(o.baseTexture, n), e.addToCache(o, n), n !== i && (Re.addToCache(o.baseTexture, i), e.addToCache(o, i)), o
                    }, e.addToCache = function (t, e) {
                        e && (-1 === t.textureCacheIds.indexOf(e) && t.textureCacheIds.push(e), Et[e] && console.warn("Texture added to the cache with an id [" + e + "] that already had an entry"), Et[e] = t)
                    }, e.removeFromCache = function (t) {
                        if ("string" == typeof t) {
                            var e = Et[t];
                            if (e) {
                                var i = e.textureCacheIds.indexOf(t);
                                return i > -1 && e.textureCacheIds.splice(i, 1), delete Et[t], e
                            }
                        } else if (t && t.textureCacheIds) {
                            for (var n = 0; n < t.textureCacheIds.length; ++n) Et[t.textureCacheIds[n]] === t && delete Et[t.textureCacheIds[n]];
                            return t.textureCacheIds.length = 0, t
                        }
                        return null
                    }, Object.defineProperty(e.prototype, "resolution", {
                        get: function () {
                            return this.baseTexture.resolution
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "frame", {
                        get: function () {
                            return this._frame
                        },
                        set: function (t) {
                            this._frame = t, this.noFrame = !1;
                            var e = t.x,
                                i = t.y,
                                n = t.width,
                                r = t.height,
                                o = e + n > this.baseTexture.width,
                                s = i + r > this.baseTexture.height;
                            if (o || s) {
                                var a = o && s ? "and" : "or",
                                    l = "X: " + e + " + " + n + " = " + (e + n) + " > " + this.baseTexture.width,
                                    h = "Y: " + i + " + " + r + " = " + (i + r) + " > " + this.baseTexture.height;
                                throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + l + " " + a + " " + h)
                            }
                            this.valid = n && r && this.baseTexture.valid, this.trim || this.rotate || (this.orig = t), this.valid && this.updateUvs()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "rotate", {
                        get: function () {
                            return this._rotate
                        },
                        set: function (t) {
                            this._rotate = t, this.valid && this.updateUvs()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return this.orig.width
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "height", {
                        get: function () {
                            return this.orig.height
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.castToBaseTexture = function () {
                        return this.baseTexture
                    }, e
                }(K());

            function Qe(t) {
                t.destroy = function () { }, t.on = function () { }, t.once = function () { }, t.emit = function () { }
            }
            Je.EMPTY = new Je(new Re), Qe(Je.EMPTY), Qe(Je.EMPTY.baseTexture), Je.WHITE = function () {
                var t = document.createElement("canvas");
                t.width = 16, t.height = 16;
                var e = t.getContext("2d");
                return e.fillStyle = "white", e.fillRect(0, 0, 16, 16), new Je(new Re(new Ue(t)))
            }(), Qe(Je.WHITE), Qe(Je.WHITE.baseTexture);
            var ti = function (t) {
                function e(e, i) {
                    var n = this,
                        r = null;
                    if (!(e instanceof qe)) {
                        var o = arguments[1],
                            s = arguments[2],
                            a = arguments[3],
                            l = arguments[4];
                        console.warn("Please use RenderTexture.create(" + o + ", " + s + ") instead of the ctor directly."), r = arguments[0], i = null, e = new qe({
                            width: o,
                            height: s,
                            scaleMode: a,
                            resolution: l
                        })
                    }
                    return (n = t.call(this, e, i) || this).legacyRenderer = r, n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n
                }
                return Le(e, t), Object.defineProperty(e.prototype, "framebuffer", {
                    get: function () {
                        return this.baseTexture.framebuffer
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.resize = function (t, e, i) {
                    void 0 === i && (i = !0), t = Math.ceil(t), e = Math.ceil(e), this.valid = t > 0 && e > 0, this._frame.width = this.orig.width = t, this._frame.height = this.orig.height = e, i && this.baseTexture.resize(t, e), this.updateUvs()
                }, e.prototype.setResolution = function (t) {
                    var e = this.baseTexture;
                    e.resolution !== t && (e.setResolution(t), this.resize(e.width, e.height, !1))
                }, e.create = function (t) {
                    return "number" == typeof t && (t = {
                        width: t,
                        height: arguments[1],
                        scaleMode: arguments[2],
                        resolution: arguments[3]
                    }), new e(new qe(t))
                }, e
            }(Je),
                ei = function () {
                    function t(t) {
                        this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
                    }
                    return t.prototype.createTexture = function (t, e) {
                        var i = new qe(Object.assign({
                            width: t,
                            height: e,
                            resolution: 1
                        }, this.textureOptions));
                        return new ti(i)
                    }, t.prototype.getOptimalTexture = function (e, i, n) {
                        void 0 === n && (n = 1);
                        var r = t.SCREEN_KEY;
                        e *= n, i *= n, this.enableFullScreen && e === this._pixelsWidth && i === this._pixelsHeight || (r = (65535 & (e = _t(e))) << 16 | 65535 & (i = _t(i))), this.texturePool[r] || (this.texturePool[r] = []);
                        var o = this.texturePool[r].pop();
                        return o || (o = this.createTexture(e, i)), o.filterPoolKey = r, o.setResolution(n), o
                    }, t.prototype.getFilterTexture = function (t, e) {
                        var i = this.getOptimalTexture(t.width, t.height, e || t.resolution);
                        return i.filterFrame = t.filterFrame, i
                    }, t.prototype.returnTexture = function (t) {
                        var e = t.filterPoolKey;
                        t.filterFrame = null, this.texturePool[e].push(t)
                    }, t.prototype.returnFilterTexture = function (t) {
                        this.returnTexture(t)
                    }, t.prototype.clear = function (t) {
                        if (t = !1 !== t)
                            for (var e in this.texturePool) {
                                var i = this.texturePool[e];
                                if (i)
                                    for (var n = 0; n < i.length; n++) i[n].destroy(!0)
                            }
                        this.texturePool = {}
                    }, t.prototype.setScreenSize = function (e) {
                        if (e.width !== this._pixelsWidth || e.height !== this._pixelsHeight) {
                            var i = t.SCREEN_KEY,
                                n = this.texturePool[i];
                            if (this.enableFullScreen = e.width > 0 && e.height > 0, n)
                                for (var r = 0; r < n.length; r++) n[r].destroy(!0);
                            this.texturePool[i] = [], this._pixelsWidth = e.width, this._pixelsHeight = e.height
                        }
                    }, t.SCREEN_KEY = "screen", t
                }(),
                ii = function () {
                    function t(t, e, i, n, r, o, s) {
                        void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === n && (n = 5126), this.buffer = t, this.size = e, this.normalized = i, this.type = n, this.stride = r, this.start = o, this.instance = s
                    }
                    return t.prototype.destroy = function () {
                        this.buffer = null
                    }, t.from = function (e, i, n, r, o) {
                        return new t(e, i, n, r, o)
                    }, t
                }(),
                ni = 0,
                ri = function () {
                    function t(t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = !1), this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i, this.static = e, this.id = ni++, this.disposeRunner = new Ee("disposeBuffer")
                    }
                    return t.prototype.update = function (t) {
                        this.data = t || this.data, this._updateID++
                    }, t.prototype.dispose = function () {
                        this.disposeRunner.emit(this, !1)
                    }, t.prototype.destroy = function () {
                        this.dispose(), this.data = null
                    }, t.from = function (e) {
                        return e instanceof Array && (e = new Float32Array(e)), new t(e)
                    }, t
                }();

            function oi(t) {
                if (4 === t.BYTES_PER_ELEMENT) return t instanceof Float32Array ? "Float32Array" : t instanceof Uint32Array ? "Uint32Array" : "Int32Array";
                if (2 === t.BYTES_PER_ELEMENT) {
                    if (t instanceof Uint16Array) return "Uint16Array"
                } else if (1 === t.BYTES_PER_ELEMENT && t instanceof Uint8Array) return "Uint8Array";
                return null
            }
            var si = {
                Float32Array,
                Uint32Array,
                Int32Array,
                Uint8Array
            },
                ai = {
                    5126: 4,
                    5123: 2,
                    5121: 1
                },
                li = 0,
                hi = {
                    Float32Array,
                    Uint32Array,
                    Int32Array,
                    Uint8Array,
                    Uint16Array
                },
                ui = function () {
                    function t(t, e) {
                        void 0 === t && (t = []), void 0 === e && (e = {}), this.buffers = t, this.indexBuffer = null, this.attributes = e, this.glVertexArrayObjects = {}, this.id = li++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Ee("disposeGeometry"), this.refCount = 0
                    }
                    return t.prototype.addAttribute = function (t, e, i, n, r, o, s, a) {
                        if (void 0 === i && (i = 0), void 0 === n && (n = !1), void 0 === a && (a = !1), !e) throw new Error("You must pass a buffer when creating an attribute");
                        e instanceof ri || (e instanceof Array && (e = new Float32Array(e)), e = new ri(e));
                        var l = t.split("|");
                        if (l.length > 1) {
                            for (var h = 0; h < l.length; h++) this.addAttribute(l[h], e, i, n, r);
                            return this
                        }
                        var u = this.buffers.indexOf(e);
                        return -1 === u && (this.buffers.push(e), u = this.buffers.length - 1), this.attributes[t] = new ii(u, i, n, r, o, s, a), this.instanced = this.instanced || a, this
                    }, t.prototype.getAttribute = function (t) {
                        return this.attributes[t]
                    }, t.prototype.getBuffer = function (t) {
                        return this.buffers[this.getAttribute(t).buffer]
                    }, t.prototype.addIndex = function (t) {
                        return t instanceof ri || (t instanceof Array && (t = new Uint16Array(t)), t = new ri(t)), t.index = !0, this.indexBuffer = t, -1 === this.buffers.indexOf(t) && this.buffers.push(t), this
                    }, t.prototype.getIndex = function () {
                        return this.indexBuffer
                    }, t.prototype.interleave = function () {
                        if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
                        var t, e = [],
                            i = [],
                            n = new ri;
                        for (t in this.attributes) {
                            var r = this.attributes[t],
                                o = this.buffers[r.buffer];
                            e.push(o.data), i.push(r.size * ai[r.type] / 4), r.buffer = 0
                        }
                        for (n.data = function (t, e) {
                            for (var i = 0, n = 0, r = {}, o = 0; o < t.length; o++) n += e[o], i += t[o].length;
                            var s = new ArrayBuffer(4 * i),
                                a = null,
                                l = 0;
                            for (o = 0; o < t.length; o++) {
                                var h = e[o],
                                    u = t[o],
                                    c = oi(u);
                                r[c] || (r[c] = new si[c](s)), a = r[c];
                                for (var d = 0; d < u.length; d++) a[(d / h | 0) * n + l + d % h] = u[d];
                                l += h
                            }
                            return new Float32Array(s)
                        }(e, i), t = 0; t < this.buffers.length; t++) this.buffers[t] !== this.indexBuffer && this.buffers[t].destroy();
                        return this.buffers = [n], this.indexBuffer && this.buffers.push(this.indexBuffer), this
                    }, t.prototype.getSize = function () {
                        for (var t in this.attributes) {
                            var e = this.attributes[t];
                            return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
                        }
                        return 0
                    }, t.prototype.dispose = function () {
                        this.disposeRunner.emit(this, !1)
                    }, t.prototype.destroy = function () {
                        this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
                    }, t.prototype.clone = function () {
                        for (var e = new t, i = 0; i < this.buffers.length; i++) e.buffers[i] = new ri(this.buffers[i].data.slice(0));
                        for (var i in this.attributes) {
                            var n = this.attributes[i];
                            e.attributes[i] = new ii(n.buffer, n.size, n.normalized, n.type, n.stride, n.start, n.instance)
                        }
                        return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.index = !0), e
                    }, t.merge = function (e) {
                        for (var i, n = new t, r = [], o = [], s = [], a = 0; a < e.length; a++) {
                            i = e[a];
                            for (var l = 0; l < i.buffers.length; l++) o[l] = o[l] || 0, o[l] += i.buffers[l].data.length, s[l] = 0
                        }
                        for (a = 0; a < i.buffers.length; a++) r[a] = new (hi[oi(i.buffers[a].data)])(o[a]), n.buffers[a] = new ri(r[a]);
                        for (a = 0; a < e.length; a++)
                            for (i = e[a], l = 0; l < i.buffers.length; l++) r[l].set(i.buffers[l].data, s[l]), s[l] += i.buffers[l].data.length;
                        if (n.attributes = i.attributes, i.indexBuffer) {
                            n.indexBuffer = n.buffers[i.buffers.indexOf(i.indexBuffer)], n.indexBuffer.index = !0;
                            var h = 0,
                                u = 0,
                                c = 0,
                                d = 0;
                            for (a = 0; a < i.buffers.length; a++)
                                if (i.buffers[a] !== i.indexBuffer) {
                                    d = a;
                                    break
                                } for (var a in i.attributes) {
                                    var p = i.attributes[a];
                                    (0 | p.buffer) === d && (u += p.size * ai[p.type] / 4)
                                }
                            for (a = 0; a < e.length; a++) {
                                var f = e[a].indexBuffer.data;
                                for (l = 0; l < f.length; l++) n.indexBuffer.data[l + c] += h;
                                h += i.buffers[d].data.length / u, c += f.length
                            }
                        }
                        return n
                    }, t
                }(),
                ci = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2]), e
                    }
                    return Le(e, t), e
                }(ui),
                di = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), e.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), e.vertexBuffer = new ri(e.vertices), e.uvBuffer = new ri(e.uvs), e.addAttribute("aVertexPosition", e.vertexBuffer).addAttribute("aTextureCoord", e.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), e
                    }
                    return Le(e, t), e.prototype.map = function (t, e) {
                        var i = 0,
                            n = 0;
                        return this.uvs[0] = i, this.uvs[1] = n, this.uvs[2] = i + e.width / t.width, this.uvs[3] = n, this.uvs[4] = i + e.width / t.width, this.uvs[5] = n + e.height / t.height, this.uvs[6] = i, this.uvs[7] = n + e.height / t.height, i = e.x, n = e.y, this.vertices[0] = i, this.vertices[1] = n, this.vertices[2] = i + e.width, this.vertices[3] = n, this.vertices[4] = i + e.width, this.vertices[5] = n + e.height, this.vertices[6] = i, this.vertices[7] = n + e.height, this.invalidate(), this
                    }, e.prototype.invalidate = function () {
                        return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
                    }, e
                }(ui),
                pi = 0,
                fi = function () {
                    function t(t, e) {
                        this.uniforms = t, this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = pi++, this.static = !!e
                    }
                    return t.prototype.update = function () {
                        this.dirtyId++
                    }, t.prototype.add = function (e, i, n) {
                        this.uniforms[e] = new t(i, n)
                    }, t.from = function (e, i) {
                        return new t(e, i)
                    }, t
                }(),
                gi = function () {
                    function t() {
                        this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.sourceFrame = new Vt, this.destinationFrame = new Vt, this.filters = []
                    }
                    return t.prototype.clear = function () {
                        this.target = null, this.filters = null, this.renderTexture = null
                    }, t
                }(),
                mi = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.defaultFilterStack = [{}], i.texturePool = new ei, i.texturePool.setScreenSize(e.view), i.statePool = [], i.quad = new ci, i.quadUv = new di, i.tempRect = new Vt, i.activeState = {}, i.globalUniforms = new fi({
                            outputFrame: i.tempRect,
                            inputSize: new Float32Array(4),
                            inputPixel: new Float32Array(4),
                            inputClamp: new Float32Array(4),
                            resolution: 1,
                            filterArea: new Float32Array(4),
                            filterClamp: new Float32Array(4)
                        }, !0), i.forceClear = !1, i.useMaxPadding = !1, i
                    }
                    return Le(e, t), e.prototype.push = function (t, e) {
                        for (var i = this.renderer, n = this.defaultFilterStack, r = this.statePool.pop() || new gi, o = e[0].resolution, s = e[0].padding, a = e[0].autoFit, l = e[0].legacy, h = 1; h < e.length; h++) {
                            var u = e[h];
                            o = Math.min(o, u.resolution), s = this.useMaxPadding ? Math.max(s, u.padding) : s + u.padding, a = a && u.autoFit, l = l || u.legacy
                        }
                        1 === n.length && (this.defaultFilterStack[0].renderTexture = i.renderTexture.current), n.push(r), r.resolution = o, r.legacy = l, r.target = t, r.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), r.sourceFrame.pad(s), a && r.sourceFrame.fit(this.renderer.renderTexture.sourceFrame), r.sourceFrame.ceil(o), r.renderTexture = this.getOptimalFilterTexture(r.sourceFrame.width, r.sourceFrame.height, o), r.filters = e, r.destinationFrame.width = r.renderTexture.width, r.destinationFrame.height = r.renderTexture.height;
                        var c = this.tempRect;
                        c.width = r.sourceFrame.width, c.height = r.sourceFrame.height, r.renderTexture.filterFrame = r.sourceFrame, i.renderTexture.bind(r.renderTexture, r.sourceFrame, c), i.renderTexture.clear()
                    }, e.prototype.pop = function () {
                        var t = this.defaultFilterStack,
                            e = t.pop(),
                            i = e.filters;
                        this.activeState = e;
                        var n = this.globalUniforms.uniforms;
                        n.outputFrame = e.sourceFrame, n.resolution = e.resolution;
                        var r = n.inputSize,
                            o = n.inputPixel,
                            s = n.inputClamp;
                        if (r[0] = e.destinationFrame.width, r[1] = e.destinationFrame.height, r[2] = 1 / r[0], r[3] = 1 / r[1], o[0] = r[0] * e.resolution, o[1] = r[1] * e.resolution, o[2] = 1 / o[0], o[3] = 1 / o[1], s[0] = .5 * o[2], s[1] = .5 * o[3], s[2] = e.sourceFrame.width * r[2] - .5 * o[2], s[3] = e.sourceFrame.height * r[3] - .5 * o[3], e.legacy) {
                            var a = n.filterArea;
                            a[0] = e.destinationFrame.width, a[1] = e.destinationFrame.height, a[2] = e.sourceFrame.x, a[3] = e.sourceFrame.y, n.filterClamp = n.inputClamp
                        }
                        this.globalUniforms.update();
                        var l = t[t.length - 1];
                        if (e.renderTexture.framebuffer.multisample > 1 && this.renderer.framebuffer.blit(), 1 === i.length) i[0].apply(this, e.renderTexture, l.renderTexture, A.BLEND, e), this.returnFilterTexture(e.renderTexture);
                        else {
                            var h = e.renderTexture,
                                u = this.getOptimalFilterTexture(h.width, h.height, e.resolution);
                            u.filterFrame = h.filterFrame;
                            var c = 0;
                            for (c = 0; c < i.length - 1; ++c) {
                                i[c].apply(this, h, u, A.CLEAR, e);
                                var d = h;
                                h = u, u = d
                            }
                            i[c].apply(this, h, l.renderTexture, A.BLEND, e), this.returnFilterTexture(h), this.returnFilterTexture(u)
                        }
                        e.clear(), this.statePool.push(e)
                    }, e.prototype.bindAndClear = function (t, e) {
                        if (void 0 === e && (e = A.CLEAR), t && t.filterFrame) {
                            var i = this.tempRect;
                            i.width = t.filterFrame.width, i.height = t.filterFrame.height, this.renderer.renderTexture.bind(t, t.filterFrame, i)
                        } else this.renderer.renderTexture.bind(t);
                        "boolean" == typeof e && (e = e ? A.CLEAR : A.BLEND, It("5.2.1", "Use CLEAR_MODES when using clear applyFilter option")), (e === A.CLEAR || e === A.BLIT && this.forceClear) && this.renderer.renderTexture.clear()
                    }, e.prototype.applyFilter = function (t, e, i, n) {
                        var r = this.renderer;
                        this.bindAndClear(i, n), t.uniforms.uSampler = e, t.uniforms.filterGlobals = this.globalUniforms, r.state.set(t.state), r.shader.bind(t), t.legacy ? (this.quadUv.map(e._frame, e.filterFrame), r.geometry.bind(this.quadUv), r.geometry.draw(m.TRIANGLES)) : (r.geometry.bind(this.quad), r.geometry.draw(m.TRIANGLE_STRIP))
                    }, e.prototype.calculateSpriteMatrix = function (t, e) {
                        var i = this.activeState,
                            n = i.sourceFrame,
                            r = i.destinationFrame,
                            o = e._texture.orig,
                            s = t.set(r.width, 0, 0, r.height, n.x, n.y),
                            a = e.worldTransform.copyTo(qt.TEMP_MATRIX);
                        return a.invert(), s.prepend(a), s.scale(1 / o.width, 1 / o.height), s.translate(e.anchor.x, e.anchor.y), s
                    }, e.prototype.destroy = function () {
                        this.texturePool.clear(!1)
                    }, e.prototype.getOptimalFilterTexture = function (t, e, i) {
                        return void 0 === i && (i = 1), this.texturePool.getOptimalTexture(t, e, i)
                    }, e.prototype.getFilterTexture = function (t, e) {
                        if ("number" == typeof t) {
                            var i = t;
                            t = e, e = i
                        }
                        t = t || this.activeState.renderTexture;
                        var n = this.texturePool.getOptimalTexture(t.width, t.height, e || t.resolution);
                        return n.filterFrame = t.filterFrame, n
                    }, e.prototype.returnFilterTexture = function (t) {
                        this.texturePool.returnTexture(t)
                    }, e.prototype.emptyPool = function () {
                        this.texturePool.clear(!0)
                    }, e.prototype.resize = function () {
                        this.texturePool.setScreenSize(this.renderer.view)
                    }, e
                }(je),
                _i = function () {
                    function t(t) {
                        this.renderer = t
                    }
                    return t.prototype.flush = function () { }, t.prototype.destroy = function () {
                        this.renderer = null
                    }, t.prototype.start = function () { }, t.prototype.stop = function () {
                        this.flush()
                    }, t.prototype.render = function (t) { }, t
                }(),
                yi = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.emptyRenderer = new _i(e), i.currentRenderer = i.emptyRenderer, i
                    }
                    return Le(e, t), e.prototype.setObjectRenderer = function (t) {
                        this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
                    }, e.prototype.flush = function () {
                        this.setObjectRenderer(this.emptyRenderer)
                    }, e.prototype.reset = function () {
                        this.setObjectRenderer(this.emptyRenderer)
                    }, e.prototype.copyBoundTextures = function (t, e) {
                        for (var i = this.renderer.texture.boundTextures, n = e - 1; n >= 0; --n) t[n] = i[n] || null, t[n] && (t[n]._batchLocation = n)
                    }, e.prototype.boundArray = function (t, e, i, n) {
                        for (var r = t.elements, o = t.ids, s = t.count, a = 0, l = 0; l < s; l++) {
                            var h = r[l],
                                u = h._batchLocation;
                            if (u >= 0 && u < n && e[u] === h) o[l] = u;
                            else
                                for (; a < n;) {
                                    var c = e[a];
                                    if (!c || c._batchEnabled !== i || c._batchLocation !== a) {
                                        o[l] = a, h._batchLocation = a, e[a] = h;
                                        break
                                    }
                                    a++
                                }
                        }
                    }, e
                }(je),
                Si = 0,
                vi = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.webGLVersion = 1, i.extensions = {}, i.supports = {
                            uint32Indices: !1
                        }, i.handleContextLost = i.handleContextLost.bind(i), i.handleContextRestored = i.handleContextRestored.bind(i), e.view.addEventListener("webglcontextlost", i.handleContextLost, !1), e.view.addEventListener("webglcontextrestored", i.handleContextRestored, !1), i
                    }
                    return Le(e, t), Object.defineProperty(e.prototype, "isLost", {
                        get: function () {
                            return !this.gl || this.gl.isContextLost()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.contextChange = function (t) {
                        this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = Si++, t.isContextLost() && t.getExtension("WEBGL_lose_context") && t.getExtension("WEBGL_lose_context").restoreContext()
                    }, e.prototype.initFromContext = function (t) {
                        this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = Si++, this.renderer.runners.contextChange.emit(t)
                    }, e.prototype.initFromOptions = function (t) {
                        var e = this.createContext(this.renderer.view, t);
                        this.initFromContext(e)
                    }, e.prototype.createContext = function (t, e) {
                        var i;
                        if (j.PREFER_ENV >= d.WEBGL2 && (i = t.getContext("webgl2", e)), i) this.webGLVersion = 2;
                        else if (this.webGLVersion = 1, !(i = t.getContext("webgl", e) || t.getContext("experimental-webgl", e))) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
                        return this.gl = i, this.getExtensions(), this.gl
                    }, e.prototype.getExtensions = function () {
                        var t = this.gl;
                        1 === this.webGLVersion ? Object.assign(this.extensions, {
                            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                            depthTexture: t.getExtension("WEBGL_depth_texture"),
                            loseContext: t.getExtension("WEBGL_lose_context"),
                            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
                            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
                            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                            floatTexture: t.getExtension("OES_texture_float"),
                            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                            textureHalfFloat: t.getExtension("OES_texture_half_float"),
                            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
                        }) : 2 === this.webGLVersion && Object.assign(this.extensions, {
                            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
                            colorBufferFloat: t.getExtension("EXT_color_buffer_float"),
                            floatTextureLinear: t.getExtension("OES_texture_float_linear")
                        })
                    }, e.prototype.handleContextLost = function (t) {
                        t.preventDefault()
                    }, e.prototype.handleContextRestored = function () {
                        this.renderer.runners.contextChange.emit(this.gl)
                    }, e.prototype.destroy = function () {
                        var t = this.renderer.view;
                        t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
                    }, e.prototype.postrender = function () {
                        this.renderer.renderingToScreen && this.gl.flush()
                    }, e.prototype.validateContext = function (t) {
                        var e = t.getContextAttributes(),
                            i = "WebGL2RenderingContext" in window && t instanceof window.WebGL2RenderingContext;
                        i && (this.webGLVersion = 2), e.stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
                        var n = i || !!t.getExtension("OES_element_index_uint");
                        this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
                    }, e
                }(je),
                bi = function (t) {
                    this.framebuffer = t, this.stencil = null, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.multisample = C.NONE, this.msaaBuffer = null, this.blitFramebuffer = null
                },
                Ti = new Vt,
                Pi = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.managedFramebuffers = [], i.unknownFramebuffer = new Ke(10, 10), i.msaaSamples = null, i
                    }
                    return Le(e, t), e.prototype.contextChange = function () {
                        var t = this.gl = this.renderer.gl;
                        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Vt, this.hasMRT = !0, this.writeDepthTexture = !0, this.disposeAll(!0), 1 === this.renderer.context.webGLVersion) {
                            var e = this.renderer.context.extensions.drawBuffers,
                                i = this.renderer.context.extensions.depthTexture;
                            j.PREFER_ENV === d.WEBGL_LEGACY && (e = null, i = null), e ? t.drawBuffers = function (t) {
                                return e.drawBuffersWEBGL(t)
                            } : (this.hasMRT = !1, t.drawBuffers = function () { }), i || (this.writeDepthTexture = !1)
                        } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
                    }, e.prototype.bind = function (t, e) {
                        var i = this.gl;
                        if (t) {
                            var n = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
                            this.current !== t && (this.current = t, i.bindFramebuffer(i.FRAMEBUFFER, n.framebuffer)), n.dirtyId !== t.dirtyId && (n.dirtyId = t.dirtyId, n.dirtyFormat !== t.dirtyFormat ? (n.dirtyFormat = t.dirtyFormat, this.updateFramebuffer(t)) : n.dirtySize !== t.dirtySize && (n.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
                            for (var r = 0; r < t.colorTextures.length; r++) {
                                var o = t.colorTextures[r];
                                this.renderer.texture.unbind(o.parentTextureArray || o)
                            }
                            t.depthTexture && this.renderer.texture.unbind(t.depthTexture), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, t.width, t.height)
                        } else this.current && (this.current = null, i.bindFramebuffer(i.FRAMEBUFFER, null)), e ? this.setViewport(e.x, e.y, e.width, e.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
                    }, e.prototype.setViewport = function (t, e, i, n) {
                        var r = this.viewport;
                        r.width === i && r.height === n && r.x === t && r.y === e || (r.x = t, r.y = e, r.width = i, r.height = n, this.gl.viewport(t, e, i, n))
                    }, Object.defineProperty(e.prototype, "size", {
                        get: function () {
                            return this.current ? {
                                x: 0,
                                y: 0,
                                width: this.current.width,
                                height: this.current.height
                            } : {
                                x: 0,
                                y: 0,
                                width: this.renderer.width,
                                height: this.renderer.height
                            }
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.clear = function (t, e, i, n, r) {
                        void 0 === r && (r = f.COLOR | f.DEPTH);
                        var o = this.gl;
                        o.clearColor(t, e, i, n), o.clear(r)
                    }, e.prototype.initFramebuffer = function (t) {
                        var e = this.gl,
                            i = new bi(e.createFramebuffer());
                        return i.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = i, this.managedFramebuffers.push(t), t.disposeRunner.add(this), i
                    }, e.prototype.resizeFramebuffer = function (t) {
                        var e = this.gl,
                            i = t.glFramebuffers[this.CONTEXT_UID];
                        i.stencil && (e.bindRenderbuffer(e.RENDERBUFFER, i.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height));
                        for (var n = t.colorTextures, r = 0; r < n.length; r++) this.renderer.texture.bind(n[r], 0);
                        t.depthTexture && this.renderer.texture.bind(t.depthTexture, 0)
                    }, e.prototype.updateFramebuffer = function (t) {
                        var e = this.gl,
                            i = t.glFramebuffers[this.CONTEXT_UID],
                            n = t.colorTextures.length;
                        e.drawBuffers || (n = Math.min(n, 1)), i.multisample > 1 && (i.msaaBuffer = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer), e.renderbufferStorageMultisample(e.RENDERBUFFER, i.multisample, e.RGBA8, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, i.msaaBuffer));
                        for (var r = [], o = 0; o < n; o++)
                            if (!(0 === o && i.multisample > 1)) {
                                var s = t.colorTextures[o],
                                    a = s.parentTextureArray || s;
                                this.renderer.texture.bind(a, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + o, s.target, a._glTextures[this.CONTEXT_UID].texture, 0), r.push(e.COLOR_ATTACHMENT0 + o)
                            } if (r.length > 1 && e.drawBuffers(r), t.depthTexture && this.writeDepthTexture) {
                                var l = t.depthTexture;
                                this.renderer.texture.bind(l, 0), e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, l._glTextures[this.CONTEXT_UID].texture, 0)
                            }
                        i.stencil || !t.stencil && !t.depth || (i.stencil = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, i.stencil), e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, t.width, t.height), t.depthTexture || e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, i.stencil))
                    }, e.prototype.detectSamples = function (t) {
                        var e = this.msaaSamples,
                            i = C.NONE;
                        if (t <= 1 || null === e) return i;
                        for (var n = 0; n < e.length; n++)
                            if (e[n] <= t) {
                                i = e[n];
                                break
                            } return 1 === i && (i = C.NONE), i
                    }, e.prototype.blit = function (t, e, i) {
                        var n = this,
                            r = n.current,
                            o = n.renderer,
                            s = n.gl,
                            a = n.CONTEXT_UID;
                        if (2 === o.context.webGLVersion && r) {
                            var l = r.glFramebuffers[a];
                            if (l) {
                                if (!t) {
                                    if (l.multisample <= 1) return;
                                    l.blitFramebuffer || (l.blitFramebuffer = new Ke(r.width, r.height), l.blitFramebuffer.addColorTexture(0, r.colorTextures[0])), (t = l.blitFramebuffer).width = r.width, t.height = r.height
                                }
                                e || ((e = Ti).width = r.width, e.height = r.height), i || (i = e);
                                var h = e.width === i.width && e.height === i.height;
                                this.bind(t), s.bindFramebuffer(s.READ_FRAMEBUFFER, l.framebuffer), s.blitFramebuffer(e.x, e.y, e.width, e.height, i.x, i.y, i.width, i.height, s.COLOR_BUFFER_BIT, h ? s.NEAREST : s.LINEAR)
                            }
                        }
                    }, e.prototype.disposeFramebuffer = function (t, e) {
                        var i = t.glFramebuffers[this.CONTEXT_UID],
                            n = this.gl;
                        if (i) {
                            delete t.glFramebuffers[this.CONTEXT_UID];
                            var r = this.managedFramebuffers.indexOf(t);
                            r >= 0 && this.managedFramebuffers.splice(r, 1), t.disposeRunner.remove(this), e || (n.deleteFramebuffer(i.framebuffer), i.stencil && n.deleteRenderbuffer(i.stencil))
                        }
                    }, e.prototype.disposeAll = function (t) {
                        var e = this.managedFramebuffers;
                        this.managedFramebuffers = [];
                        for (var i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t)
                    }, e.prototype.forceStencil = function () {
                        var t = this.current;
                        if (t) {
                            var e = t.glFramebuffers[this.CONTEXT_UID];
                            if (e && !e.stencil) {
                                t.enableStencil();
                                var i = t.width,
                                    n = t.height,
                                    r = this.gl,
                                    o = r.createRenderbuffer();
                                r.bindRenderbuffer(r.RENDERBUFFER, o), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, i, n), e.stencil = o, r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, o)
                            }
                        }
                    }, e.prototype.reset = function () {
                        this.current = this.unknownFramebuffer, this.viewport = new Vt
                    }, e
                }(je),
                Ai = function (t) {
                    this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
                },
                Ii = {
                    5126: 4,
                    5123: 2,
                    5121: 1
                },
                wi = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i._activeGeometry = null, i._activeVao = null, i.hasVao = !0, i.hasInstance = !0, i.canUseUInt32ElementIndex = !1, i.managedGeometries = {}, i.managedBuffers = {}, i
                    }
                    return Le(e, t), e.prototype.contextChange = function () {
                        this.disposeAll(!0);
                        var t = this.gl = this.renderer.gl,
                            e = this.renderer.context;
                        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== e.webGLVersion) {
                            var i = this.renderer.context.extensions.vertexArrayObject;
                            j.PREFER_ENV === d.WEBGL_LEGACY && (i = null), i ? (t.createVertexArray = function () {
                                return i.createVertexArrayOES()
                            }, t.bindVertexArray = function (t) {
                                return i.bindVertexArrayOES(t)
                            }, t.deleteVertexArray = function (t) {
                                return i.deleteVertexArrayOES(t)
                            }) : (this.hasVao = !1, t.createVertexArray = function () {
                                return null
                            }, t.bindVertexArray = function () {
                                return null
                            }, t.deleteVertexArray = function () {
                                return null
                            })
                        }
                        if (2 !== e.webGLVersion) {
                            var n = t.getExtension("ANGLE_instanced_arrays");
                            n ? (t.vertexAttribDivisor = function (t, e) {
                                return n.vertexAttribDivisorANGLE(t, e)
                            }, t.drawElementsInstanced = function (t, e, i, r, o) {
                                return n.drawElementsInstancedANGLE(t, e, i, r, o)
                            }, t.drawArraysInstanced = function (t, e, i, r) {
                                return n.drawArraysInstancedANGLE(t, e, i, r)
                            }) : this.hasInstance = !1
                        }
                        this.canUseUInt32ElementIndex = 2 === e.webGLVersion || !!e.extensions.uint32ElementIndex
                    }, e.prototype.bind = function (t, e) {
                        e = e || this.renderer.shader.shader;
                        var i = this.gl,
                            n = t.glVertexArrayObjects[this.CONTEXT_UID],
                            r = !1;
                        n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, r = !0);
                        var o = n[e.program.id] || this.initGeometryVao(t, e.program, r);
                        this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? i.bindVertexArray(o) : this.activateVao(t, e.program)), this.updateBuffers()
                    }, e.prototype.reset = function () {
                        this.unbind()
                    }, e.prototype.updateBuffers = function () {
                        for (var t = this._activeGeometry, e = this.gl, i = 0; i < t.buffers.length; i++) {
                            var n = t.buffers[i],
                                r = n._glBuffers[this.CONTEXT_UID];
                            if (n._updateID !== r.updateID) {
                                r.updateID = n._updateID;
                                var o = n.index ? e.ELEMENT_ARRAY_BUFFER : e.ARRAY_BUFFER;
                                if (e.bindBuffer(o, r.buffer), this._boundBuffer = r, r.byteLength >= n.data.byteLength) e.bufferSubData(o, 0, n.data);
                                else {
                                    var s = n.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW;
                                    r.byteLength = n.data.byteLength, e.bufferData(o, n.data, s)
                                }
                            }
                        }
                    }, e.prototype.checkCompatibility = function (t, e) {
                        var i = t.attributes,
                            n = e.attributeData;
                        for (var r in n)
                            if (!i[r]) throw new Error('shader and geometry incompatible, geometry missing the "' + r + '" attribute')
                    }, e.prototype.getSignature = function (t, e) {
                        var i = t.attributes,
                            n = e.attributeData,
                            r = ["g", t.id];
                        for (var o in i) n[o] && r.push(o);
                        return r.join("-")
                    }, e.prototype.initGeometryVao = function (t, e, i) {
                        void 0 === i && (i = !0), this.checkCompatibility(t, e);
                        var n = this.gl,
                            r = this.CONTEXT_UID,
                            o = this.getSignature(t, e),
                            s = t.glVertexArrayObjects[this.CONTEXT_UID],
                            a = s[o];
                        if (a) return s[e.id] = a, a;
                        var l = t.buffers,
                            h = t.attributes,
                            u = {},
                            c = {};
                        for (var d in l) u[d] = 0, c[d] = 0;
                        for (var d in h) !h[d].size && e.attributeData[d] ? h[d].size = e.attributeData[d].size : h[d].size || console.warn("PIXI Geometry attribute '" + d + "' size cannot be determined (likely the bound shader does not have the attribute)"), u[h[d].buffer] += h[d].size * Ii[h[d].type];
                        for (var d in h) {
                            var p = h[d],
                                f = p.size;
                            void 0 === p.stride && (u[p.buffer] === f * Ii[p.type] ? p.stride = 0 : p.stride = u[p.buffer]), void 0 === p.start && (p.start = c[p.buffer], c[p.buffer] += f * Ii[p.type])
                        }
                        a = n.createVertexArray(), n.bindVertexArray(a);
                        for (var g = 0; g < l.length; g++) {
                            var m = l[g];
                            m._glBuffers[r] || (m._glBuffers[r] = new Ai(n.createBuffer()), this.managedBuffers[m.id] = m, m.disposeRunner.add(this)), i && m._glBuffers[r].refCount++
                        }
                        return this.activateVao(t, e), this._activeVao = a, s[e.id] = a, s[o] = a, a
                    }, e.prototype.disposeBuffer = function (t, e) {
                        if (this.managedBuffers[t.id]) {
                            delete this.managedBuffers[t.id];
                            var i = t._glBuffers[this.CONTEXT_UID],
                                n = this.gl;
                            t.disposeRunner.remove(this), i && (e || n.deleteBuffer(i.buffer), delete t._glBuffers[this.CONTEXT_UID])
                        }
                    }, e.prototype.disposeGeometry = function (t, e) {
                        if (this.managedGeometries[t.id]) {
                            delete this.managedGeometries[t.id];
                            var i = t.glVertexArrayObjects[this.CONTEXT_UID],
                                n = this.gl,
                                r = t.buffers;
                            if (t.disposeRunner.remove(this), i) {
                                for (var o = 0; o < r.length; o++) {
                                    var s = r[o]._glBuffers[this.CONTEXT_UID];
                                    s.refCount--, 0 !== s.refCount || e || this.disposeBuffer(r[o], e)
                                }
                                if (!e)
                                    for (var a in i)
                                        if ("g" === a[0]) {
                                            var l = i[a];
                                            this._activeVao === l && this.unbind(), n.deleteVertexArray(l)
                                        } delete t.glVertexArrayObjects[this.CONTEXT_UID]
                            }
                        }
                    }, e.prototype.disposeAll = function (t) {
                        for (var e = Object.keys(this.managedGeometries), i = 0; i < e.length; i++) this.disposeGeometry(this.managedGeometries[e[i]], t);
                        for (e = Object.keys(this.managedBuffers), i = 0; i < e.length; i++) this.disposeBuffer(this.managedBuffers[e[i]], t)
                    }, e.prototype.activateVao = function (t, e) {
                        var i = this.gl,
                            n = this.CONTEXT_UID,
                            r = t.buffers,
                            o = t.attributes;
                        t.indexBuffer && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.indexBuffer._glBuffers[n].buffer);
                        var s = null;
                        for (var a in o) {
                            var l = o[a],
                                h = r[l.buffer]._glBuffers[n];
                            if (e.attributeData[a]) {
                                s !== h && (i.bindBuffer(i.ARRAY_BUFFER, h.buffer), s = h);
                                var u = e.attributeData[a].location;
                                if (i.enableVertexAttribArray(u), i.vertexAttribPointer(u, l.size, l.type || i.FLOAT, l.normalized, l.stride, l.start), l.instance) {
                                    if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
                                    i.vertexAttribDivisor(u, 1)
                                }
                            }
                        }
                    }, e.prototype.draw = function (t, e, i, n) {
                        var r = this.gl,
                            o = this._activeGeometry;
                        if (o.indexBuffer) {
                            var s = o.indexBuffer.data.BYTES_PER_ELEMENT,
                                a = 2 === s ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
                            2 === s || 4 === s && this.canUseUInt32ElementIndex ? o.instanced ? r.drawElementsInstanced(t, e || o.indexBuffer.data.length, a, (i || 0) * s, n || 1) : r.drawElements(t, e || o.indexBuffer.data.length, a, (i || 0) * s) : console.warn("unsupported index buffer type: uint32")
                        } else o.instanced ? r.drawArraysInstanced(t, i, e || o.getSize(), n || 1) : r.drawArrays(t, i, e || o.getSize());
                        return this
                    }, e.prototype.unbind = function () {
                        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
                    }, e
                }(je),
                Ei = function () {
                    function t(t) {
                        void 0 === t && (t = null), this.type = E.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._target = null
                    }
                    return t.prototype.reset = function () {
                        this.pooled && (this.maskObject = null, this.type = E.NONE, this.autoDetect = !0), this._target = null
                    }, t.prototype.copyCountersOrReset = function (t) {
                        t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
                    }, t
                }();

            function Ci(t, e, i) {
                var n = t.createShader(e);
                return t.shaderSource(n, i), t.compileShader(n), n
            }

            function xi(t, e, i, n) {
                var r = Ci(t, t.VERTEX_SHADER, e),
                    o = Ci(t, t.FRAGMENT_SHADER, i),
                    s = t.createProgram();
                if (t.attachShader(s, r), t.attachShader(s, o), n)
                    for (var a in n) t.bindAttribLocation(s, n[a], a);
                return t.linkProgram(s), t.getProgramParameter(s, t.LINK_STATUS) || (t.getShaderParameter(r, t.COMPILE_STATUS) || (console.warn(e), console.error(t.getShaderInfoLog(r))), t.getShaderParameter(o, t.COMPILE_STATUS) || (console.warn(i), console.error(t.getShaderInfoLog(o))), console.error("Pixi.js Error: Could not initialize shader."), console.error("gl.VALIDATE_STATUS", t.getProgramParameter(s, t.VALIDATE_STATUS)), console.error("gl.getError()", t.getError()), "" !== t.getProgramInfoLog(s) && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(s)), t.deleteProgram(s), s = null), t.deleteShader(r), t.deleteShader(o), s
            }

            function Bi(t) {
                for (var e = new Array(t), i = 0; i < e.length; i++) e[i] = !1;
                return e
            }

            function Li(t, e) {
                switch (t) {
                    case "float":
                    case "int":
                    case "sampler2D":
                    case "sampler2DArray":
                        return 0;
                    case "vec2":
                        return new Float32Array(2 * e);
                    case "vec3":
                        return new Float32Array(3 * e);
                    case "vec4":
                        return new Float32Array(4 * e);
                    case "ivec2":
                        return new Int32Array(2 * e);
                    case "ivec3":
                        return new Int32Array(3 * e);
                    case "ivec4":
                        return new Int32Array(4 * e);
                    case "bool":
                        return !1;
                    case "bvec2":
                        return Bi(2 * e);
                    case "bvec3":
                        return Bi(3 * e);
                    case "bvec4":
                        return Bi(4 * e);
                    case "mat2":
                        return new Float32Array([1, 0, 0, 1]);
                    case "mat3":
                        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    case "mat4":
                        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
                }
                return null
            }
            var Oi, Ni = {},
                Mi = Ni;

            function Ri() {
                if (Mi === Ni || Mi && Mi.isContextLost()) {
                    var t = document.createElement("canvas"),
                        e = void 0;
                    j.PREFER_ENV >= d.WEBGL2 && (e = t.getContext("webgl2", {})), e || ((e = t.getContext("webgl", {}) || t.getContext("experimental-webgl", {})) ? e.getExtension("WEBGL_draw_buffers") : e = null), Mi = e
                }
                return Mi
            }

            function Di(t, e, i) {
                if ("precision" !== t.substring(0, 9)) {
                    var n = e;
                    return e === w.HIGH && i !== w.HIGH && (n = w.MEDIUM), "precision " + n + " float;\n" + t
                }
                return i !== w.HIGH && "precision highp" === t.substring(0, 15) ? t.replace("precision highp", "precision mediump") : t
            }
            var Fi = {
                float: 1,
                vec2: 2,
                vec3: 3,
                vec4: 4,
                int: 1,
                ivec2: 2,
                ivec3: 3,
                ivec4: 4,
                bool: 1,
                bvec2: 2,
                bvec3: 3,
                bvec4: 4,
                mat2: 4,
                mat3: 9,
                mat4: 16,
                sampler2D: 1
            };

            function ki(t) {
                return Fi[t]
            }
            var Ui = null,
                Gi = {
                    FLOAT: "float",
                    FLOAT_VEC2: "vec2",
                    FLOAT_VEC3: "vec3",
                    FLOAT_VEC4: "vec4",
                    INT: "int",
                    INT_VEC2: "ivec2",
                    INT_VEC3: "ivec3",
                    INT_VEC4: "ivec4",
                    BOOL: "bool",
                    BOOL_VEC2: "bvec2",
                    BOOL_VEC3: "bvec3",
                    BOOL_VEC4: "bvec4",
                    FLOAT_MAT2: "mat2",
                    FLOAT_MAT3: "mat3",
                    FLOAT_MAT4: "mat4",
                    SAMPLER_2D: "sampler2D",
                    INT_SAMPLER_2D: "sampler2D",
                    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
                    SAMPLER_CUBE: "samplerCube",
                    INT_SAMPLER_CUBE: "samplerCube",
                    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
                    SAMPLER_2D_ARRAY: "sampler2DArray",
                    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
                    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
                };

            function Wi(t, e) {
                if (!Ui) {
                    var i = Object.keys(Gi);
                    Ui = {};
                    for (var n = 0; n < i.length; ++n) {
                        var r = i[n];
                        Ui[t[r]] = Gi[r]
                    }
                }
                return Ui[e]
            }
            var Vi, Xi = [{
                test: function (t) {
                    return "float" === t.type && 1 === t.size
                },
                code: function (t) {
                    return '\n            if(uv["' + t + '"] !== ud["' + t + '"].value)\n            {\n                ud["' + t + '"].value = uv["' + t + '"]\n                gl.uniform1f(ud["' + t + '"].location, uv["' + t + '"])\n            }\n            '
                }
            }, {
                test: function (t) {
                    return ("sampler2D" === t.type || "samplerCube" === t.type || "sampler2DArray" === t.type) && 1 === t.size && !t.isArray
                },
                code: function (t) {
                    return 't = syncData.textureCount++;\n\n            renderer.texture.bind(uv["' + t + '"], t);\n\n            if(ud["' + t + '"].value !== t)\n            {\n                ud["' + t + '"].value = t;\n                gl.uniform1i(ud["' + t + '"].location, t);\n; // eslint-disable-line max-len\n            }'
                }
            }, {
                test: function (t, e) {
                    return "mat3" === t.type && 1 === t.size && void 0 !== e.a
                },
                code: function (t) {
                    return '\n            gl.uniformMatrix3fv(ud["' + t + '"].location, false, uv["' + t + '"].toArray(true));\n            '
                }
            }, {
                test: function (t, e) {
                    return "vec2" === t.type && 1 === t.size && void 0 !== e.x
                },
                code: function (t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["' + t + '"].location, v.x, v.y);\n                }'
                }
            }, {
                test: function (t) {
                    return "vec2" === t.type && 1 === t.size
                },
                code: function (t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["' + t + '"].location, v[0], v[1]);\n                }\n            '
                }
            }, {
                test: function (t, e) {
                    return "vec4" === t.type && 1 === t.size && void 0 !== e.width
                },
                code: function (t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["' + t + '"].location, v.x, v.y, v.width, v.height)\n                }'
                }
            }, {
                test: function (t) {
                    return "vec4" === t.type && 1 === t.size
                },
                code: function (t) {
                    return '\n                cv = ud["' + t + '"].value;\n                v = uv["' + t + '"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["' + t + '"].location, v[0], v[1], v[2], v[3])\n                }'
                }
            }],
                Hi = {
                    float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
                    vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
                    vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
                    vec4: "gl.uniform4f(location, v[0], v[1], v[2], v[3])",
                    int: "gl.uniform1i(location, v)",
                    ivec2: "gl.uniform2i(location, v[0], v[1])",
                    ivec3: "gl.uniform3i(location, v[0], v[1], v[2])",
                    ivec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
                    bool: "gl.uniform1i(location, v)",
                    bvec2: "gl.uniform2i(location, v[0], v[1])",
                    bvec3: "gl.uniform3i(location, v[0], v[1], v[2])",
                    bvec4: "gl.uniform4i(location, v[0], v[1], v[2], v[3])",
                    mat2: "gl.uniformMatrix2fv(location, false, v)",
                    mat3: "gl.uniformMatrix3fv(location, false, v)",
                    mat4: "gl.uniformMatrix4fv(location, false, v)",
                    sampler2D: "gl.uniform1i(location, v)",
                    samplerCube: "gl.uniform1i(location, v)",
                    sampler2DArray: "gl.uniform1i(location, v)"
                },
                Yi = {
                    float: "gl.uniform1fv(location, v)",
                    vec2: "gl.uniform2fv(location, v)",
                    vec3: "gl.uniform3fv(location, v)",
                    vec4: "gl.uniform4fv(location, v)",
                    mat4: "gl.uniformMatrix4fv(location, false, v)",
                    mat3: "gl.uniformMatrix3fv(location, false, v)",
                    mat2: "gl.uniformMatrix2fv(location, false, v)",
                    int: "gl.uniform1iv(location, v)",
                    ivec2: "gl.uniform2iv(location, v)",
                    ivec3: "gl.uniform3iv(location, v)",
                    ivec4: "gl.uniform4iv(location, v)",
                    bool: "gl.uniform1iv(location, v)",
                    bvec2: "gl.uniform2iv(location, v)",
                    bvec3: "gl.uniform3iv(location, v)",
                    bvec4: "gl.uniform4iv(location, v)",
                    sampler2D: "gl.uniform1iv(location, v)",
                    samplerCube: "gl.uniform1iv(location, v)",
                    sampler2DArray: "gl.uniform1iv(location, v)"
                },
                ji = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");

            function zi(t) {
                for (var e = "", i = 0; i < t; ++i) i > 0 && (e += "\nelse "), i < t - 1 && (e += "if(test == " + i + ".0){}");
                return e
            }

            function Ki(t, e) {
                if (0 === t) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
                for (var i = e.createShader(e.FRAGMENT_SHADER); ;) {
                    var n = ji.replace(/%forloop%/gi, zi(t));
                    if (e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS)) break;
                    t = t / 2 | 0
                }
                return t
            }
            var qi = 0,
                Zi = {},
                $i = function () {
                    function t(e, i, n) {
                        void 0 === n && (n = "pixi-shader"), this.id = qi++, this.vertexSrc = e || t.defaultVertexSrc, this.fragmentSrc = i || t.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), "#version" !== this.vertexSrc.substring(0, 8) && (n = n.replace(/\s+/g, "-"), Zi[n] ? (Zi[n]++, n += "-" + Zi[n]) : Zi[n] = 1, this.vertexSrc = "#define SHADER_NAME " + n + "\n" + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + n + "\n" + this.fragmentSrc, this.vertexSrc = Di(this.vertexSrc, j.PRECISION_VERTEX, w.HIGH), this.fragmentSrc = Di(this.fragmentSrc, j.PRECISION_FRAGMENT, function () {
                            if (!Oi) {
                                Oi = w.MEDIUM;
                                var t = Ri();
                                if (t && t.getShaderPrecisionFormat) {
                                    var e = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT);
                                    Oi = e.precision ? w.HIGH : w.MEDIUM
                                }
                            }
                            return Oi
                        }())), this.extractData(this.vertexSrc, this.fragmentSrc), this.glPrograms = {}, this.syncUniforms = null
                    }
                    return t.prototype.extractData = function (t, e) {
                        var i = Ri();
                        if (i) {
                            var n = xi(i, t, e);
                            this.attributeData = this.getAttributeData(n, i), this.uniformData = this.getUniformData(n, i), i.deleteProgram(n)
                        } else this.uniformData = {}, this.attributeData = {}
                    }, t.prototype.getAttributeData = function (t, e) {
                        for (var i = {}, n = [], r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), o = 0; o < r; o++) {
                            var s = e.getActiveAttrib(t, o),
                                a = Wi(e, s.type),
                                l = {
                                    type: a,
                                    name: s.name,
                                    size: ki(a),
                                    location: 0
                                };
                            i[s.name] = l, n.push(l)
                        }
                        for (n.sort((function (t, e) {
                            return t.name > e.name ? 1 : -1
                        })), o = 0; o < n.length; o++) n[o].location = o;
                        return i
                    }, t.prototype.getUniformData = function (t, e) {
                        for (var i = {}, n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), r = 0; r < n; r++) {
                            var o = e.getActiveUniform(t, r),
                                s = o.name.replace(/\[.*?\]$/, ""),
                                a = o.name.match(/\[.*?\]$/),
                                l = Wi(e, o.type);
                            i[s] = {
                                type: l,
                                size: o.size,
                                isArray: a,
                                value: Li(l, o.size)
                            }
                        }
                        return i
                    }, Object.defineProperty(t, "defaultVertexSrc", {
                        get: function () {
                            return "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t, "defaultFragmentSrc", {
                        get: function () {
                            return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.from = function (e, i, n) {
                        var r = e + i,
                            o = wt[r];
                        return o || (wt[r] = o = new t(e, i, n)), o
                    }, t
                }(),
                Ji = function () {
                    function t(t, e) {
                        for (var i in this.program = t, this.uniformGroup = e ? e instanceof fi ? e : new fi(e) : new fi({}), t.uniformData) this.uniformGroup.uniforms[i] instanceof Array && (this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]))
                    }
                    return t.prototype.checkUniformExists = function (t, e) {
                        if (e.uniforms[t]) return !0;
                        for (var i in e.uniforms) {
                            var n = e.uniforms[i];
                            if (n.group && this.checkUniformExists(t, n)) return !0
                        }
                        return !1
                    }, t.prototype.destroy = function () {
                        this.uniformGroup = null
                    }, Object.defineProperty(t.prototype, "uniforms", {
                        get: function () {
                            return this.uniformGroup.uniforms
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.from = function (e, i, n) {
                        return new t($i.from(e, i), n)
                    }, t
                }(),
                Qi = function () {
                    function t() {
                        this.data = 0, this.blendMode = g.NORMAL, this.polygonOffset = 0, this.blend = !0
                    }
                    return Object.defineProperty(t.prototype, "blend", {
                        get: function () {
                            return !!(1 & this.data)
                        },
                        set: function (t) {
                            !!(1 & this.data) !== t && (this.data ^= 1)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "offsets", {
                        get: function () {
                            return !!(2 & this.data)
                        },
                        set: function (t) {
                            !!(2 & this.data) !== t && (this.data ^= 2)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "culling", {
                        get: function () {
                            return !!(4 & this.data)
                        },
                        set: function (t) {
                            !!(4 & this.data) !== t && (this.data ^= 4)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "depthTest", {
                        get: function () {
                            return !!(8 & this.data)
                        },
                        set: function (t) {
                            !!(8 & this.data) !== t && (this.data ^= 8)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "clockwiseFrontFace", {
                        get: function () {
                            return !!(16 & this.data)
                        },
                        set: function (t) {
                            !!(16 & this.data) !== t && (this.data ^= 16)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "blendMode", {
                        get: function () {
                            return this._blendMode
                        },
                        set: function (t) {
                            this.blend = t !== g.NONE, this._blendMode = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "polygonOffset", {
                        get: function () {
                            return this._polygonOffset
                        },
                        set: function (t) {
                            this.offsets = !!t, this._polygonOffset = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.for2d = function () {
                        var e = new t;
                        return e.depthTest = !1, e.blend = !0, e
                    }, t
                }(),
                tn = function (t) {
                    function e(i, n, r) {
                        var o = this,
                            s = $i.from(i || e.defaultVertexSrc, n || e.defaultFragmentSrc);
                        return (o = t.call(this, s, r) || this).padding = 0, o.resolution = j.FILTER_RESOLUTION, o.enabled = !0, o.autoFit = !0, o.legacy = !!o.program.attributeData.aTextureCoord, o.state = new Qi, o
                    }
                    return Le(e, t), e.prototype.apply = function (t, e, i, n, r) {
                        t.applyFilter(this, e, i, n)
                    }, Object.defineProperty(e.prototype, "blendMode", {
                        get: function () {
                            return this.state.blendMode
                        },
                        set: function (t) {
                            this.state.blendMode = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e, "defaultVertexSrc", {
                        get: function () {
                            return "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e, "defaultFragmentSrc", {
                        get: function () {
                            return "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(Ji),
                en = new qt,
                nn = function () {
                    function t(t, e) {
                        this._texture = t, this.mapCoord = new qt, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === e ? .5 : e, this.isSimple = !1
                    }
                    return Object.defineProperty(t.prototype, "texture", {
                        get: function () {
                            return this._texture
                        },
                        set: function (t) {
                            this._texture = t, this._textureID = -1
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.multiplyUvs = function (t, e) {
                        void 0 === e && (e = t);
                        for (var i = this.mapCoord, n = 0; n < t.length; n += 2) {
                            var r = t[n],
                                o = t[n + 1];
                            e[n] = r * i.a + o * i.c + i.tx, e[n + 1] = r * i.b + o * i.d + i.ty
                        }
                        return e
                    }, t.prototype.update = function (t) {
                        var e = this._texture;
                        if (!e || !e.valid) return !1;
                        if (!t && this._textureID === e._updateID) return !1;
                        this._textureID = e._updateID, this._updateID++;
                        var i = e._uvs;
                        this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
                        var n = e.orig,
                            r = e.trim;
                        r && (en.set(n.width / r.width, 0, 0, n.height / r.height, -r.x / r.width, -r.y / r.height), this.mapCoord.append(en));
                        var o = e.baseTexture,
                            s = this.uClampFrame,
                            a = this.clampMargin / o.resolution,
                            l = this.clampOffset;
                        return s[0] = (e._frame.x + a + l) / o.width, s[1] = (e._frame.y + a + l) / o.height, s[2] = (e._frame.x + e._frame.width - a + l) / o.width, s[3] = (e._frame.y + e._frame.height - a + l) / o.height, this.uClampOffset[0] = l / o.realWidth, this.uClampOffset[1] = l / o.realHeight, this.isSimple = e._frame.width === o.width && e._frame.height === o.height && 0 === e.rotate, !0
                    }, t
                }(),
                rn = function (t) {
                    function e(e) {
                        var i = this,
                            n = new qt;
                        return i = t.call(this, "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n") || this, e.renderable = !1, i.maskSprite = e, i.maskMatrix = n, i
                    }
                    return Le(e, t), e.prototype.apply = function (t, e, i, n) {
                        var r = this.maskSprite,
                            o = r._texture;
                        o.valid && (o.uvMatrix || (o.uvMatrix = new nn(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, r).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = r.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, e, i, n))
                    }, e
                }(tn),
                on = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.enableScissor = !1, i.alphaMaskPool = [], i.maskDataPool = [], i.maskStack = [], i.alphaMaskIndex = 0, i
                    }
                    return Le(e, t), e.prototype.setMaskStack = function (t) {
                        this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
                    }, e.prototype.push = function (t, e) {
                        var i = e;
                        if (!i.isMaskData) {
                            var n = this.maskDataPool.pop() || new Ei;
                            n.pooled = !0, n.maskObject = e, i = n
                        }
                        switch (i.autoDetect && this.detect(i), i.copyCountersOrReset(this.maskStack[this.maskStack.length - 1]), i._target = t, i.type) {
                            case E.SCISSOR:
                                this.maskStack.push(i), this.renderer.scissor.push(i);
                                break;
                            case E.STENCIL:
                                this.maskStack.push(i), this.renderer.stencil.push(i);
                                break;
                            case E.SPRITE:
                                i.copyCountersOrReset(null), this.pushSpriteMask(i), this.maskStack.push(i)
                        }
                    }, e.prototype.pop = function (t) {
                        var e = this.maskStack.pop();
                        if (e && e._target === t) {
                            switch (e.type) {
                                case E.SCISSOR:
                                    this.renderer.scissor.pop();
                                    break;
                                case E.STENCIL:
                                    this.renderer.stencil.pop(e.maskObject);
                                    break;
                                case E.SPRITE:
                                    this.popSpriteMask()
                            }
                            e.reset(), e.pooled && this.maskDataPool.push(e)
                        }
                    }, e.prototype.detect = function (t) {
                        var e = t.maskObject;
                        if (e.isSprite) t.type = E.SPRITE;
                        else if (t.type = E.STENCIL, this.enableScissor && e.isFastRect && e.isFastRect()) {
                            var i = e.worldTransform,
                                n = Math.atan2(i.b, i.a),
                                r = Math.atan2(i.d, i.c);
                            n = Math.round(n * (180 / Math.PI) * 100), r = ((r = Math.round(r * (180 / Math.PI) * 100) - n) % 18e3 + 18e3) % 18e3, 0 == (n = (n % 9e3 + 9e3) % 9e3) && 9e3 === r && (t.type = E.SCISSOR)
                        }
                    }, e.prototype.pushSpriteMask = function (t) {
                        var e = t.maskObject,
                            i = t._target,
                            n = this.alphaMaskPool[this.alphaMaskIndex];
                        n || (n = this.alphaMaskPool[this.alphaMaskIndex] = [new rn(e)]), n[0].resolution = this.renderer.resolution, n[0].maskSprite = e;
                        var r = i.filterArea;
                        i.filterArea = e.getBounds(!0), this.renderer.filter.push(i, n), i.filterArea = r, this.alphaMaskIndex++
                    }, e.prototype.popSpriteMask = function () {
                        this.renderer.filter.pop(), this.alphaMaskIndex--
                    }, e
                }(je),
                sn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.maskStack = [], i.glConst = 0, i
                    }
                    return Le(e, t), e.prototype.getStackLength = function () {
                        return this.maskStack.length
                    }, e.prototype.setMaskStack = function (t) {
                        var e = this.renderer.gl,
                            i = this.getStackLength();
                        this.maskStack = t;
                        var n = this.getStackLength();
                        n !== i && (0 === n ? e.disable(this.glConst) : (e.enable(this.glConst), this._useCurrent()))
                    }, e.prototype._useCurrent = function () { }, e.prototype.destroy = function () {
                        t.prototype.destroy.call(this), this.maskStack = null
                    }, e
                }(je),
                an = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.glConst = WebGLRenderingContext.SCISSOR_TEST, i
                    }
                    return Le(e, t), e.prototype.getStackLength = function () {
                        var t = this.maskStack[this.maskStack.length - 1];
                        return t ? t._scissorCounter : 0
                    }, e.prototype.push = function (t) {
                        var e = t.maskObject;
                        e.renderable = !0;
                        var i = t._scissorRect,
                            n = e.getBounds(!0),
                            r = this.renderer.gl;
                        e.renderable = !1, i ? n.fit(i) : r.enable(r.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = n, this._useCurrent()
                    }, e.prototype.pop = function () {
                        var t = this.renderer.gl;
                        this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
                    }, e.prototype._useCurrent = function () {
                        var t = this.maskStack[this.maskStack.length - 1]._scissorRect,
                            e = this.renderer.renderTexture.current,
                            i = this.renderer.projection,
                            n = i.transform,
                            r = i.sourceFrame,
                            o = i.destinationFrame,
                            s = e ? e.resolution : this.renderer.resolution,
                            a = (t.x - r.x) * s + o.x,
                            l = (t.y - r.y) * s + o.y,
                            h = t.width * s,
                            u = t.height * s;
                        n && (a += n.tx * s, l += n.ty * s), e || (l = this.renderer.height - u - l), this.renderer.gl.scissor(a, l, h, u)
                    }, e
                }(sn),
                ln = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.glConst = WebGLRenderingContext.STENCIL_TEST, i
                    }
                    return Le(e, t), e.prototype.getStackLength = function () {
                        var t = this.maskStack[this.maskStack.length - 1];
                        return t ? t._stencilCounter : 0
                    }, e.prototype.push = function (t) {
                        var e = t.maskObject,
                            i = this.renderer.gl,
                            n = t._stencilCounter;
                        0 === n && (this.renderer.framebuffer.forceStencil(), i.enable(i.STENCIL_TEST)), t._stencilCounter++, i.colorMask(!1, !1, !1, !1), i.stencilFunc(i.EQUAL, n, this._getBitwiseMask()), i.stencilOp(i.KEEP, i.KEEP, i.INCR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, this._useCurrent()
                    }, e.prototype.pop = function (t) {
                        var e = this.renderer.gl;
                        0 === this.getStackLength() ? (e.disable(e.STENCIL_TEST), e.clear(e.STENCIL_BUFFER_BIT), e.clearStencil(0)) : (e.colorMask(!1, !1, !1, !1), e.stencilOp(e.KEEP, e.KEEP, e.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, this._useCurrent())
                    }, e.prototype._useCurrent = function () {
                        var t = this.renderer.gl;
                        t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, this.getStackLength(), this._getBitwiseMask()), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
                    }, e.prototype._getBitwiseMask = function () {
                        return (1 << this.getStackLength()) - 1
                    }, e
                }(sn),
                hn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.destinationFrame = null, i.sourceFrame = null, i.defaultFrame = null, i.projectionMatrix = new qt, i.transform = null, i
                    }
                    return Le(e, t), e.prototype.update = function (t, e, i, n) {
                        this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = e || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, i, n), this.transform && this.projectionMatrix.append(this.transform);
                        var r = this.renderer;
                        r.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r.globalUniforms.update(), r.shader.shader && r.shader.syncUniformGroup(r.shader.shader.uniforms.globals)
                    }, e.prototype.calculateProjection = function (t, e, i, n) {
                        var r = this.projectionMatrix,
                            o = n ? -1 : 1;
                        r.identity(), r.a = 1 / e.width * 2, r.d = o * (1 / e.height * 2), r.tx = -1 - e.x * r.a, r.ty = -o - e.y * r.d
                    }, e.prototype.setTransform = function (t) { }, e
                }(je),
                un = new Vt,
                cn = new Vt,
                dn = new Vt,
                pn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.clearColor = e._backgroundColorRgba, i.defaultMaskStack = [], i.current = null, i.sourceFrame = new Vt, i.destinationFrame = new Vt, i
                    }
                    return Le(e, t), e.prototype.bind = function (t, e, i) {
                        void 0 === t && (t = null);
                        var n, r, o, s = this.renderer;
                        this.current = t, t ? (o = (n = t.baseTexture).resolution, e || (un.width = t.frame.width, un.height = t.frame.height, e = un), i || (cn.x = t.frame.x, cn.y = t.frame.y, cn.width = e.width, cn.height = e.height, i = cn), r = n.framebuffer) : (o = s.resolution, e || (un.width = s.screen.width, un.height = s.screen.height, e = un), i || ((i = un).width = e.width, i.height = e.height)), dn.x = i.x * o, dn.y = i.y * o, dn.width = i.width * o, dn.height = i.height * o, this.renderer.framebuffer.bind(r, dn), this.renderer.projection.update(i, e, o, !r), t ? this.renderer.mask.setMaskStack(n.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(e), this.destinationFrame.copyFrom(i)
                    }, e.prototype.clear = function (t, e) {
                        t = this.current ? t || this.current.baseTexture.clearColor : t || this.clearColor, this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], e)
                    }, e.prototype.resize = function () {
                        this.bind(null)
                    }, e.prototype.reset = function () {
                        this.bind(null)
                    }, e
                }(je),
                fn = function () { },
                gn = function () {
                    function t(t, e) {
                        this.program = t, this.uniformData = e, this.uniformGroups = {}
                    }
                    return t.prototype.destroy = function () {
                        this.uniformData = null, this.uniformGroups = null, this.program = null
                    }, t
                }(),
                mn = 0,
                _n = {
                    textureCount: 0
                },
                yn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.destroyed = !1, i.systemCheck(), i.gl = null, i.shader = null, i.program = null, i.cache = {}, i.id = mn++, i
                    }
                    return Le(e, t), e.prototype.systemCheck = function () {
                        if (! function () {
                            if ("boolean" == typeof Vi) return Vi;
                            try {
                                var t = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
                                Vi = !0 === t({
                                    a: "b"
                                }, "a", "b")
                            } catch (t) {
                                Vi = !1
                            }
                            return Vi
                        }()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
                    }, e.prototype.contextChange = function (t) {
                        this.gl = t, this.reset()
                    }, e.prototype.bind = function (t, e) {
                        t.uniforms.globals = this.renderer.globalUniforms;
                        var i = t.program,
                            n = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(t);
                        return this.shader = t, this.program !== i && (this.program = i, this.gl.useProgram(n.program)), e || (_n.textureCount = 0, this.syncUniformGroup(t.uniformGroup, _n)), n
                    }, e.prototype.setUniforms = function (t) {
                        var e = this.shader.program,
                            i = e.glPrograms[this.renderer.CONTEXT_UID];
                        e.syncUniforms(i.uniformData, t, this.renderer)
                    }, e.prototype.syncUniformGroup = function (t, e) {
                        var i = this.getglProgram();
                        t.static && t.dirtyId === i.uniformGroups[t.id] || (i.uniformGroups[t.id] = t.dirtyId, this.syncUniforms(t, i, e))
                    }, e.prototype.syncUniforms = function (t, e, i) {
                        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(e.uniformData, t.uniforms, this.renderer, i)
                    }, e.prototype.createSyncGroups = function (t) {
                        var e = this.getSignature(t, this.shader.program.uniformData);
                        return this.cache[e] || (this.cache[e] = function (t, e) {
                            var i = ["\n        var v = null;\n        var cv = null\n        var t = 0;\n        var gl = renderer.gl\n    "];
                            for (var n in t.uniforms) {
                                var r = e[n];
                                if (r) {
                                    for (var o = t.uniforms[n], s = !1, a = 0; a < Xi.length; a++)
                                        if (Xi[a].test(r, o)) {
                                            i.push(Xi[a].code(n, o)), s = !0;
                                            break
                                        } if (!s) {
                                            var l = (1 === r.size ? Hi : Yi)[r.type].replace("location", 'ud["' + n + '"].location');
                                            i.push('\n            cv = ud["' + n + '"].value;\n            v = uv["' + n + '"];\n            ' + l + ";")
                                        }
                                } else t.uniforms[n].group && i.push('\n                    renderer.shader.syncUniformGroup(uv["' + n + '"], syncData);\n                ')
                            }
                            return new Function("ud", "uv", "renderer", "syncData", i.join("\n"))
                        }(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[e], t.syncUniforms[this.shader.program.id]
                    }, e.prototype.getSignature = function (t, e) {
                        var i = t.uniforms,
                            n = [];
                        for (var r in i) n.push(r), e[r] && n.push(e[r].type);
                        return n.join("-")
                    }, e.prototype.getglProgram = function () {
                        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
                    }, e.prototype.generateShader = function (t) {
                        var e = this.gl,
                            i = t.program,
                            n = {};
                        for (var r in i.attributeData) n[r] = i.attributeData[r].location;
                        var o = xi(e, i.vertexSrc, i.fragmentSrc, n),
                            s = {};
                        for (var r in i.uniformData) {
                            var a = i.uniformData[r];
                            s[r] = {
                                location: e.getUniformLocation(o, r),
                                value: Li(a.type, a.size)
                            }
                        }
                        var l = new gn(o, s);
                        return i.glPrograms[this.renderer.CONTEXT_UID] = l, l
                    }, e.prototype.reset = function () {
                        this.program = null, this.shader = null
                    }, e.prototype.destroy = function () {
                        this.destroyed = !0
                    }, e
                }(je),
                Sn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.gl = null, i.stateId = 0, i.polygonOffset = 0, i.blendMode = g.NONE, i._blendEq = !1, i.map = [], i.map[0] = i.setBlend, i.map[1] = i.setOffset, i.map[2] = i.setCullFace, i.map[3] = i.setDepthTest, i.map[4] = i.setFrontFace, i.checks = [], i.defaultState = new Qi, i.defaultState.blend = !0, i
                    }
                    return Le(e, t), e.prototype.contextChange = function (t) {
                        this.gl = t, this.blendModes = function (t, e) {
                            return void 0 === e && (e = []), e[g.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.ADD] = [t.ONE, t.ONE], e[g.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.NONE] = [0, 0], e[g.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e[g.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e[g.SRC_IN] = [t.DST_ALPHA, t.ZERO], e[g.SRC_OUT] = [t.ONE_MINUS_DST_ALPHA, t.ZERO], e[g.SRC_ATOP] = [t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[g.DST_OVER] = [t.ONE_MINUS_DST_ALPHA, t.ONE], e[g.DST_IN] = [t.ZERO, t.SRC_ALPHA], e[g.DST_OUT] = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], e[g.DST_ATOP] = [t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA], e[g.XOR] = [t.ONE_MINUS_DST_ALPHA, t.ONE_MINUS_SRC_ALPHA], e[g.SUBTRACT] = [t.ONE, t.ONE, t.ONE, t.ONE, t.FUNC_REVERSE_SUBTRACT, t.FUNC_ADD], e
                        }(t), this.set(this.defaultState), this.reset()
                    }, e.prototype.set = function (t) {
                        if (t = t || this.defaultState, this.stateId !== t.data) {
                            for (var e = this.stateId ^ t.data, i = 0; e;) 1 & e && this.map[i].call(this, !!(t.data & 1 << i)), e >>= 1, i++;
                            this.stateId = t.data
                        }
                        for (i = 0; i < this.checks.length; i++) this.checks[i](this, t)
                    }, e.prototype.forceState = function (t) {
                        t = t || this.defaultState;
                        for (var e = 0; e < this.map.length; e++) this.map[e].call(this, !!(t.data & 1 << e));
                        for (e = 0; e < this.checks.length; e++) this.checks[e](this, t);
                        this.stateId = t.data
                    }, e.prototype.setBlend = function (t) {
                        this.updateCheck(e.checkBlendMode, t), this.gl[t ? "enable" : "disable"](this.gl.BLEND)
                    }, e.prototype.setOffset = function (t) {
                        this.updateCheck(e.checkPolygonOffset, t), this.gl[t ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
                    }, e.prototype.setDepthTest = function (t) {
                        this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST)
                    }, e.prototype.setCullFace = function (t) {
                        this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE)
                    }, e.prototype.setFrontFace = function (t) {
                        this.gl.frontFace(this.gl[t ? "CW" : "CCW"])
                    }, e.prototype.setBlendMode = function (t) {
                        if (t !== this.blendMode) {
                            this.blendMode = t;
                            var e = this.blendModes[t],
                                i = this.gl;
                            2 === e.length ? i.blendFunc(e[0], e[1]) : i.blendFuncSeparate(e[0], e[1], e[2], e[3]), 6 === e.length ? (this._blendEq = !0, i.blendEquationSeparate(e[4], e[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD))
                        }
                    }, e.prototype.setPolygonOffset = function (t, e) {
                        this.gl.polygonOffset(t, e)
                    }, e.prototype.reset = function () {
                        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
                    }, e.prototype.updateCheck = function (t, e) {
                        var i = this.checks.indexOf(t);
                        e && -1 === i ? this.checks.push(t) : e || -1 === i || this.checks.splice(i, 1)
                    }, e.checkBlendMode = function (t, e) {
                        t.setBlendMode(e.blendMode)
                    }, e.checkPolygonOffset = function (t, e) {
                        t.setPolygonOffset(1, e.polygonOffset)
                    }, e
                }(je),
                vn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.count = 0, i.checkCount = 0, i.maxIdle = j.GC_MAX_IDLE, i.checkCountMax = j.GC_MAX_CHECK_COUNT, i.mode = j.GC_MODE, i
                    }
                    return Le(e, t), e.prototype.postrender = function () {
                        this.renderer.renderingToScreen && (this.count++, this.mode !== I.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
                    }, e.prototype.run = function () {
                        for (var t = this.renderer.texture, e = t.managedTextures, i = !1, n = 0; n < e.length; n++) {
                            var r = e[n];
                            !r.framebuffer && this.count - r.touched > this.maxIdle && (t.destroyTexture(r, !0), e[n] = null, i = !0)
                        }
                        if (i) {
                            var o = 0;
                            for (n = 0; n < e.length; n++) null !== e[n] && (e[o++] = e[n]);
                            e.length = o
                        }
                    }, e.prototype.unload = function (t) {
                        var e = this.renderer.texture,
                            i = t._texture;
                        i && !i.framebuffer && e.destroyTexture(i);
                        for (var n = t.children.length - 1; n >= 0; n--) this.unload(t.children[n])
                    }, e
                }(je),
                bn = function (t) {
                    this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = 6408, this.internalFormat = 5121
                },
                Tn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.boundTextures = [], i.currentLocation = -1, i.managedTextures = [], i._unknownBoundTextures = !1, i.unknownTexture = new Re, i
                    }
                    return Le(e, t), e.prototype.contextChange = function () {
                        var t = this.gl = this.renderer.gl;
                        this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion;
                        var e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
                        this.boundTextures.length = e;
                        for (var i = 0; i < e; i++) this.boundTextures[i] = null;
                        this.emptyTextures = {};
                        var n = new bn(t.createTexture());
                        for (t.bindTexture(t.TEXTURE_2D, n.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = n, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new bn(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture), i = 0; i < 6; i++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
                        for (t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR), i = 0; i < this.boundTextures.length; i++) this.bind(null, i)
                    }, e.prototype.bind = function (t, e) {
                        void 0 === e && (e = 0);
                        var i = this.gl;
                        if (t) {
                            if ((t = t.castToBaseTexture()).parentTextureArray) return;
                            if (t.valid) {
                                t.touched = this.renderer.textureGC.count;
                                var n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
                                this.boundTextures[e] !== t && (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId && (this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), this.updateTexture(t)), this.boundTextures[e] = t
                            }
                        } else this.currentLocation !== e && (this.currentLocation = e, i.activeTexture(i.TEXTURE0 + e)), i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture), this.boundTextures[e] = null
                    }, e.prototype.reset = function () {
                        this._unknownBoundTextures = !0, this.currentLocation = -1;
                        for (var t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
                    }, e.prototype.unbind = function (t) {
                        var e = this.gl,
                            i = this.boundTextures;
                        if (this._unknownBoundTextures) {
                            this._unknownBoundTextures = !1;
                            for (var n = 0; n < i.length; n++) i[n] === this.unknownTexture && this.bind(null, n)
                        }
                        for (n = 0; n < i.length; n++) i[n] === t && (this.currentLocation !== n && (e.activeTexture(e.TEXTURE0 + n), this.currentLocation = n), e.bindTexture(t.target, this.emptyTextures[t.target].texture), i[n] = null)
                    }, e.prototype.initTexture = function (t) {
                        var e = new bn(this.gl.createTexture());
                        return e.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = e, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), e
                    }, e.prototype.initTextureType = function (t, e) {
                        if (e.internalFormat = t.format, e.type = t.type, 2 === this.webGLVersion) {
                            var i = this.renderer.gl;
                            t.type === i.FLOAT && t.format === i.RGBA && (e.internalFormat = i.RGBA32F), t.type === S.HALF_FLOAT && (e.type = i.HALF_FLOAT), e.type === i.HALF_FLOAT && t.format === i.RGBA && (e.internalFormat = i.RGBA16F)
                        }
                    }, e.prototype.updateTexture = function (t) {
                        var e = t._glTextures[this.CONTEXT_UID];
                        if (e) {
                            var i = this.renderer;
                            if (this.initTextureType(t, e), t.resource && t.resource.upload(i, t, e));
                            else {
                                var n = t.realWidth,
                                    r = t.realHeight,
                                    o = i.gl;
                                (e.width !== n || e.height !== r || e.dirtyId < 0) && (e.width = n, e.height = r, o.texImage2D(t.target, 0, e.internalFormat, n, r, 0, t.format, e.type, null))
                            }
                            t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t), e.dirtyId = t.dirtyId
                        }
                    }, e.prototype.destroyTexture = function (t, e) {
                        var i = this.gl;
                        if ((t = t.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(t), i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !e)) {
                            var n = this.managedTextures.indexOf(t); - 1 !== n && vt(this.managedTextures, n, 1)
                        }
                    }, e.prototype.updateTextureStyle = function (t) {
                        var e = t._glTextures[this.CONTEXT_UID];
                        e && (t.mipmap !== T.POW2 && 2 === this.webGLVersion || t.isPowerOfTwo ? e.mipmap = t.mipmap >= 1 : e.mipmap = !1, 2 === this.webGLVersion || t.isPowerOfTwo ? e.wrapMode = t.wrapMode : e.wrapMode = b.CLAMP, t.resource && t.resource.style(this.renderer, t, e) || this.setStyle(t, e), e.dirtyStyleId = t.dirtyStyleId)
                    }, e.prototype.setStyle = function (t, e) {
                        var i = this.gl;
                        if (e.mipmap && i.generateMipmap(t.target), i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode), i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode), e.mipmap) {
                            i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === v.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
                            var n = this.renderer.context.extensions.anisotropicFiltering;
                            if (n && t.anisotropicLevel > 0 && t.scaleMode === v.LINEAR) {
                                var r = Math.min(t.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                                i.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, r)
                            }
                        } else i.texParameteri(t.target, i.TEXTURE_MIN_FILTER, t.scaleMode === v.LINEAR ? i.LINEAR : i.NEAREST);
                        i.texParameteri(t.target, i.TEXTURE_MAG_FILTER, t.scaleMode === v.LINEAR ? i.LINEAR : i.NEAREST)
                    }, e
                }(je),
                Pn = {
                    FilterSystem: mi,
                    BatchSystem: yi,
                    ContextSystem: vi,
                    FramebufferSystem: Pi,
                    GeometrySystem: wi,
                    MaskSystem: on,
                    ScissorSystem: an,
                    StencilSystem: ln,
                    ProjectionSystem: hn,
                    RenderTextureSystem: pn,
                    ShaderSystem: yn,
                    StateSystem: Sn,
                    TextureGCSystem: vn,
                    TextureSystem: Tn
                },
                An = new qt,
                In = function (t) {
                    function e(e, i) {
                        void 0 === e && (e = p.UNKNOWN);
                        var n = t.call(this) || this;
                        return (i = Object.assign({}, j.RENDER_OPTIONS, i)).roundPixels && (j.ROUND_PIXELS = i.roundPixels, It("5.0.0", "Renderer roundPixels option is deprecated, please use PIXI.settings.ROUND_PIXELS", 2)), n.options = i, n.type = e, n.screen = new Vt(0, 0, i.width, i.height), n.view = i.view || document.createElement("canvas"), n.resolution = i.resolution || j.RESOLUTION, n.transparent = i.transparent, n.autoDensity = i.autoDensity || i.autoResize || !1, n.preserveDrawingBuffer = i.preserveDrawingBuffer, n.clearBeforeRender = i.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 0], n._backgroundColorString = "#000000", n.backgroundColor = i.backgroundColor || n._backgroundColor, n._lastObjectRendered = null, n.plugins = {}, n
                    }
                    return Le(e, t), e.prototype.initPlugins = function (t) {
                        for (var e in t) this.plugins[e] = new t[e](this)
                    }, Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return this.view.width
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "height", {
                        get: function () {
                            return this.view.height
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.resize = function (t, e) {
                        this.screen.width = t, this.screen.height = e, this.view.width = t * this.resolution, this.view.height = e * this.resolution, this.autoDensity && (this.view.style.width = t + "px", this.view.style.height = e + "px"), this.emit("resize", t, e)
                    }, e.prototype.generateTexture = function (t, e, i, n) {
                        0 === (n = n || t.getLocalBounds(null, !0)).width && (n.width = 1), 0 === n.height && (n.height = 1);
                        var r = ti.create({
                            width: 0 | n.width,
                            height: 0 | n.height,
                            scaleMode: e,
                            resolution: i
                        });
                        return An.tx = -n.x, An.ty = -n.y, this.render(t, r, !1, An, !!t.parent), r
                    }, e.prototype.destroy = function (t) {
                        for (var e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null;
                        t && this.view.parentNode && this.view.parentNode.removeChild(this.view);
                        var i = this;
                        i.plugins = null, i.type = p.UNKNOWN, i.view = null, i.screen = null, i._tempDisplayObjectParent = null, i.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null
                    }, Object.defineProperty(e.prototype, "backgroundColor", {
                        get: function () {
                            return this._backgroundColor
                        },
                        set: function (t) {
                            this._backgroundColor = t, this._backgroundColorString = ot(t), rt(t, this._backgroundColorRgba)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(K()),
                wn = function (t) {
                    function e(i) {
                        var n = t.call(this, p.WEBGL, i) || this;
                        return i = n.options, n.gl = null, n.CONTEXT_UID = 0, n.runners = {
                            destroy: new Ee("destroy"),
                            contextChange: new Ee("contextChange"),
                            reset: new Ee("reset"),
                            update: new Ee("update"),
                            postrender: new Ee("postrender"),
                            prerender: new Ee("prerender"),
                            resize: new Ee("resize")
                        }, n.globalUniforms = new fi({
                            projectionMatrix: new qt
                        }, !0), n.addSystem(on, "mask").addSystem(vi, "context").addSystem(Sn, "state").addSystem(yn, "shader").addSystem(Tn, "texture").addSystem(wi, "geometry").addSystem(Pi, "framebuffer").addSystem(an, "scissor").addSystem(ln, "stencil").addSystem(hn, "projection").addSystem(vn, "textureGC").addSystem(mi, "filter").addSystem(pn, "renderTexture").addSystem(yi, "batch"), n.initPlugins(e.__plugins), i.context ? n.context.initFromContext(i.context) : n.context.initFromOptions({
                            alpha: !!n.transparent,
                            antialias: i.antialias,
                            premultipliedAlpha: n.transparent && "notMultiplied" !== n.transparent,
                            stencil: !0,
                            preserveDrawingBuffer: i.preserveDrawingBuffer,
                            powerPreference: n.options.powerPreference
                        }), n.renderingToScreen = !0, it(2 === n.context.webGLVersion ? "WebGL 2" : "WebGL 1"), n.resize(n.options.width, n.options.height), n
                    }
                    return Le(e, t), e.create = function (t) {
                        if (nt()) return new e(t);
                        throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.')
                    }, e.prototype.addSystem = function (t, e) {
                        e || (e = t.name);
                        var i = new t(this);
                        if (this[e]) throw new Error('Whoops! The name "' + e + '" is already in use');
                        for (var n in this[e] = i, this.runners) this.runners[n].add(i);
                        return this
                    }, e.prototype.render = function (t, e, i, n, r) {
                        if (this.renderingToScreen = !e, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = n, !this.context.isLost) {
                            if (e || (this._lastObjectRendered = t), !r) {
                                var o = t.enableTempParent();
                                t.updateTransform(), t.disableTempParent(o)
                            }
                            this.renderTexture.bind(e), this.batch.currentRenderer.start(), (void 0 !== i ? i : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), e && e.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender")
                        }
                    }, e.prototype.resize = function (e, i) {
                        t.prototype.resize.call(this, e, i), this.runners.resize.emit(e, i)
                    }, e.prototype.reset = function () {
                        return this.runners.reset.emit(), this
                    }, e.prototype.clear = function () {
                        this.renderTexture.bind(), this.renderTexture.clear()
                    }, e.prototype.destroy = function (e) {
                        for (var i in this.runners.destroy.emit(), this.runners) this.runners[i].destroy();
                        t.prototype.destroy.call(this, e), this.gl = null
                    }, e.registerPlugin = function (t, i) {
                        e.__plugins = e.__plugins || {}, e.__plugins[t] = i
                    }, e
                }(In);

            function En(t) {
                return wn.create(t)
            }
            var Cn = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}",
                xn = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
                Bn = function () {
                    this.texArray = null, this.blend = 0, this.type = m.TRIANGLES, this.start = 0, this.size = 0, this.data = null
                },
                Ln = function () {
                    function t() {
                        this.elements = [], this.ids = [], this.count = 0
                    }
                    return t.prototype.clear = function () {
                        for (var t = 0; t < this.count; t++) this.elements[t] = null;
                        this.count = 0
                    }, t
                }(),
                On = function () {
                    function t(t) {
                        this.rawBinaryData = new ArrayBuffer(t), this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
                    }
                    return Object.defineProperty(t.prototype, "int8View", {
                        get: function () {
                            return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "uint8View", {
                        get: function () {
                            return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "int16View", {
                        get: function () {
                            return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "uint16View", {
                        get: function () {
                            return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "int32View", {
                        get: function () {
                            return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.view = function (t) {
                        return this[t + "View"]
                    }, t.prototype.destroy = function () {
                        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
                    }, t.sizeOf = function (t) {
                        switch (t) {
                            case "int8":
                            case "uint8":
                                return 1;
                            case "int16":
                            case "uint16":
                                return 2;
                            case "int32":
                            case "uint32":
                            case "float32":
                                return 4;
                            default:
                                throw new Error(t + " isn't a valid view type")
                        }
                    }, t
                }(),
                Nn = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.shaderGenerator = null, i.geometryClass = null, i.vertexSize = null, i.state = Qi.for2d(), i.size = 4 * j.SPRITE_BATCH_SIZE, i._vertexCount = 0, i._indexCount = 0, i._bufferedElements = [], i._bufferedTextures = [], i._bufferSize = 0, i._shader = null, i._packedGeometries = [], i._packedGeometryPoolSize = 2, i._flushId = 0, i._aBuffers = {}, i._iBuffers = {}, i.MAX_TEXTURES = 1, i.renderer.on("prerender", i.onPrerender, i), e.runners.contextChange.add(i), i._dcIndex = 0, i._aIndex = 0, i._iIndex = 0, i._attributeBuffer = null, i._indexBuffer = null, i._tempBoundTextures = [], i
                    }
                    return Le(e, t), e.prototype.contextChange = function () {
                        var t = this.renderer.gl;
                        j.PREFER_ENV === d.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), j.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = Ki(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
                        for (var e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass;
                        this.initFlushBuffers()
                    }, e.prototype.initFlushBuffers = function () {
                        for (var t = e._drawCallPool, i = e._textureArrayPool, n = this.size / 4, r = Math.floor(n / this.MAX_TEXTURES) + 1; t.length < n;) t.push(new Bn);
                        for (; i.length < r;) i.push(new Ln);
                        for (var o = 0; o < this.MAX_TEXTURES; o++) this._tempBoundTextures[o] = null
                    }, e.prototype.onPrerender = function () {
                        this._flushId = 0
                    }, e.prototype.render = function (t) {
                        t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t)
                    }, e.prototype.buildTexturesAndDrawCalls = function () {
                        var t = this._bufferedTextures,
                            i = this.MAX_TEXTURES,
                            n = e._textureArrayPool,
                            r = this.renderer.batch,
                            o = this._tempBoundTextures,
                            s = this.renderer.textureGC.count,
                            a = ++Re._globalBatch,
                            l = 0,
                            h = n[0],
                            u = 0;
                        r.copyBoundTextures(o, i);
                        for (var c = 0; c < this._bufferSize; ++c) {
                            var d = t[c];
                            t[c] = null, d._batchEnabled !== a && (h.count >= i && (r.boundArray(h, o, a, i), this.buildDrawCalls(h, u, c), u = c, h = n[++l], ++a), d._batchEnabled = a, d.touched = s, h.elements[h.count++] = d)
                        }
                        for (h.count > 0 && (r.boundArray(h, o, a, i), this.buildDrawCalls(h, u, this._bufferSize), ++l, ++a), c = 0; c < o.length; c++) o[c] = null;
                        Re._globalBatch = a
                    }, e.prototype.buildDrawCalls = function (t, i, n) {
                        var r = this,
                            o = r._bufferedElements,
                            s = r._attributeBuffer,
                            a = r._indexBuffer,
                            l = r.vertexSize,
                            h = e._drawCallPool,
                            u = this._dcIndex,
                            c = this._aIndex,
                            d = this._iIndex,
                            p = h[u];
                        p.start = this._iIndex, p.texArray = t;
                        for (var f = i; f < n; ++f) {
                            var g = o[f],
                                m = g._texture.baseTexture,
                                _ = lt[m.alphaMode ? 1 : 0][g.blendMode];
                            o[f] = null, i < f && p.blend !== _ && (p.size = d - p.start, i = f, (p = h[++u]).texArray = t, p.start = d), this.packInterleavedGeometry(g, s, a, c, d), c += g.vertexData.length / 2 * l, d += g.indices.length, p.blend = _
                        }
                        i < n && (p.size = d - p.start, ++u), this._dcIndex = u, this._aIndex = c, this._iIndex = d
                    }, e.prototype.bindAndClearTexArray = function (t) {
                        for (var e = this.renderer.texture, i = 0; i < t.count; i++) e.bind(t.elements[i], t.ids[i]), t.elements[i] = null;
                        t.count = 0
                    }, e.prototype.updateGeometry = function () {
                        var t = this,
                            e = t._packedGeometries,
                            i = t._attributeBuffer,
                            n = t._indexBuffer;
                        j.CAN_UPLOAD_SAME_BUFFER ? (e[this._flushId]._buffer.update(i.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(i.rawBinaryData), e[this._flushId]._indexBuffer.update(n), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
                    }, e.prototype.drawBatches = function () {
                        for (var t = this._dcIndex, i = this.renderer, n = i.gl, r = i.state, o = e._drawCallPool, s = null, a = 0; a < t; a++) {
                            var l = o[a],
                                h = l.texArray,
                                u = l.type,
                                c = l.size,
                                d = l.start,
                                p = l.blend;
                            s !== h && (s = h, this.bindAndClearTexArray(h)), this.state.blendMode = p, r.set(this.state), n.drawElements(u, c, n.UNSIGNED_SHORT, 2 * d)
                        }
                    }, e.prototype.flush = function () {
                        0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
                    }, e.prototype.start = function () {
                        this.renderer.state.set(this.state), this.renderer.shader.bind(this._shader), j.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
                    }, e.prototype.stop = function () {
                        this.flush()
                    }, e.prototype.destroy = function () {
                        for (var e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
                        this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), t.prototype.destroy.call(this)
                    }, e.prototype.getAttributeBuffer = function (t) {
                        var e = _t(Math.ceil(t / 8)),
                            i = St(e),
                            n = 8 * e;
                        this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
                        var r = this._aBuffers[n];
                        return r || (this._aBuffers[n] = r = new On(n * this.vertexSize * 4)), r
                    }, e.prototype.getIndexBuffer = function (t) {
                        var e = _t(Math.ceil(t / 12)),
                            i = St(e),
                            n = 12 * e;
                        this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
                        var r = this._iBuffers[i];
                        return r || (this._iBuffers[i] = r = new Uint16Array(n)), r
                    }, e.prototype.packInterleavedGeometry = function (t, e, i, n, r) {
                        for (var o = e.uint32View, s = e.float32View, a = n / this.vertexSize, l = t.uvs, h = t.indices, u = t.vertexData, c = t._texture.baseTexture._batchLocation, d = Math.min(t.worldAlpha, 1), p = d < 1 && t._texture.baseTexture.alphaMode ? ct(t._tintRGB, d) : t._tintRGB + (255 * d << 24), f = 0; f < u.length; f += 2) s[n++] = u[f], s[n++] = u[f + 1], s[n++] = l[f], s[n++] = l[f + 1], o[n++] = p, s[n++] = c;
                        for (f = 0; f < h.length; f++) i[r++] = a + h[f]
                    }, e._drawCallPool = [], e._textureArrayPool = [], e
                }(_i),
                Mn = function () {
                    function t(t, e) {
                        if (this.vertexSrc = t, this.fragTemplate = e, this.programCache = {}, this.defaultGroupCache = {}, e.indexOf("%count%") < 0) throw new Error('Fragment template must contain "%count%".');
                        if (e.indexOf("%forloop%") < 0) throw new Error('Fragment template must contain "%forloop%".')
                    }
                    return t.prototype.generateShader = function (t) {
                        if (!this.programCache[t]) {
                            for (var e = new Int32Array(t), i = 0; i < t; i++) e[i] = i;
                            this.defaultGroupCache[t] = fi.from({
                                uSamplers: e
                            }, !0);
                            var n = this.fragTemplate;
                            n = (n = n.replace(/%count%/gi, "" + t)).replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new $i(this.vertexSrc, n)
                        }
                        var r = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new qt,
                            default: this.defaultGroupCache[t]
                        };
                        return new Ji(this.programCache[t], r)
                    }, t.prototype.generateSampleSrc = function (t) {
                        var e = "";
                        e += "\n", e += "\n";
                        for (var i = 0; i < t; i++) i > 0 && (e += "\nelse "), i < t - 1 && (e += "if(vTextureId < " + i + ".5)"), e += "\n{", e += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);", e += "\n}";
                        return (e += "\n") + "\n"
                    }, t
                }(),
                Rn = function (t) {
                    function e(e) {
                        void 0 === e && (e = !1);
                        var i = t.call(this) || this;
                        return i._buffer = new ri(null, e, !1), i._indexBuffer = new ri(null, e, !0), i.addAttribute("aVertexPosition", i._buffer, 2, !1, S.FLOAT).addAttribute("aTextureCoord", i._buffer, 2, !1, S.FLOAT).addAttribute("aColor", i._buffer, 4, !0, S.UNSIGNED_BYTE).addAttribute("aTextureId", i._buffer, 1, !0, S.FLOAT).addIndex(i._indexBuffer), i
                    }
                    return Le(e, t), e
                }(ui),
                Dn = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n",
                Fn = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n",
                kn = function () {
                    function t() { }
                    return t.create = function (t) {
                        var e = Object.assign({
                            vertex: Dn,
                            fragment: Fn,
                            geometryClass: Rn,
                            vertexSize: 6
                        }, t),
                            i = e.vertex,
                            n = e.fragment,
                            r = e.vertexSize,
                            o = e.geometryClass;
                        return function (t) {
                            function e(e) {
                                var s = t.call(this, e) || this;
                                return s.shaderGenerator = new Mn(i, n), s.geometryClass = o, s.vertexSize = r, s
                            }
                            return Le(e, t), e
                        }(Nn)
                    }, Object.defineProperty(t, "defaultVertexSrc", {
                        get: function () {
                            return Dn
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t, "defaultFragmentTemplate", {
                        get: function () {
                            return Fn
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t
                }(),
                Un = kn.create(),
                Gn = function () {
                    function t(e) {
                        var i = this;
                        e = Object.assign({
                            forceCanvas: !1
                        }, e), this.renderer = En(e), this.stage = new ce, t._plugins.forEach((function (t) {
                            t.init.call(i, e)
                        }))
                    }
                    return t.registerPlugin = function (e) {
                        t._plugins.push(e)
                    }, t.prototype.render = function () {
                        this.renderer.render(this.stage)
                    }, Object.defineProperty(t.prototype, "view", {
                        get: function () {
                            return this.renderer.view
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "screen", {
                        get: function () {
                            return this.renderer.screen
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.destroy = function (e, i) {
                        var n = this,
                            r = t._plugins.slice(0);
                        r.reverse(), r.forEach((function (t) {
                            t.destroy.call(n)
                        })), this.stage.destroy(i), this.stage = null, this.renderer.destroy(e), this.renderer = null
                    }, t
                }();
            Gn._plugins = [];
            var Wn = function () {
                function t() { }
                return t.init = function (t) {
                    var e = this;
                    Object.defineProperty(this, "resizeTo", {
                        set: function (t) {
                            window.removeEventListener("resize", this.queueResize), this._resizeTo = t, t && (window.addEventListener("resize", this.queueResize), this.resize())
                        },
                        get: function () {
                            return this._resizeTo
                        }
                    }), this.queueResize = function () {
                        e._resizeTo && (e.cancelResize(), e._resizeId = requestAnimationFrame((function () {
                            return e.resize()
                        })))
                    }, this.cancelResize = function () {
                        e._resizeId && (cancelAnimationFrame(e._resizeId), e._resizeId = null)
                    }, this.resize = function () {
                        if (e._resizeTo) {
                            var t, i;
                            if (e.cancelResize(), e._resizeTo === window) t = window.innerWidth, i = window.innerHeight;
                            else {
                                var n = e._resizeTo;
                                t = n.clientWidth, i = n.clientHeight
                            }
                            e.renderer.resize(t, i)
                        }
                    }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
                }, t.destroy = function () {
                    window.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
                }, t
            }();
            Gn.registerPlugin(Wn);
            var Vn = new Vt,
                Xn = function () {
                    function t(t) {
                        this.renderer = t, t.extract = this
                    }
                    return t.prototype.image = function (t, e, i) {
                        var n = new Image;
                        return n.src = this.base64(t, e, i), n
                    }, t.prototype.base64 = function (t, e, i) {
                        return this.canvas(t).toDataURL(e, i)
                    }, t.prototype.canvas = function (e) {
                        var i, n, r, o = this.renderer,
                            s = !1,
                            a = !1;
                        e && (e instanceof ti ? r = e : (r = this.renderer.generateTexture(e), a = !0)), r ? (i = r.baseTexture.resolution, n = r.frame, s = !1, o.renderTexture.bind(r)) : (i = this.renderer.resolution, s = !0, (n = Vn).width = this.renderer.width, n.height = this.renderer.height, o.renderTexture.bind(null));
                        var l = Math.floor(n.width * i + 1e-4),
                            h = Math.floor(n.height * i + 1e-4),
                            u = new Lt(l, h, 1),
                            c = new Uint8Array(4 * l * h),
                            d = o.gl;
                        d.readPixels(n.x * i, n.y * i, l, h, d.RGBA, d.UNSIGNED_BYTE, c);
                        var p = u.context.getImageData(0, 0, l, h);
                        if (t.arrayPostDivide(c, p.data), u.context.putImageData(p, 0, 0), s) {
                            var f = new Lt(u.width, u.height, 1);
                            f.context.scale(1, -1), f.context.drawImage(u.canvas, 0, -h), u.destroy(), u = f
                        }
                        return a && r.destroy(!0), u.canvas
                    }, t.prototype.pixels = function (e) {
                        var i, n, r, o = this.renderer,
                            s = !1;
                        e && (e instanceof ti ? r = e : (r = this.renderer.generateTexture(e), s = !0)), r ? (i = r.baseTexture.resolution, n = r.frame, o.renderTexture.bind(r)) : (i = o.resolution, (n = Vn).width = o.width, n.height = o.height, o.renderTexture.bind(null));
                        var a = n.width * i,
                            l = n.height * i,
                            h = new Uint8Array(4 * a * l),
                            u = o.gl;
                        return u.readPixels(n.x * i, n.y * i, a, l, u.RGBA, u.UNSIGNED_BYTE, h), s && r.destroy(!0), t.arrayPostDivide(h, h), h
                    }, t.prototype.destroy = function () {
                        this.renderer.extract = null, this.renderer = null
                    }, t.arrayPostDivide = function (t, e) {
                        for (var i = 0; i < t.length; i += 4) {
                            var n = e[i + 3] = t[i + 3];
                            0 !== n ? (e[i] = Math.round(Math.min(255 * t[i] / n, 255)), e[i + 1] = Math.round(Math.min(255 * t[i + 1] / n, 255)), e[i + 2] = Math.round(Math.min(255 * t[i + 2] / n, 255))) : (e[i] = t[i], e[i + 1] = t[i + 1], e[i + 2] = t[i + 2])
                        }
                    }, t
                }(),
                Hn = i(5784),
                Yn = i.n(Hn),
                jn = i(2940),
                zn = i.n(jn);

            function Kn() { }

            function qn(t, e, i, n) {
                var r = 0,
                    o = t.length;
                ! function s(a) {
                    a || r === o ? i && i(a) : n ? setTimeout((function () {
                        e(t[r++], s)
                    }), 1) : e(t[r++], s)
                }()
            }

            function Zn(t) {
                return function () {
                    if (null === t) throw new Error("Callback was already called.");
                    var e = t;
                    t = null, e.apply(this, arguments)
                }
            }
            var $n = {};

            function Jn(t, e) {
                for (var i = 0; i < e.length; i++) {
                    var n = e[i];
                    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                }
            }

            function Qn(t, e, i) {
                return e && Jn(t.prototype, e), i && Jn(t, i), t
            }
            var tr = !(!window.XDomainRequest || "withCredentials" in new XMLHttpRequest),
                er = null;

            function ir() { }
            var nr = function () {
                function t(e, i, n) {
                    if ("string" != typeof e || "string" != typeof i) throw new Error("Both name and url are required for constructing a resource.");
                    n = n || {}, this._flags = 0, this._setFlag(t.STATUS_FLAGS.DATA_URL, 0 === i.indexOf("data:")), this.name = e, this.url = i, this.extension = this._getExtension(), this.data = null, this.crossOrigin = !0 === n.crossOrigin ? "anonymous" : n.crossOrigin, this.timeout = n.timeout || 0, this.loadType = n.loadType || this._determineLoadType(), this.xhrType = n.xhrType, this.metadata = n.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = t.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = ir, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new (zn()), this.onProgress = new (zn()), this.onComplete = new (zn()), this.onAfterMiddleware = new (zn())
                }
                t.setExtensionLoadType = function (e, i) {
                    rr(t._loadTypeMap, e, i)
                }, t.setExtensionXhrType = function (e, i) {
                    rr(t._xhrTypeMap, e, i)
                };
                var e = t.prototype;
                return e.complete = function () {
                    this._clearEvents(), this._finish()
                }, e.abort = function (e) {
                    if (!this.error) {
                        if (this.error = new Error(e), this._clearEvents(), this.xhr) this.xhr.abort();
                        else if (this.xdr) this.xdr.abort();
                        else if (this.data)
                            if (this.data.src) this.data.src = t.EMPTY_GIF;
                            else
                                for (; this.data.firstChild;) this.data.removeChild(this.data.firstChild);
                        this._finish()
                    }
                }, e.load = function (e) {
                    var i = this;
                    if (!this.isLoading)
                        if (this.isComplete) e && setTimeout((function () {
                            return e(i)
                        }), 1);
                        else switch (e && this.onComplete.once(e), this._setFlag(t.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), !1 !== this.crossOrigin && "string" == typeof this.crossOrigin || (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
                            case t.LOAD_TYPE.IMAGE:
                                this.type = t.TYPE.IMAGE, this._loadElement("image");
                                break;
                            case t.LOAD_TYPE.AUDIO:
                                this.type = t.TYPE.AUDIO, this._loadSourceElement("audio");
                                break;
                            case t.LOAD_TYPE.VIDEO:
                                this.type = t.TYPE.VIDEO, this._loadSourceElement("video");
                                break;
                            case t.LOAD_TYPE.XHR:
                            default:
                                tr && this.crossOrigin ? this._loadXdr() : this._loadXhr()
                        }
                }, e._hasFlag = function (t) {
                    return 0 != (this._flags & t)
                }, e._setFlag = function (t, e) {
                    this._flags = e ? this._flags | t : this._flags & ~t
                }, e._clearEvents = function () {
                    clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null))
                }, e._finish = function () {
                    if (this.isComplete) throw new Error("Complete called again for an already completed resource.");
                    this._setFlag(t.STATUS_FLAGS.COMPLETE, !0), this._setFlag(t.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this)
                }, e._loadElement = function (t) {
                    this.metadata.loadElement ? this.data = this.metadata.loadElement : "image" === t && void 0 !== window.Image ? this.data = new Image : this.data = document.createElement(t), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
                }, e._loadSourceElement = function (t) {
                    if (this.metadata.loadElement ? this.data = this.metadata.loadElement : "audio" === t && void 0 !== window.Audio ? this.data = new Audio : this.data = document.createElement(t), null !== this.data) {
                        if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
                            if (navigator.isCocoonJS) this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
                            else if (Array.isArray(this.url))
                                for (var e = this.metadata.mimeType, i = 0; i < this.url.length; ++i) this.data.appendChild(this._createSource(t, this.url[i], Array.isArray(e) ? e[i] : e));
                            else {
                                var n = this.metadata.mimeType;
                                this.data.appendChild(this._createSource(t, this.url, Array.isArray(n) ? n[0] : n))
                            }
                        this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout))
                    } else this.abort("Unsupported element: " + t)
                }, e._loadXhr = function () {
                    "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                    var e = this.xhr = new XMLHttpRequest;
                    e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === t.XHR_RESPONSE_TYPE.JSON || this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = t.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send()
                }, e._loadXdr = function () {
                    "string" != typeof this.xhrType && (this.xhrType = this._determineXhrType());
                    var t = this.xhr = new XDomainRequest;
                    t.timeout = this.timeout || 5e3, t.onerror = this._boundXhrOnError, t.ontimeout = this._boundXhrOnTimeout, t.onprogress = this._boundOnProgress, t.onload = this._boundXhrOnLoad, t.open("GET", this.url, !0), setTimeout((function () {
                        return t.send()
                    }), 1)
                }, e._createSource = function (t, e, i) {
                    i || (i = t + "/" + this._getExtension(e));
                    var n = document.createElement("source");
                    return n.src = e, n.type = i, n
                }, e._onError = function (t) {
                    this.abort("Failed to load element using: " + t.target.nodeName)
                }, e._onProgress = function (t) {
                    t && t.lengthComputable && this.onProgress.dispatch(this, t.loaded / t.total)
                }, e._onTimeout = function () {
                    this.abort("Load timed out.")
                }, e._xhrOnError = function () {
                    var t = this.xhr;
                    this.abort(or(t) + " Request failed. Status: " + t.status + ', text: "' + t.statusText + '"')
                }, e._xhrOnTimeout = function () {
                    var t = this.xhr;
                    this.abort(or(t) + " Request timed out.")
                }, e._xhrOnAbort = function () {
                    var t = this.xhr;
                    this.abort(or(t) + " Request was aborted by the user.")
                }, e._xhrOnLoad = function () {
                    var e = this.xhr,
                        i = "",
                        n = void 0 === e.status ? 200 : e.status;
                    if ("" !== e.responseType && "text" !== e.responseType && void 0 !== e.responseType || (i = e.responseText), 0 === n && (i.length > 0 || e.responseType === t.XHR_RESPONSE_TYPE.BUFFER) ? n = 200 : 1223 === n && (n = 204), 2 == (n / 100 | 0)) {
                        if (this.xhrType === t.XHR_RESPONSE_TYPE.TEXT) this.data = i, this.type = t.TYPE.TEXT;
                        else if (this.xhrType === t.XHR_RESPONSE_TYPE.JSON) try {
                            this.data = JSON.parse(i), this.type = t.TYPE.JSON
                        } catch (t) {
                            return void this.abort("Error trying to parse loaded json: " + t)
                        } else if (this.xhrType === t.XHR_RESPONSE_TYPE.DOCUMENT) try {
                            if (window.DOMParser) {
                                var r = new DOMParser;
                                this.data = r.parseFromString(i, "text/xml")
                            } else {
                                var o = document.createElement("div");
                                o.innerHTML = i, this.data = o
                            }
                            this.type = t.TYPE.XML
                        } catch (t) {
                            return void this.abort("Error trying to parse loaded xml: " + t)
                        } else this.data = e.response || i;
                        this.complete()
                    } else this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL)
                }, e._determineCrossOrigin = function (t, e) {
                    if (0 === t.indexOf("data:")) return "";
                    if (window.origin !== window.location.origin) return "anonymous";
                    e = e || window.location, er || (er = document.createElement("a")), er.href = t;
                    var i = !(t = Yn()(er.href, {
                        strictMode: !0
                    })).port && "" === e.port || t.port === e.port,
                        n = t.protocol ? t.protocol + ":" : "";
                    return t.host === e.hostname && i && n === e.protocol ? "" : "anonymous"
                }, e._determineXhrType = function () {
                    return t._xhrTypeMap[this.extension] || t.XHR_RESPONSE_TYPE.TEXT
                }, e._determineLoadType = function () {
                    return t._loadTypeMap[this.extension] || t.LOAD_TYPE.XHR
                }, e._getExtension = function () {
                    var t = this.url,
                        e = "";
                    if (this.isDataUrl) {
                        var i = t.indexOf("/");
                        e = t.substring(i + 1, t.indexOf(";", i))
                    } else {
                        var n = t.indexOf("?"),
                            r = t.indexOf("#"),
                            o = Math.min(n > -1 ? n : t.length, r > -1 ? r : t.length);
                        e = (t = t.substring(0, o)).substring(t.lastIndexOf(".") + 1)
                    }
                    return e.toLowerCase()
                }, e._getMimeFromXhrType = function (e) {
                    switch (e) {
                        case t.XHR_RESPONSE_TYPE.BUFFER:
                            return "application/octet-binary";
                        case t.XHR_RESPONSE_TYPE.BLOB:
                            return "application/blob";
                        case t.XHR_RESPONSE_TYPE.DOCUMENT:
                            return "application/xml";
                        case t.XHR_RESPONSE_TYPE.JSON:
                            return "application/json";
                        case t.XHR_RESPONSE_TYPE.DEFAULT:
                        case t.XHR_RESPONSE_TYPE.TEXT:
                        default:
                            return "text/plain"
                    }
                }, Qn(t, [{
                    key: "isDataUrl",
                    get: function () {
                        return this._hasFlag(t.STATUS_FLAGS.DATA_URL)
                    }
                }, {
                    key: "isComplete",
                    get: function () {
                        return this._hasFlag(t.STATUS_FLAGS.COMPLETE)
                    }
                }, {
                    key: "isLoading",
                    get: function () {
                        return this._hasFlag(t.STATUS_FLAGS.LOADING)
                    }
                }]), t
            }();

            function rr(t, e, i) {
                e && 0 === e.indexOf(".") && (e = e.substring(1)), e && (t[e] = i)
            }

            function or(t) {
                return t.toString().replace("object ", "")
            }
            nr.STATUS_FLAGS = {
                NONE: 0,
                DATA_URL: 1,
                COMPLETE: 2,
                LOADING: 4
            }, nr.TYPE = {
                UNKNOWN: 0,
                JSON: 1,
                XML: 2,
                IMAGE: 3,
                AUDIO: 4,
                VIDEO: 5,
                TEXT: 6
            }, nr.LOAD_TYPE = {
                XHR: 1,
                IMAGE: 2,
                AUDIO: 3,
                VIDEO: 4
            }, nr.XHR_RESPONSE_TYPE = {
                DEFAULT: "text",
                BUFFER: "arraybuffer",
                BLOB: "blob",
                DOCUMENT: "document",
                JSON: "json",
                TEXT: "text"
            }, nr._loadTypeMap = {
                gif: nr.LOAD_TYPE.IMAGE,
                png: nr.LOAD_TYPE.IMAGE,
                bmp: nr.LOAD_TYPE.IMAGE,
                jpg: nr.LOAD_TYPE.IMAGE,
                jpeg: nr.LOAD_TYPE.IMAGE,
                tif: nr.LOAD_TYPE.IMAGE,
                tiff: nr.LOAD_TYPE.IMAGE,
                webp: nr.LOAD_TYPE.IMAGE,
                tga: nr.LOAD_TYPE.IMAGE,
                svg: nr.LOAD_TYPE.IMAGE,
                "svg+xml": nr.LOAD_TYPE.IMAGE,
                mp3: nr.LOAD_TYPE.AUDIO,
                ogg: nr.LOAD_TYPE.AUDIO,
                wav: nr.LOAD_TYPE.AUDIO,
                mp4: nr.LOAD_TYPE.VIDEO,
                webm: nr.LOAD_TYPE.VIDEO
            }, nr._xhrTypeMap = {
                xhtml: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                html: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                htm: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                xml: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                tmx: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                svg: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                tsx: nr.XHR_RESPONSE_TYPE.DOCUMENT,
                gif: nr.XHR_RESPONSE_TYPE.BLOB,
                png: nr.XHR_RESPONSE_TYPE.BLOB,
                bmp: nr.XHR_RESPONSE_TYPE.BLOB,
                jpg: nr.XHR_RESPONSE_TYPE.BLOB,
                jpeg: nr.XHR_RESPONSE_TYPE.BLOB,
                tif: nr.XHR_RESPONSE_TYPE.BLOB,
                tiff: nr.XHR_RESPONSE_TYPE.BLOB,
                webp: nr.XHR_RESPONSE_TYPE.BLOB,
                tga: nr.XHR_RESPONSE_TYPE.BLOB,
                json: nr.XHR_RESPONSE_TYPE.JSON,
                text: nr.XHR_RESPONSE_TYPE.TEXT,
                txt: nr.XHR_RESPONSE_TYPE.TEXT,
                ttf: nr.XHR_RESPONSE_TYPE.BUFFER,
                otf: nr.XHR_RESPONSE_TYPE.BUFFER
            }, nr.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
            var sr = window.URL || window.webkitURL,
                ar = {
                    caching: function (t, e) {
                        var i = this;
                        $n[t.url] ? (t.data = $n[t.url], t.complete()) : t.onComplete.once((function () {
                            return $n[i.url] = i.data
                        })), e()
                    },
                    parsing: function (t, e) {
                        if (t.data) {
                            if (t.xhr && t.xhrType === nr.XHR_RESPONSE_TYPE.BLOB)
                                if (window.Blob && "string" != typeof t.data) {
                                    if (0 === t.data.type.indexOf("image")) {
                                        var i = sr.createObjectURL(t.data);
                                        return t.blob = t.data, t.data = new Image, t.data.src = i, t.type = nr.TYPE.IMAGE, void (t.data.onload = function () {
                                            sr.revokeObjectURL(i), t.data.onload = null, e()
                                        })
                                    }
                                } else {
                                    var n = t.xhr.getResponseHeader("content-type");
                                    if (n && 0 === n.indexOf("image")) return t.data = new Image, t.data.src = "data:" + n + ";base64," + function (t) {
                                        for (var e = "", i = 0; i < t.length;) {
                                            for (var n = [0, 0, 0], r = [0, 0, 0, 0], o = 0; o < n.length; ++o) i < t.length ? n[o] = 255 & t.charCodeAt(i++) : n[o] = 0;
                                            switch (r[0] = n[0] >> 2, r[1] = (3 & n[0]) << 4 | n[1] >> 4, r[2] = (15 & n[1]) << 2 | n[2] >> 6, r[3] = 63 & n[2], i - (t.length - 1)) {
                                                case 2:
                                                    r[3] = 64, r[2] = 64;
                                                    break;
                                                case 1:
                                                    r[3] = 64
                                            }
                                            for (var s = 0; s < r.length; ++s) e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(r[s])
                                        }
                                        return e
                                    }(t.xhr.responseText), t.type = nr.TYPE.IMAGE, void (t.data.onload = function () {
                                        t.data.onload = null, e()
                                    })
                                } e()
                        } else e()
                    }
                },
                lr = /(#[\w-]+)?$/,
                hr = function () {
                    function t(e, i) {
                        var n = this;
                        void 0 === e && (e = ""), void 0 === i && (i = 10), this.baseUrl = e, this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function (t, e) {
                            return n._loadResource(t, e)
                        }, this._queue = function (t, e) {
                            if (null == e) e = 1;
                            else if (0 === e) throw new Error("Concurrency must not be zero");
                            var i = 0,
                                n = {
                                    _tasks: [],
                                    concurrency: e,
                                    saturated: Kn,
                                    unsaturated: Kn,
                                    buffer: e / 4,
                                    empty: Kn,
                                    drain: Kn,
                                    error: Kn,
                                    started: !1,
                                    paused: !1,
                                    push: function (t, e) {
                                        r(t, !1, e)
                                    },
                                    kill: function () {
                                        i = 0, n.drain = Kn, n.started = !1, n._tasks = []
                                    },
                                    unshift: function (t, e) {
                                        r(t, !0, e)
                                    },
                                    process: function () {
                                        for (; !n.paused && i < n.concurrency && n._tasks.length;) {
                                            var e = n._tasks.shift();
                                            0 === n._tasks.length && n.empty(), (i += 1) === n.concurrency && n.saturated(), t(e.data, Zn(o(e)))
                                        }
                                    },
                                    length: function () {
                                        return n._tasks.length
                                    },
                                    running: function () {
                                        return i
                                    },
                                    idle: function () {
                                        return n._tasks.length + i === 0
                                    },
                                    pause: function () {
                                        !0 !== n.paused && (n.paused = !0)
                                    },
                                    resume: function () {
                                        if (!1 !== n.paused) {
                                            n.paused = !1;
                                            for (var t = 1; t <= n.concurrency; t++) n.process()
                                        }
                                    }
                                };

                            function r(t, e, i) {
                                if (null != i && "function" != typeof i) throw new Error("task callback must be a function");
                                if (n.started = !0, null == t && n.idle()) setTimeout((function () {
                                    return n.drain()
                                }), 1);
                                else {
                                    var r = {
                                        data: t,
                                        callback: "function" == typeof i ? i : Kn
                                    };
                                    e ? n._tasks.unshift(r) : n._tasks.push(r), setTimeout((function () {
                                        return n.process()
                                    }), 1)
                                }
                            }

                            function o(t) {
                                return function () {
                                    i -= 1, t.callback.apply(t, arguments), null != arguments[0] && n.error(arguments[0], t.data), i <= n.concurrency - n.buffer && n.unsaturated(), n.idle() && n.drain(), n.process()
                                }
                            }
                            return n
                        }(this._boundLoadResource, i), this._queue.pause(), this.resources = {}, this.onProgress = new (zn()), this.onError = new (zn()), this.onLoad = new (zn()), this.onStart = new (zn()), this.onComplete = new (zn());
                        for (var r = 0; r < t._defaultBeforeMiddleware.length; ++r) this.pre(t._defaultBeforeMiddleware[r]);
                        for (var o = 0; o < t._defaultAfterMiddleware.length; ++o) this.use(t._defaultAfterMiddleware[o])
                    }
                    var e = t.prototype;
                    return e.add = function (t, e, i, n) {
                        if (Array.isArray(t)) {
                            for (var r = 0; r < t.length; ++r) this.add(t[r]);
                            return this
                        }
                        if ("object" == typeof t && (n = e || t.callback || t.onComplete, i = t, e = t.url, t = t.name || t.key || t.url), "string" != typeof e && (n = i, i = e, e = t), "string" != typeof e) throw new Error("No url passed to add resource to loader.");
                        if ("function" == typeof i && (n = i, i = null), this.loading && (!i || !i.parentResource)) throw new Error("Cannot add resources while the loader is running.");
                        if (this.resources[t]) throw new Error('Resource named "' + t + '" already exists.');
                        if (e = this._prepareUrl(e), this.resources[t] = new nr(t, e, i), "function" == typeof n && this.resources[t].onAfterMiddleware.once(n), this.loading) {
                            for (var o = i.parentResource, s = [], a = 0; a < o.children.length; ++a) o.children[a].isComplete || s.push(o.children[a]);
                            var l = o.progressChunk * (s.length + 1) / (s.length + 2);
                            o.children.push(this.resources[t]), o.progressChunk = l;
                            for (var h = 0; h < s.length; ++h) s[h].progressChunk = l;
                            this.resources[t].progressChunk = l
                        }
                        return this._queue.push(this.resources[t]), this
                    }, e.pre = function (t) {
                        return this._beforeMiddleware.push(t), this
                    }, e.use = function (t) {
                        return this._afterMiddleware.push(t), this
                    }, e.reset = function () {
                        for (var t in this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause(), this.resources) {
                            var e = this.resources[t];
                            e._onLoadBinding && e._onLoadBinding.detach(), e.isLoading && e.abort()
                        }
                        return this.resources = {}, this
                    }, e.load = function (t) {
                        if ("function" == typeof t && this.onComplete.once(t), this.loading) return this;
                        if (this._queue.idle()) this._onStart(), this._onComplete();
                        else {
                            for (var e = 100 / this._queue._tasks.length, i = 0; i < this._queue._tasks.length; ++i) this._queue._tasks[i].data.progressChunk = e;
                            this._onStart(), this._queue.resume()
                        }
                        return this
                    }, e._prepareUrl = function (t) {
                        var e, i = Yn()(t, {
                            strictMode: !0
                        });
                        if (e = i.protocol || !i.path || 0 === t.indexOf("//") ? t : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && "/" !== t.charAt(0) ? this.baseUrl + "/" + t : this.baseUrl + t, this.defaultQueryString) {
                            var n = lr.exec(e)[0]; - 1 !== (e = e.substr(0, e.length - n.length)).indexOf("?") ? e += "&" + this.defaultQueryString : e += "?" + this.defaultQueryString, e += n
                        }
                        return e
                    }, e._loadResource = function (t, e) {
                        var i = this;
                        t._dequeue = e, qn(this._beforeMiddleware, (function (e, n) {
                            e.call(i, t, (function () {
                                n(t.isComplete ? {} : null)
                            }))
                        }), (function () {
                            t.isComplete ? i._onLoad(t) : (t._onLoadBinding = t.onComplete.once(i._onLoad, i), t.load())
                        }), !0)
                    }, e._onStart = function () {
                        this.progress = 0, this.loading = !0, this.onStart.dispatch(this)
                    }, e._onComplete = function () {
                        this.progress = 100, this.loading = !1, this.onComplete.dispatch(this, this.resources)
                    }, e._onLoad = function (t) {
                        var e = this;
                        t._onLoadBinding = null, this._resourcesParsing.push(t), t._dequeue(), qn(this._afterMiddleware, (function (i, n) {
                            i.call(e, t, n)
                        }), (function () {
                            t.onAfterMiddleware.dispatch(t), e.progress = Math.min(100, e.progress + t.progressChunk), e.onProgress.dispatch(e, t), t.error ? e.onError.dispatch(t.error, e, t) : e.onLoad.dispatch(e, t), e._resourcesParsing.splice(e._resourcesParsing.indexOf(t), 1), e._queue.idle() && 0 === e._resourcesParsing.length && e._onComplete()
                        }), !0)
                    }, Qn(t, [{
                        key: "concurrency",
                        get: function () {
                            return this._queue.concurrency
                        },
                        set: function (t) {
                            this._queue.concurrency = t
                        }
                    }]), t
                }();
            hr._defaultBeforeMiddleware = [], hr._defaultAfterMiddleware = [], hr.pre = function (t) {
                return hr._defaultBeforeMiddleware.push(t), hr
            }, hr.use = function (t) {
                return hr._defaultAfterMiddleware.push(t), hr
            };
            var ur = nr,
                cr = function (t, e) {
                    return cr = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, cr(t, e)
                },
                dr = function () {
                    function t() { }
                    return t.use = function (t, e) {
                        t.data && t.type === nr.TYPE.IMAGE && (t.texture = Je.fromLoader(t.data, t.url, t.name)), e()
                    }, t
                }(),
                pr = function (t) {
                    function e(i, n) {
                        for (var r = t.call(this, i, n) || this, o = 0; o < e._plugins.length; ++o) {
                            var s = e._plugins[o],
                                a = s.pre,
                                l = s.use;
                            a && r.pre(a), l && r.use(l)
                        }
                        return r._protected = !1, r
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        cr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype.destroy = function () {
                        this._protected || this.reset()
                    }, Object.defineProperty(e, "shared", {
                        get: function () {
                            var t = e._shared;
                            return t || ((t = new e)._protected = !0, e._shared = t), t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.registerPlugin = function (t) {
                        return e._plugins.push(t), t.add && t.add(), e
                    }, e._plugins = [], e
                }(hr);
            pr.registerPlugin({
                use: ar.parsing
            }), pr.registerPlugin(dr);
            var fr = function () {
                function t() { }
                return t.init = function (t) {
                    t = Object.assign({
                        sharedLoader: !1
                    }, t), this.loader = t.sharedLoader ? pr.shared : new pr
                }, t.destroy = function () {
                    this.loader && (this.loader.destroy(), this.loader = null)
                }, t
            }(),
                gr = function (t, e) {
                    return gr = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, gr(t, e)
                };

            function mr(t, e) {
                function i() {
                    this.constructor = t
                }
                gr(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var _r, yr, Sr = function (t) {
                function e(e, i, n, r) {
                    void 0 === e && (e = 1500), void 0 === n && (n = 16384), void 0 === r && (r = !1);
                    var o = t.call(this) || this;
                    return n > 16384 && (n = 16384), o._properties = [!1, !0, !1, !1, !1], o._maxSize = e, o._batchSize = n, o._buffers = null, o._bufferUpdateIDs = [], o._updateID = 0, o.interactiveChildren = !1, o.blendMode = g.NORMAL, o.autoResize = r, o.roundPixels = !0, o.baseTexture = null, o.setProperties(i), o._tint = 0, o.tintRgb = new Float32Array(4), o.tint = 16777215, o
                }
                return mr(e, t), e.prototype.setProperties = function (t) {
                    t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
                }, e.prototype.updateTransform = function () {
                    this.displayObjectUpdateTransform()
                }, Object.defineProperty(e.prototype, "tint", {
                    get: function () {
                        return this._tint
                    },
                    set: function (t) {
                        this._tint = t, rt(t, this.tintRgb)
                    },
                    enumerable: !1,
                    configurable: !0
                }), e.prototype.render = function (t) {
                    var e = this;
                    this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", (function () {
                        return e.onChildrenChange(0)
                    }))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
                }, e.prototype.onChildrenChange = function (t) {
                    for (var e = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < e;) this._bufferUpdateIDs.push(0);
                    this._bufferUpdateIDs[e] = ++this._updateID
                }, e.prototype.dispose = function () {
                    if (this._buffers) {
                        for (var t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
                        this._buffers = null
                    }
                }, e.prototype.destroy = function (e) {
                    t.prototype.destroy.call(this, e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
                }, e
            }(ce),
                vr = function () {
                    function t(t, e, i) {
                        this.geometry = new ui, this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
                        for (var n = 0; n < t.length; ++n) {
                            var r = t[n];
                            r = {
                                attributeName: r.attributeName,
                                size: r.size,
                                uploadFunction: r.uploadFunction,
                                type: r.type || S.FLOAT,
                                offset: r.offset
                            }, e[n] ? this.dynamicProperties.push(r) : this.staticProperties.push(r)
                        }
                        this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
                    }
                    return t.prototype.initBuffers = function () {
                        var t = this.geometry,
                            e = 0;
                        this.indexBuffer = new ri(pt(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
                        for (var i = 0; i < this.dynamicProperties.length; ++i)(s = this.dynamicProperties[i]).offset = e, e += s.size, this.dynamicStride += s.size;
                        var n = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
                        this.dynamicData = new Float32Array(n), this.dynamicDataUint32 = new Uint32Array(n), this.dynamicBuffer = new ri(this.dynamicData, !1, !1);
                        var r = 0;
                        for (this.staticStride = 0, i = 0; i < this.staticProperties.length; ++i)(s = this.staticProperties[i]).offset = r, r += s.size, this.staticStride += s.size;
                        var o = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
                        for (this.staticData = new Float32Array(o), this.staticDataUint32 = new Uint32Array(o), this.staticBuffer = new ri(this.staticData, !0, !1), i = 0; i < this.dynamicProperties.length; ++i) {
                            var s = this.dynamicProperties[i];
                            t.addAttribute(s.attributeName, this.dynamicBuffer, 0, s.type === S.UNSIGNED_BYTE, s.type, 4 * this.dynamicStride, 4 * s.offset)
                        }
                        for (i = 0; i < this.staticProperties.length; ++i) s = this.staticProperties[i], t.addAttribute(s.attributeName, this.staticBuffer, 0, s.type === S.UNSIGNED_BYTE, s.type, 4 * this.staticStride, 4 * s.offset)
                    }, t.prototype.uploadDynamic = function (t, e, i) {
                        for (var n = 0; n < this.dynamicProperties.length; n++) {
                            var r = this.dynamicProperties[n];
                            r.uploadFunction(t, e, i, r.type === S.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, r.offset)
                        }
                        this.dynamicBuffer._updateID++
                    }, t.prototype.uploadStatic = function (t, e, i) {
                        for (var n = 0; n < this.staticProperties.length; n++) {
                            var r = this.staticProperties[n];
                            r.uploadFunction(t, e, i, r.type === S.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, r.offset)
                        }
                        this.staticBuffer._updateID++
                    }, t.prototype.destroy = function () {
                        this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
                    }, t
                }(),
                br = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.shader = null, i.properties = null, i.tempMatrix = new qt, i.properties = [{
                            attributeName: "aVertexPosition",
                            size: 2,
                            uploadFunction: i.uploadVertices,
                            offset: 0
                        }, {
                            attributeName: "aPositionCoord",
                            size: 2,
                            uploadFunction: i.uploadPosition,
                            offset: 0
                        }, {
                            attributeName: "aRotation",
                            size: 1,
                            uploadFunction: i.uploadRotation,
                            offset: 0
                        }, {
                            attributeName: "aTextureCoord",
                            size: 2,
                            uploadFunction: i.uploadUvs,
                            offset: 0
                        }, {
                            attributeName: "aColor",
                            size: 1,
                            type: S.UNSIGNED_BYTE,
                            uploadFunction: i.uploadTint,
                            offset: 0
                        }], i.shader = Ji.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n", "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}", {}), i.state = Qi.for2d(), i
                    }
                    return mr(e, t), e.prototype.render = function (t) {
                        var e = t.children,
                            i = t._maxSize,
                            n = t._batchSize,
                            r = this.renderer,
                            o = e.length;
                        if (0 !== o) {
                            o > i && !t.autoResize && (o = i);
                            var s = t._buffers;
                            s || (s = t._buffers = this.generateBuffers(t));
                            var a = e[0]._texture.baseTexture;
                            this.state.blendMode = ht(t.blendMode, a.alphaMode), r.state.set(this.state);
                            var l = r.gl,
                                h = t.worldTransform.copyTo(this.tempMatrix);
                            h.prepend(r.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = h.toArray(!0), this.shader.uniforms.uColor = ut(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, a.alphaMode), this.shader.uniforms.uSampler = a, this.renderer.shader.bind(this.shader);
                            for (var u = !1, c = 0, d = 0; c < o; c += n, d += 1) {
                                var p = o - c;
                                p > n && (p = n), d >= s.length && s.push(this._generateOneMoreBuffer(t));
                                var f = s[d];
                                f.uploadDynamic(e, c, p);
                                var g = t._bufferUpdateIDs[d] || 0;
                                (u = u || f._updateID < g) && (f._updateID = t._updateID, f.uploadStatic(e, c, p)), r.geometry.bind(f.geometry), l.drawElements(l.TRIANGLES, 6 * p, l.UNSIGNED_SHORT, 0)
                            }
                        }
                    }, e.prototype.generateBuffers = function (t) {
                        for (var e = [], i = t._maxSize, n = t._batchSize, r = t._properties, o = 0; o < i; o += n) e.push(new vr(this.properties, r, n));
                        return e
                    }, e.prototype._generateOneMoreBuffer = function (t) {
                        var e = t._batchSize,
                            i = t._properties;
                        return new vr(this.properties, i, e)
                    }, e.prototype.uploadVertices = function (t, e, i, n, r, o) {
                        for (var s = 0, a = 0, l = 0, h = 0, u = 0; u < i; ++u) {
                            var c = t[e + u],
                                d = c._texture,
                                p = c.scale.x,
                                f = c.scale.y,
                                g = d.trim,
                                m = d.orig;
                            g ? (s = (a = g.x - c.anchor.x * m.width) + g.width, l = (h = g.y - c.anchor.y * m.height) + g.height) : (s = m.width * (1 - c.anchor.x), a = m.width * -c.anchor.x, l = m.height * (1 - c.anchor.y), h = m.height * -c.anchor.y), n[o] = a * p, n[o + 1] = h * f, n[o + r] = s * p, n[o + r + 1] = h * f, n[o + 2 * r] = s * p, n[o + 2 * r + 1] = l * f, n[o + 3 * r] = a * p, n[o + 3 * r + 1] = l * f, o += 4 * r
                        }
                    }, e.prototype.uploadPosition = function (t, e, i, n, r, o) {
                        for (var s = 0; s < i; s++) {
                            var a = t[e + s].position;
                            n[o] = a.x, n[o + 1] = a.y, n[o + r] = a.x, n[o + r + 1] = a.y, n[o + 2 * r] = a.x, n[o + 2 * r + 1] = a.y, n[o + 3 * r] = a.x, n[o + 3 * r + 1] = a.y, o += 4 * r
                        }
                    }, e.prototype.uploadRotation = function (t, e, i, n, r, o) {
                        for (var s = 0; s < i; s++) {
                            var a = t[e + s].rotation;
                            n[o] = a, n[o + r] = a, n[o + 2 * r] = a, n[o + 3 * r] = a, o += 4 * r
                        }
                    }, e.prototype.uploadUvs = function (t, e, i, n, r, o) {
                        for (var s = 0; s < i; ++s) {
                            var a = t[e + s]._texture._uvs;
                            a ? (n[o] = a.x0, n[o + 1] = a.y0, n[o + r] = a.x1, n[o + r + 1] = a.y1, n[o + 2 * r] = a.x2, n[o + 2 * r + 1] = a.y2, n[o + 3 * r] = a.x3, n[o + 3 * r + 1] = a.y3, o += 4 * r) : (n[o] = 0, n[o + 1] = 0, n[o + r] = 0, n[o + r + 1] = 0, n[o + 2 * r] = 0, n[o + 2 * r + 1] = 0, n[o + 3 * r] = 0, n[o + 3 * r + 1] = 0, o += 4 * r)
                        }
                    }, e.prototype.uploadTint = function (t, e, i, n, r, o) {
                        for (var s = 0; s < i; ++s) {
                            var a = t[e + s],
                                l = a._texture.baseTexture.alphaMode > 0,
                                h = a.alpha,
                                u = h < 1 && l ? ct(a._tintRGB, h) : a._tintRGB + (255 * h << 24);
                            n[o] = u, n[o + r] = u, n[o + 2 * r] = u, n[o + 3 * r] = u, o += 4 * r
                        }
                    }, e.prototype.destroy = function () {
                        t.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
                    }, e
                }(_i);
            ! function (t) {
                t.MITER = "miter", t.BEVEL = "bevel", t.ROUND = "round"
            }(_r || (_r = {})),
                function (t) {
                    t.BUTT = "butt", t.ROUND = "round", t.SQUARE = "square"
                }(yr || (yr = {}));
            var Tr = {
                adaptive: !0,
                maxLength: 10,
                minSegments: 8,
                maxSegments: 2048,
                epsilon: 1e-4,
                _segmentsCount: function (t, e) {
                    if (void 0 === e && (e = 20), !this.adaptive || !t || isNaN(t)) return e;
                    var i = Math.ceil(t / this.maxLength);
                    return i < this.minSegments ? i = this.minSegments : i > this.maxSegments && (i = this.maxSegments), i
                }
            },
                Pr = function () {
                    function t() {
                        this.color = 16777215, this.alpha = 1, this.texture = Je.WHITE, this.matrix = null, this.visible = !1, this.reset()
                    }
                    return t.prototype.clone = function () {
                        var e = new t;
                        return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e
                    }, t.prototype.reset = function () {
                        this.color = 16777215, this.alpha = 1, this.texture = Je.WHITE, this.matrix = null, this.visible = !1
                    }, t.prototype.destroy = function () {
                        this.texture = null, this.matrix = null
                    }, t
                }(),
                Ar = function (t, e) {
                    return Ar = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Ar(t, e)
                };

            function Ir(t, e) {
                function i() {
                    this.constructor = t
                }
                Ar(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var wr = {
                build: function (t) {
                    t.points = t.shape.points.slice()
                },
                triangulate: function (t, e) {
                    var i = t.points,
                        n = t.holes,
                        r = e.points,
                        o = e.indices;
                    if (i.length >= 6) {
                        for (var s = [], a = 0; a < n.length; a++) {
                            var l = n[a];
                            s.push(i.length / 2), i = i.concat(l.points)
                        }
                        var h = Z()(i, s, 2);
                        if (!h) return;
                        var u = r.length / 2;
                        for (a = 0; a < h.length; a += 3) o.push(h[a] + u), o.push(h[a + 1] + u), o.push(h[a + 2] + u);
                        for (a = 0; a < i.length; a++) r.push(i[a])
                    }
                }
            },
                Er = {
                    build: function (t) {
                        var e, i, n = t.shape,
                            r = t.points,
                            o = n.x,
                            s = n.y;
                        if (r.length = 0, t.type === kt.CIRC) e = n.radius, i = n.radius;
                        else {
                            var a = t.shape;
                            e = a.width, i = a.height
                        }
                        if (0 !== e && 0 !== i) {
                            var l = Math.floor(30 * Math.sqrt(n.radius)) || Math.floor(15 * Math.sqrt(e + i));
                            l /= 2.3;
                            for (var h = 2 * Math.PI / l, u = 0; u < l - .5; u++) r.push(o + Math.sin(-h * u) * e, s + Math.cos(-h * u) * i);
                            r.push(r[0], r[1])
                        }
                    },
                    triangulate: function (t, e) {
                        var i = t.points,
                            n = e.points,
                            r = e.indices,
                            o = n.length / 2,
                            s = o,
                            a = t.shape,
                            l = t.matrix,
                            h = a.x,
                            u = a.y;
                        n.push(t.matrix ? l.a * h + l.c * u + l.tx : h, t.matrix ? l.b * h + l.d * u + l.ty : u);
                        for (var c = 0; c < i.length; c += 2) n.push(i[c], i[c + 1]), r.push(o++, s, o)
                    }
                },
                Cr = {
                    build: function (t) {
                        var e = t.shape,
                            i = e.x,
                            n = e.y,
                            r = e.width,
                            o = e.height,
                            s = t.points;
                        s.length = 0, s.push(i, n, i + r, n, i + r, n + o, i, n + o)
                    },
                    triangulate: function (t, e) {
                        var i = t.points,
                            n = e.points,
                            r = n.length / 2;
                        n.push(i[0], i[1], i[2], i[3], i[6], i[7], i[4], i[5]), e.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3)
                    }
                };

            function xr(t, e, i) {
                return t + (e - t) * i
            }

            function Br(t, e, i, n, r, o, s) {
                void 0 === s && (s = []);
                for (var a = s, l = 0, h = 0, u = 0, c = 0, d = 0, p = 0, f = 0, g = 0; f <= 20; ++f) l = xr(t, i, g = f / 20), h = xr(e, n, g), u = xr(i, r, g), c = xr(n, o, g), d = xr(l, u, g), p = xr(h, c, g), a.push(d, p);
                return a
            }
            var Lr = {
                build: function (t) {
                    var e = t.shape,
                        i = t.points,
                        n = e.x,
                        r = e.y,
                        o = e.width,
                        s = e.height,
                        a = Math.max(0, Math.min(e.radius, Math.min(o, s) / 2));
                    i.length = 0, a ? (Br(n, r + a, n, r, n + a, r, i), Br(n + o - a, r, n + o, r, n + o, r + a, i), Br(n + o, r + s - a, n + o, r + s, n + o - a, r + s, i), Br(n + a, r + s, n, r + s, n, r + s - a, i)) : i.push(n, r, n + o, r, n + o, r + s, n, r + s)
                },
                triangulate: function (t, e) {
                    for (var i = t.points, n = e.points, r = e.indices, o = n.length / 2, s = Z()(i, null, 2), a = 0, l = s.length; a < l; a += 3) r.push(s[a] + o), r.push(s[a + 1] + o), r.push(s[a + 2] + o);
                    for (a = 0, l = i.length; a < l; a++) n.push(i[a], i[++a])
                }
            };

            function Or(t, e, i, n, r, o, s, a) {
                var l, h;
                s ? (l = n, h = -i) : (l = -n, h = i);
                var u = t - i * r + l,
                    c = e - n * r + h,
                    d = t + i * o + l,
                    p = e + n * o + h;
                return a.push(u, c), a.push(d, p), 2
            }

            function Nr(t, e, i, n, r, o, s, a) {
                var l = i - t,
                    h = n - e,
                    u = Math.atan2(l, h),
                    c = Math.atan2(r - t, o - e);
                a && u < c ? u += 2 * Math.PI : !a && u > c && (c += 2 * Math.PI);
                var d = u,
                    p = c - u,
                    f = Math.abs(p),
                    g = Math.sqrt(l * l + h * h),
                    m = 1 + (15 * f * Math.sqrt(g) / Math.PI >> 0),
                    _ = p / m;
                if (d += _, a) {
                    s.push(t, e), s.push(i, n);
                    for (var y = 1, S = d; y < m; y++, S += _) s.push(t, e), s.push(t + Math.sin(S) * g, e + Math.cos(S) * g);
                    s.push(t, e), s.push(r, o)
                } else {
                    for (s.push(i, n), s.push(t, e), y = 1, S = d; y < m; y++, S += _) s.push(t + Math.sin(S) * g, e + Math.cos(S) * g), s.push(t, e);
                    s.push(r, o), s.push(t, e)
                }
                return 2 * m
            }

            function Mr(t, e) {
                t.lineStyle.native ? function (t, e) {
                    var i = 0,
                        n = t.shape,
                        r = t.points || n.points,
                        o = n.type !== kt.POLY || n.closeStroke;
                    if (0 !== r.length) {
                        var s = e.points,
                            a = e.indices,
                            l = r.length / 2,
                            h = s.length / 2,
                            u = h;
                        for (s.push(r[0], r[1]), i = 1; i < l; i++) s.push(r[2 * i], r[2 * i + 1]), a.push(u, u + 1), u++;
                        o && a.push(u, h)
                    }
                }(t, e) : function (t, e) {
                    var i = t.shape,
                        n = t.points || i.points.slice(),
                        r = e.closePointEps;
                    if (0 !== n.length) {
                        var o = t.lineStyle,
                            s = new zt(n[0], n[1]),
                            a = new zt(n[n.length - 2], n[n.length - 1]),
                            l = i.type !== kt.POLY || i.closeStroke,
                            h = Math.abs(s.x - a.x) < r && Math.abs(s.y - a.y) < r;
                        if (l) {
                            n = n.slice(), h && (n.pop(), n.pop(), a.set(n[n.length - 2], n[n.length - 1]));
                            var u = .5 * (s.x + a.x),
                                c = .5 * (a.y + s.y);
                            n.unshift(u, c), n.push(u, c)
                        }
                        var d = e.points,
                            p = n.length / 2,
                            f = n.length,
                            g = d.length / 2,
                            m = o.width / 2,
                            _ = m * m,
                            y = o.miterLimit * o.miterLimit,
                            S = n[0],
                            v = n[1],
                            b = n[2],
                            T = n[3],
                            P = 0,
                            A = 0,
                            I = -(v - T),
                            w = S - b,
                            E = 0,
                            C = 0,
                            x = Math.sqrt(I * I + w * w);
                        I /= x, w /= x, I *= m, w *= m;
                        var B = o.alignment,
                            L = 2 * (1 - B),
                            O = 2 * B;
                        l || (o.cap === yr.ROUND ? f += Nr(S - I * (L - O) * .5, v - w * (L - O) * .5, S - I * L, v - w * L, S + I * O, v + w * O, d, !0) + 2 : o.cap === yr.SQUARE && (f += Or(S, v, I, w, L, O, !0, d))), d.push(S - I * L, v - w * L), d.push(S + I * O, v + w * O);
                        for (var N = 1; N < p - 1; ++N) {
                            S = n[2 * (N - 1)], v = n[2 * (N - 1) + 1], b = n[2 * N], T = n[2 * N + 1], P = n[2 * (N + 1)], A = n[2 * (N + 1) + 1], I = -(v - T), w = S - b, I /= x = Math.sqrt(I * I + w * w), w /= x, I *= m, w *= m, E = -(T - A), C = b - P, E /= x = Math.sqrt(E * E + C * C), C /= x, E *= m, C *= m;
                            var M = b - S,
                                R = v - T,
                                D = b - P,
                                F = A - T,
                                k = R * D - F * M,
                                U = k < 0;
                            if (Math.abs(k) < .1) d.push(b - I * L, T - w * L), d.push(b + I * O, T + w * O);
                            else {
                                var G = (-I + S) * (-w + T) - (-I + b) * (-w + v),
                                    W = (-E + P) * (-C + T) - (-E + b) * (-C + A),
                                    V = (M * W - D * G) / k,
                                    X = (F * G - R * W) / k,
                                    H = (V - b) * (V - b) + (X - T) * (X - T),
                                    Y = b + (V - b) * L,
                                    j = T + (X - T) * L,
                                    z = b - (V - b) * O,
                                    K = T - (X - T) * O,
                                    q = U ? L : O;
                                H <= Math.min(M * M + R * R, D * D + F * F) + q * q * _ ? o.join === _r.BEVEL || H / _ > y ? (U ? (d.push(Y, j), d.push(b + I * O, T + w * O), d.push(Y, j), d.push(b + E * O, T + C * O)) : (d.push(b - I * L, T - w * L), d.push(z, K), d.push(b - E * L, T - C * L), d.push(z, K)), f += 2) : o.join === _r.ROUND ? U ? (d.push(Y, j), d.push(b + I * O, T + w * O), f += Nr(b, T, b + I * O, T + w * O, b + E * O, T + C * O, d, !0) + 4, d.push(Y, j), d.push(b + E * O, T + C * O)) : (d.push(b - I * L, T - w * L), d.push(z, K), f += Nr(b, T, b - I * L, T - w * L, b - E * L, T - C * L, d, !1) + 4, d.push(b - E * L, T - C * L), d.push(z, K)) : (d.push(Y, j), d.push(z, K)) : (d.push(b - I * L, T - w * L), d.push(b + I * O, T + w * O), o.join === _r.BEVEL || H / _ > y || (o.join === _r.ROUND ? f += U ? Nr(b, T, b + I * O, T + w * O, b + E * O, T + C * O, d, !0) + 2 : Nr(b, T, b - I * L, T - w * L, b - E * L, T - C * L, d, !1) + 2 : (U ? (d.push(z, K), d.push(z, K)) : (d.push(Y, j), d.push(Y, j)), f += 2)), d.push(b - E * L, T - C * L), d.push(b + E * O, T + C * O), f += 2)
                            }
                        }
                        S = n[2 * (p - 2)], v = n[2 * (p - 2) + 1], b = n[2 * (p - 1)], I = -(v - (T = n[2 * (p - 1) + 1])), w = S - b, I /= x = Math.sqrt(I * I + w * w), w /= x, I *= m, w *= m, d.push(b - I * L, T - w * L), d.push(b + I * O, T + w * O), l || (o.cap === yr.ROUND ? f += Nr(b - I * (L - O) * .5, T - w * (L - O) * .5, b - I * L, T - w * L, b + I * O, T + w * O, d, !1) + 2 : o.cap === yr.SQUARE && (f += Or(b, T, I, w, L, O, !1, d)));
                        var Z = e.indices,
                            $ = Tr.epsilon * Tr.epsilon;
                        for (N = g; N < f + g - 2; ++N) S = d[2 * N], v = d[2 * N + 1], b = d[2 * (N + 1)], T = d[2 * (N + 1) + 1], P = d[2 * (N + 2)], A = d[2 * (N + 2) + 1], Math.abs(S * (T - A) + b * (A - v) + P * (v - T)) < $ || Z.push(N, N + 1, N + 2)
                    }
                }(t, e)
            }
            var Rr, Dr, Fr = function (t) {
                function e(e, i, n, r, o, s) {
                    void 0 === s && (s = 0), o = o || r / 2;
                    for (var a = -1 * Math.PI / 2 + s, l = 2 * n, h = Ut / l, u = [], c = 0; c < l; c++) {
                        var d = c % 2 ? o : r,
                            p = c * h + a;
                        u.push(e + d * Math.cos(p), i + d * Math.sin(p))
                    }
                    return t.call(this, u) || this
                }
                return Ir(e, t), e
            }(Yt),
                kr = function () {
                    function t() { }
                    return t.curveTo = function (t, e, i, n, r, o) {
                        var s = o[o.length - 2],
                            a = o[o.length - 1] - e,
                            l = s - t,
                            h = n - e,
                            u = i - t,
                            c = Math.abs(a * u - l * h);
                        if (c < 1e-8 || 0 === r) return o[o.length - 2] === t && o[o.length - 1] === e || o.push(t, e), null;
                        var d = a * a + l * l,
                            p = h * h + u * u,
                            f = a * h + l * u,
                            g = r * Math.sqrt(d) / c,
                            m = r * Math.sqrt(p) / c,
                            _ = g * f / d,
                            y = m * f / p,
                            S = g * u + m * l,
                            v = g * h + m * a,
                            b = l * (m + _),
                            T = a * (m + _),
                            P = u * (g + y),
                            A = h * (g + y);
                        return {
                            cx: S + t,
                            cy: v + e,
                            radius: r,
                            startAngle: Math.atan2(T - v, b - S),
                            endAngle: Math.atan2(A - v, P - S),
                            anticlockwise: l * h > u * a
                        }
                    }, t.arc = function (t, e, i, n, r, o, s, a, l) {
                        for (var h = s - o, u = Tr._segmentsCount(Math.abs(h) * r, 40 * Math.ceil(Math.abs(h) / Ut)), c = h / (2 * u), d = 2 * c, p = Math.cos(c), f = Math.sin(c), g = u - 1, m = g % 1 / g, _ = 0; _ <= g; ++_) {
                            var y = c + o + d * (_ + m * _),
                                S = Math.cos(y),
                                v = -Math.sin(y);
                            l.push((p * S + f * v) * r + i, (p * -v + f * S) * r + n)
                        }
                    }, t
                }(),
                Ur = function () {
                    function t() { }
                    return t.curveLength = function (t, e, i, n, r, o, s, a) {
                        for (var l = 0, h = 0, u = 0, c = 0, d = 0, p = 0, f = 0, g = 0, m = 0, _ = 0, y = 0, S = t, v = e, b = 1; b <= 10; ++b) _ = S - (g = (f = (p = (d = 1 - (h = b / 10)) * d) * d) * t + 3 * p * h * i + 3 * d * (u = h * h) * r + (c = u * h) * s), y = v - (m = f * e + 3 * p * h * n + 3 * d * u * o + c * a), S = g, v = m, l += Math.sqrt(_ * _ + y * y);
                        return l
                    }, t.curveTo = function (e, i, n, r, o, s, a) {
                        var l = a[a.length - 2],
                            h = a[a.length - 1];
                        a.length -= 2;
                        var u = Tr._segmentsCount(t.curveLength(l, h, e, i, n, r, o, s)),
                            c = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            g = 0;
                        a.push(l, h);
                        for (var m = 1, _ = 0; m <= u; ++m) p = (d = (c = 1 - (_ = m / u)) * c) * c, g = (f = _ * _) * _, a.push(p * l + 3 * d * _ * e + 3 * c * f * n + g * o, p * h + 3 * d * _ * i + 3 * c * f * r + g * s)
                    }, t
                }(),
                Gr = function () {
                    function t() { }
                    return t.curveLength = function (t, e, i, n, r, o) {
                        var s = t - 2 * i + r,
                            a = e - 2 * n + o,
                            l = 2 * i - 2 * t,
                            h = 2 * n - 2 * e,
                            u = 4 * (s * s + a * a),
                            c = 4 * (s * l + a * h),
                            d = l * l + h * h,
                            p = 2 * Math.sqrt(u + c + d),
                            f = Math.sqrt(u),
                            g = 2 * u * f,
                            m = 2 * Math.sqrt(d),
                            _ = c / f;
                        return (g * p + f * c * (p - m) + (4 * d * u - c * c) * Math.log((2 * f + _ + p) / (_ + m))) / (4 * g)
                    }, t.curveTo = function (e, i, n, r, o) {
                        for (var s = o[o.length - 2], a = o[o.length - 1], l = Tr._segmentsCount(t.curveLength(s, a, e, i, n, r)), h = 0, u = 0, c = 1; c <= l; ++c) {
                            var d = c / l;
                            h = s + (e - s) * d, u = a + (i - a) * d, o.push(h + (e + (n - e) * d - h) * d, u + (i + (r - i) * d - u) * d)
                        }
                    }, t
                }(),
                Wr = function () {
                    function t() {
                        this.reset()
                    }
                    return t.prototype.begin = function (t, e, i) {
                        this.reset(), this.style = t, this.start = e, this.attribStart = i
                    }, t.prototype.end = function (t, e) {
                        this.attribSize = e - this.attribStart, this.size = t - this.start
                    }, t.prototype.reset = function () {
                        this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
                    }, t
                }(),
                Vr = ((Rr = {})[kt.POLY] = wr, Rr[kt.CIRC] = Er, Rr[kt.ELIP] = Er, Rr[kt.RECT] = Cr, Rr[kt.RREC] = Lr, Rr),
                Xr = [],
                Hr = [],
                Yr = {
                    buildPoly: wr,
                    buildCircle: Er,
                    buildRectangle: Cr,
                    buildRoundedRectangle: Lr,
                    FILL_COMMANDS: Vr,
                    BATCH_POOL: Xr,
                    DRAW_CALL_POOL: Hr,
                    buildLine: Mr,
                    Star: Fr,
                    ArcUtils: kr,
                    BezierUtils: Ur,
                    QuadraticUtils: Gr,
                    BatchPart: Wr
                },
                jr = function () {
                    function t(t, e, i, n) {
                        void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null), this.shape = t, this.lineStyle = i, this.fillStyle = e, this.matrix = n, this.type = t.type, this.points = [], this.holes = []
                    }
                    return t.prototype.clone = function () {
                        return new t(this.shape, this.fillStyle, this.lineStyle, this.matrix)
                    }, t.prototype.destroy = function () {
                        this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
                    }, t
                }(),
                zr = new zt,
                Kr = new oe,
                qr = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.uvsFloat32 = null, e.indicesUint16 = null, e.points = [], e.colors = [], e.uvs = [], e.indices = [], e.textureIds = [], e.graphicsData = [], e.dirty = 0, e.batchDirty = -1, e.cacheDirty = -1, e.clearDirty = 0, e.drawCalls = [], e.batches = [], e.shapeIndex = 0, e._bounds = new oe, e.boundsDirty = -1, e.boundsPadding = 0, e.batchable = !1, e.indicesUint16 = null, e.uvsFloat32 = null, e.closePointEps = 1e-4, e
                    }
                    return Ir(e, t), Object.defineProperty(e.prototype, "bounds", {
                        get: function () {
                            return this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.invalidate = function () {
                        this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
                        for (var t = 0; t < this.drawCalls.length; t++) this.drawCalls[t].texArray.clear(), Hr.push(this.drawCalls[t]);
                        for (this.drawCalls.length = 0, t = 0; t < this.batches.length; t++) {
                            var e = this.batches[t];
                            e.reset(), Xr.push(e)
                        }
                        this.batches.length = 0
                    }, e.prototype.clear = function () {
                        return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
                    }, e.prototype.drawShape = function (t, e, i, n) {
                        void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null);
                        var r = new jr(t, e, i, n);
                        return this.graphicsData.push(r), this.dirty++, this
                    }, e.prototype.drawHole = function (t, e) {
                        if (void 0 === e && (e = null), !this.graphicsData.length) return null;
                        var i = new jr(t, null, null, e),
                            n = this.graphicsData[this.graphicsData.length - 1];
                        return i.lineStyle = n.lineStyle, n.holes.push(i), this.dirty++, this
                    }, e.prototype.destroy = function () {
                        t.prototype.destroy.call(this);
                        for (var e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
                        this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
                    }, e.prototype.containsPoint = function (t) {
                        for (var e = this.graphicsData, i = 0; i < e.length; ++i) {
                            var n = e[i];
                            if (n.fillStyle.visible && n.shape && (n.matrix ? n.matrix.applyInverse(t, zr) : zr.copyFrom(t), n.shape.contains(zr.x, zr.y))) {
                                var r = !1;
                                if (n.holes)
                                    for (var o = 0; o < n.holes.length; o++)
                                        if (n.holes[o].shape.contains(zr.x, zr.y)) {
                                            r = !0;
                                            break
                                        } if (!r) return !0
                            }
                        }
                        return !1
                    }, e.prototype.updateBatches = function (t) {
                        if (this.graphicsData.length) {
                            if (this.validateBatching()) {
                                this.cacheDirty = this.dirty;
                                var e = this.uvs,
                                    i = this.graphicsData,
                                    n = null,
                                    r = null;
                                this.batches.length > 0 && (r = (n = this.batches[this.batches.length - 1]).style);
                                for (var o = this.shapeIndex; o < i.length; o++) {
                                    this.shapeIndex++;
                                    var s = i[o],
                                        a = s.fillStyle,
                                        l = s.lineStyle;
                                    Vr[s.type].build(s), s.matrix && this.transformPoints(s.points, s.matrix);
                                    for (var h = 0; h < 2; h++) {
                                        var u = 0 === h ? a : l;
                                        if (u.visible) {
                                            var c = u.texture.baseTexture,
                                                d = this.indices.length,
                                                p = this.points.length / 2;
                                            c.wrapMode = b.REPEAT, 0 === h ? this.processFill(s) : this.processLine(s);
                                            var f = this.points.length / 2 - p;
                                            0 !== f && (n && !this._compareStyles(r, u) && (n.end(d, p), n = null), n || ((n = Xr.pop() || new Wr).begin(u, d, p), this.batches.push(n), r = u), this.addUvs(this.points, e, u.texture, p, f, u.matrix))
                                        }
                                    }
                                }
                                var g = this.indices.length,
                                    m = this.points.length / 2;
                                if (n && n.end(g, m), 0 !== this.batches.length) {
                                    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) this.indicesUint16.set(this.indices);
                                    else {
                                        var _ = m > 65535 && t;
                                        this.indicesUint16 = _ ? new Uint32Array(this.indices) : new Uint16Array(this.indices)
                                    }
                                    this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
                                } else this.batchable = !0
                            }
                        } else this.batchable = !0
                    }, e.prototype._compareStyles = function (t, e) {
                        return !(!t || !e) && t.texture.baseTexture === e.texture.baseTexture && t.color + t.alpha === e.color + e.alpha && !!t.native == !!e.native
                    }, e.prototype.validateBatching = function () {
                        if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
                        for (var t = 0, e = this.graphicsData.length; t < e; t++) {
                            var i = this.graphicsData[t],
                                n = i.fillStyle,
                                r = i.lineStyle;
                            if (n && !n.texture.baseTexture.valid) return !1;
                            if (r && !r.texture.baseTexture.valid) return !1
                        }
                        return !0
                    }, e.prototype.packBatches = function () {
                        this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
                        for (var t = this.batches, e = 0, i = t.length; e < i; e++)
                            for (var n = t[e], r = 0; r < n.size; r++) {
                                var o = n.start + r;
                                this.indicesUint16[o] = this.indicesUint16[o] - n.attribStart
                            }
                    }, e.prototype.isBatchable = function () {
                        if (this.points.length > 131070) return !1;
                        for (var t = this.batches, i = 0; i < t.length; i++)
                            if (t[i].style.native) return !1;
                        return this.points.length < 2 * e.BATCHABLE_SIZE
                    }, e.prototype.buildDrawCalls = function () {
                        for (var t = ++Re._globalBatch, e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), Hr.push(this.drawCalls[e]);
                        this.drawCalls.length = 0;
                        var i = this.colors,
                            n = this.textureIds,
                            r = Hr.pop();
                        r || ((r = new Bn).texArray = new Ln), r.texArray.count = 0, r.start = 0, r.size = 0, r.type = m.TRIANGLES;
                        var o = 0,
                            s = null,
                            a = 0,
                            l = !1,
                            h = m.TRIANGLES,
                            u = 0;
                        for (this.drawCalls.push(r), e = 0; e < this.batches.length; e++) {
                            var c = this.batches[e],
                                d = c.style,
                                p = d.texture.baseTexture;
                            l !== !!d.native && (h = (l = !!d.native) ? m.LINES : m.TRIANGLES, s = null, o = 8, t++), s !== p && (s = p, p._batchEnabled !== t && (8 === o && (t++, o = 0, r.size > 0 && ((r = Hr.pop()) || ((r = new Bn).texArray = new Ln), this.drawCalls.push(r)), r.start = u, r.size = 0, r.texArray.count = 0, r.type = h), p.touched = 1, p._batchEnabled = t, p._batchLocation = o, p.wrapMode = 10497, r.texArray.elements[r.texArray.count++] = p, o++)), r.size += c.size, u += c.size, a = p._batchLocation, this.addColors(i, d.color, d.alpha, c.attribSize, c.attribStart), this.addTextureIds(n, a, c.attribSize, c.attribStart)
                        }
                        Re._globalBatch = t, this.packAttributes()
                    }, e.prototype.packAttributes = function () {
                        for (var t = this.points, e = this.uvs, i = this.colors, n = this.textureIds, r = new ArrayBuffer(3 * t.length * 4), o = new Float32Array(r), s = new Uint32Array(r), a = 0, l = 0; l < t.length / 2; l++) o[a++] = t[2 * l], o[a++] = t[2 * l + 1], o[a++] = e[2 * l], o[a++] = e[2 * l + 1], s[a++] = i[l], o[a++] = n[l];
                        this._buffer.update(r), this._indexBuffer.update(this.indicesUint16)
                    }, e.prototype.processFill = function (t) {
                        t.holes.length ? (this.processHoles(t.holes), wr.triangulate(t, this)) : Vr[t.type].triangulate(t, this)
                    }, e.prototype.processLine = function (t) {
                        Mr(t, this);
                        for (var e = 0; e < t.holes.length; e++) Mr(t.holes[e], this)
                    }, e.prototype.processHoles = function (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            Vr[i.type].build(i), i.matrix && this.transformPoints(i.points, i.matrix)
                        }
                    }, e.prototype.calculateBounds = function () {
                        var t = this._bounds,
                            e = Kr,
                            i = qt.IDENTITY;
                        this._bounds.clear(), e.clear();
                        for (var n = 0; n < this.graphicsData.length; n++) {
                            var r = this.graphicsData[n],
                                o = r.shape,
                                s = r.type,
                                a = r.lineStyle,
                                l = r.matrix || qt.IDENTITY,
                                h = 0;
                            if (a && a.visible) {
                                var u = a.alignment;
                                h = a.width, s === kt.POLY ? h *= .5 + Math.abs(.5 - u) : h *= Math.max(0, u)
                            }
                            if (i !== l && (e.isEmpty() || (t.addBoundsMatrix(e, i), e.clear()), i = l), s === kt.RECT || s === kt.RREC) {
                                var c = o;
                                e.addFramePad(c.x, c.y, c.x + c.width, c.y + c.height, h, h)
                            } else if (s === kt.CIRC) {
                                var d = o;
                                e.addFramePad(d.x, d.y, d.x, d.y, d.radius + h, d.radius + h)
                            } else if (s === kt.ELIP) {
                                var p = o;
                                e.addFramePad(p.x, p.y, p.x, p.y, p.width + h, p.height + h)
                            } else {
                                var f = o;
                                t.addVerticesMatrix(i, f.points, 0, f.points.length, h, h)
                            }
                        }
                        e.isEmpty() || t.addBoundsMatrix(e, i), t.pad(this.boundsPadding, this.boundsPadding)
                    }, e.prototype.transformPoints = function (t, e) {
                        for (var i = 0; i < t.length / 2; i++) {
                            var n = t[2 * i],
                                r = t[2 * i + 1];
                            t[2 * i] = e.a * n + e.c * r + e.tx, t[2 * i + 1] = e.b * n + e.d * r + e.ty
                        }
                    }, e.prototype.addColors = function (t, e, i, n, r) {
                        void 0 === r && (r = 0);
                        var o = ct((e >> 16) + (65280 & e) + ((255 & e) << 16), i);
                        t.length = Math.max(t.length, r + n);
                        for (var s = 0; s < n; s++) t[r + s] = o
                    }, e.prototype.addTextureIds = function (t, e, i, n) {
                        void 0 === n && (n = 0), t.length = Math.max(t.length, n + i);
                        for (var r = 0; r < i; r++) t[n + r] = e
                    }, e.prototype.addUvs = function (t, e, i, n, r, o) {
                        void 0 === o && (o = null);
                        for (var s = 0, a = e.length, l = i.frame; s < r;) {
                            var h = t[2 * (n + s)],
                                u = t[2 * (n + s) + 1];
                            if (o) {
                                var c = o.a * h + o.c * u + o.tx;
                                u = o.b * h + o.d * u + o.ty, h = c
                            }
                            s++, e.push(h / l.width, u / l.height)
                        }
                        var d = i.baseTexture;
                        (l.width < d.width || l.height < d.height) && this.adjustUvs(e, i, a, r)
                    }, e.prototype.adjustUvs = function (t, e, i, n) {
                        for (var r = e.baseTexture, o = 1e-6, s = i + 2 * n, a = e.frame, l = a.width / r.width, h = a.height / r.height, u = a.x / a.width, c = a.y / a.height, d = Math.floor(t[i] + o), p = Math.floor(t[i + 1] + o), f = i + 2; f < s; f += 2) d = Math.min(d, Math.floor(t[f] + o)), p = Math.min(p, Math.floor(t[f + 1] + o));
                        for (u -= d, c -= p, f = i; f < s; f += 2) t[f] = (t[f] + u) * l, t[f + 1] = (t[f + 1] + c) * h
                    }, e.BATCHABLE_SIZE = 100, e
                }(Rn),
                Zr = function (t) {
                    function e() {
                        var e = null !== t && t.apply(this, arguments) || this;
                        return e.width = 0, e.alignment = .5, e.native = !1, e.cap = yr.BUTT, e.join = _r.MITER, e.miterLimit = 10, e
                    }
                    return Ir(e, t), e.prototype.clone = function () {
                        var t = new e;
                        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
                    }, e.prototype.reset = function () {
                        t.prototype.reset.call(this), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
                    }, e
                }(Pr),
                $r = new Float32Array(3),
                Jr = {},
                Qr = function (t) {
                    function e(e) {
                        void 0 === e && (e = null);
                        var i = t.call(this) || this;
                        return i._geometry = e || new qr, i._geometry.refCount++, i.shader = null, i.state = Qi.for2d(), i._fillStyle = new Pr, i._lineStyle = new Zr, i._matrix = null, i._holeMode = !1, i.currentPath = null, i.batches = [], i.batchTint = -1, i.batchDirty = -1, i.vertexData = null, i.pluginName = "batch", i._transformID = -1, i.tint = 16777215, i.blendMode = g.NORMAL, i
                    }
                    return Ir(e, t), Object.defineProperty(e.prototype, "geometry", {
                        get: function () {
                            return this._geometry
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.clone = function () {
                        return this.finishPoly(), new e(this._geometry)
                    }, Object.defineProperty(e.prototype, "blendMode", {
                        get: function () {
                            return this.state.blendMode
                        },
                        set: function (t) {
                            this.state.blendMode = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tint", {
                        get: function () {
                            return this._tint
                        },
                        set: function (t) {
                            this._tint = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "fill", {
                        get: function () {
                            return this._fillStyle
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "line", {
                        get: function () {
                            return this._lineStyle
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.lineStyle = function (t) {
                        if (void 0 === t && (t = null), "number" == typeof t) {
                            var e = arguments;
                            t = {
                                width: e[0] || 0,
                                color: e[1] || 0,
                                alpha: void 0 !== e[2] ? e[2] : 1,
                                alignment: void 0 !== e[3] ? e[3] : .5,
                                native: !!e[4]
                            }
                        }
                        return this.lineTextureStyle(t)
                    }, e.prototype.lineTextureStyle = function (t) {
                        if ("number" == typeof t) {
                            It("v5.2.0", "Please use object-based options for Graphics#lineTextureStyle");
                            var e = arguments;
                            t = {
                                width: e[0],
                                texture: e[1],
                                color: e[2],
                                alpha: e[3],
                                matrix: e[4],
                                alignment: e[5],
                                native: e[6]
                            }, Object.keys(t).forEach((function (e) {
                                return void 0 === t[e] && delete t[e]
                            }))
                        }
                        t = Object.assign({
                            width: 0,
                            texture: Je.WHITE,
                            color: t && t.texture ? 16777215 : 0,
                            alpha: 1,
                            matrix: null,
                            alignment: .5,
                            native: !1,
                            cap: yr.BUTT,
                            join: _r.MITER,
                            miterLimit: 10
                        }, t), this.currentPath && this.startPoly();
                        var i = t.width > 0 && t.alpha > 0;
                        return i ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, {
                            visible: i
                        }, t)) : this._lineStyle.reset(), this
                    }, e.prototype.startPoly = function () {
                        if (this.currentPath) {
                            var t = this.currentPath.points,
                                e = this.currentPath.points.length;
                            e > 2 && (this.drawShape(this.currentPath), this.currentPath = new Yt, this.currentPath.closeStroke = !1, this.currentPath.points.push(t[e - 2], t[e - 1]))
                        } else this.currentPath = new Yt, this.currentPath.closeStroke = !1
                    }, e.prototype.finishPoly = function () {
                        this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
                    }, e.prototype.moveTo = function (t, e) {
                        return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = e, this
                    }, e.prototype.lineTo = function (t, e) {
                        this.currentPath || this.moveTo(0, 0);
                        var i = this.currentPath.points,
                            n = i[i.length - 2],
                            r = i[i.length - 1];
                        return n === t && r === e || i.push(t, e), this
                    }, e.prototype._initCurve = function (t, e) {
                        void 0 === t && (t = 0), void 0 === e && (e = 0), this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [t, e]) : this.moveTo(t, e)
                    }, e.prototype.quadraticCurveTo = function (t, e, i, n) {
                        this._initCurve();
                        var r = this.currentPath.points;
                        return 0 === r.length && this.moveTo(0, 0), Gr.curveTo(t, e, i, n, r), this
                    }, e.prototype.bezierCurveTo = function (t, e, i, n, r, o) {
                        return this._initCurve(), Ur.curveTo(t, e, i, n, r, o, this.currentPath.points), this
                    }, e.prototype.arcTo = function (t, e, i, n, r) {
                        this._initCurve(t, e);
                        var o = this.currentPath.points,
                            s = kr.curveTo(t, e, i, n, r, o);
                        if (s) {
                            var a = s.cx,
                                l = s.cy,
                                h = s.radius,
                                u = s.startAngle,
                                c = s.endAngle,
                                d = s.anticlockwise;
                            this.arc(a, l, h, u, c, d)
                        }
                        return this
                    }, e.prototype.arc = function (t, e, i, n, r, o) {
                        if (void 0 === o && (o = !1), n === r) return this;
                        if (!o && r <= n ? r += Ut : o && n <= r && (n += Ut), 0 == r - n) return this;
                        var s = t + Math.cos(n) * i,
                            a = e + Math.sin(n) * i,
                            l = this._geometry.closePointEps,
                            h = this.currentPath ? this.currentPath.points : null;
                        if (h) {
                            var u = Math.abs(h[h.length - 2] - s),
                                c = Math.abs(h[h.length - 1] - a);
                            u < l && c < l || h.push(s, a)
                        } else this.moveTo(s, a), h = this.currentPath.points;
                        return kr.arc(s, a, t, e, i, n, r, o, h), this
                    }, e.prototype.beginFill = function (t, e) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 1), this.beginTextureFill({
                            texture: Je.WHITE,
                            color: t,
                            alpha: e
                        })
                    }, e.prototype.beginTextureFill = function (t) {
                        if (t instanceof Je) {
                            It("v5.2.0", "Please use object-based options for Graphics#beginTextureFill");
                            var e = arguments;
                            t = {
                                texture: e[0],
                                color: e[1],
                                alpha: e[2],
                                matrix: e[3]
                            }, Object.keys(t).forEach((function (e) {
                                return void 0 === t[e] && delete t[e]
                            }))
                        }
                        t = Object.assign({
                            texture: Je.WHITE,
                            color: 16777215,
                            alpha: 1,
                            matrix: null
                        }, t), this.currentPath && this.startPoly();
                        var i = t.alpha > 0;
                        return i ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, {
                            visible: i
                        }, t)) : this._fillStyle.reset(), this
                    }, e.prototype.endFill = function () {
                        return this.finishPoly(), this._fillStyle.reset(), this
                    }, e.prototype.drawRect = function (t, e, i, n) {
                        return this.drawShape(new Vt(t, e, i, n))
                    }, e.prototype.drawRoundedRect = function (t, e, i, n, r) {
                        return this.drawShape(new jt(t, e, i, n, r))
                    }, e.prototype.drawCircle = function (t, e, i) {
                        return this.drawShape(new Xt(t, e, i))
                    }, e.prototype.drawEllipse = function (t, e, i, n) {
                        return this.drawShape(new Ht(t, e, i, n))
                    }, e.prototype.drawPolygon = function () {
                        for (var t, e = arguments, i = [], n = 0; n < arguments.length; n++) i[n] = e[n];
                        var r = !0,
                            o = i[0];
                        o.points ? (r = o.closeStroke, t = o.points) : t = Array.isArray(i[0]) ? i[0] : i;
                        var s = new Yt(t);
                        return s.closeStroke = r, this.drawShape(s), this
                    }, e.prototype.drawShape = function (t) {
                        return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
                    }, e.prototype.drawStar = function (t, e, i, n, r, o) {
                        return void 0 === o && (o = 0), this.drawPolygon(new Fr(t, e, i, n, r, o))
                    }, e.prototype.clear = function () {
                        return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
                    }, e.prototype.isFastRect = function () {
                        var t = this._geometry.graphicsData;
                        return 1 === t.length && t[0].shape.type === kt.RECT && !(t[0].lineStyle.visible && t[0].lineStyle.width)
                    }, e.prototype._render = function (t) {
                        this.finishPoly();
                        var e = this._geometry,
                            i = t.context.supports.uint32Indices;
                        e.updateBatches(i), e.batchable ? (this.batchDirty !== e.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t))
                    }, e.prototype._populateBatches = function () {
                        var t = this._geometry,
                            e = this.blendMode,
                            i = t.batches.length;
                        this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = i, this.vertexData = new Float32Array(t.points);
                        for (var n = 0; n < i; n++) {
                            var r = t.batches[n],
                                o = r.style.color,
                                s = new Float32Array(this.vertexData.buffer, 4 * r.attribStart * 2, 2 * r.attribSize),
                                a = new Float32Array(t.uvsFloat32.buffer, 4 * r.attribStart * 2, 2 * r.attribSize),
                                l = {
                                    vertexData: s,
                                    blendMode: e,
                                    indices: new Uint16Array(t.indicesUint16.buffer, 2 * r.start, r.size),
                                    uvs: a,
                                    _batchRGB: rt(o),
                                    _tintRGB: o,
                                    _texture: r.style.texture,
                                    alpha: r.style.alpha,
                                    worldAlpha: 1
                                };
                            this.batches[n] = l
                        }
                    }, e.prototype._renderBatched = function (t) {
                        if (this.batches.length) {
                            t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
                            for (var e = 0, i = this.batches.length; e < i; e++) {
                                var n = this.batches[e];
                                n.worldAlpha = this.worldAlpha * n.alpha, t.plugins[this.pluginName].render(n)
                            }
                        }
                    }, e.prototype._renderDirect = function (t) {
                        var e = this._resolveDirectShader(t),
                            i = this._geometry,
                            n = this.tint,
                            r = this.worldAlpha,
                            o = e.uniforms,
                            s = i.drawCalls;
                        o.translationMatrix = this.transform.worldTransform, o.tint[0] = (n >> 16 & 255) / 255 * r, o.tint[1] = (n >> 8 & 255) / 255 * r, o.tint[2] = (255 & n) / 255 * r, o.tint[3] = r, t.shader.bind(e), t.geometry.bind(i, e), t.state.set(this.state);
                        for (var a = 0, l = s.length; a < l; a++) this._renderDrawCallDirect(t, i.drawCalls[a])
                    }, e.prototype._renderDrawCallDirect = function (t, e) {
                        for (var i = e.texArray, n = e.type, r = e.size, o = e.start, s = i.count, a = 0; a < s; a++) t.texture.bind(i.elements[a], a);
                        t.geometry.draw(n, r, o)
                    }, e.prototype._resolveDirectShader = function (t) {
                        var e = this.shader,
                            i = this.pluginName;
                        if (!e) {
                            if (!Jr[i]) {
                                for (var n = t.plugins.batch.MAX_TEXTURES, r = new Int32Array(n), o = 0; o < n; o++) r[o] = o;
                                var s = {
                                    tint: new Float32Array([1, 1, 1, 1]),
                                    translationMatrix: new qt,
                                    default: fi.from({
                                        uSamplers: r
                                    }, !0)
                                },
                                    a = t.plugins[i]._shader.program;
                                Jr[i] = new Ji(a, s)
                            }
                            e = Jr[i]
                        }
                        return e
                    }, e.prototype._calculateBounds = function () {
                        this.finishPoly();
                        var t = this._geometry;
                        if (t.graphicsData.length) {
                            var e = t.bounds,
                                i = e.minX,
                                n = e.minY,
                                r = e.maxX,
                                o = e.maxY;
                            this._bounds.addFrame(this.transform, i, n, r, o)
                        }
                    }, e.prototype.containsPoint = function (t) {
                        return this.worldTransform.applyInverse(t, e._TEMP_POINT), this._geometry.containsPoint(e._TEMP_POINT)
                    }, e.prototype.calculateTints = function () {
                        if (this.batchTint !== this.tint) {
                            this.batchTint = this.tint;
                            for (var t = rt(this.tint, $r), e = 0; e < this.batches.length; e++) {
                                var i = this.batches[e],
                                    n = i._batchRGB,
                                    r = (t[0] * n[0] * 255 << 16) + (t[1] * n[1] * 255 << 8) + (0 | t[2] * n[2] * 255);
                                i._tintRGB = (r >> 16) + (65280 & r) + ((255 & r) << 16)
                            }
                        }
                    }, e.prototype.calculateVertices = function () {
                        var t = this.transform._worldID;
                        if (this._transformID !== t) {
                            this._transformID = t;
                            for (var e = this.transform.worldTransform, i = e.a, n = e.b, r = e.c, o = e.d, s = e.tx, a = e.ty, l = this._geometry.points, h = this.vertexData, u = 0, c = 0; c < l.length; c += 2) {
                                var d = l[c],
                                    p = l[c + 1];
                                h[u++] = i * d + r * p + s, h[u++] = o * p + n * d + a
                            }
                        }
                    }, e.prototype.closePath = function () {
                        var t = this.currentPath;
                        return t && (t.closeStroke = !0), this
                    }, e.prototype.setMatrix = function (t) {
                        return this._matrix = t, this
                    }, e.prototype.beginHole = function () {
                        return this.finishPoly(), this._holeMode = !0, this
                    }, e.prototype.endHole = function () {
                        return this.finishPoly(), this._holeMode = !1, this
                    }, e.prototype.destroy = function (e) {
                        this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, t.prototype.destroy.call(this, e)
                    }, e._TEMP_POINT = new zt, e
                }(ce),
                to = function (t, e) {
                    return to = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, to(t, e)
                },
                eo = new zt,
                io = new Uint16Array([0, 1, 2, 0, 2, 3]),
                no = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i._anchor = new Kt(i._onAnchorUpdate, i, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), i._texture = null, i._width = 0, i._height = 0, i._tint = null, i._tintRGB = null, i.tint = 16777215, i.blendMode = g.NORMAL, i._cachedTint = 16777215, i.uvs = null, i.texture = e || Je.EMPTY, i.vertexData = new Float32Array(8), i.vertexTrimmedData = null, i._transformID = -1, i._textureID = -1, i._transformTrimmedID = -1, i._textureTrimmedID = -1, i.indices = io, i.pluginName = "batch", i.isSprite = !0, i._roundPixels = j.ROUND_PIXELS, i
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        to(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype._onTextureUpdate = function () {
                        this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = bt(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = bt(this.scale.y) * this._height / this._texture.orig.height)
                    }, e.prototype._onAnchorUpdate = function () {
                        this._transformID = -1, this._transformTrimmedID = -1
                    }, e.prototype.calculateVertices = function () {
                        var t = this._texture;
                        if (this._transformID !== this.transform._worldID || this._textureID !== t._updateID) {
                            this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
                            var e = this.transform.worldTransform,
                                i = e.a,
                                n = e.b,
                                r = e.c,
                                o = e.d,
                                s = e.tx,
                                a = e.ty,
                                l = this.vertexData,
                                h = t.trim,
                                u = t.orig,
                                c = this._anchor,
                                d = 0,
                                p = 0,
                                f = 0,
                                g = 0;
                            if (h ? (d = (p = h.x - c._x * u.width) + h.width, f = (g = h.y - c._y * u.height) + h.height) : (d = (p = -c._x * u.width) + u.width, f = (g = -c._y * u.height) + u.height), l[0] = i * p + r * g + s, l[1] = o * g + n * p + a, l[2] = i * d + r * g + s, l[3] = o * g + n * d + a, l[4] = i * d + r * f + s, l[5] = o * f + n * d + a, l[6] = i * p + r * f + s, l[7] = o * f + n * p + a, this._roundPixels)
                                for (var m = j.RESOLUTION, _ = 0; _ < l.length; ++_) l[_] = Math.round((l[_] * m | 0) / m)
                        }
                    }, e.prototype.calculateTrimmedVertices = function () {
                        if (this.vertexTrimmedData) {
                            if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
                        } else this.vertexTrimmedData = new Float32Array(8);
                        this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
                        var t = this._texture,
                            e = this.vertexTrimmedData,
                            i = t.orig,
                            n = this._anchor,
                            r = this.transform.worldTransform,
                            o = r.a,
                            s = r.b,
                            a = r.c,
                            l = r.d,
                            h = r.tx,
                            u = r.ty,
                            c = -n._x * i.width,
                            d = c + i.width,
                            p = -n._y * i.height,
                            f = p + i.height;
                        e[0] = o * c + a * p + h, e[1] = l * p + s * c + u, e[2] = o * d + a * p + h, e[3] = l * p + s * d + u, e[4] = o * d + a * f + h, e[5] = l * f + s * d + u, e[6] = o * c + a * f + h, e[7] = l * f + s * c + u
                    }, e.prototype._render = function (t) {
                        this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
                    }, e.prototype._calculateBounds = function () {
                        var t = this._texture.trim,
                            e = this._texture.orig;
                        !t || t.width === e.width && t.height === e.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
                    }, e.prototype.getLocalBounds = function (e) {
                        return 0 === this.children.length ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Vt), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
                    }, e.prototype.containsPoint = function (t) {
                        this.worldTransform.applyInverse(t, eo);
                        var e = this._texture.orig.width,
                            i = this._texture.orig.height,
                            n = -e * this.anchor.x,
                            r = 0;
                        return eo.x >= n && eo.x < n + e && (r = -i * this.anchor.y, eo.y >= r && eo.y < r + i)
                    }, e.prototype.destroy = function (e) {
                        if (t.prototype.destroy.call(this, e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof e ? e : e && e.texture) {
                            var i = "boolean" == typeof e ? e : e && e.baseTexture;
                            this._texture.destroy(!!i)
                        }
                        this._texture = null
                    }, e.from = function (t, i) {
                        return new e(t instanceof Je ? t : Je.from(t, i))
                    }, Object.defineProperty(e.prototype, "roundPixels", {
                        get: function () {
                            return this._roundPixels
                        },
                        set: function (t) {
                            this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return Math.abs(this.scale.x) * this._texture.orig.width
                        },
                        set: function (t) {
                            var e = bt(this.scale.x) || 1;
                            this.scale.x = e * t / this._texture.orig.width, this._width = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "height", {
                        get: function () {
                            return Math.abs(this.scale.y) * this._texture.orig.height
                        },
                        set: function (t) {
                            var e = bt(this.scale.y) || 1;
                            this.scale.y = e * t / this._texture.orig.height, this._height = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "anchor", {
                        get: function () {
                            return this._anchor
                        },
                        set: function (t) {
                            this._anchor.copyFrom(t)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tint", {
                        get: function () {
                            return this._tint
                        },
                        set: function (t) {
                            this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "texture", {
                        get: function () {
                            return this._texture
                        },
                        set: function (t) {
                            this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || Je.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(ce),
                ro = function (t, e) {
                    return ro = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, ro(t, e)
                };
            ! function (t) {
                t[t.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", t[t.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL"
            }(Dr || (Dr = {}));
            var oo = {
                align: "left",
                breakWords: !1,
                dropShadow: !1,
                dropShadowAlpha: 1,
                dropShadowAngle: Math.PI / 6,
                dropShadowBlur: 0,
                dropShadowColor: "black",
                dropShadowDistance: 5,
                fill: "black",
                fillGradientType: Dr.LINEAR_VERTICAL,
                fillGradientStops: [],
                fontFamily: "Arial",
                fontSize: 26,
                fontStyle: "normal",
                fontVariant: "normal",
                fontWeight: "normal",
                letterSpacing: 0,
                lineHeight: 0,
                lineJoin: "miter",
                miterLimit: 10,
                padding: 0,
                stroke: "black",
                strokeThickness: 0,
                textBaseline: "alphabetic",
                trim: !1,
                whiteSpace: "pre",
                wordWrap: !1,
                wordWrapWidth: 100,
                leading: 0
            },
                so = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
                ao = function () {
                    function t(t) {
                        this.styleID = 0, this.reset(), uo(this, t, t)
                    }
                    return t.prototype.clone = function () {
                        var e = {};
                        return uo(e, this, oo), new t(e)
                    }, t.prototype.reset = function () {
                        uo(this, oo, oo)
                    }, Object.defineProperty(t.prototype, "align", {
                        get: function () {
                            return this._align
                        },
                        set: function (t) {
                            this._align !== t && (this._align = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "breakWords", {
                        get: function () {
                            return this._breakWords
                        },
                        set: function (t) {
                            this._breakWords !== t && (this._breakWords = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "dropShadow", {
                        get: function () {
                            return this._dropShadow
                        },
                        set: function (t) {
                            this._dropShadow !== t && (this._dropShadow = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "dropShadowAlpha", {
                        get: function () {
                            return this._dropShadowAlpha
                        },
                        set: function (t) {
                            this._dropShadowAlpha !== t && (this._dropShadowAlpha = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "dropShadowAngle", {
                        get: function () {
                            return this._dropShadowAngle
                        },
                        set: function (t) {
                            this._dropShadowAngle !== t && (this._dropShadowAngle = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "dropShadowBlur", {
                        get: function () {
                            return this._dropShadowBlur
                        },
                        set: function (t) {
                            this._dropShadowBlur !== t && (this._dropShadowBlur = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "dropShadowColor", {
                        get: function () {
                            return this._dropShadowColor
                        },
                        set: function (t) {
                            var e = ho(t);
                            this._dropShadowColor !== e && (this._dropShadowColor = e, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "dropShadowDistance", {
                        get: function () {
                            return this._dropShadowDistance
                        },
                        set: function (t) {
                            this._dropShadowDistance !== t && (this._dropShadowDistance = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fill", {
                        get: function () {
                            return this._fill
                        },
                        set: function (t) {
                            var e = ho(t);
                            this._fill !== e && (this._fill = e, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fillGradientType", {
                        get: function () {
                            return this._fillGradientType
                        },
                        set: function (t) {
                            this._fillGradientType !== t && (this._fillGradientType = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fillGradientStops", {
                        get: function () {
                            return this._fillGradientStops
                        },
                        set: function (t) {
                            (function (t, e) {
                                if (!Array.isArray(t) || !Array.isArray(e)) return !1;
                                if (t.length !== e.length) return !1;
                                for (var i = 0; i < t.length; ++i)
                                    if (t[i] !== e[i]) return !1;
                                return !0
                            })(this._fillGradientStops, t) || (this._fillGradientStops = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fontFamily", {
                        get: function () {
                            return this._fontFamily
                        },
                        set: function (t) {
                            this.fontFamily !== t && (this._fontFamily = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fontSize", {
                        get: function () {
                            return this._fontSize
                        },
                        set: function (t) {
                            this._fontSize !== t && (this._fontSize = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fontStyle", {
                        get: function () {
                            return this._fontStyle
                        },
                        set: function (t) {
                            this._fontStyle !== t && (this._fontStyle = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fontVariant", {
                        get: function () {
                            return this._fontVariant
                        },
                        set: function (t) {
                            this._fontVariant !== t && (this._fontVariant = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "fontWeight", {
                        get: function () {
                            return this._fontWeight
                        },
                        set: function (t) {
                            this._fontWeight !== t && (this._fontWeight = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "letterSpacing", {
                        get: function () {
                            return this._letterSpacing
                        },
                        set: function (t) {
                            this._letterSpacing !== t && (this._letterSpacing = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "lineHeight", {
                        get: function () {
                            return this._lineHeight
                        },
                        set: function (t) {
                            this._lineHeight !== t && (this._lineHeight = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "leading", {
                        get: function () {
                            return this._leading
                        },
                        set: function (t) {
                            this._leading !== t && (this._leading = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "lineJoin", {
                        get: function () {
                            return this._lineJoin
                        },
                        set: function (t) {
                            this._lineJoin !== t && (this._lineJoin = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "miterLimit", {
                        get: function () {
                            return this._miterLimit
                        },
                        set: function (t) {
                            this._miterLimit !== t && (this._miterLimit = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "padding", {
                        get: function () {
                            return this._padding
                        },
                        set: function (t) {
                            this._padding !== t && (this._padding = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "stroke", {
                        get: function () {
                            return this._stroke
                        },
                        set: function (t) {
                            var e = ho(t);
                            this._stroke !== e && (this._stroke = e, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "strokeThickness", {
                        get: function () {
                            return this._strokeThickness
                        },
                        set: function (t) {
                            this._strokeThickness !== t && (this._strokeThickness = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "textBaseline", {
                        get: function () {
                            return this._textBaseline
                        },
                        set: function (t) {
                            this._textBaseline !== t && (this._textBaseline = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "trim", {
                        get: function () {
                            return this._trim
                        },
                        set: function (t) {
                            this._trim !== t && (this._trim = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "whiteSpace", {
                        get: function () {
                            return this._whiteSpace
                        },
                        set: function (t) {
                            this._whiteSpace !== t && (this._whiteSpace = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "wordWrap", {
                        get: function () {
                            return this._wordWrap
                        },
                        set: function (t) {
                            this._wordWrap !== t && (this._wordWrap = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "wordWrapWidth", {
                        get: function () {
                            return this._wordWrapWidth
                        },
                        set: function (t) {
                            this._wordWrapWidth !== t && (this._wordWrapWidth = t, this.styleID++)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.toFontString = function () {
                        var t = "number" == typeof this.fontSize ? this.fontSize + "px" : this.fontSize,
                            e = this.fontFamily;
                        Array.isArray(this.fontFamily) || (e = this.fontFamily.split(","));
                        for (var i = e.length - 1; i >= 0; i--) {
                            var n = e[i].trim();
                            !/([\"\'])[^\'\"]+\1/.test(n) && so.indexOf(n) < 0 && (n = '"' + n + '"'), e[i] = n
                        }
                        return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + t + " " + e.join(",")
                    }, t
                }();

            function lo(t) {
                return "number" == typeof t ? ot(t) : ("string" == typeof t && 0 === t.indexOf("0x") && (t = t.replace("0x", "#")), t)
            }

            function ho(t) {
                if (Array.isArray(t)) {
                    for (var e = 0; e < t.length; ++e) t[e] = lo(t[e]);
                    return t
                }
                return lo(t)
            }

            function uo(t, e, i) {
                for (var n in i) Array.isArray(e[n]) ? t[n] = e[n].slice() : t[n] = e[n]
            }
            var co = function () {
                function t(t, e, i, n, r, o, s, a, l) {
                    this.text = t, this.style = e, this.width = i, this.height = n, this.lines = r, this.lineWidths = o, this.lineHeight = s, this.maxLineWidth = a, this.fontProperties = l
                }
                return t.measureText = function (e, i, n, r) {
                    void 0 === r && (r = t._canvas), n = null == n ? i.wordWrap : n;
                    var o = i.toFontString(),
                        s = t.measureFont(o);
                    0 === s.fontSize && (s.fontSize = i.fontSize, s.ascent = i.fontSize);
                    var a = r.getContext("2d");
                    a.font = o;
                    for (var l = (n ? t.wordWrap(e, i, r) : e).split(/(?:\r\n|\r|\n)/), h = new Array(l.length), u = 0, c = 0; c < l.length; c++) {
                        var d = a.measureText(l[c]).width + (l[c].length - 1) * i.letterSpacing;
                        h[c] = d, u = Math.max(u, d)
                    }
                    var p = u + i.strokeThickness;
                    i.dropShadow && (p += i.dropShadowDistance);
                    var f = i.lineHeight || s.fontSize + i.strokeThickness,
                        g = Math.max(f, s.fontSize + i.strokeThickness) + (l.length - 1) * (f + i.leading);
                    return i.dropShadow && (g += i.dropShadowDistance), new t(e, i, p, g, l, h, f + i.leading, u, s)
                }, t.wordWrap = function (e, i, n) {
                    void 0 === n && (n = t._canvas);
                    for (var r = n.getContext("2d"), o = 0, s = "", a = "", l = Object.create(null), h = i.letterSpacing, u = i.whiteSpace, c = t.collapseSpaces(u), d = t.collapseNewlines(u), p = !c, f = i.wordWrapWidth + h, g = t.tokenize(e), m = 0; m < g.length; m++) {
                        var _ = g[m];
                        if (t.isNewline(_)) {
                            if (!d) {
                                a += t.addLine(s), p = !c, s = "", o = 0;
                                continue
                            }
                            _ = " "
                        }
                        if (c) {
                            var y = t.isBreakingSpace(_),
                                S = t.isBreakingSpace(s[s.length - 1]);
                            if (y && S) continue
                        }
                        var v = t.getFromCache(_, h, l, r);
                        if (v > f)
                            if ("" !== s && (a += t.addLine(s), s = "", o = 0), t.canBreakWords(_, i.breakWords))
                                for (var b = t.wordWrapSplit(_), T = 0; T < b.length; T++) {
                                    for (var P = b[T], A = 1; b[T + A];) {
                                        var I = b[T + A],
                                            w = P[P.length - 1];
                                        if (t.canBreakChars(w, I, _, T, i.breakWords)) break;
                                        P += I, A++
                                    }
                                    T += P.length - 1;
                                    var E = t.getFromCache(P, h, l, r);
                                    E + o > f && (a += t.addLine(s), p = !1, s = "", o = 0), s += P, o += E
                                } else {
                                s.length > 0 && (a += t.addLine(s), s = "", o = 0);
                                var C = m === g.length - 1;
                                a += t.addLine(_, !C), p = !1, s = "", o = 0
                            } else v + o > f && (p = !1, a += t.addLine(s), s = "", o = 0), (s.length > 0 || !t.isBreakingSpace(_) || p) && (s += _, o += v)
                    }
                    return a + t.addLine(s, !1)
                }, t.addLine = function (e, i) {
                    return void 0 === i && (i = !0), e = t.trimRight(e), i ? e + "\n" : e
                }, t.getFromCache = function (t, e, i, n) {
                    var r = i[t];
                    if ("number" != typeof r) {
                        var o = t.length * e;
                        r = n.measureText(t).width + o, i[t] = r
                    }
                    return r
                }, t.collapseSpaces = function (t) {
                    return "normal" === t || "pre-line" === t
                }, t.collapseNewlines = function (t) {
                    return "normal" === t
                }, t.trimRight = function (e) {
                    if ("string" != typeof e) return "";
                    for (var i = e.length - 1; i >= 0; i--) {
                        var n = e[i];
                        if (!t.isBreakingSpace(n)) break;
                        e = e.slice(0, -1)
                    }
                    return e
                }, t.isNewline = function (e) {
                    return "string" == typeof e && t._newlines.indexOf(e.charCodeAt(0)) >= 0
                }, t.isBreakingSpace = function (e) {
                    return "string" == typeof e && t._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0
                }, t.tokenize = function (e) {
                    var i = [],
                        n = "";
                    if ("string" != typeof e) return i;
                    for (var r = 0; r < e.length; r++) {
                        var o = e[r];
                        t.isBreakingSpace(o) || t.isNewline(o) ? ("" !== n && (i.push(n), n = ""), i.push(o)) : n += o
                    }
                    return "" !== n && i.push(n), i
                }, t.canBreakWords = function (t, e) {
                    return e
                }, t.canBreakChars = function (t, e, i, n, r) {
                    return !0
                }, t.wordWrapSplit = function (t) {
                    return t.split("")
                }, t.measureFont = function (e) {
                    if (t._fonts[e]) return t._fonts[e];
                    var i = {
                        ascent: 0,
                        descent: 0,
                        fontSize: 0
                    },
                        n = t._canvas,
                        r = t._context;
                    r.font = e;
                    var o = t.METRICS_STRING + t.BASELINE_SYMBOL,
                        s = Math.ceil(r.measureText(o).width),
                        a = Math.ceil(r.measureText(t.BASELINE_SYMBOL).width),
                        l = 2 * a;
                    a = a * t.BASELINE_MULTIPLIER | 0, n.width = s, n.height = l, r.fillStyle = "#f00", r.fillRect(0, 0, s, l), r.font = e, r.textBaseline = "alphabetic", r.fillStyle = "#000", r.fillText(o, 0, a);
                    var h = r.getImageData(0, 0, s, l).data,
                        u = h.length,
                        c = 4 * s,
                        d = 0,
                        p = 0,
                        f = !1;
                    for (d = 0; d < a; ++d) {
                        for (var g = 0; g < c; g += 4)
                            if (255 !== h[p + g]) {
                                f = !0;
                                break
                            } if (f) break;
                        p += c
                    }
                    for (i.ascent = a - d, p = u - c, f = !1, d = l; d > a; --d) {
                        for (g = 0; g < c; g += 4)
                            if (255 !== h[p + g]) {
                                f = !0;
                                break
                            } if (f) break;
                        p -= c
                    }
                    return i.descent = d - a, i.fontSize = i.ascent + i.descent, t._fonts[e] = i, i
                }, t.clearMetrics = function (e) {
                    void 0 === e && (e = ""), e ? delete t._fonts[e] : t._fonts = {}
                }, t
            }(),
                po = function () {
                    try {
                        var t = new OffscreenCanvas(0, 0),
                            e = t.getContext("2d");
                        return e && e.measureText ? t : document.createElement("canvas")
                    } catch (t) {
                        return document.createElement("canvas")
                    }
                }();
            po.width = po.height = 10, co._canvas = po, co._context = po.getContext("2d"), co._fonts = {}, co.METRICS_STRING = "|q", co.BASELINE_SYMBOL = "M", co.BASELINE_MULTIPLIER = 1.4, co._newlines = [10, 13], co._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
            var fo = {
                texture: !0,
                children: !1,
                baseTexture: !0
            },
                go = function (t) {
                    function e(e, i, n) {
                        var r = this,
                            o = !1;
                        n || (n = document.createElement("canvas"), o = !0), n.width = 3, n.height = 3;
                        var s = Je.from(n);
                        return s.orig = new Vt, s.trim = new Vt, (r = t.call(this, s) || this)._ownCanvas = o, r.canvas = n, r.context = r.canvas.getContext("2d"), r._resolution = j.RESOLUTION, r._autoResolution = !0, r._text = null, r._style = null, r._styleListener = null, r._font = "", r.text = e, r.style = i, r.localStyleID = -1, r
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        ro(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype.updateText = function (t) {
                        var e = this._style;
                        if (this.localStyleID !== e.styleID && (this.dirty = !0, this.localStyleID = e.styleID), this.dirty || !t) {
                            this._font = this._style.toFontString();
                            var i, n, r = this.context,
                                o = co.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
                                s = o.width,
                                a = o.height,
                                l = o.lines,
                                h = o.lineHeight,
                                u = o.lineWidths,
                                c = o.maxLineWidth,
                                d = o.fontProperties;
                            this.canvas.width = Math.ceil((Math.max(1, s) + 2 * e.padding) * this._resolution), this.canvas.height = Math.ceil((Math.max(1, a) + 2 * e.padding) * this._resolution), r.scale(this._resolution, this._resolution), r.clearRect(0, 0, this.canvas.width, this.canvas.height), r.font = this._font, r.lineWidth = e.strokeThickness, r.textBaseline = e.textBaseline, r.lineJoin = e.lineJoin, r.miterLimit = e.miterLimit;
                            for (var p = e.dropShadow ? 2 : 1, f = 0; f < p; ++f) {
                                var g = e.dropShadow && 0 === f,
                                    m = g ? Math.ceil(Math.max(1, a) + 2 * e.padding) : 0,
                                    _ = m * this._resolution;
                                if (g) {
                                    r.fillStyle = "black", r.strokeStyle = "black";
                                    var y = e.dropShadowColor,
                                        S = rt("number" == typeof y ? y : st(y)),
                                        v = e.dropShadowBlur * this._resolution,
                                        b = e.dropShadowDistance * this._resolution;
                                    r.shadowColor = "rgba(" + 255 * S[0] + "," + 255 * S[1] + "," + 255 * S[2] + "," + e.dropShadowAlpha + ")", r.shadowBlur = v, r.shadowOffsetX = Math.cos(e.dropShadowAngle) * b, r.shadowOffsetY = Math.sin(e.dropShadowAngle) * b + _
                                } else r.fillStyle = this._generateFillStyle(e, l, o), r.strokeStyle = e.stroke, r.shadowColor = "black", r.shadowBlur = 0, r.shadowOffsetX = 0, r.shadowOffsetY = 0;
                                for (var T = 0; T < l.length; T++) i = e.strokeThickness / 2, n = e.strokeThickness / 2 + T * h + d.ascent, "right" === e.align ? i += c - u[T] : "center" === e.align && (i += (c - u[T]) / 2), e.stroke && e.strokeThickness && this.drawLetterSpacing(l[T], i + e.padding, n + e.padding - m, !0), e.fill && this.drawLetterSpacing(l[T], i + e.padding, n + e.padding - m)
                            }
                            this.updateTexture()
                        }
                    }, e.prototype.drawLetterSpacing = function (t, e, i, n) {
                        void 0 === n && (n = !1);
                        var r = this._style.letterSpacing;
                        if (0 !== r)
                            for (var o = e, s = Array.from ? Array.from(t) : t.split(""), a = this.context.measureText(t).width, l = 0, h = 0; h < s.length; ++h) {
                                var u = s[h];
                                n ? this.context.strokeText(u, o, i) : this.context.fillText(u, o, i), o += a - (l = this.context.measureText(t.substring(h + 1)).width) + r, a = l
                            } else n ? this.context.strokeText(t, e, i) : this.context.fillText(t, e, i)
                    }, e.prototype.updateTexture = function () {
                        var t = this.canvas;
                        if (this._style.trim) {
                            var e = Ot(t);
                            e.data && (t.width = e.width, t.height = e.height, this.context.putImageData(e.data, 0, 0))
                        }
                        var i = this._texture,
                            n = this._style,
                            r = n.trim ? 0 : n.padding,
                            o = i.baseTexture;
                        i.trim.width = i._frame.width = Math.ceil(t.width / this._resolution), i.trim.height = i._frame.height = Math.ceil(t.height / this._resolution), i.trim.x = -r, i.trim.y = -r, i.orig.width = i._frame.width - 2 * r, i.orig.height = i._frame.height - 2 * r, this._onTextureUpdate(), o.setRealSize(t.width, t.height, this._resolution), this._recursivePostUpdateTransform(), this.dirty = !1
                    }, e.prototype._render = function (e) {
                        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), t.prototype._render.call(this, e)
                    }, e.prototype.getLocalBounds = function (e) {
                        return this.updateText(!0), t.prototype.getLocalBounds.call(this, e)
                    }, e.prototype._calculateBounds = function () {
                        this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
                    }, e.prototype._generateFillStyle = function (t, e, i) {
                        var n, r = t.fill;
                        if (!Array.isArray(r)) return r;
                        if (1 === r.length) return r[0];
                        var o = t.dropShadow ? t.dropShadowDistance : 0,
                            s = t.padding || 0,
                            a = Math.ceil(this.canvas.width / this._resolution) - o - 2 * s,
                            l = Math.ceil(this.canvas.height / this._resolution) - o - 2 * s,
                            h = r.slice(),
                            u = t.fillGradientStops.slice();
                        if (!u.length)
                            for (var c = h.length + 1, d = 1; d < c; ++d) u.push(d / c);
                        if (h.unshift(r[0]), u.unshift(0), h.push(r[r.length - 1]), u.push(1), t.fillGradientType === Dr.LINEAR_VERTICAL) {
                            n = this.context.createLinearGradient(a / 2, s, a / 2, l + s);
                            var p = 0,
                                f = (i.fontProperties.fontSize + t.strokeThickness) / l;
                            for (d = 0; d < e.length; d++)
                                for (var g = i.lineHeight * d, m = 0; m < h.length; m++) {
                                    var _ = g / l + ("number" == typeof u[m] ? u[m] : m / h.length) * f,
                                        y = Math.max(p, _);
                                    y = Math.min(y, 1), n.addColorStop(y, h[m]), p = y
                                }
                        } else {
                            n = this.context.createLinearGradient(s, l / 2, a + s, l / 2);
                            var S = h.length + 1,
                                v = 1;
                            for (d = 0; d < h.length; d++) {
                                var b;
                                b = "number" == typeof u[d] ? u[d] : v / S, n.addColorStop(b, h[d]), v++
                            }
                        }
                        return n
                    }, e.prototype.destroy = function (e) {
                        "boolean" == typeof e && (e = {
                            children: e
                        }), e = Object.assign({}, fo, e), t.prototype.destroy.call(this, e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
                    }, Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
                        },
                        set: function (t) {
                            this.updateText(!0);
                            var e = bt(this.scale.x) || 1;
                            this.scale.x = e * t / this._texture.orig.width, this._width = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "height", {
                        get: function () {
                            return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
                        },
                        set: function (t) {
                            this.updateText(!0);
                            var e = bt(this.scale.y) || 1;
                            this.scale.y = e * t / this._texture.orig.height, this._height = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "style", {
                        get: function () {
                            return this._style
                        },
                        set: function (t) {
                            t = t || {}, this._style = t instanceof ao ? t : new ao(t), this.localStyleID = -1, this.dirty = !0
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "text", {
                        get: function () {
                            return this._text
                        },
                        set: function (t) {
                            t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "resolution", {
                        get: function () {
                            return this._resolution
                        },
                        set: function (t) {
                            this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(no);
            j.UPLOADS_PER_FRAME = 4;
            var mo = function (t, e) {
                return mo = Object.setPrototypeOf || {
                    __proto__: []
                }
                    instanceof Array && function (t, e) {
                        t.__proto__ = e
                    } || function (t, e) {
                        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                    }, mo(t, e)
            },
                _o = function () {
                    function t(t) {
                        this.maxItemsPerFrame = t, this.itemsLeft = 0
                    }
                    return t.prototype.beginFrame = function () {
                        this.itemsLeft = this.maxItemsPerFrame
                    }, t.prototype.allowedToUpload = function () {
                        return this.itemsLeft-- > 0
                    }, t
                }();

            function yo(t, e) {
                var i = !1;
                if (t && t._textures && t._textures.length)
                    for (var n = 0; n < t._textures.length; n++)
                        if (t._textures[n] instanceof Je) {
                            var r = t._textures[n].baseTexture; - 1 === e.indexOf(r) && (e.push(r), i = !0)
                        } return i
            }

            function So(t, e) {
                if (t.baseTexture instanceof Re) {
                    var i = t.baseTexture;
                    return -1 === e.indexOf(i) && e.push(i), !0
                }
                return !1
            }

            function vo(t, e) {
                if (t._texture && t._texture instanceof Je) {
                    var i = t._texture.baseTexture;
                    return -1 === e.indexOf(i) && e.push(i), !0
                }
                return !1
            }

            function bo(t, e) {
                return e instanceof go && (e.updateText(!0), !0)
            }

            function To(t, e) {
                if (e instanceof ao) {
                    var i = e.toFontString();
                    return co.measureFont(i), !0
                }
                return !1
            }

            function Po(t, e) {
                if (t instanceof go) {
                    -1 === e.indexOf(t.style) && e.push(t.style), -1 === e.indexOf(t) && e.push(t);
                    var i = t._texture.baseTexture;
                    return -1 === e.indexOf(i) && e.push(i), !0
                }
                return !1
            }

            function Ao(t, e) {
                return t instanceof ao && (-1 === e.indexOf(t) && e.push(t), !0)
            }
            var Io = function () {
                function t(t) {
                    var e = this;
                    this.limiter = new _o(j.UPLOADS_PER_FRAME), this.renderer = t, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function () {
                        e.queue && e.prepareItems()
                    }, this.registerFindHook(Po), this.registerFindHook(Ao), this.registerFindHook(yo), this.registerFindHook(So), this.registerFindHook(vo), this.registerUploadHook(bo), this.registerUploadHook(To)
                }
                return t.prototype.upload = function (t, e) {
                    "function" == typeof t && (e = t, t = null), t && this.add(t), this.queue.length ? (e && this.completes.push(e), this.ticking || (this.ticking = !0, _e.system.addOnce(this.tick, this, pe.UTILITY))) : e && e()
                }, t.prototype.tick = function () {
                    setTimeout(this.delayedTick, 0)
                }, t.prototype.prepareItems = function () {
                    for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
                        var t = this.queue[0],
                            e = !1;
                        if (t && !t._destroyed)
                            for (var i = 0, n = this.uploadHooks.length; i < n; i++)
                                if (this.uploadHooks[i](this.uploadHookHelper, t)) {
                                    this.queue.shift(), e = !0;
                                    break
                                } e || this.queue.shift()
                    }
                    if (this.queue.length) _e.system.addOnce(this.tick, this, pe.UTILITY);
                    else {
                        this.ticking = !1;
                        var r = this.completes.slice(0);
                        for (this.completes.length = 0, i = 0, n = r.length; i < n; i++) r[i]()
                    }
                }, t.prototype.registerFindHook = function (t) {
                    return t && this.addHooks.push(t), this
                }, t.prototype.registerUploadHook = function (t) {
                    return t && this.uploadHooks.push(t), this
                }, t.prototype.add = function (t) {
                    for (var e = 0, i = this.addHooks.length; e < i && !this.addHooks[e](t, this.queue); e++);
                    if (t instanceof ce)
                        for (e = t.children.length - 1; e >= 0; e--) this.add(t.children[e]);
                    return this
                }, t.prototype.destroy = function () {
                    this.ticking && _e.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
                }, t
            }();

            function wo(t, e) {
                return e instanceof Re && (e._glTextures[t.CONTEXT_UID] || t.texture.bind(e), !0)
            }

            function Eo(t, e) {
                if (!(e instanceof Qr)) return !1;
                var i = e.geometry;
                e.finishPoly(), i.updateBatches();
                for (var n = i.batches, r = 0; r < n.length; r++) {
                    var o = n[r].style.texture;
                    o && wo(t, o.baseTexture)
                }
                return i.batchable || t.geometry.bind(i, e._resolveDirectShader(t)), !0
            }

            function Co(t, e) {
                return t instanceof Qr && (e.push(t), !0)
            }
            var xo = function (t) {
                function e(e) {
                    var i = t.call(this, e) || this;
                    return i.uploadHookHelper = i.renderer, i.registerFindHook(Co), i.registerUploadHook(wo), i.registerUploadHook(Eo), i
                }
                return function (t, e) {
                    function i() {
                        this.constructor = t
                    }
                    mo(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                }(e, t), e
            }(Io),
                Bo = function () {
                    function t(t) {
                        this.maxMilliseconds = t, this.frameStart = 0
                    }
                    return t.prototype.beginFrame = function () {
                        this.frameStart = Date.now()
                    }, t.prototype.allowedToUpload = function () {
                        return Date.now() - this.frameStart < this.maxMilliseconds
                    }, t
                }(),
                Lo = function () {
                    function t(t, e, i) {
                        void 0 === i && (i = null), this._texture = t instanceof Je ? t : null, this.baseTexture = t instanceof Re ? t : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = e;
                        var n = this.baseTexture.resource;
                        this.resolution = this._updateResolution(i || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
                    }
                    return t.prototype._updateResolution = function (t) {
                        void 0 === t && (t = null);
                        var e = this.data.meta.scale,
                            i = Ft(t, null);
                        return null === i && (i = void 0 !== e ? parseFloat(e) : 1), 1 !== i && this.baseTexture.setResolution(i), i
                    }, t.prototype.parse = function (e) {
                        this._batchIndex = 0, this._callback = e, this._frameKeys.length <= t.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
                    }, t.prototype._processFrames = function (e) {
                        for (var i = e, n = t.BATCH_SIZE; i - e < n && i < this._frameKeys.length;) {
                            var r = this._frameKeys[i],
                                o = this._frames[r],
                                s = o.frame;
                            if (s) {
                                var a, l = null,
                                    h = !1 !== o.trimmed && o.sourceSize ? o.sourceSize : o.frame,
                                    u = new Vt(0, 0, Math.floor(h.w) / this.resolution, Math.floor(h.h) / this.resolution);
                                a = o.rotated ? new Vt(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : new Vt(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), !1 !== o.trimmed && o.spriteSourceSize && (l = new Vt(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[r] = new Je(this.baseTexture, a, u, l, o.rotated ? 2 : 0, o.anchor), Je.addToCache(this.textures[r], r)
                            }
                            i++
                        }
                    }, t.prototype._processAnimations = function () {
                        var t = this.data.animations || {};
                        for (var e in t) {
                            this.animations[e] = [];
                            for (var i = 0; i < t[e].length; i++) {
                                var n = t[e][i];
                                this.animations[e].push(this.textures[n])
                            }
                        }
                    }, t.prototype._parseComplete = function () {
                        var t = this._callback;
                        this._callback = null, this._batchIndex = 0, t.call(this, this.textures)
                    }, t.prototype._nextBatch = function () {
                        var e = this;
                        this._processFrames(this._batchIndex * t.BATCH_SIZE), this._batchIndex++, setTimeout((function () {
                            e._batchIndex * t.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete())
                        }), 0)
                    }, t.prototype.destroy = function (t) {
                        var e;
                        for (var i in void 0 === t && (t = !1), this.textures) this.textures[i].destroy();
                        this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, t && (null === (e = this._texture) || void 0 === e || e.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null
                    }, t.BATCH_SIZE = 1e3, t
                }(),
                Oo = function () {
                    function t() { }
                    return t.use = function (e, i) {
                        var n = this,
                            r = e.name + "_image";
                        if (e.data && e.type === ur.TYPE.JSON && e.data.frames && !n.resources[r]) {
                            var o = {
                                crossOrigin: e.crossOrigin,
                                metadata: e.metadata.imageMetadata,
                                parentResource: e
                            },
                                s = t.getResourcePath(e, n.baseUrl);
                            n.add(r, s, o, (function (t) {
                                if (t.error) i(t.error);
                                else {
                                    var n = new Lo(t.texture, e.data, e.url);
                                    n.parse((function () {
                                        e.spritesheet = n, e.textures = n.textures, i()
                                    }))
                                }
                            }))
                        } else i()
                    }, t.getResourcePath = function (t, e) {
                        return t.isDataUrl ? t.data.meta.image : $.resolve(t.url.replace(e, ""), t.data.meta.image)
                    }, t
                }(),
                No = function (t, e) {
                    return No = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, No(t, e)
                };

            function Mo(t, e) {
                function i() {
                    this.constructor = t
                }
                No(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var Ro = new zt,
                Do = function (t) {
                    function e(e, i, n) {
                        void 0 === i && (i = 100), void 0 === n && (n = 100);
                        var r = t.call(this, e) || this;
                        return r.tileTransform = new re, r._width = i, r._height = n, r.uvMatrix = r.texture.uvMatrix || new nn(e), r.pluginName = "tilingSprite", r.uvRespectAnchor = !1, r
                    }
                    return Mo(e, t), Object.defineProperty(e.prototype, "clampMargin", {
                        get: function () {
                            return this.uvMatrix.clampMargin
                        },
                        set: function (t) {
                            this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tileScale", {
                        get: function () {
                            return this.tileTransform.scale
                        },
                        set: function (t) {
                            this.tileTransform.scale.copyFrom(t)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tilePosition", {
                        get: function () {
                            return this.tileTransform.position
                        },
                        set: function (t) {
                            this.tileTransform.position.copyFrom(t)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype._onTextureUpdate = function () {
                        this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
                    }, e.prototype._render = function (t) {
                        var e = this._texture;
                        e && e.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
                    }, e.prototype._calculateBounds = function () {
                        var t = this._width * -this._anchor._x,
                            e = this._height * -this._anchor._y,
                            i = this._width * (1 - this._anchor._x),
                            n = this._height * (1 - this._anchor._y);
                        this._bounds.addFrame(this.transform, t, e, i, n)
                    }, e.prototype.getLocalBounds = function (e) {
                        return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new Vt), e = this._localBoundsRect), this._bounds.getRectangle(e)) : t.prototype.getLocalBounds.call(this, e)
                    }, e.prototype.containsPoint = function (t) {
                        this.worldTransform.applyInverse(t, Ro);
                        var e = this._width,
                            i = this._height,
                            n = -e * this.anchor._x;
                        if (Ro.x >= n && Ro.x < n + e) {
                            var r = -i * this.anchor._y;
                            if (Ro.y >= r && Ro.y < r + i) return !0
                        }
                        return !1
                    }, e.prototype.destroy = function (e) {
                        t.prototype.destroy.call(this, e), this.tileTransform = null, this.uvMatrix = null
                    }, e.from = function (t, i) {
                        return "number" == typeof i && (It("5.3.0", "TilingSprite.from use options instead of width and height args"), i = {
                            width: i,
                            height: arguments[2]
                        }), new e(Je.from(t, i), i.width, i.height)
                    }, Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return this._width
                        },
                        set: function (t) {
                            this._width = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "height", {
                        get: function () {
                            return this._height
                        },
                        set: function (t) {
                            this._height = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(no),
                Fo = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n",
                ko = new qt,
                Uo = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this,
                            n = {
                                globals: i.renderer.globalUniforms
                            };
                        return i.shader = Ji.from(Fo, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture2D(uSampler, coord);\n    gl_FragColor = texSample * uColor;\n}\n", n), i.simpleShader = Ji.from(Fo, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n", n), i.quad = new di, i.state = Qi.for2d(), i
                    }
                    return Mo(e, t), e.prototype.render = function (t) {
                        var e = this.renderer,
                            i = this.quad,
                            n = i.vertices;
                        n[0] = n[6] = t._width * -t.anchor.x, n[1] = n[3] = t._height * -t.anchor.y, n[2] = n[4] = t._width * (1 - t.anchor.x), n[5] = n[7] = t._height * (1 - t.anchor.y), t.uvRespectAnchor && ((n = i.uvs)[0] = n[6] = -t.anchor.x, n[1] = n[3] = -t.anchor.y, n[2] = n[4] = 1 - t.anchor.x, n[5] = n[7] = 1 - t.anchor.y), i.invalidate();
                        var r = t._texture,
                            o = r.baseTexture,
                            s = t.tileTransform.localTransform,
                            a = t.uvMatrix,
                            l = o.isPowerOfTwo && r.frame.width === o.width && r.frame.height === o.height;
                        l && (o._glTextures[e.CONTEXT_UID] ? l = o.wrapMode !== b.CLAMP : o.wrapMode === b.CLAMP && (o.wrapMode = b.REPEAT));
                        var h = l ? this.simpleShader : this.shader,
                            u = r.width,
                            c = r.height,
                            d = t._width,
                            p = t._height;
                        ko.set(s.a * u / d, s.b * u / p, s.c * c / d, s.d * c / p, s.tx / d, s.ty / p), ko.invert(), l ? ko.prepend(a.mapCoord) : (h.uniforms.uMapCoord = a.mapCoord.toArray(!0), h.uniforms.uClampFrame = a.uClampFrame, h.uniforms.uClampOffset = a.uClampOffset), h.uniforms.uTransform = ko.toArray(!0), h.uniforms.uColor = dt(t.tint, t.worldAlpha, h.uniforms.uColor, o.alphaMode), h.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), h.uniforms.uSampler = r, e.shader.bind(h), e.geometry.bind(i), this.state.blendMode = ht(t.blendMode, o.alphaMode), e.state.set(this.state), e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
                    }, e
                }(_i),
                Go = function (t, e) {
                    return Go = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Go(t, e)
                };

            function Wo(t, e) {
                function i() {
                    this.constructor = t
                }
                Go(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var Vo = function () {
                function t(t, e) {
                    this.uvBuffer = t, this.uvMatrix = e, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
                }
                return t.prototype.update = function (t) {
                    if (t || this._bufferUpdateId !== this.uvBuffer._updateID || this._textureUpdateId !== this.uvMatrix._updateID) {
                        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
                        var e = this.uvBuffer.data;
                        this.data && this.data.length === e.length || (this.data = new Float32Array(e.length)), this.uvMatrix.multiplyUvs(e, this.data), this._updateID++
                    }
                }, t
            }(),
                Xo = new zt,
                Ho = new Yt,
                Yo = function (t) {
                    function e(e, i, n, r) {
                        void 0 === r && (r = m.TRIANGLES);
                        var o = t.call(this) || this;
                        return o.geometry = e, e.refCount++, o.shader = i, o.state = n || Qi.for2d(), o.drawMode = r, o.start = 0, o.size = 0, o.uvs = null, o.indices = null, o.vertexData = new Float32Array(1), o.vertexDirty = 0, o._transformID = -1, o._roundPixels = j.ROUND_PIXELS, o.batchUvs = null, o
                    }
                    return Wo(e, t), Object.defineProperty(e.prototype, "uvBuffer", {
                        get: function () {
                            return this.geometry.buffers[1]
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "verticesBuffer", {
                        get: function () {
                            return this.geometry.buffers[0]
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "material", {
                        get: function () {
                            return this.shader
                        },
                        set: function (t) {
                            this.shader = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "blendMode", {
                        get: function () {
                            return this.state.blendMode
                        },
                        set: function (t) {
                            this.state.blendMode = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "roundPixels", {
                        get: function () {
                            return this._roundPixels
                        },
                        set: function (t) {
                            this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tint", {
                        get: function () {
                            return this.shader.tint
                        },
                        set: function (t) {
                            this.shader.tint = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "texture", {
                        get: function () {
                            return this.shader.texture
                        },
                        set: function (t) {
                            this.shader.texture = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype._render = function (t) {
                        var i = this.geometry.buffers[0].data;
                        this.shader.batchable && this.drawMode === m.TRIANGLES && i.length < 2 * e.BATCHABLE_SIZE ? this._renderToBatch(t) : this._renderDefault(t)
                    }, e.prototype._renderDefault = function (t) {
                        var e = this.shader;
                        e.alpha = this.worldAlpha, e.update && e.update(), t.batch.flush(), e.program.uniformData.translationMatrix && (e.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0)), t.shader.bind(e), t.state.set(this.state), t.geometry.bind(this.geometry, e), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
                    }, e.prototype._renderToBatch = function (t) {
                        var e = this.geometry;
                        this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = e.indexBuffer.data, this._tintRGB = this.shader._tintRGB, this._texture = this.shader.texture;
                        var i = this.material.pluginName;
                        t.batch.setObjectRenderer(t.plugins[i]), t.plugins[i].render(this)
                    }, e.prototype.calculateVertices = function () {
                        var t = this.geometry,
                            e = t.buffers[0].data;
                        if (t.vertexDirtyId !== this.vertexDirty || this._transformID !== this.transform._worldID) {
                            this._transformID = this.transform._worldID, this.vertexData.length !== e.length && (this.vertexData = new Float32Array(e.length));
                            for (var i = this.transform.worldTransform, n = i.a, r = i.b, o = i.c, s = i.d, a = i.tx, l = i.ty, h = this.vertexData, u = 0; u < h.length / 2; u++) {
                                var c = e[2 * u],
                                    d = e[2 * u + 1];
                                h[2 * u] = n * c + o * d + a, h[2 * u + 1] = r * c + s * d + l
                            }
                            if (this._roundPixels) {
                                var p = j.RESOLUTION;
                                for (u = 0; u < h.length; ++u) h[u] = Math.round((h[u] * p | 0) / p)
                            }
                            this.vertexDirty = t.vertexDirtyId
                        }
                    }, e.prototype.calculateUvs = function () {
                        var t = this.geometry.buffers[1];
                        this.shader.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new Vo(t, this.shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
                    }, e.prototype._calculateBounds = function () {
                        this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
                    }, e.prototype.containsPoint = function (t) {
                        if (!this.getBounds().contains(t.x, t.y)) return !1;
                        this.worldTransform.applyInverse(t, Xo);
                        for (var e = this.geometry.getBuffer("aVertexPosition").data, i = Ho.points, n = this.geometry.getIndex().data, r = n.length, o = 4 === this.drawMode ? 3 : 1, s = 0; s + 2 < r; s += o) {
                            var a = 2 * n[s],
                                l = 2 * n[s + 1],
                                h = 2 * n[s + 2];
                            if (i[0] = e[a], i[1] = e[a + 1], i[2] = e[l], i[3] = e[l + 1], i[4] = e[h], i[5] = e[h + 1], Ho.contains(Xo.x, Xo.y)) return !0
                        }
                        return !1
                    }, e.prototype.destroy = function (e) {
                        t.prototype.destroy.call(this, e), this.geometry.refCount--, 0 === this.geometry.refCount && this.geometry.dispose(), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
                    }, e.BATCHABLE_SIZE = 100, e
                }(ce),
                jo = function (t) {
                    function e(e, i) {
                        var n = this,
                            r = {
                                uSampler: e,
                                alpha: 1,
                                uTextureMatrix: qt.IDENTITY,
                                uColor: new Float32Array([1, 1, 1, 1])
                            };
                        return (i = Object.assign({
                            tint: 16777215,
                            alpha: 1,
                            pluginName: "batch"
                        }, i)).uniforms && Object.assign(r, i.uniforms), (n = t.call(this, i.program || $i.from("attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n", "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"), r) || this)._colorDirty = !1, n.uvMatrix = new nn(e), n.batchable = void 0 === i.program, n.pluginName = i.pluginName, n.tint = i.tint, n.alpha = i.alpha, n
                    }
                    return Wo(e, t), Object.defineProperty(e.prototype, "texture", {
                        get: function () {
                            return this.uniforms.uSampler
                        },
                        set: function (t) {
                            this.uniforms.uSampler !== t && (this.uniforms.uSampler = t, this.uvMatrix.texture = t)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "alpha", {
                        get: function () {
                            return this._alpha
                        },
                        set: function (t) {
                            t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "tint", {
                        get: function () {
                            return this._tint
                        },
                        set: function (t) {
                            t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (65280 & t) + ((255 & t) << 16), this._colorDirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.update = function () {
                        if (this._colorDirty) {
                            this._colorDirty = !1;
                            var t = this.texture.baseTexture;
                            dt(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
                        }
                        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
                    }, e
                }(Ji),
                zo = function (t) {
                    function e(e, i, n) {
                        var r = t.call(this) || this,
                            o = new ri(e),
                            s = new ri(i, !0),
                            a = new ri(n, !0, !0);
                        return r.addAttribute("aVertexPosition", o, 2, !1, S.FLOAT).addAttribute("aTextureCoord", s, 2, !1, S.FLOAT).addIndex(a), r._updateId = -1, r
                    }
                    return Wo(e, t), Object.defineProperty(e.prototype, "vertexDirtyId", {
                        get: function () {
                            return this.buffers[0]._updateID
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(ui),
                Ko = function (t, e) {
                    return Ko = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Ko(t, e)
                },
                qo = function () {
                    this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = []
                },
                Zo = function () {
                    function t() { }
                    return t.test = function (t) {
                        return "string" == typeof t && 0 === t.indexOf("info face=")
                    }, t.parse = function (t) {
                        var e = t.match(/^[a-z]+\s+.+$/gm),
                            i = {
                                info: [],
                                common: [],
                                page: [],
                                char: [],
                                chars: [],
                                kerning: [],
                                kernings: []
                            };
                        for (var n in e) {
                            var r = e[n].match(/^[a-z]+/gm)[0],
                                o = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                                s = {};
                            for (var a in o) {
                                var l = o[a].split("="),
                                    h = l[0],
                                    u = l[1].replace(/"/gm, ""),
                                    c = parseFloat(u),
                                    d = isNaN(c) ? u : c;
                                s[h] = d
                            }
                            i[r].push(s)
                        }
                        var p = new qo;
                        return i.info.forEach((function (t) {
                            return p.info.push({
                                face: t.face,
                                size: parseInt(t.size, 10)
                            })
                        })), i.common.forEach((function (t) {
                            return p.common.push({
                                lineHeight: parseInt(t.lineHeight, 10)
                            })
                        })), i.page.forEach((function (t) {
                            return p.page.push({
                                id: parseInt(t.id, 10),
                                file: t.file
                            })
                        })), i.char.forEach((function (t) {
                            return p.char.push({
                                id: parseInt(t.id, 10),
                                page: parseInt(t.page, 10),
                                x: parseInt(t.x, 10),
                                y: parseInt(t.y, 10),
                                width: parseInt(t.width, 10),
                                height: parseInt(t.height, 10),
                                xoffset: parseInt(t.xoffset, 10),
                                yoffset: parseInt(t.yoffset, 10),
                                xadvance: parseInt(t.xadvance, 10)
                            })
                        })), i.kerning.forEach((function (t) {
                            return p.kerning.push({
                                first: parseInt(t.first, 10),
                                second: parseInt(t.second, 10),
                                amount: parseInt(t.amount, 10)
                            })
                        })), p
                    }, t
                }(),
                $o = function () {
                    function t() { }
                    return t.test = function (t) {
                        return t instanceof XMLDocument && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face")
                    }, t.parse = function (t) {
                        for (var e = new qo, i = t.getElementsByTagName("info"), n = t.getElementsByTagName("common"), r = t.getElementsByTagName("page"), o = t.getElementsByTagName("char"), s = t.getElementsByTagName("kerning"), a = 0; a < i.length; a++) e.info.push({
                            face: i[a].getAttribute("face"),
                            size: parseInt(i[a].getAttribute("size"), 10)
                        });
                        for (a = 0; a < n.length; a++) e.common.push({
                            lineHeight: parseInt(n[a].getAttribute("lineHeight"), 10)
                        });
                        for (a = 0; a < r.length; a++) e.page.push({
                            id: parseInt(r[a].getAttribute("id"), 10) || 0,
                            file: r[a].getAttribute("file")
                        });
                        for (a = 0; a < o.length; a++) {
                            var l = o[a];
                            e.char.push({
                                id: parseInt(l.getAttribute("id"), 10),
                                page: parseInt(l.getAttribute("page"), 10) || 0,
                                x: parseInt(l.getAttribute("x"), 10),
                                y: parseInt(l.getAttribute("y"), 10),
                                width: parseInt(l.getAttribute("width"), 10),
                                height: parseInt(l.getAttribute("height"), 10),
                                xoffset: parseInt(l.getAttribute("xoffset"), 10),
                                yoffset: parseInt(l.getAttribute("yoffset"), 10),
                                xadvance: parseInt(l.getAttribute("xadvance"), 10)
                            })
                        }
                        for (a = 0; a < s.length; a++) e.kerning.push({
                            first: parseInt(s[a].getAttribute("first"), 10),
                            second: parseInt(s[a].getAttribute("second"), 10),
                            amount: parseInt(s[a].getAttribute("amount"), 10)
                        });
                        return e
                    }, t
                }(),
                Jo = function () {
                    function t() { }
                    return t.test = function (t) {
                        if ("string" == typeof t && t.indexOf("<font>") > -1) {
                            var e = (new self.DOMParser).parseFromString(t, "text/xml");
                            return $o.test(e)
                        }
                        return !1
                    }, t.parse = function (t) {
                        var e = (new window.DOMParser).parseFromString(t, "text/xml");
                        return $o.parse(e)
                    }, t
                }(),
                Qo = [Zo, $o, Jo];

            function ts(t) {
                for (var e = 0; e < Qo.length; e++)
                    if (Qo[e].test(t)) return Qo[e];
                return null
            }

            function es(t, e, i, n, r, o, s) {
                var a = i.text,
                    l = i.fontProperties;
                e.translate(n, r), e.scale(o, o);
                var h = s.strokeThickness / 2,
                    u = -s.strokeThickness / 2;
                if (e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = function (t, e, i, n, r, o) {
                    var s, a = i.fill;
                    if (!Array.isArray(a)) return a;
                    if (1 === a.length) return a[0];
                    var l = i.dropShadow ? i.dropShadowDistance : 0,
                        h = i.padding || 0,
                        u = Math.ceil(t.width / n) - l - 2 * h,
                        c = Math.ceil(t.height / n) - l - 2 * h,
                        d = a.slice(),
                        p = i.fillGradientStops.slice();
                    if (!p.length)
                        for (var f = d.length + 1, g = 1; g < f; ++g) p.push(g / f);
                    if (d.unshift(a[0]), p.unshift(0), d.push(a[a.length - 1]), p.push(1), i.fillGradientType === Dr.LINEAR_VERTICAL) {
                        s = e.createLinearGradient(u / 2, h, u / 2, c + h);
                        var m = 0,
                            _ = (o.fontProperties.fontSize + i.strokeThickness) / c;
                        for (g = 0; g < r.length; g++)
                            for (var y = o.lineHeight * g, S = 0; S < d.length; S++) {
                                var v = y / c + ("number" == typeof p[S] ? p[S] : S / d.length) * _,
                                    b = Math.max(m, v);
                                b = Math.min(b, 1), s.addColorStop(b, d[S]), m = b
                            }
                    } else {
                        s = e.createLinearGradient(h, c / 2, u + h, c / 2);
                        var T = d.length + 1,
                            P = 1;
                        for (g = 0; g < d.length; g++) {
                            var A;
                            A = "number" == typeof p[g] ? p[g] : P / T, s.addColorStop(A, d[g]), P++
                        }
                    }
                    return s
                }(t, e, s, o, [a], i), e.strokeStyle = s.stroke, s.dropShadow) {
                    var c = s.dropShadowColor,
                        d = rt("number" == typeof c ? c : st(c)),
                        p = s.dropShadowBlur * o,
                        f = s.dropShadowDistance * o;
                    e.shadowColor = "rgba(" + 255 * d[0] + "," + 255 * d[1] + "," + 255 * d[2] + "," + s.dropShadowAlpha + ")", e.shadowBlur = p, e.shadowOffsetX = Math.cos(s.dropShadowAngle) * f, e.shadowOffsetY = Math.sin(s.dropShadowAngle) * f
                } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
                s.stroke && s.strokeThickness && e.strokeText(a, h, u + i.lineHeight - l.descent), s.fill && e.fillText(a, h, u + i.lineHeight - l.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)"
            }
            var is = function () {
                function t(t, e, i) {
                    var n = t.info[0],
                        r = t.common[0],
                        o = Ft(t.page[0].file),
                        s = {};
                    this._ownsTextures = i, this.font = n.face, this.size = n.size, this.lineHeight = r.lineHeight / o, this.chars = {}, this.pageTextures = s;
                    for (var a = 0; a < t.page.length; a++) {
                        var l = t.page[a],
                            h = l.id,
                            u = l.file;
                        s[h] = e instanceof Array ? e[a] : e[u]
                    }
                    for (a = 0; a < t.char.length; a++) {
                        var c = t.char[a],
                            d = (h = c.id, c.page),
                            p = t.char[a],
                            f = p.x,
                            g = p.y,
                            m = p.width,
                            _ = p.height,
                            y = p.xoffset,
                            S = p.yoffset,
                            v = p.xadvance;
                        g /= o, m /= o, _ /= o, y /= o, S /= o, v /= o;
                        var b = new Vt((f /= o) + s[d].frame.x / o, g + s[d].frame.y / o, m, _);
                        this.chars[h] = {
                            xOffset: y,
                            yOffset: S,
                            xAdvance: v,
                            kerning: {},
                            texture: new Je(s[d].baseTexture, b),
                            page: d
                        }
                    }
                    for (a = 0; a < t.kerning.length; a++) {
                        var T = t.kerning[a],
                            P = T.first,
                            A = T.second,
                            I = T.amount;
                        P /= o, A /= o, I /= o, this.chars[A] && (this.chars[A].kerning[P] = I)
                    }
                }
                return t.prototype.destroy = function () {
                    for (var t in this.chars) this.chars[t].texture.destroy(), this.chars[t].texture = null;
                    for (var t in this.pageTextures) this._ownsTextures && this.pageTextures[t].destroy(!0), this.pageTextures[t] = null;
                    this.chars = null, this.pageTextures = null
                }, t.install = function (e, i, n) {
                    var r;
                    if (e instanceof qo) r = e;
                    else {
                        var o = ts(e);
                        if (!o) throw new Error("Unrecognized data format for font.");
                        r = o.parse(e)
                    }
                    i instanceof Je && (i = [i]);
                    var s = new t(r, i, n);
                    return t.available[s.font] = s, s
                }, t.uninstall = function (e) {
                    var i = t.available[e];
                    if (!i) throw new Error("No font found named '" + e + "'");
                    i.destroy(), delete t.available[e]
                }, t.from = function (e, i, n) {
                    if (!e) throw new Error("[BitmapFont] Property `name` is required.");
                    var r = Object.assign({}, t.defaultOptions, n),
                        o = r.chars,
                        s = r.padding,
                        a = r.resolution,
                        l = r.textureWidth,
                        h = r.textureHeight,
                        u = function (t) {
                            "string" == typeof t && (t = [t]);
                            for (var e = [], i = 0, n = t.length; i < n; i++) {
                                var r = t[i];
                                if (Array.isArray(r)) {
                                    if (2 !== r.length) throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + r.length + ".");
                                    var o = r[0].charCodeAt(0),
                                        s = r[1].charCodeAt(0);
                                    if (s < o) throw new Error("[BitmapFont]: Invalid character range.");
                                    for (var a = o, l = s; a <= l; a++) e.push(String.fromCharCode(a))
                                } else e.push.apply(e, r.split(""))
                            }
                            if (0 === e.length) throw new Error("[BitmapFont]: Empty set when resolving characters.");
                            return e
                        }(o),
                        c = i instanceof ao ? i : new ao(i),
                        d = l,
                        p = new qo;
                    p.info[0] = {
                        face: c.fontFamily,
                        size: c.fontSize
                    }, p.common[0] = {
                        lineHeight: c.fontSize
                    };
                    for (var f, g, m, _ = 0, y = 0, S = 0, v = [], b = 0; b < u.length; b++) {
                        f || ((f = document.createElement("canvas")).width = l, f.height = h, g = f.getContext("2d"), m = new Re(f, {
                            resolution: a
                        }), v.push(new Je(m)), p.page.push({
                            id: v.length - 1,
                            file: ""
                        }));
                        var T = co.measureText(u[b], c, !1, f),
                            P = T.width,
                            A = Math.ceil(T.height),
                            I = Math.ceil(("italic" === c.fontStyle ? 2 : 1) * P);
                        if (y >= h - A * a) {
                            if (0 === y) throw new Error("[BitmapFont] textureHeight " + h + "px is too small for " + c.fontSize + "px fonts");
                            --b, f = null, g = null, m = null, y = 0, _ = 0, S = 0
                        } else if (S = Math.max(A + T.fontProperties.descent, S), I * a + _ >= d) --b, y += S * a, y = Math.ceil(y), _ = 0, S = 0;
                        else {
                            es(f, g, T, _, y, a, c);
                            var w = T.text.charCodeAt(0);
                            p.char.push({
                                id: w,
                                page: v.length - 1,
                                x: _ / a,
                                y: y / a,
                                width: I,
                                height: A,
                                xoffset: 0,
                                yoffset: 0,
                                xadvance: Math.ceil(P - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0))
                            }), _ += (I + 2 * s) * a, _ = Math.ceil(_)
                        }
                    }
                    var E = new t(p, v, !0);
                    return void 0 !== t.available[e] && t.uninstall(e), t.available[e] = E, E
                }, t.ALPHA = [
                    ["a", "z"],
                    ["A", "Z"], " "
                ], t.NUMERIC = [
                    ["0", "9"]
                ], t.ALPHANUMERIC = [
                    ["a", "z"],
                    ["A", "Z"],
                    ["0", "9"], " "
                ], t.ASCII = [
                    [" ", "~"]
                ], t.defaultOptions = {
                    resolution: 1,
                    textureWidth: 512,
                    textureHeight: 512,
                    padding: 4,
                    chars: t.ALPHANUMERIC
                }, t.available = {}, t
            }(),
                ns = [],
                rs = [],
                os = function (t) {
                    function e(i, n) {
                        void 0 === n && (n = {});
                        var r = t.call(this) || this;
                        r._tint = 16777215, n.font && (It("5.3.0", "PIXI.BitmapText constructor style.font property is deprecated."), r._upgradeStyle(n));
                        var o = Object.assign({}, e.styleDefaults, n),
                            s = o.align,
                            a = o.tint,
                            l = o.maxWidth,
                            h = o.letterSpacing,
                            u = o.fontName,
                            c = o.fontSize;
                        if (!is.available[u]) throw new Error('Missing BitmapFont "' + u + '"');
                        return r._activePagesMeshData = [], r._textWidth = 0, r._textHeight = 0, r._align = s, r._tint = a, r._fontName = u, r._fontSize = c || is.available[u].size, r._text = i, r._maxWidth = l, r._maxLineHeight = 0, r._letterSpacing = h, r._anchor = new Kt((function () {
                            r.dirty = !0
                        }), r, 0, 0), r._roundPixels = j.ROUND_PIXELS, r.dirty = !0, r._textureCache = {}, r
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        Ko(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype.updateText = function () {
                        for (var t, e = is.available[this._fontName], i = this._fontSize / e.size, n = new zt, r = [], o = [], s = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ", a = s.length, l = this._maxWidth * e.size / this._fontSize, h = null, u = 0, c = 0, d = 0, p = -1, f = 0, g = 0, m = 0, _ = 0; _ < a; _++) {
                            var y = s.charCodeAt(_),
                                S = s.charAt(_);
                            if (/(?:\s)/.test(S) && (p = _, f = u), "\r" !== S && "\n" !== S) {
                                var v = e.chars[y];
                                if (v) {
                                    h && v.kerning[h] && (n.x += v.kerning[h]);
                                    var b = rs.pop() || {
                                        texture: Je.EMPTY,
                                        line: 0,
                                        charCode: 0,
                                        position: new zt
                                    };
                                    b.texture = v.texture, b.line = d, b.charCode = y, b.position.x = n.x + v.xOffset + this._letterSpacing / 2, b.position.y = n.y + v.yOffset, r.push(b), n.x += v.xAdvance + this._letterSpacing, u = n.x, m = Math.max(m, v.yOffset + v.texture.height), h = y, -1 !== p && l > 0 && n.x > l && (vt(r, 1 + p - ++g, 1 + _ - p), _ = p, p = -1, o.push(f), c = Math.max(c, f), d++, n.x = 0, n.y += e.lineHeight, h = null)
                                }
                            } else o.push(u), c = Math.max(c, u), ++d, ++g, n.x = 0, n.y += e.lineHeight, h = null
                        }
                        var T = s.charAt(s.length - 1);
                        "\r" !== T && "\n" !== T && (/(?:\s)/.test(T) && (u = f), o.push(u), c = Math.max(c, u));
                        var P = [];
                        for (_ = 0; _ <= d; _++) {
                            var A = 0;
                            "right" === this._align ? A = c - o[_] : "center" === this._align && (A = (c - o[_]) / 2), P.push(A)
                        }
                        var I = r.length,
                            w = {},
                            E = [],
                            C = this._activePagesMeshData;
                        for (_ = 0; _ < C.length; _++) ns.push(C[_]);
                        for (_ = 0; _ < I; _++) {
                            var x = (k = r[_].texture).baseTexture.uid;
                            if (!w[x]) {
                                if (!(Y = ns.pop())) {
                                    var B = new zo,
                                        L = new jo(Je.EMPTY);
                                    Y = {
                                        index: 0,
                                        indexCount: 0,
                                        vertexCount: 0,
                                        uvsCount: 0,
                                        total: 0,
                                        mesh: new Yo(B, L),
                                        vertices: null,
                                        uvs: null,
                                        indices: null
                                    }
                                }
                                Y.index = 0, Y.indexCount = 0, Y.vertexCount = 0, Y.uvsCount = 0, Y.total = 0;
                                var O = this._textureCache;
                                O[x] = O[x] || new Je(k.baseTexture), Y.mesh.texture = O[x], Y.mesh.tint = this._tint, E.push(Y), w[x] = Y
                            }
                            w[x].total++
                        }
                        for (_ = 0; _ < C.length; _++) - 1 === E.indexOf(C[_]) && this.removeChild(C[_].mesh);
                        for (_ = 0; _ < E.length; _++) E[_].mesh.parent !== this && this.addChild(E[_].mesh);
                        for (var _ in this._activePagesMeshData = E, w) {
                            var N = (Y = w[_]).total;
                            if (!((null === (t = Y.indices) || void 0 === t ? void 0 : t.length) > 6 * N) || Y.vertices.length < 2 * Yo.BATCHABLE_SIZE) Y.vertices = new Float32Array(8 * N), Y.uvs = new Float32Array(8 * N), Y.indices = new Uint16Array(6 * N);
                            else
                                for (var M = Y.total, R = Y.vertices, D = 4 * M * 2; D < R.length; D++) R[D] = 0;
                            Y.mesh.size = 6 * N
                        }
                        for (_ = 0; _ < I; _++) {
                            var F = (S = r[_]).position.x + P[S.line];
                            this._roundPixels && (F = Math.round(F));
                            var k, U = F * i,
                                G = S.position.y * i,
                                W = w[(k = S.texture).baseTexture.uid],
                                V = k.frame,
                                X = k._uvs,
                                H = W.index++;
                            W.indices[6 * H + 0] = 0 + 4 * H, W.indices[6 * H + 1] = 1 + 4 * H, W.indices[6 * H + 2] = 2 + 4 * H, W.indices[6 * H + 3] = 0 + 4 * H, W.indices[6 * H + 4] = 2 + 4 * H, W.indices[6 * H + 5] = 3 + 4 * H, W.vertices[8 * H + 0] = U, W.vertices[8 * H + 1] = G, W.vertices[8 * H + 2] = U + V.width * i, W.vertices[8 * H + 3] = G, W.vertices[8 * H + 4] = U + V.width * i, W.vertices[8 * H + 5] = G + V.height * i, W.vertices[8 * H + 6] = U, W.vertices[8 * H + 7] = G + V.height * i, W.uvs[8 * H + 0] = X.x0, W.uvs[8 * H + 1] = X.y0, W.uvs[8 * H + 2] = X.x1, W.uvs[8 * H + 3] = X.y1, W.uvs[8 * H + 4] = X.x2, W.uvs[8 * H + 5] = X.y2, W.uvs[8 * H + 6] = X.x3, W.uvs[8 * H + 7] = X.y3
                        }
                        for (var _ in this._textWidth = c * i, this._textHeight = (n.y + e.lineHeight) * i, w) {
                            var Y = w[_];
                            if (0 !== this.anchor.x || 0 !== this.anchor.y)
                                for (var j = 0, z = this._textWidth * this.anchor.x, K = this._textHeight * this.anchor.y, q = 0; q < Y.total; q++) Y.vertices[j++] -= z, Y.vertices[j++] -= K, Y.vertices[j++] -= z, Y.vertices[j++] -= K, Y.vertices[j++] -= z, Y.vertices[j++] -= K, Y.vertices[j++] -= z, Y.vertices[j++] -= K;
                            this._maxLineHeight = m * i;
                            var Z = Y.mesh.geometry.getBuffer("aVertexPosition"),
                                $ = Y.mesh.geometry.getBuffer("aTextureCoord"),
                                J = Y.mesh.geometry.getIndex();
                            Z.data = Y.vertices, $.data = Y.uvs, J.data = Y.indices, Z.update(), $.update(), J.update()
                        }
                        for (_ = 0; _ < r.length; _++) rs.push(r[_])
                    }, e.prototype.updateTransform = function () {
                        this.validate(), this.containerUpdateTransform()
                    }, e.prototype.getLocalBounds = function () {
                        return this.validate(), t.prototype.getLocalBounds.call(this)
                    }, e.prototype.validate = function () {
                        this.dirty && (this.updateText(), this.dirty = !1)
                    }, Object.defineProperty(e.prototype, "tint", {
                        get: function () {
                            return this._tint
                        },
                        set: function (t) {
                            if (this._tint !== t) {
                                this._tint = t;
                                for (var e = 0; e < this._activePagesMeshData.length; e++) this._activePagesMeshData[e].mesh.tint = t
                            }
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "align", {
                        get: function () {
                            return this._align
                        },
                        set: function (t) {
                            this._align !== t && (this._align = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "fontName", {
                        get: function () {
                            return this._fontName
                        },
                        set: function (t) {
                            if (!is.available[t]) throw new Error('Missing BitmapFont "' + t + '"');
                            this._fontName !== t && (this._fontName = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "fontSize", {
                        get: function () {
                            return this._fontSize
                        },
                        set: function (t) {
                            this._fontSize !== t && (this._fontSize = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "anchor", {
                        get: function () {
                            return this._anchor
                        },
                        set: function (t) {
                            "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "text", {
                        get: function () {
                            return this._text
                        },
                        set: function (t) {
                            t = String(null == t ? "" : t), this._text !== t && (this._text = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "maxWidth", {
                        get: function () {
                            return this._maxWidth
                        },
                        set: function (t) {
                            this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "maxLineHeight", {
                        get: function () {
                            return this.validate(), this._maxLineHeight
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "textWidth", {
                        get: function () {
                            return this.validate(), this._textWidth
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "letterSpacing", {
                        get: function () {
                            return this._letterSpacing
                        },
                        set: function (t) {
                            this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "roundPixels", {
                        get: function () {
                            return this._roundPixels
                        },
                        set: function (t) {
                            t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0)
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "textHeight", {
                        get: function () {
                            return this.validate(), this._textHeight
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype._upgradeStyle = function (t) {
                        if ("string" == typeof t.font) {
                            var e = t.font.split(" ");
                            t.fontName = 1 === e.length ? e[0] : e.slice(1).join(" "), e.length >= 2 && (t.fontSize = parseInt(e[0], 10))
                        } else t.fontName = t.font.name, t.fontSize = "number" == typeof t.font.size ? t.font.size : parseInt(t.font.size, 10)
                    }, e.prototype.destroy = function (e) {
                        var i = this._textureCache;
                        for (var n in i) i[n].destroy(), delete i[n];
                        this._textureCache = null, t.prototype.destroy.call(this, e)
                    }, e.registerFont = function (t, e) {
                        return It("5.3.0", "PIXI.BitmapText.registerFont is deprecated, use PIXI.BitmapFont.install"), is.install(t, e)
                    }, Object.defineProperty(e, "fonts", {
                        get: function () {
                            return It("5.3.0", "PIXI.BitmapText.fonts is deprecated, use PIXI.BitmapFont.available"), is.available
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.styleDefaults = {
                        align: "left",
                        tint: 16777215,
                        maxWidth: 0,
                        letterSpacing: 0
                    }, e
                }(ce),
                ss = function () {
                    function t() { }
                    return t.add = function () {
                        ur.setExtensionXhrType("fnt", ur.XHR_RESPONSE_TYPE.TEXT)
                    }, t.use = function (e, i) {
                        var n = ts(e.data);
                        if (n)
                            for (var r = t.getBaseUrl(this, e), o = n.parse(e.data), s = {}, a = function (t) {
                                s[t.metadata.pageFile] = t.texture, Object.keys(s).length === o.page.length && (e.bitmapFont = is.install(o, s, !0), i())
                            }, l = 0; l < o.page.length; ++l) {
                                var h = o.page[l].file,
                                    u = r + h,
                                    c = !1;
                                for (var d in this.resources) {
                                    var p = this.resources[d];
                                    if (p.url === u) {
                                        p.metadata.pageFile = h, p.texture ? a(p) : p.onAfterMiddleware.add(a), c = !0;
                                        break
                                    }
                                }
                                if (!c) {
                                    var f = {
                                        crossOrigin: e.crossOrigin,
                                        loadType: ur.LOAD_TYPE.IMAGE,
                                        metadata: Object.assign({
                                            pageFile: h
                                        }, e.metadata.imageMetadata),
                                        parentResource: e
                                    };
                                    this.add(u, f, a)
                                }
                            } else i()
                    }, t.getBaseUrl = function (e, i) {
                        var n = i.isDataUrl ? "" : t.dirname(i.url);
                        return i.isDataUrl && ("." === n && (n = ""), e.baseUrl && n && "/" === e.baseUrl.charAt(e.baseUrl.length - 1) && (n += "/")), (n = n.replace(e.baseUrl, "")) && "/" !== n.charAt(n.length - 1) && (n += "/"), n
                    }, t.dirname = function (t) {
                        var e = t.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
                        return e === t ? "." : "" === e ? "/" : e
                    }, t
                }(),
                as = function (t, e) {
                    return as = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, as(t, e)
                },
                ls = function (t) {
                    function e(e) {
                        void 0 === e && (e = 1);
                        var i = t.call(this, Cn, "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n", {
                            uAlpha: 1
                        }) || this;
                        return i.alpha = e, i
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        as(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), Object.defineProperty(e.prototype, "alpha", {
                        get: function () {
                            return this.uniforms.uAlpha
                        },
                        set: function (t) {
                            this.uniforms.uAlpha = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(tn),
                hs = function (t, e) {
                    return hs = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, hs(t, e)
                };

            function us(t, e) {
                function i() {
                    this.constructor = t
                }
                hs(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var cs, ds, ps, fs, gs, ms, _s, ys, Ss, vs, bs, Ts, Ps, As, Is, ws, Es, Cs = {
                5: [.153388, .221461, .250301],
                7: [.071303, .131514, .189879, .214607],
                9: [.028532, .067234, .124009, .179044, .20236],
                11: [.0093, .028002, .065984, .121703, .175713, .198596],
                13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
                15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
            },
                xs = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
            ! function (t) {
                t[t.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", t[t.WEBGL = 1] = "WEBGL", t[t.WEBGL2 = 2] = "WEBGL2"
            }(cs || (cs = {})),
                function (t) {
                    t[t.UNKNOWN = 0] = "UNKNOWN", t[t.WEBGL = 1] = "WEBGL", t[t.CANVAS = 2] = "CANVAS"
                }(ds || (ds = {})),
                function (t) {
                    t[t.COLOR = 16384] = "COLOR", t[t.DEPTH = 256] = "DEPTH", t[t.STENCIL = 1024] = "STENCIL"
                }(ps || (ps = {})),
                function (t) {
                    t[t.NORMAL = 0] = "NORMAL", t[t.ADD = 1] = "ADD", t[t.MULTIPLY = 2] = "MULTIPLY", t[t.SCREEN = 3] = "SCREEN", t[t.OVERLAY = 4] = "OVERLAY", t[t.DARKEN = 5] = "DARKEN", t[t.LIGHTEN = 6] = "LIGHTEN", t[t.COLOR_DODGE = 7] = "COLOR_DODGE", t[t.COLOR_BURN = 8] = "COLOR_BURN", t[t.HARD_LIGHT = 9] = "HARD_LIGHT", t[t.SOFT_LIGHT = 10] = "SOFT_LIGHT", t[t.DIFFERENCE = 11] = "DIFFERENCE", t[t.EXCLUSION = 12] = "EXCLUSION", t[t.HUE = 13] = "HUE", t[t.SATURATION = 14] = "SATURATION", t[t.COLOR = 15] = "COLOR", t[t.LUMINOSITY = 16] = "LUMINOSITY", t[t.NORMAL_NPM = 17] = "NORMAL_NPM", t[t.ADD_NPM = 18] = "ADD_NPM", t[t.SCREEN_NPM = 19] = "SCREEN_NPM", t[t.NONE = 20] = "NONE", t[t.SRC_OVER = 0] = "SRC_OVER", t[t.SRC_IN = 21] = "SRC_IN", t[t.SRC_OUT = 22] = "SRC_OUT", t[t.SRC_ATOP = 23] = "SRC_ATOP", t[t.DST_OVER = 24] = "DST_OVER", t[t.DST_IN = 25] = "DST_IN", t[t.DST_OUT = 26] = "DST_OUT", t[t.DST_ATOP = 27] = "DST_ATOP", t[t.ERASE = 26] = "ERASE", t[t.SUBTRACT = 28] = "SUBTRACT", t[t.XOR = 29] = "XOR"
                }(fs || (fs = {})),
                function (t) {
                    t[t.POINTS = 0] = "POINTS", t[t.LINES = 1] = "LINES", t[t.LINE_LOOP = 2] = "LINE_LOOP", t[t.LINE_STRIP = 3] = "LINE_STRIP", t[t.TRIANGLES = 4] = "TRIANGLES", t[t.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", t[t.TRIANGLE_FAN = 6] = "TRIANGLE_FAN"
                }(gs || (gs = {})),
                function (t) {
                    t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL"
                }(ms || (ms = {})),
                function (t) {
                    t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z"
                }(_s || (_s = {})),
                function (t) {
                    t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.FLOAT = 5126] = "FLOAT", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT"
                }(ys || (ys = {})),
                function (t) {
                    t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR"
                }(Ss || (Ss = {})),
                function (t) {
                    t[t.CLAMP = 33071] = "CLAMP", t[t.REPEAT = 10497] = "REPEAT", t[t.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT"
                }(vs || (vs = {})),
                function (t) {
                    t[t.OFF = 0] = "OFF", t[t.POW2 = 1] = "POW2", t[t.ON = 2] = "ON"
                }(bs || (bs = {})),
                function (t) {
                    t[t.NPM = 0] = "NPM", t[t.UNPACK = 1] = "UNPACK", t[t.PMA = 2] = "PMA", t[t.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", t[t.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", t[t.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA"
                }(Ts || (Ts = {})),
                function (t) {
                    t[t.NO = 0] = "NO", t[t.YES = 1] = "YES", t[t.AUTO = 2] = "AUTO", t[t.BLEND = 0] = "BLEND", t[t.CLEAR = 1] = "CLEAR", t[t.BLIT = 2] = "BLIT"
                }(Ps || (Ps = {})),
                function (t) {
                    t[t.AUTO = 0] = "AUTO", t[t.MANUAL = 1] = "MANUAL"
                }(As || (As = {})),
                function (t) {
                    t.LOW = "lowp", t.MEDIUM = "mediump", t.HIGH = "highp"
                }(Is || (Is = {})),
                function (t) {
                    t[t.NONE = 0] = "NONE", t[t.SCISSOR = 1] = "SCISSOR", t[t.STENCIL = 2] = "STENCIL", t[t.SPRITE = 3] = "SPRITE"
                }(ws || (ws = {})),
                function (t) {
                    t[t.NONE = 0] = "NONE", t[t.LOW = 2] = "LOW", t[t.MEDIUM = 4] = "MEDIUM", t[t.HIGH = 8] = "HIGH"
                }(Es || (Es = {}));
            var Bs = function (t) {
                function e(e, i, n, r, o) {
                    void 0 === i && (i = 8), void 0 === n && (n = 4), void 0 === r && (r = j.FILTER_RESOLUTION), void 0 === o && (o = 5);
                    var s = this,
                        a = function (t, e) {
                            var i, n = Math.ceil(t / 2),
                                r = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }",
                                o = "";
                            i = e ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
                            for (var s = 0; s < t; s++) {
                                var a = i.replace("%index%", s.toString());
                                o += a = a.replace("%sampleIndex%", s - (n - 1) + ".0"), o += "\n"
                            }
                            return (r = r.replace("%blur%", o)).replace("%size%", t.toString())
                        }(o, e),
                        l = function (t) {
                            for (var e, i = Cs[t], n = i.length, r = xs, o = "", s = 0; s < t; s++) {
                                var a = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", s.toString());
                                e = s, s >= n && (e = t - s - 1), o += a = a.replace("%value%", i[e].toString()), o += "\n"
                            }
                            return (r = r.replace("%blur%", o)).replace("%size%", t.toString())
                        }(o);
                    return (s = t.call(this, a, l) || this).horizontal = e, s.resolution = r, s._quality = 0, s.quality = n, s.blur = i, s
                }
                return us(e, t), e.prototype.apply = function (t, e, i, n) {
                    if (i ? this.horizontal ? this.uniforms.strength = 1 / i.width * (i.width / e.width) : this.uniforms.strength = 1 / i.height * (i.height / e.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / e.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / e.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) t.applyFilter(this, e, i, n);
                    else {
                        var r = t.getFilterTexture(),
                            o = t.renderer,
                            s = e,
                            a = r;
                        this.state.blend = !1, t.applyFilter(this, s, a, Ps.CLEAR);
                        for (var l = 1; l < this.passes - 1; l++) {
                            t.bindAndClear(s, Ps.BLIT), this.uniforms.uSampler = a;
                            var h = a;
                            a = s, s = h, o.shader.bind(this), o.geometry.draw(5)
                        }
                        this.state.blend = !0, t.applyFilter(this, a, i, n), t.returnFilterTexture(r)
                    }
                }, Object.defineProperty(e.prototype, "blur", {
                    get: function () {
                        return this.strength
                    },
                    set: function (t) {
                        this.padding = 1 + 2 * Math.abs(t), this.strength = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), Object.defineProperty(e.prototype, "quality", {
                    get: function () {
                        return this._quality
                    },
                    set: function (t) {
                        this._quality = t, this.passes = t
                    },
                    enumerable: !1,
                    configurable: !0
                }), e
            }(tn),
                Ls = function (t) {
                    function e(e, i, n, r) {
                        void 0 === e && (e = 8), void 0 === i && (i = 4), void 0 === n && (n = j.FILTER_RESOLUTION), void 0 === r && (r = 5);
                        var o = t.call(this) || this;
                        return o.blurXFilter = new Bs(!0, e, i, n, r), o.blurYFilter = new Bs(!1, e, i, n, r), o.resolution = n, o.quality = i, o.blur = e, o.repeatEdgePixels = !1, o
                    }
                    return us(e, t), e.prototype.apply = function (t, e, i, n) {
                        var r = Math.abs(this.blurXFilter.strength),
                            o = Math.abs(this.blurYFilter.strength);
                        if (r && o) {
                            var s = t.getFilterTexture();
                            this.blurXFilter.apply(t, e, s, Ps.CLEAR), this.blurYFilter.apply(t, s, i, n), t.returnFilterTexture(s)
                        } else o ? this.blurYFilter.apply(t, e, i, n) : this.blurXFilter.apply(t, e, i, n)
                    }, e.prototype.updatePadding = function () {
                        this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
                    }, Object.defineProperty(e.prototype, "blur", {
                        get: function () {
                            return this.blurXFilter.blur
                        },
                        set: function (t) {
                            this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "quality", {
                        get: function () {
                            return this.blurXFilter.quality
                        },
                        set: function (t) {
                            this.blurXFilter.quality = this.blurYFilter.quality = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "blurX", {
                        get: function () {
                            return this.blurXFilter.blur
                        },
                        set: function (t) {
                            this.blurXFilter.blur = t, this.updatePadding()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "blurY", {
                        get: function () {
                            return this.blurYFilter.blur
                        },
                        set: function (t) {
                            this.blurYFilter.blur = t, this.updatePadding()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "blendMode", {
                        get: function () {
                            return this.blurYFilter.blendMode
                        },
                        set: function (t) {
                            this.blurYFilter.blendMode = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "repeatEdgePixels", {
                        get: function () {
                            return this._repeatEdgePixels
                        },
                        set: function (t) {
                            this._repeatEdgePixels = t, this.updatePadding()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(tn),
                Os = function (t, e) {
                    return Os = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Os(t, e)
                },
                Ns = function (t) {
                    function e() {
                        var e = this,
                            i = {
                                m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
                                uAlpha: 1
                            };
                        return (e = t.call(this, xn, "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n", i) || this).alpha = 1, e
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        Os(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype._loadMatrix = function (t, e) {
                        void 0 === e && (e = !1);
                        var i = t;
                        e && (this._multiply(i, this.uniforms.m, t), i = this._colorMatrix(i)), this.uniforms.m = i
                    }, e.prototype._multiply = function (t, e, i) {
                        return t[0] = e[0] * i[0] + e[1] * i[5] + e[2] * i[10] + e[3] * i[15], t[1] = e[0] * i[1] + e[1] * i[6] + e[2] * i[11] + e[3] * i[16], t[2] = e[0] * i[2] + e[1] * i[7] + e[2] * i[12] + e[3] * i[17], t[3] = e[0] * i[3] + e[1] * i[8] + e[2] * i[13] + e[3] * i[18], t[4] = e[0] * i[4] + e[1] * i[9] + e[2] * i[14] + e[3] * i[19] + e[4], t[5] = e[5] * i[0] + e[6] * i[5] + e[7] * i[10] + e[8] * i[15], t[6] = e[5] * i[1] + e[6] * i[6] + e[7] * i[11] + e[8] * i[16], t[7] = e[5] * i[2] + e[6] * i[7] + e[7] * i[12] + e[8] * i[17], t[8] = e[5] * i[3] + e[6] * i[8] + e[7] * i[13] + e[8] * i[18], t[9] = e[5] * i[4] + e[6] * i[9] + e[7] * i[14] + e[8] * i[19] + e[9], t[10] = e[10] * i[0] + e[11] * i[5] + e[12] * i[10] + e[13] * i[15], t[11] = e[10] * i[1] + e[11] * i[6] + e[12] * i[11] + e[13] * i[16], t[12] = e[10] * i[2] + e[11] * i[7] + e[12] * i[12] + e[13] * i[17], t[13] = e[10] * i[3] + e[11] * i[8] + e[12] * i[13] + e[13] * i[18], t[14] = e[10] * i[4] + e[11] * i[9] + e[12] * i[14] + e[13] * i[19] + e[14], t[15] = e[15] * i[0] + e[16] * i[5] + e[17] * i[10] + e[18] * i[15], t[16] = e[15] * i[1] + e[16] * i[6] + e[17] * i[11] + e[18] * i[16], t[17] = e[15] * i[2] + e[16] * i[7] + e[17] * i[12] + e[18] * i[17], t[18] = e[15] * i[3] + e[16] * i[8] + e[17] * i[13] + e[18] * i[18], t[19] = e[15] * i[4] + e[16] * i[9] + e[17] * i[14] + e[18] * i[19] + e[19], t
                    }, e.prototype._colorMatrix = function (t) {
                        var e = new Float32Array(t);
                        return e[4] /= 255, e[9] /= 255, e[14] /= 255, e[19] /= 255, e
                    }, e.prototype.brightness = function (t, e) {
                        var i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(i, e)
                    }, e.prototype.greyscale = function (t, e) {
                        var i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(i, e)
                    }, e.prototype.blackAndWhite = function (t) {
                        this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], t)
                    }, e.prototype.hue = function (t, e) {
                        t = (t || 0) / 180 * Math.PI;
                        var i = Math.cos(t),
                            n = Math.sin(t),
                            r = 1 / 3,
                            o = (0, Math.sqrt)(r),
                            s = [i + (1 - i) * r, r * (1 - i) - o * n, r * (1 - i) + o * n, 0, 0, r * (1 - i) + o * n, i + r * (1 - i), r * (1 - i) - o * n, 0, 0, r * (1 - i) - o * n, r * (1 - i) + o * n, i + r * (1 - i), 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(s, e)
                    }, e.prototype.contrast = function (t, e) {
                        var i = (t || 0) + 1,
                            n = -.5 * (i - 1),
                            r = [i, 0, 0, 0, n, 0, i, 0, 0, n, 0, 0, i, 0, n, 0, 0, 0, 1, 0];
                        this._loadMatrix(r, e)
                    }, e.prototype.saturate = function (t, e) {
                        void 0 === t && (t = 0);
                        var i = 2 * t / 3 + 1,
                            n = -.5 * (i - 1),
                            r = [i, n, n, 0, 0, n, i, n, 0, 0, n, n, i, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(r, e)
                    }, e.prototype.desaturate = function () {
                        this.saturate(-1)
                    }, e.prototype.negative = function (t) {
                        this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], t)
                    }, e.prototype.sepia = function (t) {
                        this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], t)
                    }, e.prototype.technicolor = function (t) {
                        this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], t)
                    }, e.prototype.polaroid = function (t) {
                        this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], t)
                    }, e.prototype.toBGR = function (t) {
                        this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], t)
                    }, e.prototype.kodachrome = function (t) {
                        this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], t)
                    }, e.prototype.browni = function (t) {
                        this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], t)
                    }, e.prototype.vintage = function (t) {
                        this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], t)
                    }, e.prototype.colorTone = function (t, e, i, n, r) {
                        var o = ((i = i || 16770432) >> 16 & 255) / 255,
                            s = (i >> 8 & 255) / 255,
                            a = (255 & i) / 255,
                            l = ((n = n || 3375104) >> 16 & 255) / 255,
                            h = (n >> 8 & 255) / 255,
                            u = (255 & n) / 255,
                            c = [.3, .59, .11, 0, 0, o, s, a, t = t || .2, 0, l, h, u, e = e || .15, 0, o - l, s - h, a - u, 0, 0];
                        this._loadMatrix(c, r)
                    }, e.prototype.night = function (t, e) {
                        var i = [-2 * (t = t || .1), -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, 2 * t, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(i, e)
                    }, e.prototype.predator = function (t, e) {
                        var i = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
                        this._loadMatrix(i, e)
                    }, e.prototype.lsd = function (t) {
                        this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], t)
                    }, e.prototype.reset = function () {
                        this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
                    }, Object.defineProperty(e.prototype, "matrix", {
                        get: function () {
                            return this.uniforms.m
                        },
                        set: function (t) {
                            this.uniforms.m = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "alpha", {
                        get: function () {
                            return this.uniforms.uAlpha
                        },
                        set: function (t) {
                            this.uniforms.uAlpha = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(tn);
            Ns.prototype.grayscale = Ns.prototype.greyscale;
            var Ms = function (t, e) {
                return Ms = Object.setPrototypeOf || {
                    __proto__: []
                }
                    instanceof Array && function (t, e) {
                        t.__proto__ = e
                    } || function (t, e) {
                        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                    }, Ms(t, e)
            },
                Rs = function (t) {
                    function e(e, i) {
                        var n = this,
                            r = new qt;
                        return e.renderable = !1, (n = t.call(this, "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n", "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n", {
                            mapSampler: e._texture,
                            filterMatrix: r,
                            scale: {
                                x: 1,
                                y: 1
                            },
                            rotation: new Float32Array([1, 0, 0, 1])
                        }) || this).maskSprite = e, n.maskMatrix = r, null == i && (i = 20), n.scale = new zt(i, i), n
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        Ms(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype.apply = function (t, e, i, n) {
                        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
                        var r = this.maskSprite.worldTransform,
                            o = Math.sqrt(r.a * r.a + r.b * r.b),
                            s = Math.sqrt(r.c * r.c + r.d * r.d);
                        0 !== o && 0 !== s && (this.uniforms.rotation[0] = r.a / o, this.uniforms.rotation[1] = r.b / o, this.uniforms.rotation[2] = r.c / s, this.uniforms.rotation[3] = r.d / s), t.applyFilter(this, e, i, n)
                    }, Object.defineProperty(e.prototype, "map", {
                        get: function () {
                            return this.uniforms.mapSampler
                        },
                        set: function (t) {
                            this.uniforms.mapSampler = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(tn),
                Ds = function (t, e) {
                    return Ds = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Ds(t, e)
                },
                Fs = function (t) {
                    function e() {
                        return t.call(this, "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputPixel;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n", 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputPixel;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputPixel.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n') || this
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        Ds(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e
                }(tn),
                ks = function (t, e) {
                    return ks = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, ks(t, e)
                },
                Us = function (t) {
                    function e(e, i) {
                        void 0 === e && (e = .5), void 0 === i && (i = Math.random());
                        var n = t.call(this, xn, "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n", {
                            uNoise: 0,
                            uSeed: 0
                        }) || this;
                        return n.noise = e, n.seed = i, n
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        ks(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), Object.defineProperty(e.prototype, "noise", {
                        get: function () {
                            return this.uniforms.uNoise
                        },
                        set: function (t) {
                            this.uniforms.uNoise = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "seed", {
                        get: function () {
                            return this.uniforms.uSeed
                        },
                        set: function (t) {
                            this.uniforms.uSeed = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(tn),
                Gs = new qt;
            le.prototype._cacheAsBitmap = !1, le.prototype._cacheData = null;
            var Ws = function () {
                this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
            };
            Object.defineProperties(le.prototype, {
                cacheAsBitmap: {
                    get: function () {
                        return this._cacheAsBitmap
                    },
                    set: function (t) {
                        var e;
                        this._cacheAsBitmap !== t && (this._cacheAsBitmap = t, t ? (this._cacheData || (this._cacheData = new Ws), (e = this._cacheData).originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : ((e = this._cacheData).sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea))
                    }
                }
            }), le.prototype._renderCached = function (t) {
                !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
            }, le.prototype._initCachedDisplayObject = function (t) {
                if (!this._cacheData || !this._cacheData.sprite) {
                    var e = this.alpha;
                    this.alpha = 1, t.batch.flush();
                    var i = this.getLocalBounds(null, !0).clone();
                    if (this.filters) {
                        var n = this.filters[0].padding;
                        i.pad(n)
                    }
                    i.ceil(j.RESOLUTION);
                    var r = t.renderTexture.current,
                        o = t.renderTexture.sourceFrame.clone(),
                        s = t.renderTexture.destinationFrame.clone(),
                        a = t.projection.transform,
                        l = ti.create({
                            width: i.width,
                            height: i.height
                        }),
                        h = "cacheAsBitmap_" + Pt();
                    this._cacheData.textureCacheId = h, Re.addToCache(l.baseTexture, h), Je.addToCache(l, h);
                    var u = this.transform.localTransform.copyTo(Gs).invert().translate(-i.x, -i.y);
                    this.render = this._cacheData.originalRender, t.render(this, l, !0, u, !1), t.projection.transform = a, t.renderTexture.bind(r, o, s), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null;
                    var c = new no(l);
                    c.transform.worldTransform = this.transform.worldTransform, c.anchor.x = -i.x / i.width, c.anchor.y = -i.y / i.height, c.alpha = e, c._bounds = this._bounds, this._cacheData.sprite = c, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = c.containsPoint.bind(c)
                }
            }, le.prototype._renderCachedCanvas = function (t) {
                !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
            }, le.prototype._initCachedDisplayObjectCanvas = function (t) {
                if (!this._cacheData || !this._cacheData.sprite) {
                    var e = this.getLocalBounds(null, !0),
                        i = this.alpha;
                    this.alpha = 1;
                    var n = t.context,
                        r = t._projTransform;
                    e.ceil(j.RESOLUTION);
                    var o = ti.create({
                        width: e.width,
                        height: e.height
                    }),
                        s = "cacheAsBitmap_" + Pt();
                    this._cacheData.textureCacheId = s, Re.addToCache(o.baseTexture, s), Je.addToCache(o, s);
                    var a = Gs;
                    this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, o, !0, a, !1), t.context = n, t._projTransform = r, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null;
                    var l = new no(o);
                    l.transform.worldTransform = this.transform.worldTransform, l.anchor.x = -e.x / e.width, l.anchor.y = -e.y / e.height, l.alpha = i, l._bounds = this._bounds, this._cacheData.sprite = l, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = l.containsPoint.bind(l)
                }
            }, le.prototype._calculateCachedBounds = function () {
                this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
            }, le.prototype._getCachedLocalBounds = function () {
                return this._cacheData.sprite.getLocalBounds(null)
            }, le.prototype._destroyCachedDisplayObject = function () {
                this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Re.removeFromCache(this._cacheData.textureCacheId), Je.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
            }, le.prototype._cacheAsBitmapDestroy = function (t) {
                this.cacheAsBitmap = !1, this.destroy(t)
            }, le.prototype.name = null, ce.prototype.getChildByName = function (t, e) {
                for (var i = 0, n = this.children.length; i < n; i++)
                    if (this.children[i].name === t) return this.children[i];
                if (e)
                    for (i = 0, n = this.children.length; i < n; i++)
                        if (this.children[i].getChildByName) {
                            var r = this.children[i].getChildByName(t, !0);
                            if (r) return r
                        } return null
            }, le.prototype.getGlobalPosition = function (t, e) {
                return void 0 === t && (t = new zt), void 0 === e && (e = !1), this.parent ? this.parent.toGlobal(this.position, t, e) : (t.x = this.position.x, t.y = this.position.y), t
            };
            var Vs = function (t, e) {
                return Vs = Object.setPrototypeOf || {
                    __proto__: []
                }
                    instanceof Array && function (t, e) {
                        t.__proto__ = e
                    } || function (t, e) {
                        for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                    }, Vs(t, e)
            };

            function Xs(t, e) {
                function i() {
                    this.constructor = t
                }
                Vs(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var Hs = function (t) {
                function e(e, i, n, r) {
                    void 0 === e && (e = 100), void 0 === i && (i = 100), void 0 === n && (n = 10), void 0 === r && (r = 10);
                    var o = t.call(this) || this;
                    return o.segWidth = n, o.segHeight = r, o.width = e, o.height = i, o.build(), o
                }
                return Xs(e, t), e.prototype.build = function () {
                    for (var t = this.segWidth * this.segHeight, e = [], i = [], n = [], r = this.segWidth - 1, o = this.segHeight - 1, s = this.width / r, a = this.height / o, l = 0; l < t; l++) {
                        var h = l % this.segWidth,
                            u = l / this.segWidth | 0;
                        e.push(h * s, u * a), i.push(h / r, u / o)
                    }
                    var c = r * o;
                    for (l = 0; l < c; l++) {
                        var d = l % r,
                            p = l / r | 0,
                            f = p * this.segWidth + d,
                            g = p * this.segWidth + d + 1,
                            m = (p + 1) * this.segWidth + d,
                            _ = (p + 1) * this.segWidth + d + 1;
                        n.push(f, g, m, g, _, m)
                    }
                    this.buffers[0].data = new Float32Array(e), this.buffers[1].data = new Float32Array(i), this.indexBuffer.data = new Uint16Array(n), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
                }, e
            }(zo),
                Ys = function (t) {
                    function e(e, i, n) {
                        void 0 === e && (e = 200), void 0 === n && (n = 0);
                        var r = t.call(this, new Float32Array(4 * i.length), new Float32Array(4 * i.length), new Uint16Array(6 * (i.length - 1))) || this;
                        return r.points = i, r._width = e, r.textureScale = n, r.build(), r
                    }
                    return Xs(e, t), Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return this._width
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.build = function () {
                        var t = this.points;
                        if (t) {
                            var e = this.getBuffer("aVertexPosition"),
                                i = this.getBuffer("aTextureCoord"),
                                n = this.getIndex();
                            if (!(t.length < 1)) {
                                e.data.length / 4 !== t.length && (e.data = new Float32Array(4 * t.length), i.data = new Float32Array(4 * t.length), n.data = new Uint16Array(6 * (t.length - 1)));
                                var r = i.data,
                                    o = n.data;
                                r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1;
                                for (var s = 0, a = t[0], l = this._width * this.textureScale, h = t.length, u = 0; u < h; u++) {
                                    var c = 4 * u;
                                    if (this.textureScale > 0) {
                                        var d = a.x - t[u].x,
                                            p = a.y - t[u].y,
                                            f = Math.sqrt(d * d + p * p);
                                        a = t[u], s += f / l
                                    } else s = u / (h - 1);
                                    r[c] = s, r[c + 1] = 0, r[c + 2] = s, r[c + 3] = 1
                                }
                                var g = 0;
                                for (u = 0; u < h - 1; u++) c = 2 * u, o[g++] = c, o[g++] = c + 1, o[g++] = c + 2, o[g++] = c + 2, o[g++] = c + 1, o[g++] = c + 3;
                                i.update(), n.update(), this.updateVertices()
                            }
                        }
                    }, e.prototype.updateVertices = function () {
                        var t = this.points;
                        if (!(t.length < 1)) {
                            for (var e, i = t[0], n = 0, r = 0, o = this.buffers[0].data, s = t.length, a = 0; a < s; a++) {
                                var l = t[a],
                                    h = 4 * a;
                                r = -((e = a < t.length - 1 ? t[a + 1] : l).x - i.x), n = e.y - i.y;
                                var u = Math.sqrt(n * n + r * r),
                                    c = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
                                n /= u, r /= u, n *= c, r *= c, o[h] = l.x + n, o[h + 1] = l.y + r, o[h + 2] = l.x - n, o[h + 3] = l.y - r, i = l
                            }
                            this.buffers[0].update()
                        }
                    }, e.prototype.update = function () {
                        this.textureScale > 0 ? this.build() : this.updateVertices()
                    }, e
                }(zo),
                js = function (t) {
                    function e(e, i, n) {
                        void 0 === n && (n = 0);
                        var r = this,
                            o = new Ys(e.height, i, n),
                            s = new jo(e);
                        return n > 0 && (e.baseTexture.wrapMode = b.REPEAT), (r = t.call(this, o, s) || this).autoUpdate = !0, r
                    }
                    return Xs(e, t), e.prototype._render = function (e) {
                        var i = this.geometry;
                        (this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height, i.update()), t.prototype._render.call(this, e)
                    }, e
                }(Yo),
                zs = function (t) {
                    function e(e, i, n) {
                        var r = this,
                            o = new Hs(e.width, e.height, i, n),
                            s = new jo(Je.WHITE);
                        return (r = t.call(this, o, s) || this).texture = e, r
                    }
                    return Xs(e, t), e.prototype.textureUpdated = function () {
                        this._textureID = this.shader.texture._updateID;
                        var t = this.geometry;
                        t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build()
                    }, Object.defineProperty(e.prototype, "texture", {
                        get: function () {
                            return this.shader.texture
                        },
                        set: function (t) {
                            this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype._render = function (e) {
                        this._textureID !== this.shader.texture._updateID && this.textureUpdated(), t.prototype._render.call(this, e)
                    }, e.prototype.destroy = function (e) {
                        this.shader.texture.off("update", this.textureUpdated, this), t.prototype.destroy.call(this, e)
                    }, e
                }(Yo),
                Ks = function (t) {
                    function e(e, i, n, r, o) {
                        void 0 === e && (e = Je.EMPTY);
                        var s = this,
                            a = new zo(i, n, r);
                        a.getBuffer("aVertexPosition").static = !1;
                        var l = new jo(e);
                        return (s = t.call(this, a, l, null, o) || this).autoUpdate = !0, s
                    }
                    return Xs(e, t), Object.defineProperty(e.prototype, "vertices", {
                        get: function () {
                            return this.geometry.getBuffer("aVertexPosition").data
                        },
                        set: function (t) {
                            this.geometry.getBuffer("aVertexPosition").data = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype._render = function (e) {
                        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), t.prototype._render.call(this, e)
                    }, e
                }(Yo),
                qs = function (t) {
                    function e(e, i, n, r, o) {
                        void 0 === i && (i = 10), void 0 === n && (n = 10), void 0 === r && (r = 10), void 0 === o && (o = 10);
                        var s = t.call(this, Je.WHITE, 4, 4) || this;
                        return s._origWidth = e.orig.width, s._origHeight = e.orig.height, s._width = s._origWidth, s._height = s._origHeight, s._leftWidth = i, s._rightWidth = r, s._topHeight = n, s._bottomHeight = o, s.texture = e, s
                    }
                    return Xs(e, t), e.prototype.textureUpdated = function () {
                        this._textureID = this.shader.texture._updateID, this._refresh()
                    }, Object.defineProperty(e.prototype, "vertices", {
                        get: function () {
                            return this.geometry.getBuffer("aVertexPosition").data
                        },
                        set: function (t) {
                            this.geometry.getBuffer("aVertexPosition").data = t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.updateHorizontalVertices = function () {
                        var t = this.vertices,
                            e = this._getMinScale();
                        t[9] = t[11] = t[13] = t[15] = this._topHeight * e, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * e, t[25] = t[27] = t[29] = t[31] = this._height
                    }, e.prototype.updateVerticalVertices = function () {
                        var t = this.vertices,
                            e = this._getMinScale();
                        t[2] = t[10] = t[18] = t[26] = this._leftWidth * e, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e, t[6] = t[14] = t[22] = t[30] = this._width
                    }, e.prototype._getMinScale = function () {
                        var t = this._leftWidth + this._rightWidth,
                            e = this._width > t ? 1 : this._width / t,
                            i = this._topHeight + this._bottomHeight,
                            n = this._height > i ? 1 : this._height / i;
                        return Math.min(e, n)
                    }, Object.defineProperty(e.prototype, "width", {
                        get: function () {
                            return this._width
                        },
                        set: function (t) {
                            this._width = t, this._refresh()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "height", {
                        get: function () {
                            return this._height
                        },
                        set: function (t) {
                            this._height = t, this._refresh()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "leftWidth", {
                        get: function () {
                            return this._leftWidth
                        },
                        set: function (t) {
                            this._leftWidth = t, this._refresh()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "rightWidth", {
                        get: function () {
                            return this._rightWidth
                        },
                        set: function (t) {
                            this._rightWidth = t, this._refresh()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "topHeight", {
                        get: function () {
                            return this._topHeight
                        },
                        set: function (t) {
                            this._topHeight = t, this._refresh()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "bottomHeight", {
                        get: function () {
                            return this._bottomHeight
                        },
                        set: function (t) {
                            this._bottomHeight = t, this._refresh()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype._refresh = function () {
                        var t = this.texture,
                            e = this.geometry.buffers[1].data;
                        this._origWidth = t.orig.width, this._origHeight = t.orig.height;
                        var i = 1 / this._origWidth,
                            n = 1 / this._origHeight;
                        e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1, e[2] = e[10] = e[18] = e[26] = i * this._leftWidth, e[4] = e[12] = e[20] = e[28] = 1 - i * this._rightWidth, e[9] = e[11] = e[13] = e[15] = n * this._topHeight, e[17] = e[19] = e[21] = e[23] = 1 - n * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
                    }, e
                }(zs),
                Zs = function (t, e) {
                    return Zs = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Zs(t, e)
                },
                $s = function (t) {
                    function e(e, i) {
                        void 0 === i && (i = !0);
                        var n = t.call(this, e[0] instanceof Je ? e[0] : e[0].texture) || this;
                        return n._textures = null, n._durations = null, n._autoUpdate = i, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = e, n
                    }
                    return function (t, e) {
                        function i() {
                            this.constructor = t
                        }
                        Zs(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
                    }(e, t), e.prototype.stop = function () {
                        this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1))
                    }, e.prototype.play = function () {
                        this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (_e.shared.add(this.update, this, pe.HIGH), this._isConnectedToTicker = !0))
                    }, e.prototype.gotoAndStop = function (t) {
                        this.stop();
                        var e = this.currentFrame;
                        this._currentTime = t, e !== this.currentFrame && this.updateTexture()
                    }, e.prototype.gotoAndPlay = function (t) {
                        var e = this.currentFrame;
                        this._currentTime = t, e !== this.currentFrame && this.updateTexture(), this.play()
                    }, e.prototype.update = function (t) {
                        if (this._playing) {
                            var e = this.animationSpeed * t,
                                i = this.currentFrame;
                            if (null !== this._durations) {
                                var n = this._currentTime % 1 * this._durations[this.currentFrame];
                                for (n += e / 60 * 1e3; n < 0;) this._currentTime--, n += this._durations[this.currentFrame];
                                var r = Math.sign(this.animationSpeed * t);
                                for (this._currentTime = Math.floor(this._currentTime); n >= this._durations[this.currentFrame];) n -= this._durations[this.currentFrame] * r, this._currentTime += r;
                                this._currentTime += n / this._durations[this.currentFrame]
                            } else this._currentTime += e;
                            this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : i !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < i || this.animationSpeed < 0 && this.currentFrame > i) && this.onLoop(), this.updateTexture())
                        }
                    }, e.prototype.updateTexture = function () {
                        var t = this.currentFrame;
                        this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
                    }, e.prototype.destroy = function (e) {
                        this.stop(), t.prototype.destroy.call(this, e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
                    }, e.fromFrames = function (t) {
                        for (var i = [], n = 0; n < t.length; ++n) i.push(Je.from(t[n]));
                        return new e(i)
                    }, e.fromImages = function (t) {
                        for (var i = [], n = 0; n < t.length; ++n) i.push(Je.from(t[n]));
                        return new e(i)
                    }, Object.defineProperty(e.prototype, "totalFrames", {
                        get: function () {
                            return this._textures.length
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "textures", {
                        get: function () {
                            return this._textures
                        },
                        set: function (t) {
                            if (t[0] instanceof Je) this._textures = t, this._durations = null;
                            else {
                                this._textures = [], this._durations = [];
                                for (var e = 0; e < t.length; e++) this._textures.push(t[e].texture), this._durations.push(t[e].time)
                            }
                            this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "currentFrame", {
                        get: function () {
                            var t = Math.floor(this._currentTime) % this._textures.length;
                            return t < 0 && (t += this._textures.length), t
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "playing", {
                        get: function () {
                            return this._playing
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "autoUpdate", {
                        get: function () {
                            return this._autoUpdate
                        },
                        set: function (t) {
                            t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (_e.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (_e.shared.add(this.update, this), this._isConnectedToTicker = !0))
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }(no),
                Js = function (t, e) {
                    return Js = Object.setPrototypeOf || {
                        __proto__: []
                    }
                        instanceof Array && function (t, e) {
                            t.__proto__ = e
                        } || function (t, e) {
                            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
                        }, Js(t, e)
                };

            function Qs(t, e) {
                function i() {
                    this.constructor = t
                }
                Js(t, e), t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
            }
            var ta = "5.0.0";

            function ea() {
                var t = this;
                Object.defineProperties(t, {
                    SVG_SIZE: {
                        get: function () {
                            return It(ta, "PIXI.utils.SVG_SIZE property has moved to PIXI.resources.SVGResource.SVG_SIZE"), t.SVGResource.SVG_SIZE
                        }
                    },
                    TransformStatic: {
                        get: function () {
                            return It(ta, "PIXI.TransformStatic class has been removed, use PIXI.Transform"), t.Transform
                        }
                    },
                    TransformBase: {
                        get: function () {
                            return It(ta, "PIXI.TransformBase class has been removed, use PIXI.Transform"), t.Transform
                        }
                    },
                    TRANSFORM_MODE: {
                        get: function () {
                            return It(ta, "PIXI.TRANSFORM_MODE property has been removed"), {
                                STATIC: 0,
                                DYNAMIC: 1
                            }
                        }
                    },
                    WebGLRenderer: {
                        get: function () {
                            return It(ta, "PIXI.WebGLRenderer class has moved to PIXI.Renderer"), t.Renderer
                        }
                    },
                    CanvasRenderTarget: {
                        get: function () {
                            return It(ta, "PIXI.CanvasRenderTarget class has moved to PIXI.utils.CanvasRenderTarget"), t.utils.CanvasRenderTarget
                        }
                    },
                    loader: {
                        get: function () {
                            return It(ta, "PIXI.loader instance has moved to PIXI.Loader.shared"), t.Loader.shared
                        }
                    },
                    FilterManager: {
                        get: function () {
                            return It(ta, "PIXI.FilterManager class has moved to PIXI.systems.FilterSystem"), t.systems.FilterSystem
                        }
                    },
                    CanvasTinter: {
                        get: function () {
                            return It("5.2.0", "PIXI.CanvasTinter namespace has moved to PIXI.canvasUtils"), t.canvasUtils
                        }
                    },
                    GroupD8: {
                        get: function () {
                            return It("5.2.0", "PIXI.GroupD8 namespace has moved to PIXI.groupD8"), t.groupD8
                        }
                    }
                }), t.accessibility = {}, Object.defineProperties(t.accessibility, {
                    AccessibilityManager: {
                        get: function () {
                            return It("5.3.0", "PIXI.accessibility.AccessibilityManager moved to PIXI.AccessibilityManager"), t.AccessibilityManager
                        }
                    }
                }), t.interaction = {}, Object.defineProperties(t.interaction, {
                    InteractionManager: {
                        get: function () {
                            return It("5.3.0", "PIXI.interaction.InteractionManager moved to PIXI.InteractionManager"), t.InteractionManager
                        }
                    },
                    InteractionData: {
                        get: function () {
                            return It("5.3.0", "PIXI.interaction.InteractionData moved to PIXI.InteractionData"), t.InteractionData
                        }
                    },
                    InteractionEvent: {
                        get: function () {
                            return It("5.3.0", "PIXI.interaction.InteractionEvent moved to PIXI.InteractionEvent"), t.InteractionEvent
                        }
                    }
                }), t.prepare = {}, Object.defineProperties(t.prepare, {
                    BasePrepare: {
                        get: function () {
                            return It("5.2.1", "PIXI.prepare.BasePrepare moved to PIXI.BasePrepare"), t.BasePrepare
                        }
                    },
                    Prepare: {
                        get: function () {
                            return It("5.2.1", "PIXI.prepare.Prepare moved to PIXI.Prepare"), t.Prepare
                        }
                    },
                    CanvasPrepare: {
                        get: function () {
                            return It("5.2.1", "PIXI.prepare.CanvasPrepare moved to PIXI.CanvasPrepare"), t.CanvasPrepare
                        }
                    }
                }), t.extract = {}, Object.defineProperties(t.extract, {
                    Extract: {
                        get: function () {
                            return It("5.2.1", "PIXI.extract.Extract moved to PIXI.Extract"), t.Extract
                        }
                    },
                    CanvasExtract: {
                        get: function () {
                            return It("5.2.1", "PIXI.extract.CanvasExtract moved to PIXI.CanvasExtract"), t.CanvasExtract
                        }
                    }
                }), t.extras = {}, Object.defineProperties(t.extras, {
                    TilingSprite: {
                        get: function () {
                            return It(ta, "PIXI.extras.TilingSprite class has moved to PIXI.TilingSprite"), t.TilingSprite
                        }
                    },
                    TilingSpriteRenderer: {
                        get: function () {
                            return It(ta, "PIXI.extras.TilingSpriteRenderer class has moved to PIXI.TilingSpriteRenderer"), t.TilingSpriteRenderer
                        }
                    },
                    AnimatedSprite: {
                        get: function () {
                            return It(ta, "PIXI.extras.AnimatedSprite class has moved to PIXI.AnimatedSprite"), t.AnimatedSprite
                        }
                    },
                    BitmapText: {
                        get: function () {
                            return It(ta, "PIXI.extras.BitmapText class has moved to PIXI.BitmapText"), t.BitmapText
                        }
                    }
                }), t.TilingSprite.fromFrame = function (e, i, n) {
                    return It("5.3.0", "TilingSprite.fromFrame is deprecated, use TilingSprite.from"), t.TilingSprite.from(e, {
                        width: i,
                        height: n
                    })
                }, t.TilingSprite.fromImage = function (e, i, n, r) {
                    return void 0 === r && (r = {}), It("5.3.0", "TilingSprite.fromImage is deprecated, use TilingSprite.from"), r && "object" != typeof r && (r = {
                        scaleMode: arguments[4],
                        resourceOptions: {
                            crossorigin: arguments[3]
                        }
                    }), r.width = i, r.height = n, t.TilingSprite.from(e, r)
                }, Object.defineProperties(t.utils, {
                    getSvgSize: {
                        get: function () {
                            return It(ta, "PIXI.utils.getSvgSize function has moved to PIXI.resources.SVGResource.getSize"), t.resources.SVGResource.getSize
                        }
                    }
                }), t.mesh = {}, Object.defineProperties(t.mesh, {
                    Mesh: {
                        get: function () {
                            return It(ta, "PIXI.mesh.Mesh class has moved to PIXI.SimpleMesh"), t.SimpleMesh
                        }
                    },
                    NineSlicePlane: {
                        get: function () {
                            return It(ta, "PIXI.mesh.NineSlicePlane class has moved to PIXI.NineSlicePlane"), t.NineSlicePlane
                        }
                    },
                    Plane: {
                        get: function () {
                            return It(ta, "PIXI.mesh.Plane class has moved to PIXI.SimplePlane"), t.SimplePlane
                        }
                    },
                    Rope: {
                        get: function () {
                            return It(ta, "PIXI.mesh.Rope class has moved to PIXI.SimpleRope"), t.SimpleRope
                        }
                    },
                    RawMesh: {
                        get: function () {
                            return It(ta, "PIXI.mesh.RawMesh class has moved to PIXI.Mesh"), t.Mesh
                        }
                    },
                    CanvasMeshRenderer: {
                        get: function () {
                            return It(ta, "PIXI.mesh.CanvasMeshRenderer class has moved to PIXI.CanvasMeshRenderer"), t.CanvasMeshRenderer
                        }
                    },
                    MeshRenderer: {
                        get: function () {
                            return It(ta, "PIXI.mesh.MeshRenderer class has moved to PIXI.MeshRenderer"), t.MeshRenderer
                        }
                    }
                }), t.particles = {}, Object.defineProperties(t.particles, {
                    ParticleContainer: {
                        get: function () {
                            return It(ta, "PIXI.particles.ParticleContainer class has moved to PIXI.ParticleContainer"), t.ParticleContainer
                        }
                    },
                    ParticleRenderer: {
                        get: function () {
                            return It(ta, "PIXI.particles.ParticleRenderer class has moved to PIXI.ParticleRenderer"), t.ParticleRenderer
                        }
                    }
                }), t.ticker = {}, Object.defineProperties(t.ticker, {
                    Ticker: {
                        get: function () {
                            return It(ta, "PIXI.ticker.Ticker class has moved to PIXI.Ticker"), t.Ticker
                        }
                    },
                    shared: {
                        get: function () {
                            return It(ta, "PIXI.ticker.shared instance has moved to PIXI.Ticker.shared"), t.Ticker.shared
                        }
                    }
                }), t.loaders = {}, Object.defineProperties(t.loaders, {
                    Loader: {
                        get: function () {
                            return It(ta, "PIXI.loaders.Loader class has moved to PIXI.Loader"), t.Loader
                        }
                    },
                    Resource: {
                        get: function () {
                            return It(ta, "PIXI.loaders.Resource class has moved to PIXI.LoaderResource"), t.LoaderResource
                        }
                    },
                    bitmapFontParser: {
                        get: function () {
                            return It(ta, "PIXI.loaders.bitmapFontParser function has moved to PIXI.BitmapFontLoader.use"), t.BitmapFontLoader.use
                        }
                    },
                    parseBitmapFontData: {
                        get: function () {
                            It(ta, "PIXI.loaders.parseBitmapFontData function has removed")
                        }
                    },
                    spritesheetParser: {
                        get: function () {
                            return It(ta, "PIXI.loaders.spritesheetParser function has moved to PIXI.SpritesheetLoader.use"), t.SpritesheetLoader.use
                        }
                    },
                    getResourcePath: {
                        get: function () {
                            return It(ta, "PIXI.loaders.getResourcePath property has moved to PIXI.SpritesheetLoader.getResourcePath"), t.SpritesheetLoader.getResourcePath
                        }
                    }
                }), t.Loader.addPixiMiddleware = function (e) {
                    return It(ta, "PIXI.loaders.Loader.addPixiMiddleware function is deprecated, use PIXI.loaders.Loader.registerPlugin"), t.loaders.Loader.registerPlugin({
                        use: e()
                    })
                };
                var e = function (t) {
                    return "on" + t.charAt(0).toUpperCase() + t.slice(1)
                };
                Object.assign(t.Loader.prototype, {
                    on: function (t) {
                        var i = e(t);
                        It(ta, "PIXI.Loader#on is completely deprecated, use PIXI.Loader#" + i + ".add")
                    },
                    once: function (t) {
                        var i = e(t);
                        It(ta, "PIXI.Loader#once is completely deprecated, use PIXI.Loader#" + i + ".once")
                    },
                    off: function (t) {
                        var i = e(t);
                        It(ta, "PIXI.Loader#off is completely deprecated, use PIXI.Loader#" + i + ".detach")
                    }
                }), Object.defineProperty(t.extract, "WebGLExtract", {
                    get: function () {
                        return It(ta, "PIXI.extract.WebGLExtract method has moved to PIXI.Extract"), t.Extract
                    }
                }), Object.defineProperty(t.prepare, "WebGLPrepare", {
                    get: function () {
                        return It(ta, "PIXI.prepare.WebGLPrepare class has moved to PIXI.Prepare"), t.Prepare
                    }
                }), t.Container.prototype._renderWebGL = function (t) {
                    It(ta, "PIXI.Container._renderWebGL method has moved to PIXI.Container._render"), this._render(t)
                }, t.Container.prototype.renderWebGL = function (t) {
                    It(ta, "PIXI.Container.renderWebGL method has moved to PIXI.Container.render"), this.render(t)
                }, t.DisplayObject.prototype.renderWebGL = function (t) {
                    It(ta, "PIXI.DisplayObject.renderWebGL method has moved to PIXI.DisplayObject.render"), this.render(t)
                }, t.Container.prototype.renderAdvancedWebGL = function (t) {
                    It(ta, "PIXI.Container.renderAdvancedWebGL method has moved to PIXI.Container.renderAdvanced"), this.renderAdvanced(t)
                }, Object.defineProperties(t.settings, {
                    TRANSFORM_MODE: {
                        get: function () {
                            return It(ta, "PIXI.settings.TRANSFORM_MODE property has been removed"), 0
                        },
                        set: function () {
                            It(ta, "PIXI.settings.TRANSFORM_MODE property has been removed")
                        }
                    }
                });
                var i = t.BaseTexture;
                i.prototype.loadSource = function (e) {
                    It(ta, "PIXI.BaseTexture.loadSource method has been deprecated");
                    var i = t.resources.autoDetectResource(e);
                    i.internal = !0, this.setResource(i), this.update()
                };
                var n = !1;
                Object.defineProperties(i.prototype, {
                    hasLoaded: {
                        get: function () {
                            return It(ta, "PIXI.BaseTexture.hasLoaded property has been removed, use PIXI.BaseTexture.valid"), this.valid
                        }
                    },
                    imageUrl: {
                        get: function () {
                            var t;
                            return It(ta, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), null === (t = this.resource) || void 0 === t ? void 0 : t.url
                        },
                        set: function (t) {
                            It(ta, "PIXI.BaseTexture.imageUrl property has been removed, use PIXI.BaseTexture.resource.url"), this.resource && (this.resource.url = t)
                        }
                    },
                    source: {
                        get: function () {
                            return It(ta, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source`"), this.resource.source
                        },
                        set: function (t) {
                            It(ta, "PIXI.BaseTexture.source property has been moved, use `PIXI.BaseTexture.resource.source` if you want to set HTMLCanvasElement. Otherwise, create new BaseTexture."), this.resource && (this.resource.source = t)
                        }
                    },
                    premultiplyAlpha: {
                        get: function () {
                            return It("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode
                        },
                        set: function (t) {
                            It("5.2.0", "PIXI.BaseTexture.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t)
                        }
                    },
                    _id: {
                        get: function () {
                            return n || (It("5.2.0", "PIXI.BaseTexture._id batch local field has been changed to `_batchLocation`"), n = !0), this._batchLocation
                        },
                        set: function (t) {
                            this._batchLocation = t
                        }
                    }
                }), i.fromImage = function (t, e, n, r) {
                    It(ta, "PIXI.BaseTexture.fromImage method has been replaced with PIXI.BaseTexture.from");
                    var o = {
                        scale: r,
                        crossorigin: e
                    };
                    return i.from(t, {
                        scaleMode: n,
                        resourceOptions: o
                    })
                }, i.fromCanvas = function (t, e) {
                    return It(ta, "PIXI.BaseTexture.fromCanvas method has been replaced with PIXI.BaseTexture.from"), i.from(t, {
                        scaleMode: e
                    })
                }, i.fromSVG = function (t, e, n, r) {
                    It(ta, "PIXI.BaseTexture.fromSVG method has been replaced with PIXI.BaseTexture.from");
                    var o = {
                        scale: r,
                        crossorigin: e
                    };
                    return i.from(t, {
                        scaleMode: n,
                        resourceOptions: o
                    })
                }, Object.defineProperties(t.resources.ImageResource.prototype, {
                    premultiplyAlpha: {
                        get: function () {
                            return It("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), 0 !== this.alphaMode
                        },
                        set: function (t) {
                            It("5.2.0", "PIXI.resources.ImageResource.premultiplyAlpha property has been changed to `alphaMode`, see `PIXI.ALPHA_MODES`"), this.alphaMode = Number(t)
                        }
                    }
                }), t.Point.prototype.copy = function (t) {
                    return It(ta, "PIXI.Point.copy method has been replaced with PIXI.Point.copyFrom"), this.copyFrom(t)
                }, t.ObservablePoint.prototype.copy = function (t) {
                    return It(ta, "PIXI.ObservablePoint.copy method has been replaced with PIXI.ObservablePoint.copyFrom"), this.copyFrom(t)
                }, t.Rectangle.prototype.copy = function (t) {
                    return It(ta, "PIXI.Rectangle.copy method has been replaced with PIXI.Rectangle.copyFrom"), this.copyFrom(t)
                }, t.Matrix.prototype.copy = function (t) {
                    return It(ta, "PIXI.Matrix.copy method has been replaced with PIXI.Matrix.copyTo"), this.copyTo(t)
                }, t.systems.StateSystem.prototype.setState = function (t) {
                    return It("v5.1.0", "StateSystem.setState has been renamed to StateSystem.set"), this.set(t)
                }, Object.assign(t.systems.FilterSystem.prototype, {
                    getRenderTarget: function (t, e) {
                        return It(ta, "PIXI.FilterManager.getRenderTarget method has been replaced with PIXI.systems.FilterSystem#getFilterTexture"), this.getFilterTexture(null, e)
                    },
                    returnRenderTarget: function (t) {
                        It(ta, "PIXI.FilterManager.returnRenderTarget method has been replaced with PIXI.systems.FilterSystem.returnFilterTexture"), this.returnFilterTexture(t)
                    },
                    calculateScreenSpaceMatrix: function (t) {
                        It(ta, "PIXI.systems.FilterSystem.calculateScreenSpaceMatrix method is removed, use `(vTextureCoord * inputSize.xy) + outputFrame.xy` instead");
                        var e = t.identity(),
                            i = this.activeState,
                            n = i.sourceFrame,
                            r = i.destinationFrame;
                        return e.translate(n.x / r.width, n.y / r.height), e.scale(r.width, r.height), e
                    },
                    calculateNormalizedScreenSpaceMatrix: function (t) {
                        It(ta, "PIXI.systems.FilterManager.calculateNormalizedScreenSpaceMatrix method is removed, use `((vTextureCoord * inputSize.xy) + outputFrame.xy) / outputFrame.zw` instead.");
                        var e = this.activeState,
                            i = e.sourceFrame,
                            n = e.destinationFrame,
                            r = t.identity();
                        r.translate(i.x / n.width, i.y / n.height);
                        var o = n.width / i.width,
                            s = n.height / i.height;
                        return r.scale(o, s), r
                    }
                }), Object.defineProperties(t.RenderTexture.prototype, {
                    sourceFrame: {
                        get: function () {
                            return It(ta, "PIXI.RenderTexture.sourceFrame property has been removed"), this.filterFrame
                        }
                    },
                    size: {
                        get: function () {
                            return It(ta, "PIXI.RenderTexture.size property has been removed"), this._frame
                        }
                    }
                });
                var r = function (t) {
                    function e(e, i, n, r) {
                        return It(ta, "PIXI.filters.BlurXFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !0, e, i, n, r) || this
                    }
                    return Qs(e, t), e
                }(t.filters.BlurFilterPass),
                    o = function (t) {
                        function e(e, i, n, r) {
                            return It(ta, "PIXI.filters.BlurYFilter class is deprecated, use PIXI.filters.BlurFilterPass"), t.call(this, !1, e, i, n, r) || this
                        }
                        return Qs(e, t), e
                    }(t.filters.BlurFilterPass);
                Object.assign(t.filters, {
                    BlurXFilter: r,
                    BlurYFilter: o
                });
                var s = t.Sprite,
                    a = t.Texture,
                    l = t.Graphics;

                function h(t, e, i, n) {
                    return It(ta, "PIXI.Sprite." + t + " method is deprecated, use PIXI.Sprite.from"), s.from(e, {
                        resourceOptions: {
                            scale: n,
                            crossorigin: i
                        }
                    })
                }

                function u(t, e, i, n) {
                    return It(ta, "PIXI.Texture." + t + " method is deprecated, use PIXI.Texture.from"), a.from(e, {
                        resourceOptions: {
                            scale: n,
                            crossorigin: i
                        }
                    })
                }
                l.prototype.generateCanvasTexture || (l.prototype.generateCanvasTexture = function () {
                    It(ta, 'PIXI.Graphics.generateCanvasTexture method is only available in "pixi.js-legacy"')
                }), Object.defineProperty(l.prototype, "graphicsData", {
                    get: function () {
                        return It(ta, "PIXI.Graphics.graphicsData property is deprecated, use PIXI.Graphics.geometry.graphicsData"), this.geometry.graphicsData
                    }
                }), s.fromImage = h.bind(null, "fromImage"), s.fromSVG = h.bind(null, "fromSVG"), s.fromCanvas = h.bind(null, "fromCanvas"), s.fromVideo = h.bind(null, "fromVideo"), s.fromFrame = h.bind(null, "fromFrame"), a.fromImage = u.bind(null, "fromImage"), a.fromSVG = u.bind(null, "fromSVG"), a.fromCanvas = u.bind(null, "fromCanvas"), a.fromVideo = u.bind(null, "fromVideo"), a.fromFrame = u.bind(null, "fromFrame"), Object.defineProperty(t.AbstractRenderer.prototype, "autoResize", {
                    get: function () {
                        return It(ta, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity
                    },
                    set: function (t) {
                        It(ta, "PIXI.AbstractRenderer.autoResize property is deprecated, use PIXI.AbstractRenderer.autoDensity"), this.autoDensity = t
                    }
                }), Object.defineProperty(t.Renderer.prototype, "textureManager", {
                    get: function () {
                        return It(ta, "PIXI.Renderer.textureManager property is deprecated, use PIXI.Renderer.texture"), this.texture
                    }
                }), t.utils.mixins = {
                    mixin: function () {
                        It(ta, "PIXI.utils.mixins.mixin function is no longer available")
                    },
                    delayMixin: function () {
                        It(ta, "PIXI.utils.mixins.delayMixin function is no longer available")
                    },
                    performMixins: function () {
                        It(ta, "PIXI.utils.mixins.performMixins function is no longer available")
                    }
                }, Object.defineProperty(t.BitmapText.prototype, "font", {
                    get: function () {
                        return It("5.3.0", "PIXI.BitmapText.font property is deprecated, use fontName, fontSize, tint or align properties"), {
                            name: this._fontName,
                            size: this._fontSize,
                            tint: this._tint,
                            align: this._align
                        }
                    },
                    set: function (e) {
                        if (It("5.3.0", "PIXI.BitmapText.font property is deprecated, use fontName, fontSize, tint or align properties"), e) {
                            var i = {
                                font: e
                            };
                            this._upgradeStyle(i), i.fontSize = i.fontSize || t.BitmapFont.available[i.fontName].size, this._fontName = i.fontName, this._fontSize = i.fontSize, this.dirty = !0
                        }
                    }
                })
            }
            wn.registerPlugin("accessibility", ge), wn.registerPlugin("extract", Xn), wn.registerPlugin("interaction", we), wn.registerPlugin("particle", br), wn.registerPlugin("prepare", xo), wn.registerPlugin("batch", Un), wn.registerPlugin("tilingSprite", Uo), pr.registerPlugin(ss), pr.registerPlugin(Oo), Gn.registerPlugin(ye), Gn.registerPlugin(fr);
            var ia = "5.3.12",
                na = {
                    AlphaFilter: ls,
                    BlurFilter: Ls,
                    BlurFilterPass: Bs,
                    ColorMatrixFilter: Ns,
                    DisplacementFilter: Rs,
                    FXAAFilter: Fs,
                    NoiseFilter: Us
                }
        },
        5798: t => {
            "use strict";
            var e = String.prototype.replace,
                i = /%20/g,
                n = "RFC3986";
            t.exports = {
                default: n,
                formatters: {
                    RFC1738: function (t) {
                        return e.call(t, i, "+")
                    },
                    RFC3986: function (t) {
                        return String(t)
                    }
                },
                RFC1738: "RFC1738",
                RFC3986: n
            }
        },
        129: (t, e, i) => {
            "use strict";
            var n = i(8261),
                r = i(5235),
                o = i(5798);
            t.exports = {
                formats: o,
                parse: r,
                stringify: n
            }
        },
        5235: (t, e, i) => {
            "use strict";
            var n = i(2769),
                r = Object.prototype.hasOwnProperty,
                o = Array.isArray,
                s = {
                    allowDots: !1,
                    allowPrototypes: !1,
                    allowSparse: !1,
                    arrayLimit: 20,
                    charset: "utf-8",
                    charsetSentinel: !1,
                    comma: !1,
                    decoder: n.decode,
                    delimiter: "&",
                    depth: 5,
                    ignoreQueryPrefix: !1,
                    interpretNumericEntities: !1,
                    parameterLimit: 1e3,
                    parseArrays: !0,
                    plainObjects: !1,
                    strictNullHandling: !1
                },
                a = function (t) {
                    return t.replace(/&#(\d+);/g, (function (t, e) {
                        return String.fromCharCode(parseInt(e, 10))
                    }))
                },
                l = function (t, e) {
                    return t && "string" == typeof t && e.comma && t.indexOf(",") > -1 ? t.split(",") : t
                },
                h = function (t, e, i, n) {
                    if (t) {
                        var o = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
                            s = /(\[[^[\]]*])/g,
                            a = i.depth > 0 && /(\[[^[\]]*])/.exec(o),
                            h = a ? o.slice(0, a.index) : o,
                            u = [];
                        if (h) {
                            if (!i.plainObjects && r.call(Object.prototype, h) && !i.allowPrototypes) return;
                            u.push(h)
                        }
                        for (var c = 0; i.depth > 0 && null !== (a = s.exec(o)) && c < i.depth;) {
                            if (c += 1, !i.plainObjects && r.call(Object.prototype, a[1].slice(1, -1)) && !i.allowPrototypes) return;
                            u.push(a[1])
                        }
                        return a && u.push("[" + o.slice(a.index) + "]"),
                            function (t, e, i, n) {
                                for (var r = n ? e : l(e, i), o = t.length - 1; o >= 0; --o) {
                                    var s, a = t[o];
                                    if ("[]" === a && i.parseArrays) s = [].concat(r);
                                    else {
                                        s = i.plainObjects ? Object.create(null) : {};
                                        var h = "[" === a.charAt(0) && "]" === a.charAt(a.length - 1) ? a.slice(1, -1) : a,
                                            u = parseInt(h, 10);
                                        i.parseArrays || "" !== h ? !isNaN(u) && a !== h && String(u) === h && u >= 0 && i.parseArrays && u <= i.arrayLimit ? (s = [])[u] = r : "__proto__" !== h && (s[h] = r) : s = {
                                            0: r
                                        }
                                    }
                                    r = s
                                }
                                return r
                            }(u, e, i, n)
                    }
                };
            t.exports = function (t, e) {
                var i = function (t) {
                    if (!t) return s;
                    if (null !== t.decoder && void 0 !== t.decoder && "function" != typeof t.decoder) throw new TypeError("Decoder has to be a function.");
                    if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                    var e = void 0 === t.charset ? s.charset : t.charset;
                    return {
                        allowDots: void 0 === t.allowDots ? s.allowDots : !!t.allowDots,
                        allowPrototypes: "boolean" == typeof t.allowPrototypes ? t.allowPrototypes : s.allowPrototypes,
                        allowSparse: "boolean" == typeof t.allowSparse ? t.allowSparse : s.allowSparse,
                        arrayLimit: "number" == typeof t.arrayLimit ? t.arrayLimit : s.arrayLimit,
                        charset: e,
                        charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : s.charsetSentinel,
                        comma: "boolean" == typeof t.comma ? t.comma : s.comma,
                        decoder: "function" == typeof t.decoder ? t.decoder : s.decoder,
                        delimiter: "string" == typeof t.delimiter || n.isRegExp(t.delimiter) ? t.delimiter : s.delimiter,
                        depth: "number" == typeof t.depth || !1 === t.depth ? +t.depth : s.depth,
                        ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
                        interpretNumericEntities: "boolean" == typeof t.interpretNumericEntities ? t.interpretNumericEntities : s.interpretNumericEntities,
                        parameterLimit: "number" == typeof t.parameterLimit ? t.parameterLimit : s.parameterLimit,
                        parseArrays: !1 !== t.parseArrays,
                        plainObjects: "boolean" == typeof t.plainObjects ? t.plainObjects : s.plainObjects,
                        strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : s.strictNullHandling
                    }
                }(e);
                if ("" === t || null == t) return i.plainObjects ? Object.create(null) : {};
                for (var u = "string" == typeof t ? function (t, e) {
                    var i, h = {
                        __proto__: null
                    },
                        u = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t,
                        c = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit,
                        d = u.split(e.delimiter, c),
                        p = -1,
                        f = e.charset;
                    if (e.charsetSentinel)
                        for (i = 0; i < d.length; ++i) 0 === d[i].indexOf("utf8=") && ("utf8=%E2%9C%93" === d[i] ? f = "utf-8" : "utf8=%26%2310003%3B" === d[i] && (f = "iso-8859-1"), p = i, i = d.length);
                    for (i = 0; i < d.length; ++i)
                        if (i !== p) {
                            var g, m, _ = d[i],
                                y = _.indexOf("]="),
                                S = -1 === y ? _.indexOf("=") : y + 1; - 1 === S ? (g = e.decoder(_, s.decoder, f, "key"), m = e.strictNullHandling ? null : "") : (g = e.decoder(_.slice(0, S), s.decoder, f, "key"), m = n.maybeMap(l(_.slice(S + 1), e), (function (t) {
                                    return e.decoder(t, s.decoder, f, "value")
                                }))), m && e.interpretNumericEntities && "iso-8859-1" === f && (m = a(m)), _.indexOf("[]=") > -1 && (m = o(m) ? [m] : m), r.call(h, g) ? h[g] = n.combine(h[g], m) : h[g] = m
                        } return h
                }(t, i) : t, c = i.plainObjects ? Object.create(null) : {}, d = Object.keys(u), p = 0; p < d.length; ++p) {
                    var f = d[p],
                        g = h(f, u[f], i, "string" == typeof t);
                    c = n.merge(c, g, i)
                }
                return !0 === i.allowSparse ? c : n.compact(c)
            }
        },
        8261: (t, e, i) => {
            "use strict";
            var n = i(7478),
                r = i(2769),
                o = i(5798),
                s = Object.prototype.hasOwnProperty,
                a = {
                    brackets: function (t) {
                        return t + "[]"
                    },
                    comma: "comma",
                    indices: function (t, e) {
                        return t + "[" + e + "]"
                    },
                    repeat: function (t) {
                        return t
                    }
                },
                l = Array.isArray,
                h = Array.prototype.push,
                u = function (t, e) {
                    h.apply(t, l(e) ? e : [e])
                },
                c = Date.prototype.toISOString,
                d = o.default,
                p = {
                    addQueryPrefix: !1,
                    allowDots: !1,
                    charset: "utf-8",
                    charsetSentinel: !1,
                    delimiter: "&",
                    encode: !0,
                    encoder: r.encode,
                    encodeValuesOnly: !1,
                    format: d,
                    formatter: o.formatters[d],
                    indices: !1,
                    serializeDate: function (t) {
                        return c.call(t)
                    },
                    skipNulls: !1,
                    strictNullHandling: !1
                },
                f = {},
                g = function t(e, i, o, s, a, h, c, d, g, m, _, y, S, v, b, T) {
                    for (var P, A = e, I = T, w = 0, E = !1; void 0 !== (I = I.get(f)) && !E;) {
                        var C = I.get(e);
                        if (w += 1, void 0 !== C) {
                            if (C === w) throw new RangeError("Cyclic object value");
                            E = !0
                        }
                        void 0 === I.get(f) && (w = 0)
                    }
                    if ("function" == typeof d ? A = d(i, A) : A instanceof Date ? A = _(A) : "comma" === o && l(A) && (A = r.maybeMap(A, (function (t) {
                        return t instanceof Date ? _(t) : t
                    }))), null === A) {
                        if (a) return c && !v ? c(i, p.encoder, b, "key", y) : i;
                        A = ""
                    }
                    if ("string" == typeof (P = A) || "number" == typeof P || "boolean" == typeof P || "symbol" == typeof P || "bigint" == typeof P || r.isBuffer(A)) return c ? [S(v ? i : c(i, p.encoder, b, "key", y)) + "=" + S(c(A, p.encoder, b, "value", y))] : [S(i) + "=" + S(String(A))];
                    var x, B = [];
                    if (void 0 === A) return B;
                    if ("comma" === o && l(A)) v && c && (A = r.maybeMap(A, c)), x = [{
                        value: A.length > 0 ? A.join(",") || null : void 0
                    }];
                    else if (l(d)) x = d;
                    else {
                        var L = Object.keys(A);
                        x = g ? L.sort(g) : L
                    }
                    for (var O = s && l(A) && 1 === A.length ? i + "[]" : i, N = 0; N < x.length; ++N) {
                        var M = x[N],
                            R = "object" == typeof M && void 0 !== M.value ? M.value : A[M];
                        if (!h || null !== R) {
                            var D = l(A) ? "function" == typeof o ? o(O, M) : O : O + (m ? "." + M : "[" + M + "]");
                            T.set(e, w);
                            var F = n();
                            F.set(f, T), u(B, t(R, D, o, s, a, h, "comma" === o && v && l(A) ? null : c, d, g, m, _, y, S, v, b, F))
                        }
                    }
                    return B
                };
            t.exports = function (t, e) {
                var i, r = t,
                    h = function (t) {
                        if (!t) return p;
                        if (null !== t.encoder && void 0 !== t.encoder && "function" != typeof t.encoder) throw new TypeError("Encoder has to be a function.");
                        var e = t.charset || p.charset;
                        if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
                        var i = o.default;
                        if (void 0 !== t.format) {
                            if (!s.call(o.formatters, t.format)) throw new TypeError("Unknown format option provided.");
                            i = t.format
                        }
                        var n = o.formatters[i],
                            r = p.filter;
                        return ("function" == typeof t.filter || l(t.filter)) && (r = t.filter), {
                            addQueryPrefix: "boolean" == typeof t.addQueryPrefix ? t.addQueryPrefix : p.addQueryPrefix,
                            allowDots: void 0 === t.allowDots ? p.allowDots : !!t.allowDots,
                            charset: e,
                            charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : p.charsetSentinel,
                            delimiter: void 0 === t.delimiter ? p.delimiter : t.delimiter,
                            encode: "boolean" == typeof t.encode ? t.encode : p.encode,
                            encoder: "function" == typeof t.encoder ? t.encoder : p.encoder,
                            encodeValuesOnly: "boolean" == typeof t.encodeValuesOnly ? t.encodeValuesOnly : p.encodeValuesOnly,
                            filter: r,
                            format: i,
                            formatter: n,
                            serializeDate: "function" == typeof t.serializeDate ? t.serializeDate : p.serializeDate,
                            skipNulls: "boolean" == typeof t.skipNulls ? t.skipNulls : p.skipNulls,
                            sort: "function" == typeof t.sort ? t.sort : null,
                            strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : p.strictNullHandling
                        }
                    }(e);
                "function" == typeof h.filter ? r = (0, h.filter)("", r) : l(h.filter) && (i = h.filter);
                var c, d = [];
                if ("object" != typeof r || null === r) return "";
                c = e && e.arrayFormat in a ? e.arrayFormat : e && "indices" in e ? e.indices ? "indices" : "repeat" : "indices";
                var f = a[c];
                if (e && "commaRoundTrip" in e && "boolean" != typeof e.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
                var m = "comma" === f && e && e.commaRoundTrip;
                i || (i = Object.keys(r)), h.sort && i.sort(h.sort);
                for (var _ = n(), y = 0; y < i.length; ++y) {
                    var S = i[y];
                    h.skipNulls && null === r[S] || u(d, g(r[S], S, f, m, h.strictNullHandling, h.skipNulls, h.encode ? h.encoder : null, h.filter, h.sort, h.allowDots, h.serializeDate, h.format, h.formatter, h.encodeValuesOnly, h.charset, _))
                }
                var v = d.join(h.delimiter),
                    b = !0 === h.addQueryPrefix ? "?" : "";
                return h.charsetSentinel && ("iso-8859-1" === h.charset ? b += "utf8=%26%2310003%3B&" : b += "utf8=%E2%9C%93&"), v.length > 0 ? b + v : ""
            }
        },
        2769: (t, e, i) => {
            "use strict";
            var n = i(5798),
                r = Object.prototype.hasOwnProperty,
                o = Array.isArray,
                s = function () {
                    for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
                    return t
                }(),
                a = function (t, e) {
                    for (var i = e && e.plainObjects ? Object.create(null) : {}, n = 0; n < t.length; ++n) void 0 !== t[n] && (i[n] = t[n]);
                    return i
                };
            t.exports = {
                arrayToObject: a,
                assign: function (t, e) {
                    return Object.keys(e).reduce((function (t, i) {
                        return t[i] = e[i], t
                    }), t)
                },
                combine: function (t, e) {
                    return [].concat(t, e)
                },
                compact: function (t) {
                    for (var e = [{
                        obj: {
                            o: t
                        },
                        prop: "o"
                    }], i = [], n = 0; n < e.length; ++n)
                        for (var r = e[n], s = r.obj[r.prop], a = Object.keys(s), l = 0; l < a.length; ++l) {
                            var h = a[l],
                                u = s[h];
                            "object" == typeof u && null !== u && -1 === i.indexOf(u) && (e.push({
                                obj: s,
                                prop: h
                            }), i.push(u))
                        }
                    return function (t) {
                        for (; t.length > 1;) {
                            var e = t.pop(),
                                i = e.obj[e.prop];
                            if (o(i)) {
                                for (var n = [], r = 0; r < i.length; ++r) void 0 !== i[r] && n.push(i[r]);
                                e.obj[e.prop] = n
                            }
                        }
                    }(e), t
                },
                decode: function (t, e, i) {
                    var n = t.replace(/\+/g, " ");
                    if ("iso-8859-1" === i) return n.replace(/%[0-9a-f]{2}/gi, unescape);
                    try {
                        return decodeURIComponent(n)
                    } catch (t) {
                        return n
                    }
                },
                encode: function (t, e, i, r, o) {
                    if (0 === t.length) return t;
                    var a = t;
                    if ("symbol" == typeof t ? a = Symbol.prototype.toString.call(t) : "string" != typeof t && (a = String(t)), "iso-8859-1" === i) return escape(a).replace(/%u[0-9a-f]{4}/gi, (function (t) {
                        return "%26%23" + parseInt(t.slice(2), 16) + "%3B"
                    }));
                    for (var l = "", h = 0; h < a.length; ++h) {
                        var u = a.charCodeAt(h);
                        45 === u || 46 === u || 95 === u || 126 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122 || o === n.RFC1738 && (40 === u || 41 === u) ? l += a.charAt(h) : u < 128 ? l += s[u] : u < 2048 ? l += s[192 | u >> 6] + s[128 | 63 & u] : u < 55296 || u >= 57344 ? l += s[224 | u >> 12] + s[128 | u >> 6 & 63] + s[128 | 63 & u] : (h += 1, u = 65536 + ((1023 & u) << 10 | 1023 & a.charCodeAt(h)), l += s[240 | u >> 18] + s[128 | u >> 12 & 63] + s[128 | u >> 6 & 63] + s[128 | 63 & u])
                    }
                    return l
                },
                isBuffer: function (t) {
                    return !(!t || "object" != typeof t || !(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t)))
                },
                isRegExp: function (t) {
                    return "[object RegExp]" === Object.prototype.toString.call(t)
                },
                maybeMap: function (t, e) {
                    if (o(t)) {
                        for (var i = [], n = 0; n < t.length; n += 1) i.push(e(t[n]));
                        return i
                    }
                    return e(t)
                },
                merge: function t(e, i, n) {
                    if (!i) return e;
                    if ("object" != typeof i) {
                        if (o(e)) e.push(i);
                        else {
                            if (!e || "object" != typeof e) return [e, i];
                            (n && (n.plainObjects || n.allowPrototypes) || !r.call(Object.prototype, i)) && (e[i] = !0)
                        }
                        return e
                    }
                    if (!e || "object" != typeof e) return [e].concat(i);
                    var s = e;
                    return o(e) && !o(i) && (s = a(e, n)), o(e) && o(i) ? (i.forEach((function (i, o) {
                        if (r.call(e, o)) {
                            var s = e[o];
                            s && "object" == typeof s && i && "object" == typeof i ? e[o] = t(s, i, n) : e.push(i)
                        } else e[o] = i
                    })), e) : Object.keys(i).reduce((function (e, o) {
                        var s = i[o];
                        return r.call(e, o) ? e[o] = t(e[o], s, n) : e[o] = s, e
                    }), s)
                }
            }
        },
        7478: (t, e, i) => {
            "use strict";
            var n = i(210),
                r = i(1924),
                o = i(631),
                s = n("%TypeError%"),
                a = n("%WeakMap%", !0),
                l = n("%Map%", !0),
                h = r("WeakMap.prototype.get", !0),
                u = r("WeakMap.prototype.set", !0),
                c = r("WeakMap.prototype.has", !0),
                d = r("Map.prototype.get", !0),
                p = r("Map.prototype.set", !0),
                f = r("Map.prototype.has", !0),
                g = function (t, e) {
                    for (var i, n = t; null !== (i = n.next); n = i)
                        if (i.key === e) return n.next = i.next, i.next = t.next, t.next = i, i
                };
            t.exports = function () {
                var t, e, i, n = {
                    assert: function (t) {
                        if (!n.has(t)) throw new s("Side channel does not contain " + o(t))
                    },
                    get: function (n) {
                        if (a && n && ("object" == typeof n || "function" == typeof n)) {
                            if (t) return h(t, n)
                        } else if (l) {
                            if (e) return d(e, n)
                        } else if (i) return function (t, e) {
                            var i = g(t, e);
                            return i && i.value
                        }(i, n)
                    },
                    has: function (n) {
                        if (a && n && ("object" == typeof n || "function" == typeof n)) {
                            if (t) return c(t, n)
                        } else if (l) {
                            if (e) return f(e, n)
                        } else if (i) return function (t, e) {
                            return !!g(t, e)
                        }(i, n);
                        return !1
                    },
                    set: function (n, r) {
                        a && n && ("object" == typeof n || "function" == typeof n) ? (t || (t = new a), u(t, n, r)) : l ? (e || (e = new l), p(e, n, r)) : (i || (i = {
                            key: {},
                            next: null
                        }), function (t, e, i) {
                            var n = g(t, e);
                            n ? n.value = i : t.next = {
                                key: e,
                                next: t.next,
                                value: i
                            }
                        }(i, n, r))
                    }
                };
                return n
            }
        },
        1819: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                default: () => _
            });
            var n = i(3379),
                r = i.n(n),
                o = i(7795),
                s = i.n(o),
                a = i(569),
                l = i.n(a),
                h = i(3565),
                u = i.n(h),
                c = i(9216),
                d = i.n(c),
                p = i(4589),
                f = i.n(p),
                g = i(7284),
                m = {};
            m.styleTagTransform = f(), m.setAttributes = u(), m.insert = l().bind(null, "head"), m.domAPI = s(), m.insertStyleElement = d(), r()(g.Z, m);
            const _ = g.Z && g.Z.locals ? g.Z.locals : void 0
        },
        6172: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                default: () => _
            });
            var n = i(3379),
                r = i.n(n),
                o = i(7795),
                s = i.n(o),
                a = i(569),
                l = i.n(a),
                h = i(3565),
                u = i.n(h),
                c = i(9216),
                d = i.n(c),
                p = i(4589),
                f = i.n(p),
                g = i(8779),
                m = {};
            m.styleTagTransform = f(), m.setAttributes = u(), m.insert = l().bind(null, "head"), m.domAPI = s(), m.insertStyleElement = d(), r()(g.Z, m);
            const _ = g.Z && g.Z.locals ? g.Z.locals : void 0
        },
        9012: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                default: () => _
            });
            var n = i(3379),
                r = i.n(n),
                o = i(7795),
                s = i.n(o),
                a = i(569),
                l = i.n(a),
                h = i(3565),
                u = i.n(h),
                c = i(9216),
                d = i.n(c),
                p = i(4589),
                f = i.n(p),
                g = i(4894),
                m = {};
            m.styleTagTransform = f(), m.setAttributes = u(), m.insert = l().bind(null, "head"), m.domAPI = s(), m.insertStyleElement = d(), r()(g.Z, m);
            const _ = g.Z && g.Z.locals ? g.Z.locals : void 0
        },
        901: (t, e, i) => {
            "use strict";
            i.r(e), i.d(e, {
                default: () => _
            });
            var n = i(3379),
                r = i.n(n),
                o = i(7795),
                s = i.n(o),
                a = i(569),
                l = i.n(a),
                h = i(3565),
                u = i.n(h),
                c = i(9216),
                d = i.n(c),
                p = i(4589),
                f = i.n(p),
                g = i(1672),
                m = {};
            m.styleTagTransform = f(), m.setAttributes = u(), m.insert = l().bind(null, "head"), m.domAPI = s(), m.insertStyleElement = d(), r()(g.Z, m);
            const _ = g.Z && g.Z.locals ? g.Z.locals : void 0
        },
        3379: t => {
            "use strict";
            var e = [];

            function i(t) {
                for (var i = -1, n = 0; n < e.length; n++)
                    if (e[n].identifier === t) {
                        i = n;
                        break
                    } return i
            }

            function n(t, n) {
                for (var o = {}, s = [], a = 0; a < t.length; a++) {
                    var l = t[a],
                        h = n.base ? l[0] + n.base : l[0],
                        u = o[h] || 0,
                        c = "".concat(h, " ").concat(u);
                    o[h] = u + 1;
                    var d = i(c),
                        p = {
                            css: l[1],
                            media: l[2],
                            sourceMap: l[3],
                            supports: l[4],
                            layer: l[5]
                        };
                    if (-1 !== d) e[d].references++, e[d].updater(p);
                    else {
                        var f = r(p, n);
                        n.byIndex = a, e.splice(a, 0, {
                            identifier: c,
                            updater: f,
                            references: 1
                        })
                    }
                    s.push(c)
                }
                return s
            }

            function r(t, e) {
                var i = e.domAPI(e);
                return i.update(t),
                    function (e) {
                        if (e) {
                            if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap && e.supports === t.supports && e.layer === t.layer) return;
                            i.update(t = e)
                        } else i.remove()
                    }
            }
            t.exports = function (t, r) {
                var o = n(t = t || [], r = r || {});
                return function (t) {
                    t = t || [];
                    for (var s = 0; s < o.length; s++) {
                        var a = i(o[s]);
                        e[a].references--
                    }
                    for (var l = n(t, r), h = 0; h < o.length; h++) {
                        var u = i(o[h]);
                        0 === e[u].references && (e[u].updater(), e.splice(u, 1))
                    }
                    o = l
                }
            }
        },
        569: t => {
            "use strict";
            var e = {};
            t.exports = function (t, i) {
                var n = function (t) {
                    if (void 0 === e[t]) {
                        var i = document.querySelector(t);
                        if (window.HTMLIFrameElement && i instanceof window.HTMLIFrameElement) try {
                            i = i.contentDocument.head
                        } catch (t) {
                            i = null
                        }
                        e[t] = i
                    }
                    return e[t]
                }(t);
                if (!n) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                n.appendChild(i)
            }
        },
        9216: t => {
            "use strict";
            t.exports = function (t) {
                var e = document.createElement("style");
                return t.setAttributes(e, t.attributes), t.insert(e, t.options), e
            }
        },
        3565: (t, e, i) => {
            "use strict";
            t.exports = function (t) {
                var e = i.nc;
                e && t.setAttribute("nonce", e)
            }
        },
        7795: t => {
            "use strict";
            t.exports = function (t) {
                if ("undefined" == typeof document) return {
                    update: function () { },
                    remove: function () { }
                };
                var e = t.insertStyleElement(t);
                return {
                    update: function (i) {
                        ! function (t, e, i) {
                            var n = "";
                            i.supports && (n += "@supports (".concat(i.supports, ") {")), i.media && (n += "@media ".concat(i.media, " {"));
                            var r = void 0 !== i.layer;
                            r && (n += "@layer".concat(i.layer.length > 0 ? " ".concat(i.layer) : "", " {")), n += i.css, r && (n += "}"), i.media && (n += "}"), i.supports && (n += "}");
                            var o = i.sourceMap;
                            o && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), e.styleTagTransform(n, t, e.options)
                        }(e, t, i)
                    },
                    remove: function () {
                        ! function (t) {
                            if (null === t.parentNode) return !1;
                            t.parentNode.removeChild(t)
                        }(e)
                    }
                }
            }
        },
        4589: t => {
            "use strict";
            t.exports = function (t, e) {
                if (e.styleSheet) e.styleSheet.cssText = t;
                else {
                    for (; e.firstChild;) e.removeChild(e.firstChild);
                    e.appendChild(document.createTextNode(t))
                }
            }
        },
        2937: function (t, e, i) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function (t, e, i, n) {
                void 0 === n && (n = i);
                var r = Object.getOwnPropertyDescriptor(e, i);
                r && !("get" in r ? !e.__esModule : r.writable || r.configurable) || (r = {
                    enumerable: !0,
                    get: function () {
                        return e[i]
                    }
                }), Object.defineProperty(t, n, r)
            } : function (t, e, i, n) {
                void 0 === n && (n = i), t[n] = e[i]
            }),
                r = this && this.__setModuleDefault || (Object.create ? function (t, e) {
                    Object.defineProperty(t, "default", {
                        enumerable: !0,
                        value: e
                    })
                } : function (t, e) {
                    t.default = e
                }),
                o = this && this.__importStar || function (t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var i in t) "default" !== i && Object.prototype.hasOwnProperty.call(t, i) && n(e, t, i);
                    return r(e, t), e
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), Promise.resolve().then((() => o(i(3832))));
            const s = o(i(3832));
            window.PIXI = s, i(356);
            const a = i(6358),
                l = i(4347),
                h = i(3875),
                u = i(9276),
                c = i(2983),
                d = i(8680);
            a.gsap.registerPlugin(l.CustomEase, h.CustomWiggle, u.MotionPathPlugin, c.PixiPlugin);
            const p = i(7246),
                f = i(1410),
                g = i(8714),
                m = i(502),
                _ = i(5245),
                y = i(7141),
                S = i(1556),
                v = i(2836);
            window.NolimitLauncher = m.NolimitLauncher.instance, m.NolimitLauncher.instance.settings.log = d.LogLevel.DEV, m.NolimitLauncher.instance.launch([new y.TheCrypt, new g.SlotKeypad, new _.NolimitGameIntroPlugin(new p.TheCryptIntroConfig), new S.NolimitSlotAudio, new f.NolimitPromotionPlugin(new v.TheCryptPromoPanelConfig)])
        },
        2836: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptPromoPanelConfig = void 0;
            const n = i(430),
                r = i(7835),
                o = i(7075),
                s = i(7162),
                a = i(9692),
                l = i(5160),
                h = i(3554),
                u = i(2185),
                c = i(7141);
            e.TheCryptPromoPanelConfig = class {
                constructor() { }
                getActionSpinOptions() {
                    return {
                        gameName: "The Crypt",
                        hasActionSpin: !0,
                        mainGame: {
                            header: () => "xBET",
                            options: [{
                                name: "NORMAL",
                                id: 0,
                                image: "NORMAL.png"
                            }, {
                                name: "BOOSTED_BET",
                                id: 1,
                                image: "BOOSTED_BET.png"
                            }],
                            type: r.ASMainGamePickOptions.BOOSTED_BET
                        },
                        graphics: {
                            backgroundTextureName: s.TheCryptGameAssets.MAIN_GAME_BACKGROUND
                        },
                        getParsedData: (t, e, i) => ({
                            totalWin: t.accumulatedRoundWin,
                            wasFeatureBuy: t.wasFeatureBuy,
                            freeSpinTriggeredThisSpin: this.isFreeSpinTriggered(t),
                            totalSpinWinnings: this.getSpinWin(t, e, i),
                            isBigWin: this.isBigWin(t),
                            winType: r.WINTYPE.NORMAL,
                            featureName: this.getFeatureName(t),
                            isRoundComplete: this.isRoundComplete(t),
                            isBonusEnd: this.isBonusEnd(t),
                            isWinCapHit: t.brokeTheBank
                        })
                    }
                }
                isBigWin(t) {
                    let e = t.totalSpinWinnings;
                    if (t.wasFeatureBuy) {
                        const t = l.TheCryptHelper.getBuyFeaturePrice();
                        return n.Helper.ceilToDecimals(e / t, 2) >= 1
                    }
                    return n.Helper.ceilToDecimals(e / t.playedBetValue, 2) >= 15
                }
                getSpinWin(t, e, i) {
                    return t.totalSpinWinnings
                }
                isFreeSpinTriggered(t) {
                    return (t.mode === a.TheCryptGameMode.NORMAL || t.mode === a.TheCryptGameMode.NORMAL_AVALANCHE) && t.nextMode === a.TheCryptGameMode.FREESPIN
                }
                getFeatureName(t) {
                    return t.mode == a.TheCryptGameMode.FREESPIN || t.nextMode == a.TheCryptGameMode.FREESPIN || t.mode == a.TheCryptGameMode.FREESPIN_AVALANCHE || t.nextMode == a.TheCryptGameMode.FREESPIN_AVALANCHE ? "RESURRECTION SPINS" : t.mode
                }
                isRoundComplete(t) {
                    return [a.TheCryptGameMode.FREESPIN, a.TheCryptGameMode.NORMAL].indexOf(t.nextMode) > -1
                }
                isBonusEnd(t) {
                    return t.nextMode === a.TheCryptGameMode.NORMAL && (t.mode === a.TheCryptGameMode.FREESPIN || t.mode === a.TheCryptGameMode.FREESPIN_AVALANCHE)
                }
                onActionSpinPlaySound(t) {
                    t == o.ActionSpinSound.WIN ? u.TheCryptSoundManager.playSound(h.TheCryptSoundConfig.AS_WIN) : t == o.ActionSpinSound.BIG_WIN && u.TheCryptSoundManager.playSound(h.TheCryptSoundConfig.AS_WIN_BIG)
                }
                onPlayBonusInGame(t) {
                    c.TheCrypt.apiPlugin.slotStates.resetGameStartedAndGameServerFlag(), c.TheCrypt.model.onGame(t), c.TheCrypt.realArea.reInitReels(), setTimeout((() => {
                        c.TheCrypt.gameFlowController.start()
                    }), 300)
                }
            }
        },
        3217: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SimplePresentationRunner = void 0;
            class i {
                static run(t, e, n) {
                    const r = t.concat(),
                        o = r.shift();
                    null == o ? e() : o.shouldRun() ? o.start({
                        finish: () => i.run(r, e, n),
                        setSkipCallback: n
                    }) : i.run(r, e, n)
                }
                static skip(t) {
                    t.progress(1), t.kill()
                }
            }
            e.SimplePresentationRunner = i
        },
        7141: function (t, e, i) {
            "use strict";
            var n = this && this.__awaiter || function (t, e, i, n) {
                return new (i || (i = Promise))((function (r, o) {
                    function s(t) {
                        try {
                            l(n.next(t))
                        } catch (t) {
                            o(t)
                        }
                    }

                    function a(t) {
                        try {
                            l(n.throw(t))
                        } catch (t) {
                            o(t)
                        }
                    }

                    function l(t) {
                        var e;
                        t.done ? r(t.value) : (e = t.value, e instanceof i ? e : new i((function (t) {
                            t(e)
                        }))).then(s, a)
                    }
                    l((n = n.apply(t, e || [])).next())
                }))
            };
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCrypt = void 0;
            const r = i(1115),
                o = i(8680),
                s = i(6038),
                a = i(2201),
                l = i(2111),
                h = i(4514),
                u = i(1653),
                c = i(6328),
                d = i(343),
                p = i(6667),
                f = i(4267),
                g = i(7785),
                m = i(7310),
                _ = i(7162),
                y = i(2179),
                S = i(5644),
                v = i(8869),
                b = i(2185),
                T = i(1765),
                P = i(5160),
                A = i(3116),
                I = i(5411),
                w = i(760),
                E = i(6810),
                C = i(1863),
                x = i(2509),
                B = i(7917),
                L = i(447),
                O = i(7249),
                N = i(2054),
                M = i(4722),
                R = i(5818),
                D = i(9692),
                F = i(2327),
                k = i(4819),
                U = i(9331),
                G = i(4283),
                W = i(160),
                V = i(5944),
                X = i(2303),
                H = i(3465),
                Y = i(749),
                j = i(9621),
                z = i(2228),
                K = i(8119),
                q = i(8882),
                Z = i(7345),
                $ = i(2558);
            class J extends r.SlotGame {
                constructor() {
                    super(), this._defaultSymbolValues = {
                        L1: {
                            3: 3,
                            4: 4,
                            5: 8,
                            6: 15
                        },
                        L2: {
                            3: 3,
                            4: 4,
                            5: 8,
                            6: 14
                        },
                        L3: {
                            3: 3,
                            4: 4,
                            5: 8,
                            6: 12
                        },
                        L4: {
                            3: 2,
                            4: 3,
                            5: 6,
                            6: 12
                        },
                        L5: {
                            3: 2,
                            4: 3,
                            5: 6,
                            6: 10
                        },
                        L6: {
                            3: 2,
                            4: 3,
                            5: 6,
                            6: 10
                        },
                        M1: {
                            3: 10,
                            4: 25,
                            5: 50,
                            6: 75
                        },
                        M2: {
                            3: 5,
                            4: 8,
                            5: 20,
                            6: 30
                        },
                        M3: {
                            3: 4,
                            4: 6,
                            5: 15,
                            6: 25
                        },
                        M4: {
                            3: 4,
                            4: 6,
                            5: 12,
                            6: 22
                        },
                        M5: {
                            3: 4,
                            4: 5,
                            5: 10,
                            6: 20
                        },
                        M6: {
                            3: 4,
                            4: 5,
                            5: 10,
                            6: 18
                        },
                        W: {
                            3: 10,
                            4: 25,
                            5: 50,
                            6: 75
                        }
                    }
                }
                init() {
                    return super.init().then((t => {
                        g.NolimitConfig.isDevMode && (globalThis.__PIXI_APP__ = h.NolimitApplication.pixiApp), J.model = new A.TheCryptModel(r.SlotGame.apiPlugin, !0), J.gameFlowController = new s.GameFlowController(r.SlotGame.apiPlugin, J.model), J.gameFlowController.flowStateLogger.level = o.LogLevel.DEV;
                        const e = new U.TheCryptWinPresentation,
                            i = new x.TheCryptNormalBetPresentation,
                            n = new O.TheCryptNormalResultPresentation;
                        return J.gameFlowController.addGameModeFlowStatePresentationMap(F.GameMode.NORMAL, new Map([
                            [a.FlowState.IDLE, new C.TheCryptIdleNormalPresentation],
                            [a.FlowState.BET, i],
                            [a.FlowState.RESULT, n],
                            [a.FlowState.WIN, e]
                        ])), J.gameFlowController.addGameModeFlowStatePresentationMap(D.TheCryptGameMode.NORMAL_AVALANCHE, new Map([
                            [a.FlowState.IDLE, new R.TheCryptAvalancheIdlePresentation],
                            [a.FlowState.RESULT, n],
                            [a.FlowState.WIN, e]
                        ])), J.gameFlowController.addGameModeFlowStatePresentationMap(F.GameMode.FREESPIN, new Map([
                            [a.FlowState.IDLE, new M.TheCryptFSIdlePresentation],
                            [a.FlowState.BET, new B.TheCryptFSBetPresentation],
                            [a.FlowState.RESULT, new L.TheCryptFSResultPresentation],
                            [a.FlowState.WIN, new N.TheCryptFSWinPresentation]
                        ])), J.gameFlowController.addGameModeFlowStatePresentationMap(D.TheCryptGameMode.FREESPIN_AVALANCHE, new Map([
                            [a.FlowState.IDLE, new M.TheCryptFSIdlePresentation],
                            [a.FlowState.BET, new B.TheCryptFSBetPresentation],
                            [a.FlowState.RESULT, new L.TheCryptFSResultPresentation],
                            [a.FlowState.WIN, new N.TheCryptFSWinPresentation]
                        ])), t
                    }))
                }
                getReady() {
                    const t = Object.create(null, {
                        getReady: {
                            get: () => super.getReady
                        }
                    });
                    return n(this, void 0, void 0, (function* () {
                        const e = yield t.getReady.call(this), i = new l.FontLoader(h.NolimitApplication.resourcePath);
                        return i.add(u.OpenSans.ITALIC_600), i.add(u.OpenSans.NORMAL_300), i.add(u.OpenSans.NORMAL_400), i.add(u.OpenSans.NORMAL_700), c.AssetsConfig.addToAssetsConfig(_.TheCryptGameAssets.RESOURCES_GROUPS), J.assetLoader = new d.AssetLoader(J.apiPlugin, h.NolimitApplication.resourcePath + "/resources/"), yield Promise.all([i.load(), J.assetLoader.load(p.ResourcesGroupName.MAIN)]), yield J.createViewsAndComponents(), e
                    }))
                }
                getReadyToStart() {
                    const t = Object.create(null, {
                        getReadyToStart: {
                            get: () => super.getReadyToStart
                        }
                    });
                    return n(this, void 0, void 0, (function* () {
                        return J.model.isRestore && J.keypadPlugin.setWin(J.model.initData.accumulatedRoundWin, !0, P.TheCryptHelper.isWinBelowStake()), yield t.getReadyToStart.call(this)
                    }))
                }
                start() {
                    const t = Object.create(null, {
                        start: {
                            get: () => super.start
                        }
                    });
                    return n(this, void 0, void 0, (function* () {
                        b.TheCryptSoundManager.playAmbientLoop(1e3);
                        const e = yield t.start.call(this);
                        return J.gameFlowController.start(), J.xBetController.start(), J.setMode(J.model.mode), e
                    }))
                }
                static addLayer(t) {
                    return h.NolimitApplication.addLayerAt(t.name, t, 0), t
                }
                static setMode(t) {
                    J.background.setMode(t), J.reelFrame.setMode(t), J.reelBackground.setMode(t)
                }
                static createViewsAndComponents() {
                    g.NolimitConfig.isDevMode && (h.NolimitApplication.addLayerAt("SPEEDSTER", new PIXI.Container, 0), J.addLayer(new m.Speedster)), J.symbolAnimation = new j.TheCryptSymbolAnimation, J.highSymbolRealArea = new K.HighSymbolReelArea, J.realArea = new E.TheCryptReelArea, J.background = new T.TheCryptBackground, J.gameViewContainer = new X.TheCryptGameView, J.reelFrame = new H.TheCryptReelFrame, J.reelBackground = new Y.TheCryptReelBackground, J.collectors = new k.TheCryptCollector, J.initialWinView = new G.TheCryptInitialWinView, J.emptyLayerBelowCollector = new PIXI.Container, J.reelAnticipation = new Z.TheCryptReelAnticipation, J.gameViewContainer.addChild(J.background), J.gameViewContainer.addChild(J.reelBackground), J.gameViewContainer.addChild(J.realArea), J.gameViewContainer.addChild(J.highSymbolRealArea), J.gameViewContainer.addChild(J.reelFrame), J.gameViewContainer.addChild(J.symbolAnimation), J.gameViewContainer.addChild(J.reelAnticipation), J.gameViewContainer.addChild(J.emptyLayerBelowCollector), J.gameViewContainer.addChild(J.collectors), J.gameViewContainer.addChild(J.initialWinView), h.NolimitApplication.addLayerAt(J.gameViewContainer.name, J.gameViewContainer, 0), J.xBetController = new q.XBetController, h.NolimitApplication.addLayerAt(J.xBetController.name, J.xBetController, 1), J.fullScreenDimmer = new $.TheCryptFullScreenDimmer, h.NolimitApplication.addLayerAt(J.fullScreenDimmer.name, J.fullScreenDimmer, 2), J.totalWinView = new W.TheCryptTotalWinView, h.NolimitApplication.addLayerAt(J.totalWinView.name, J.totalWinView, 3), J.bigWinView = new V.TheCryptBigWinView, h.NolimitApplication.addLayerAt(J.bigWinView.name, J.bigWinView, 4), J.extraFreespinAwardView = new z.ExtraFreespinAwardView, h.NolimitApplication.addLayerAt(J.extraFreespinAwardView.name, J.extraFreespinAwardView, 5), J.freespinIntro = new y.TheCryptFreespinIntro, h.NolimitApplication.addLayerAt(J.freespinIntro.name, J.freespinIntro, 6), J.freespinOutro = new S.TheCryptFreespinOutro, h.NolimitApplication.addLayerAt(J.freespinOutro.name, J.freespinOutro, 7), J.winCapScreen = new v.TheCryptWinCapView, h.NolimitApplication.addLayerAt(J.winCapScreen.name, J.winCapScreen, 8), J.reels = [];
                    for (let t = 0; t < w.TheCryptGameConfig.reel_num; t++) {
                        const e = new I.TheCryptAvalancheReelModel(t);
                        J.reels.push(e)
                    }
                }
                static getSymbolString(t, e) {
                    return `\n            <div class="symbol">\n            <img src="{{gamePath}}screens/images/symbols/${t}.png">\n            <div class="payout-group">\n            \n                <div class="payout">\n                    <span style="margin-left: 2.38em ;padding-right:1em" class="number">6</span>\n                    <span style="margin-left: 0.1em" class="multiplier" data-multiplier="${.05 * e[6]}">${.05 * e[6]}</span>\n                </div>\n                <div class="payout">\n                    <span style="margin-left: 2.38em ;padding-right:1em" class="number">5</span>\n                    <span style="margin-left: 0.1em" class="multiplier" data-multiplier="${.05 * e[5]}">${.05 * e[5]}</span>\n                </div>\n                <div class="payout">\n                    <span style="margin-left: 2.38em ;padding-right:1em" class="number">4</span>\n                    <span style="margin-left: 0.1em" class="multiplier" data-multiplier="${.05 * e[4]}">${.05 * e[4]}</span>\n                </div>\n                <div class="payout">\n                    <span style="margin-left: 2.38em ;padding-right:1em" class="number">3</span>\n                    <span style="margin-left: 0.1em" class="multiplier" data-multiplier="${.05 * e[3]}">${.05 * e[3]}</span>\n                </div>\n            </div>\n            </div>\n        `
                }
                getPaytable() {
                    const t = new f.TemplateLoader(r.SlotGame.apiPlugin.resources.getStaticRoot());
                    t.add({
                        name: "Paytable",
                        url: "nolimit/screens/paytable.mustache"
                    });
                    let e = this._defaultSymbolValues;
                    return J.model.initData.symbolValues ? (e = J.model.initData.symbolValues, o.Logger.logDev("Using symbolValues from INIT data")) : o.Logger.logDev("Using default symbolValues"), t.load().then((t => {
                        for (let i of t)
                            if ("Paytable" === i.name && i.loadedData) {
                                for (let t in e) i.loadedData = i.loadedData.replace(`{{${t}}}`, J.getSymbolString(t, e[t]));
                                return i.loadedData
                            } throw new Error("TheCrypt could not load Paytable")
                    }))
                }
                getNoWinGameData() {
                    return {
                        reels: [
                            ["Y", "Y", "L2", "L2", "M6", "L1"],
                            ["Y", "Y", "M1", "M5", "L4", "L4"],
                            ["Y", "Y", "M4", "L3", "L1", "L1"],
                            ["Y", "Y", "L5", "M6", "L3", "S"],
                            ["Y", "Y", "M6", "L3", "L3", "M5"],
                            ["Y", "Y", "L1", "L5", "M1", "L4"]
                        ],
                        evaluatedArea: [
                            ["Y", "Y", "L2", "L2", "M6", "L1"],
                            ["Y", "Y", "M1", "M5", "L4", "L4"],
                            ["Y", "Y", "M4", "L3", "L1", "L1"],
                            ["Y", "Y", "L5", "M6", "L3", "S"],
                            ["Y", "Y", "M6", "L3", "L3", "M5"],
                            ["Y", "Y", "L1", "L5", "M1", "L4"]
                        ],
                        reelsAfterCollapse: [
                            ["Y", "Y", "L2", "L2", "M6", "L1"],
                            ["Y", "Y", "M1", "M5", "L4", "L4"],
                            ["Y", "Y", "M4", "L3", "L1", "L1"],
                            ["Y", "Y", "L5", "M6", "L3", "S"],
                            ["Y", "Y", "M6", "L3", "L3", "M5"],
                            ["Y", "Y", "L1", "L5", "M1", "L4"]
                        ],
                        betWayWins: [],
                        totalSpinWinnings: 0,
                        accumulatedRoundWin: 0,
                        playedBetValue: 100,
                        mode: "NORMAL",
                        nextMode: "NORMAL",
                        numberOfFreespinsPlayed: 0,
                        freespinsLeft: 0,
                        addedNumberOfFreespinsThisSpin: 0,
                        wasFeatureBuy: !1,
                        brokeTheBank: !1,
                        totalNumberOfWays: 4096,
                        dragonSideReel: [0, 0],
                        gameAreaSize: [4, 4, 4, 4, 4, 4],
                        xNudgeMultiplier: [0, 0, 0, 0, 0, 0],
                        thisSpinWinning: 0,
                        xNudgeMultiplierAfterCollapse: [0, 0, 0, 0, 0, 0],
                        m1NextMultiplier: 1,
                        waysWonTotalRound: 0,
                        freeSpinType: 0,
                        mysterySymbolRevealed: "",
                        m1CurrentMultiplier: 1,
                        level: 0,
                        numXNudge: 0,
                        position: [
                            [!1, !1, !1, !1],
                            [!1, !1, !1, !1],
                            [!1, !1, !1, !1],
                            [!1, !1, !1, !1],
                            [!1, !1, !1, !1],
                            [!1, !1, !1, !1]
                        ]
                    }
                }
            }
            J.boostedName = "BOOSTED_BET", e.TheCrypt = J
        },
        7162: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptGameAssets = void 0;
            const n = i(379),
                r = i(8964),
                o = i(7962),
                s = i(4168);
            class a { }
            a.INTRO_BACKGROUND = "introBg", a.INTRO_LOGO = "introLogo", a.NORMAL_REEL_DIVIDER = "reelDivider", a.NEAR_WIN_REEL_DIVIDER = "reelDividerNearWin", a.MAIN_GAME_BACKGROUND = "introBg", a.FREE_SPIN_BACKGROUND = "freespinBackground", a.FREE_SPIN_INTRO_PATTERN = "fsPattern", a.BITMAP_FONT_WIN_COUNT_UP = "NumbersWinCountUp", a.BITMAP_FONT_WIN_WAYS = "NumbersWaysWon", a.BITMAP_FONT_NUDGE_WILD_MULTIPLIER = "NumbersXNudge", a.BITMAP_FONT_METER_M1 = "NumbersM1Mult", a.BITMAP_FONT_FS_SPINS = "NumbersFSSpins", a.RESOURCES_GROUPS = {
                intro: [],
                main: [{
                    name: "fonts",
                    assets: [new r.BitmapFontAsset("numbersOpenSans800", "fonts/bitmapfonts/NumbersOpenSans800.fnt"), new r.BitmapFontAsset("NumbersM1Mult", "fonts/bitmapfonts/NumbersM1Mult.fnt"), new r.BitmapFontAsset("NumbersWaysWon", "fonts/bitmapfonts/NumbersWaysWon.fnt"), new r.BitmapFontAsset("NumbersXNudge", "fonts/bitmapfonts/NumbersXNudge.fnt"), new r.BitmapFontAsset("NumbersWinCountUp", "fonts/bitmapfonts/NumbersWinCountUp.fnt"), new r.BitmapFontAsset("NumbersFSSpins", "fonts/bitmapfonts/NumbersFSSpins.fnt")]
                }, {
                    name: "main",
                    autoLoad: [n.AssetQualityLevel.HIGH],
                    assets: [new o.TextureAsset("main0", "sheets/main/main0.json"), new o.TextureAsset("main1", "sheets/main/main1.json"), new o.TextureAsset("main2", "sheets/main/main2.json")]
                }, {
                    name: "mainHigh",
                    autoLoad: [n.AssetQualityLevel.HIGH],
                    assets: [new o.TextureAsset("mainHigh0", "sheets/mainHigh/mainHigh0.json")]
                }, {
                    name: "mainJpeg",
                    assets: [new o.TextureAsset("mainJpeg0", "sheets/mainJpeg/mainJpeg0.json"), new o.TextureAsset("mainJpeg1", "sheets/mainJpeg/mainJpeg1.json"), new o.TextureAsset("mainJpeg2", "sheets/mainJpeg/mainJpeg2.json"), new o.TextureAsset("mainJpeg3", "sheets/mainJpeg/mainJpeg3.json"), new o.TextureAsset("mainJpeg4", "sheets/mainJpeg/mainJpeg4.json"), new o.TextureAsset("mainJpeg5", "sheets/mainJpeg/mainJpeg5.json"), new o.TextureAsset("mainJpeg6", "sheets/mainJpeg/mainJpeg6.json"), new o.TextureAsset("mainJpeg7", "sheets/mainJpeg/mainJpeg7.json")],
                    animations: {
                        gemAdd: "gem_add/FS_gem_add_"
                    }
                }, {
                    name: "symbolsHighQuality",
                    autoLoad: [n.AssetQualityLevel.MEDIUM, n.AssetQualityLevel.HIGH],
                    assets: [new o.TextureAsset("symbolsHighQuality0", "sheets/symbolsHighQuality/symbolsHighQuality0.json"), new o.TextureAsset("symbolsHighQuality1", "sheets/symbolsHighQuality/symbolsHighQuality1.json")],
                    animations: {
                        symFrame: "symFrame",
                        "M/M_spin": "XW/XW_spin",
                        symFrame_FW: "symFrame_FW"
                    }
                }, {
                    name: "noTinyPng",
                    autoLoad: [n.AssetQualityLevel.HIGH],
                    assets: [new o.TextureAsset("noTinyPng", "sheets/noTinyPng/noTinyPng0.json")]
                }, {
                    name: "spine",
                    assets: [new s.SpineAsset("W_1", "spine/W_1.json"), new s.SpineAsset("W_2", "spine/W_2.json"), new s.SpineAsset("W_3", "spine/W_3.json"), new s.SpineAsset("M", "spine/XW.json"), new s.SpineAsset("meterM1", "spine/meterM1.json"), new s.SpineAsset("S_1", "spine/S_1.json"), new s.SpineAsset("S_2", "spine/S_2.json"), new s.SpineAsset("S_3", "spine/S_3.json"), new s.SpineAsset("SymLSize1", "spine/symL_1.json"), new s.SpineAsset("SymLSize2", "spine/symL_2.json"), new s.SpineAsset("SymLSize3", "spine/symL_3.json"), new s.SpineAsset("SymMSize1", "spine/symM_1.json"), new s.SpineAsset("SymMSize2", "spine/symM_2.json"), new s.SpineAsset("SymMSize3", "spine/symM_3.json"), new s.SpineAsset("reelFrame", "spine/reel_frame.json"), new s.SpineAsset("reelBg", "spine/reel_bg.json"), new s.SpineAsset("meter", "spine/meter.json"), new s.SpineAsset("FW", "spine/stacked_wild.json"), new s.SpineAsset("FS_background", "spine/FS_background.json"), new s.SpineAsset("FS_Intro", "spine/FS_Intro.json"), new s.SpineAsset("FS_Outro", "spine/FS_Outro.json"), new s.SpineAsset("bigWinLv1", "spine/bigWinLv1.json"), new s.SpineAsset("bigWinLv2", "spine/bigWinLv2.json"), new s.SpineAsset("bigWinLv3", "spine/bigWinLv3.json"), new s.SpineAsset("bigWinLv4", "spine/bigWinLv4.json"), new s.SpineAsset("bigWinLv5", "spine/bigWinLv5.json"), new s.SpineAsset("winCap", "spine/winCap.json"), new s.SpineAsset("plus2banner", "spine/plus2banner.json"), new s.SpineAsset("total_win", "spine/total_win.json"), new s.SpineAsset("s_anticipation", "spine/s_anticipation.json"), new s.SpineAsset("eyeAnimation", "spine/eye.json"), new s.SpineAsset("ghost", "spine/ghost.json")]
                }]
            }, e.TheCryptGameAssets = a
        },
        760: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptGameConfig = void 0;
            class i { }
            i.reel_num = 6, i.reelsNum = 6, i.symbolsNumOnReel = 6, i.MSymbolCollectorLevels = 4, i.M1CollectorLevels = 1, i.reelHeight = 600, i.symbolHeight = 150, i.symbolWidth = 120, i.defaultGameAreaSize = [4, 4, 4, 4, 4, 4], i.reelAreaPos = new PIXI.Point(58, 80), i.reelAreaMaskPos = new PIXI.Point(0, 0), i.reelPositions = [new PIXI.Point(0, 0), new PIXI.Point(0 + i.symbolWidth, 0), new PIXI.Point(0 + 2 * i.symbolWidth, 0), new PIXI.Point(0 + 3 * i.symbolWidth, 0), new PIXI.Point(0 + 4 * i.symbolWidth, 0), new PIXI.Point(0 + 5 * i.symbolWidth, 0), new PIXI.Point(0 + 6 * i.symbolWidth, 0)], i.DEFAULT_WAYS = 4096, i.SYMBOL_HIGHLIGHT_DURATION = .2, e.TheCryptGameConfig = i
        },
        5611: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AnimatedMeshRope = void 0;
            const n = i(6358),
                r = i(3601);
            class o extends PIXI.SimpleRope {
                constructor(t, e, i = 15) {
                    super(t[0], r.GSAPBezierSpline.interpolate(e)), this._textures = [], this._currentFrame = 0, this._textures = t, this._totalFrames = this._textures.length, this._totalDuration = this._textures.length / i, this._frameDuration = this._totalDuration / this._textures.length
                }
                playAnimation() {
                    this._tl = n.gsap.timeline();
                    for (let t = 1; t < this._totalFrames; t++) {
                        const e = t * this._frameDuration;
                        this._tl.add((() => {
                            this.updateTexture()
                        }), e)
                    }
                    this._tl.add((() => this.onRemove()))
                }
                updateTexture() {
                    this._currentFrame++, this.texture = this._textures[this._currentFrame]
                }
                onRemove() {
                    this._tl && this._tl.isActive() && (this._tl.pause(), this._tl.kill()), this.transform && (this.parent && this.parent.removeChild(this), this.destroy())
                }
            }
            e.AnimatedMeshRope = o
        },
        7429: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.BasicBitmapCountUp = void 0;
            const n = i(6358),
                r = i(1115),
                o = i(2366),
                s = i(2185);
            class a extends PIXI.Container {
                constructor(t, e, i) {
                    super(), this._maxWidth = e, this._anchor = i || new PIXI.Point(.5, .5), this._amountText = new PIXI.BitmapText("0000000", t), this.addChild(this._amountText)
                }
                stopAt(t) {
                    null != this._activeAnimation && (this._activeAnimation.pause(), this._activeAnimation.kill()), delete this._activeAnimation, this.currentCountValue = t, this._prevValue = t, this.setAmount(t)
                }
                preCalculateScale(t, e) {
                    this.setScaleToFitMaxWidth(t, e), this._pareCalculatedScale = !0
                }
                getCountAnimation(t, e, i, r = "none", a = -1) {
                    const l = o.TheCryptWinConfig.getWinConfig().type,
                        h = n.gsap.timeline({
                            onUpdate: () => this.updateText()
                        });
                    return h.add((() => {
                        l !== o.TheCryptWinConfig.LARGE && l !== o.TheCryptWinConfig.MEDIUM || s.TheCryptSoundManager.playCountUpStart(), s.TheCryptSoundManager.countUpEndSoundPlayed = !1
                    }), 0), h.add((() => this.stopAt(t))), h.add((() => {
                        this._activeAnimation = h
                    })), this._pareCalculatedScale || h.add((() => this.setScaleToFitMaxWidth(t, e))), h.add((() => this.updateTextLayout())), h.add(n.gsap.to(this, {
                        duration: i,
                        currentCountValue: e,
                        ease: r
                    })), h.add((() => {
                        this.setAmount(e), l !== o.TheCryptWinConfig.LARGE && l !== o.TheCryptWinConfig.MEDIUM || s.TheCryptSoundManager.stopSoundEffect("winCountup")
                    })), h
                }
                updateText() {
                    this.currentCountValue - this._prevValue > .01 && (this.setAmount(this.currentCountValue), this._prevValue = this.currentCountValue)
                }
                setAmount(t) {
                    const e = r.SlotGame.apiPlugin.currency.formatValue(t);
                    e.length != this._amountText.text.length ? (this._amountText.text = e, this.updateTextLayout()) : this._amountText.text = e
                }
                updateTextLayout() {
                    this._amountText.position.set(-this._amountText.width * this._anchor.x, -this._amountText.height * this._anchor.y)
                }
                setScaleToFitMaxWidth(t, e) {
                    let i = 1;
                    null != this._maxWidth && (this._amountText.scale.set(1), this.setAmount(e), i = Math.min(this._maxWidth / this._amountText.width, 1), this.setAmount(t)), this._amountText.scale.set(i)
                }
            }
            e.BasicBitmapCountUp = a
        },
        3601: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.GSAPBezierSpline = void 0;
            const n = i(9276);
            class r {
                static interpolate(t) {
                    const e = n.MotionPathPlugin.arrayToRawPath(t, {
                        type: "cubic"
                    });
                    let i = [];
                    return e.forEach((t => {
                        let e = new PIXI.Point(t[0], t[1]),
                            n = new PIXI.Point(t[2], t[3]),
                            o = new PIXI.Point(t[4], t[5]),
                            s = new PIXI.Point(t[6], t[7]),
                            a = 0;
                        for (; a < 1;) i.push(r.interpolateCubicBezier(e, n, o, s, a)), a += .02;
                        i.push(r.interpolateCubicBezier(e, n, o, s, 1))
                    })), i
                }
                static interpolateCubicBezier(t, e, i, n, r = .5) {
                    let o = new PIXI.Point;
                    return o.x = Math.pow(1 - r, 3) * t.x + 3 * Math.pow(1 - r, 2) * r * e.x + 3 * (1 - r) * Math.pow(r, 2) * i.x + Math.pow(r, 3) * n.x, o.y = Math.pow(1 - r, 3) * t.y + 3 * Math.pow(1 - r, 2) * r * e.y + 3 * (1 - r) * Math.pow(r, 2) * i.y + Math.pow(r, 3) * n.y, o
                }
            }
            e.GSAPBezierSpline = r
        },
        2092: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.AnimationEffects = void 0;
            const n = i(6358),
                r = i(6358),
                o = i(9529);
            e.AnimationEffects = class {
                static Yoyo(t) {
                    let e = t.obj.y,
                        i = t.obj.x,
                        n = !0;
                    const o = new r.gsap.core.Timeline({
                        onComplete: () => {
                            t.positionCb ? (t.obj.x = t.positionCb().x, t.obj.y = t.positionCb().y) : t.updateOnComplete && (t.obj.y = e, t.obj.x = i)
                        },
                        onUpdate: () => {
                            const r = o.progress();
                            o.time();
                            let s = t.ease ? t.ease(r) : r;
                            t.reverseEase && (s = 1 - s), n ? n = !1 : (t.positionCb && (i = t.positionCb().x, e = t.positionCb().y), t.obj.x = i + t.x * s, t.obj.y = e + t.y * s)
                        }
                    });
                    return o.to(this, {
                        duration: t.duration
                    }), o
                }
                static Shake(t) {
                    let e = t.obj.y,
                        i = t.obj.x,
                        n = !0;
                    const o = new r.gsap.core.Timeline({
                        onStart: () => {
                            e = t.obj.y, i = t.obj.x
                        },
                        onComplete: () => {
                            t.positionCb ? (t.obj.x = t.positionCb().x, t.obj.y = t.positionCb().y) : t.updateOnComplete && (t.obj.y = e, t.obj.x = i)
                        },
                        onUpdate: () => {
                            const r = o.progress(),
                                s = o.time();
                            let a = t.ease ? t.ease(r) : r;
                            n ? n = !1 : (t.positionCb && (i = t.positionCb().x, e = t.positionCb().y), t.reverseEase && (a = 1 - a), t.Intensity ? (0 != t.y && (t.obj.y = e + Math.cos(s * t.hertz) * (t.Intensity * a) * t.y), 0 != t.x && (t.obj.x = i + Math.sin(s * t.hertz) * (t.Intensity * a) * t.x)) : (0 != t.y && (t.obj.y = e + Math.cos(s * t.hertz) * a * t.y), 0 != t.x && (t.obj.x = i + Math.sin(s * t.hertz) * a * t.x)))
                        }
                    });
                    return o.to(this, {
                        duration: t.duration
                    }), o
                }
                static Bounce(t, e = 1.2, i = .25) {
                    const s = o.MathHelper.pointMul(t.scale, e),
                        a = o.MathHelper.pointMul(t.scale, 1);
                    return r.gsap.fromTo(t.scale, {
                        x: s.x,
                        y: s.y
                    }, {
                        x: a.x,
                        y: a.y,
                        duration: i,
                        ease: n.Bounce.easeOut
                    })
                }
            }
        },
        8063: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Ways = void 0;
            const n = i(760),
                r = i(6358),
                o = i(9315),
                s = i(7141),
                a = i(3832),
                l = i(7162);
            class h extends PIXI.Container {
                constructor() {
                    super(), this.name = "Ways", this._ways = new a.BitmapText(n.TheCryptGameConfig.DEFAULT_WAYS.toString(), {
                        fontName: l.TheCryptGameAssets.BITMAP_FONT_WIN_WAYS,
                        fontSize: 20,
                        tint: 16777215
                    }), this._ways.anchor = new PIXI.Point(1, 0), this._ways.letterSpacing = -12, this._animation = new o.TimelineSprite(s.TheCrypt.assetLoader.getTextures("gemAdd")), this._animation.hide(), this.addChild(this._animation), this.addChild(this._ways), this.updatePosition(), this._animation.blendMode = PIXI.BLEND_MODES.ADD, this._animation.scale.set(2), this._animation.anchor.set(.5, 0)
                }
                updatePosition() {
                    this._ways.position.set(350, 0), this._animation.position.set(350 - .5 * this._ways.width, -84)
                }
                updateValue(t) {
                    const e = new r.TimelineLite;
                    return e.add(this._animation.getAnimationAutoShowHide(!0, !0)), e.add((() => {
                        this._ways.text = t.toString(), this.updatePosition()
                    }), .3), e
                }
                reset() {
                    this._ways.text = n.TheCryptGameConfig.DEFAULT_WAYS.toString(), this.updatePosition()
                }
                get value() {
                    return parseInt(this._ways.text)
                }
                get textWidth() {
                    return this._ways.width
                }
                get textHeight() {
                    return this._ways.height
                }
            }
            e.Ways = h
        },
        5257: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptAnimationConfig = void 0;
            const n = i(3875),
                r = i(6358);
            class o { }
            o.bigWinAnticipationWiggle = n.CustomWiggle.create("bigWinAnticipationWiggle", {
                wiggles: 50,
                amplitudeEase: r.Linear.easeNone,
                timingEase: r.Linear.easeNone
            }), o.bigWinAnticipationWiggle2 = n.CustomWiggle.create("bigWinAnticipationWiggle", {
                wiggles: 40,
                amplitudeEase: r.Linear.easeNone,
                timingEase: r.Linear.easeNone
            }), o.capWinAnticipationWiggleX = n.CustomWiggle.create("Wiggle.easeOut", {
                wiggles: 70,
                type: "easeOut"
            }), o.capWinAnticipationWiggleY = n.CustomWiggle.create("Wiggle.easeOut", {
                wiggles: 70,
                type: "easeOut"
            }), e.TheCryptAnimationConfig = o
        },
        1295: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFontConfig = void 0;
            const n = i(7162);
            class r { }
            r.NUDGE_WILD_MULTIPLIER_STYLE = {
                fontName: n.TheCryptGameAssets.BITMAP_FONT_NUDGE_WILD_MULTIPLIER,
                fontSize: 54
            }, r.M1_MULTIPLIER_STYLE = {
                fontName: n.TheCryptGameAssets.BITMAP_FONT_METER_M1,
                fontSize: 34
            }, e.TheCryptFontConfig = r
        },
        3554: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptSoundConfig = void 0;
            class i { }
            i.MAIN_GAME_AMBIANCE = "background-music-main", i.FS_AMBIANCE_1 = "fs1", i.FS_AMBIANCE_2 = "fs2", i.FS_INTRO = "fsIntroLoop", i.REELS_IN = "reelsSpinIn", i.REELS_OUT = "reelsSpinOut", i.REEL_LANDING = ["reelLanding1", "reelLanding2", "reelLanding3", "reelLanding4", "reelLanding5", "reelLanding6", "reelLanding7", "reelLanding8", "reelLanding9", "reelLanding10", "reelLanding11"], i.ANTICIPATION_LANDING = "scatterAnticipationLand01", i.WIN_TINY = "winTiny", i.WIN_SMALL = "winSmall", i.WIN_MEDIUM = "winMedium", i.WIN_LARGE = "winLarge", i.WIN_CAP_MUSIC = "capWinMusic", i.WIN_CAP_START = "capWinStart", i.BIGWIN = ["bigwin1", "bigwin2", "bigwin3", "bigwin4", "bigwin5"], i.BIGWIN_ENDS = ["bigwinEnds1", "bigwinEnds1", "bigwinEnds1", "bigwinEnds2", "bigwinEnds3"], i.XWAYS_LANDING = ["xwaysLand01", "xwaysLand02", "xwaysLand03"], i.WILD_LANDING = ["wildLand01", "wildLand02", "wildLand03", "wildLand04"], i.WILD_EXPAND = "wildNudgeFinal1", i.WILD_NUDGE = ["wildNudge1", "wildNudge2", "wildNudge3"], i.WILD_NUDGE_FINAL = ["wildNudgeFinal1", "wildNudgeFinal2", "wildNudgeFinal3", "wildNudgeFinal4"], i.SCATTER_LANDING = ["scatterAnticipationLand01", "scatterAnticipationLand02", "scatterAnticipationLand03"], i.FREESPINS_ADD_2 = "fsPlusSpins", i.METER_SHOW = "fsMeterToWild", i.METER_TO_WILD = "fsMeterFull", i.METER_LIGHT = "fsMeterFill", i.SYM_TO_WILD = "fsSymToWild", i.FREESPIN_OUTRO = "fsEnds", i.WIN_EXPLOSION_SINGLE = "winExplosionSingle", i.WIN_EXPLOSION_MULTI = ["winExplosion01", "winExplosion02", "winExplosion03", "winExplosion04", "winExplosion05", "winExplosion06"], i.WIN_HIGHLIGHT_LOW = ["winHighlightLow01", "winHighlightLow02", "winHighlightLow03"], i.WIN_HIGHLIGHT_HIGH = ["winHighlightHigh01", "winHighlightHigh02", "winHighlightHigh03"], i.WIN_HIGHLIGHT_M_SYM = ["winHighlightHighSym01", "winHighlightHighSym02", "winHighlightHighSym03"], i.COLLECT_SWOOSH = ["fsMeterWoosh01", "fsMeterWoosh02", "fsMeterWoosh03", "fsMeterWoosh04", "fsMeterWoosh05", "fsMeterWoosh06"], i.CONTINUE_BUTTON = "continueButton", i.XBET_ON = "xbetOn", i.XBET_OFF = "xbetOff", i.AS_WIN = "asWin", i.AS_WIN_BIG = "asWinBig", e.TheCryptSoundConfig = i
        },
        2366: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptWinConfig = void 0;
            const n = i(7141);
            class r {
                static getWinConfig() {
                    const t = n.TheCrypt.model.winRatio;
                    for (let e = r.WIN_RATIOS.bigWin.length - 1; e >= 0; e--)
                        if (t >= r.WIN_RATIOS.bigWin[e].ratio) return 0 === e || t >= 1.2 * r.WIN_RATIOS.bigWin[e].from ? r.WIN_RATIOS.bigWin[e] : r.WIN_RATIOS.bigWin[e - 1];
                    for (let e = r.WIN_RATIOS.normalWin.length - 1; e >= 0; e--)
                        if (t >= r.WIN_RATIOS.normalWin[e].ratio) return r.WIN_RATIOS.normalWin[e];
                    return r.WIN_RATIOS.normalWin[0]
                }
                static getBigWinLevels(t) {
                    let e = [];
                    const i = r.WIN_RATIOS.bigWin.length;
                    for (let n = 0; n < i; n++) t >= r.WIN_RATIOS.bigWin[n].ratio && e.push(r.WIN_RATIOS.bigWin[n]);
                    return e
                }
                static getBigWinLevel(t) {
                    let e = -1;
                    const i = r.WIN_RATIOS.bigWin.length;
                    for (let n = 0; n < i; n++) t >= r.WIN_RATIOS.bigWin[n].ratio && (e = n);
                    return e
                }
                static setLastConfig(t, e) {
                    let i = e[e.length - 1];
                    return 1.2 * i.from > t && e.length > 1 ? (e.pop(), r.setLastConfig(t, e)) : (i.to = t, e)
                }
            }
            r.TINY = "tiny", r.SMALL = "small", r.MEDIUM = "medium", r.LARGE = "large", r.BIG_WIN_01 = "bigWin01", r.BIG_WIN_02 = "bigWin02", r.BIG_WIN_03 = "bigWin03", r.BIG_WIN_04 = "bigWin04", r.BIG_WIN_05 = "bigWin05", r.WIN_RATIOS = {
                normalWin: [{
                    ratio: 0,
                    duration: .001,
                    type: r.TINY
                }, {
                    ratio: 1.5,
                    duration: .001,
                    type: r.SMALL
                }, {
                    ratio: 3,
                    duration: .5,
                    type: r.MEDIUM
                }, {
                    ratio: 5,
                    duration: 1,
                    type: r.LARGE
                }],
                bigWin: [{
                    from: 15,
                    to: 25,
                    id: 1,
                    ratio: 15,
                    duration: 4.228,
                    type: r.BIG_WIN_01
                }, {
                    from: 25,
                    to: 50,
                    id: 2,
                    ratio: 25,
                    duration: 4.228,
                    type: r.BIG_WIN_02
                }, {
                    from: 50,
                    to: 100,
                    id: 3,
                    ratio: 50,
                    duration: 4.228,
                    type: r.BIG_WIN_03
                }, {
                    from: 100,
                    to: 250,
                    id: 4,
                    ratio: 100,
                    duration: 8.476,
                    type: r.BIG_WIN_04
                }, {
                    from: 250,
                    to: 27e3,
                    id: 5,
                    ratio: 250,
                    duration: 8.476,
                    type: r.BIG_WIN_05
                }]
            }, e.TheCryptWinConfig = r
        },
        7310: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.Speedster = void 0;
            const n = i(6358),
                r = i(3832),
                o = i(5383),
                s = i(7785),
                a = i(4514);
            class l extends PIXI.Graphics {
                constructor() {
                    super(), this.beginFill(0, .6), this.drawRect(0, 0, 300, 40), this.endFill()
                }
            }
            class h extends PIXI.Text {
                constructor(t = "", e) {
                    super(t, e), this.alpha = .7
                }
            }
            class u extends PIXI.Container {
                constructor() {
                    super(), s.NolimitConfig.isDevMode && (u.initSpeedController(this), this.onResize()), this.name = "Speedster"
                }
                static get currentText() {
                    return this.deTxt + this.globalSpeed
                }
                static get DebugText() {
                    return this.debugCont.children[1]
                }
                static pauseGame() {
                    u.globalSpeed = 1e-4, u.globalSpeed = parseFloat(u.globalSpeed.toFixed(1)), n.gsap.globalTimeline.timeScale(u.globalSpeed), u.updateText()
                }
                static initSpeedController(t) {
                    this.debugCont = t, document.addEventListener("keydown", (function (t) {
                        let e = !0;
                        switch (t.key) {
                            case "1":
                            case "r":
                            case "R":
                                u.globalSpeed = 1;
                                break;
                            case "2":
                                u.globalSpeed = 2;
                                break;
                            case "3":
                                u.globalSpeed = 3;
                                break;
                            case "4":
                                u.globalSpeed = 4;
                                break;
                            case "5":
                                u.globalSpeed = 5;
                                break;
                            case "q":
                            case "Q":
                                u.globalSpeed = 1e-4;
                                break;
                            case "s":
                            case "S":
                                u.globalSpeed = Math.max(u.globalSpeed - .1, .1);
                                break;
                            case "w":
                            case "W":
                                u.globalSpeed += .1;
                                break;
                            default:
                                e = !1
                        }
                        e && (u.globalSpeed = parseFloat(u.globalSpeed.toFixed(1)), n.gsap.globalTimeline.timeScale(u.globalSpeed), u.updateText())
                    }), !1), this.debugCont.addChild(new l), this.debugCont.addChild(new h(this.currentText, this.DEFAULT_TXT_STYLE)), this.debugCont.alpha = 0
                }
                static updateText() {
                    u.DebugText.text = u.currentText, this.tl = u.setTimeline(this.tl, new n.gsap.core.Timeline);
                    const t = .3 * this.globalSpeed,
                        e = .35 * this.globalSpeed;
                    this.tl.fromTo(this.debugCont, {
                        alpha: 1
                    }, {
                        duration: t,
                        alpha: 0,
                        delay: e
                    }), this.tl.play()
                }
                static setTimeline(t, e, i = !1) {
                    return t ? (i && t.totalProgress(1), t.pause(), t.kill(), t.clear(!0), t = void 0, e || new n.gsap.core.Timeline) : e || new n.gsap.core.Timeline
                }
                onResize() {
                    const t = this.calcDim(u.layoutDim);
                    u.debugCont && u.debugCont.children.forEach((e => {
                        e.position = t.position, e.scale = t.scale
                    }))
                }
                calcDim(t) {
                    let e = a.NolimitApplication.isLandscape ? t.landscape : t.portrait;
                    return {
                        rotation: null != e.rotation ? e.rotation : 0,
                        scale: e.scale,
                        position: e.position
                    }
                }
            }
            u.layoutDim = {
                landscape: {
                    scale: new r.Point(.75, .75),
                    position: new r.Point(260, 150)
                },
                portrait: {
                    scale: new r.Point(.75, .75),
                    position: new r.Point(260, 150)
                }
            }, u.DEFAULT_TXT_STYLE = {
                fontWeight: o.FontWeight.BOLD,
                fontFamily: "Helvetica",
                align: "center",
                fill: "#FFFFFF",
                fontSize: 34,
                wordWrap: !0,
                wordWrapWidth: 500,
                dropShadow: !0,
                dropShadowAngle: 8,
                dropShadowBlur: 4,
                dropShadowDistance: 4
            }, u.globalSpeed = 1, u.deTxt = "Current Speed: ", e.Speedster = u
        },
        1863: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptIdleNormalPresentation = void 0;
            const n = i(7141);
            e.TheCryptIdleNormalPresentation = class {
                constructor() { }
                start(t) {
                    n.TheCrypt.xBetController.buttonsVisible = !0, n.TheCrypt.autoPlayPlugin.isAutoplayRound || (n.TheCrypt.xBetController.featureEnabled = !0, n.TheCrypt.xBetController.startIdle(!n.TheCrypt.model.gameData), n.TheCrypt.reelFrame.startIdle()), this.onComplete(t)
                }
                onComplete(t) {
                    t.finish()
                }
                skip(t) {
                    this.onComplete(t)
                }
            }
        },
        2509: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptNormalBetPresentation = void 0;
            const n = i(7141),
                r = i(6358);
            e.TheCryptNormalBetPresentation = class {
                constructor() { }
                start(t) {
                    const e = r.gsap.timeline();
                    n.TheCrypt.xBetController.featureEnabled = !1, n.TheCrypt.xBetController.stopIdle(), n.TheCrypt.reelFrame.reset(), n.TheCrypt.reelFrame.stopIdle(), e.add([() => {
                        n.TheCrypt.reelBackground.onSpin(), n.TheCrypt.reelFrame.onSymbolsDropOut()
                    }, n.TheCrypt.realArea.dropOut()]), e.add((() => {
                        t.finish()
                    }), "-0.5")
                }
            }
        },
        7249: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptNormalResultPresentation = void 0;
            const n = i(3217),
                r = i(7141),
                o = i(9692),
                s = i(5885),
                a = i(9249);
            e.TheCryptNormalResultPresentation = class {
                constructor() { }
                start(t) {
                    const e = [];
                    r.TheCrypt.model.data.mode == o.TheCryptGameMode.NORMAL ? e.push(new s.DropInPresentation) : r.TheCrypt.model.data.mode == o.TheCryptGameMode.NORMAL_AVALANCHE && e.push(new a.FillUpPresentation), n.SimplePresentationRunner.run(e, (() => t.finish()), (e => t.setSkipCallback(e)))
                }
            }
        },
        9331: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptWinPresentation = void 0;
            const n = i(3217),
                r = i(355),
                o = i(6627),
                s = i(5010),
                a = i(8609),
                l = i(2139),
                h = i(9515),
                u = i(7378),
                c = i(3524);
            e.TheCryptWinPresentation = class {
                constructor() {
                    this.presentations = [new u.TheCryptXWayExpandPresentation, new s.TheCryptNudgePresentation, new r.TheCryptInitialWinPresentation, new o.CollapsePresentation, new a.WinCountUpPresentation, new h.TheCryptRoundEndPresentation, new l.TheCryptBigWinPresentation, new c.WinCapPresentation]
                }
                start(t) {
                    n.SimplePresentationRunner.run(this.presentations, (() => t.finish()), (e => t.setSkipCallback(e)))
                }
            }
        },
        5818: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptAvalancheIdlePresentation = void 0;
            const n = i(1115),
                r = i(7141),
                o = i(6865);
            e.TheCryptAvalancheIdlePresentation = class {
                constructor() { }
                start(t) {
                    n.SlotGame.apiPlugin.betHandler.zeroBet(), r.TheCrypt.model.isRestore && o.ScatterCounter.onRestore(), t.finish()
                }
            }
        },
        7917: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFSBetPresentation = void 0, e.TheCryptFSBetPresentation = class {
                start(t) {
                    t.finish()
                }
            }
        },
        4722: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFSIdlePresentation = void 0;
            const n = i(3217),
                r = i(7141),
                o = i(1115),
                s = i(1013),
                a = i(5160),
                l = i(8420),
                h = i(6627),
                u = i(4298),
                c = i(6865);
            e.TheCryptFSIdlePresentation = class {
                constructor() {
                    this._presentations = [new s.FreespinIntroPresentation, new h.CollapsePresentation, new u.DropOutPresentation, new l.UpgradeCollectorPresentation]
                }
                start(t) {
                    this._flowStateController = t, r.TheCrypt.model.isRestore && (c.ScatterCounter.onRestore(), r.TheCrypt.reelFrame.updateWays(r.TheCrypt.model.initData.totalNumberOfWays), r.TheCrypt.model.initData.accumulatedRoundWin > 0 && r.TheCrypt.keypadPlugin.setWin(r.TheCrypt.model.initData.accumulatedRoundWin, !0, a.TheCryptHelper.isWinBelowStake())), n.SimplePresentationRunner.run(this._presentations, (() => this.complete()), (e => t.setSkipCallback(e)))
                }
                complete() {
                    const t = r.TheCrypt.model.isRestore ? 0 : r.TheCrypt.model.data.addedNumberOfFreespinsThisSpin;
                    let e = r.TheCrypt.model.freespinsLeft - 1 - t;
                    r.TheCrypt.model.freespinTriggeredThisSpin || !r.TheCrypt.model.isNextRespin ? (r.TheCrypt.reelFrame.reset(), e += r.TheCrypt.model.freespinTriggeredThisSpin ? t : 0, r.TheCrypt.keypadPlugin.setZeroBetSpinCounter(e)) : r.TheCrypt.model.isRestore && (r.TheCrypt.reelFrame.reset(), e += 1, r.TheCrypt.keypadPlugin.setZeroBetSpinCounter(e)), o.SlotGame.apiPlugin.betHandler.zeroBet(), this._flowStateController.finish()
                }
            }
        },
        447: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFSResultPresentation = void 0;
            const n = i(7141),
                r = i(3217),
                o = i(9692),
                s = i(5885),
                a = i(9249);
            e.TheCryptFSResultPresentation = class {
                start(t) {
                    const e = [];
                    n.TheCrypt.model.data.mode == o.TheCryptGameMode.FREESPIN ? e.push(new s.DropInPresentation) : n.TheCrypt.model.data.mode == o.TheCryptGameMode.FREESPIN_AVALANCHE && e.push(new a.FillUpPresentation), r.SimplePresentationRunner.run(e, (() => t.finish()), (e => t.setSkipCallback(e)))
                }
            }
        },
        2054: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFSWinPresentation = void 0;
            const n = i(3217),
                r = i(7378),
                o = i(5010),
                s = i(355),
                a = i(8609),
                l = i(9515),
                h = i(2139),
                u = i(8058),
                c = i(3524),
                d = i(870);
            e.TheCryptFSWinPresentation = class {
                constructor() {
                    this._presentations = [new r.TheCryptXWayExpandPresentation, new o.TheCryptNudgePresentation, new s.TheCryptInitialWinPresentation, new a.WinCountUpPresentation, new l.TheCryptRoundEndPresentation, new h.TheCryptBigWinPresentation, new u.FreespinOutroPresentation, new c.WinCapPresentation, new d.FreeSpinNoWinPause]
                }
                start(t) {
                    n.SimplePresentationRunner.run(this._presentations, (() => t.finish()), (e => t.setSkipCallback(e)))
                }
            }
        },
        7246: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptIntroConfig = void 0;
            const n = i(8115),
                r = i(2408),
                o = i(4514),
                s = i(8917);
            e.TheCryptIntroConfig = class {
                constructor() {
                    this.colors = {
                        slideShowColors: {
                            backgroundColor: 0,
                            backgroundAlpha: .8,
                            bulletColor: 16777215
                        },
                        stampColor: 16777215
                    }, this.continueButtonClickSound = "continueButton", this.stampConfig = {
                        xBet: !0,
                        xWays: !0,
                        xNudge: !0,
                        volatility: n.Volatility.EXTREME
                    }
                }
                init() {
                    const t = new r.ImgLoader(o.NolimitApplication.resourcePath);
                    return t.add("introBg", "resources/images/Intro_BG.jpg"), t.add("introDiv", "resources/images/Intro_Divider.png"), t.add("feature1", "resources/images/intro_feature1.png"), t.add("feature2", "resources/images/intro_feature2.png"), t.add("logo", "resources/images/introLogo.png"), t.load().then((t => (this.initGraphics(), this)))
                }
                initGraphics() {
                    this.background = new PIXI.Container;
                    const t = new PIXI.Sprite(r.ImgLoader.getImgTexture("introBg"));
                    t.anchor.set(.5, .5), this.background.addChild(t), this.borderTop = new PIXI.Container;
                    const e = new PIXI.Sprite(r.ImgLoader.getImgTexture("introDiv"));
                    e.anchor.set(.5, .5), this.borderTop.addChild(e), this.borderBottom = new PIXI.Container;
                    const i = new PIXI.Sprite(r.ImgLoader.getImgTexture("introDiv"));
                    i.rotation = Math.PI, i.anchor.set(.5, .5), this.borderBottom.addChild(i), this.logo = new PIXI.Container;
                    const n = new PIXI.Sprite(r.ImgLoader.getImgTexture("logo"));
                    n.anchor.set(.5, .5), n.position.set(-5, 18), this.logo.addChild(n), this.pages = [new s.TheCryptSlideShowPage(r.ImgLoader.getImgTexture("feature1")), new s.TheCryptSlideShowPage(r.ImgLoader.getImgTexture("feature2"))]
                }
                onShow() {
                    this.logo.parent.addChild(this.logo)
                }
            }
        },
        8917: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptSlideShowPage = void 0;
            const n = i(2960);
            class r extends n.SlideShowPage {
                constructor(t) {
                    if (super(void 0, void 0, void 0, void 0), t) {
                        let e = new PIXI.Sprite(t);
                        e.anchor.set(.5), this.addChild(e)
                    }
                }
            }
            e.TheCryptSlideShowPage = r
        },
        2139: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptBigWinPresentation = void 0;
            const n = i(7141),
                r = i(6358),
                o = i(2366),
                s = i(2185);
            e.TheCryptBigWinPresentation = class {
                constructor() {
                    this.FADE_AWAY_DURATION = 3
                }
                shouldRun() {
                    return !n.TheCrypt.model.brokeTheBank && n.TheCrypt.model.isBigWin
                }
                start(t) {
                    const e = this._bigWinLevels = o.TheCryptWinConfig.getBigWinLevels(n.TheCrypt.model.winRatio),
                        i = e.length;
                    n.TheCrypt.bigWinView.maxLevel = i;
                    const a = n.TheCrypt.model.gameData.totalSpinWinnings,
                        l = r.gsap.timeline(),
                        h = n.TheCrypt.model.hasXWaysSymbolThisAvalanche ? 1 : 0;
                    l.add(n.TheCrypt.gameViewContainer.addDimmer(!0, 1.215), h + .7);
                    for (let t = 0; t < 6; t++) n.TheCrypt.realArea.allReels[t].reelView.getAllSymbols().forEach((t => {
                        l.add(t.getShakeAnimation(1.715), h)
                    }));
                    l.add((() => {
                        s.TheCryptSoundManager.playBigWinLevelSound(0)
                    }), h), l.add(n.TheCrypt.bigWinView.show(.1), h + 1.715 - .2);
                    for (let r = 0; r < e.length; r++) {
                        const o = e[r],
                            h = 0 === r ? 0 : o.from * n.TheCrypt.model.gameData.playedBetValue,
                            u = r + 1 === i ? a : o.to * n.TheCrypt.model.gameData.playedBetValue,
                            c = l.duration();
                        l.add((() => {
                            t.setSkipCallback((() => {
                                n.TheCrypt.bigWinView.onAbort(o.id - 1), l.seek(o.type + "_end", !1)
                            }))
                        }), c), l.add([() => {
                            s.TheCryptSoundManager.playBigWinLevelSound(r)
                        }, n.TheCrypt.bigWinView.getLevelAnimation(h, u, o.duration, o.id)], c), l.addLabel(o.type + "_end")
                    }
                    l.add((() => {
                        n.TheCrypt.bigWinView.hide(this.FADE_AWAY_DURATION)
                    })), l.add((() => {
                        t.finish()
                    }), "+=" + .8 * this.FADE_AWAY_DURATION)
                }
            }
        },
        355: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptInitialWinPresentation = void 0;
            const n = i(2185),
                r = i(3554),
                o = i(7141),
                s = i(2820),
                a = i(6358),
                l = i(2366),
                h = i(5160),
                u = i(6364);
            e.TheCryptInitialWinPresentation = class {
                constructor() { }
                shouldRun() {
                    return o.TheCrypt.model.isNextRespin
                }
                start(t) {
                    const e = a.gsap.timeline(),
                        i = o.TheCrypt.model.currentWinRatio >= l.TheCryptWinConfig.WIN_RATIOS.normalWin[3].ratio,
                        c = i ? .12 : 0,
                        d = i ? .2 : 0,
                        p = h.TheCryptHelper.getToggleType(),
                        f = u.ArrayHelper.initArrayWithValues(6, (() => !1)),
                        g = u.ArrayHelper.initArrayWithValues(6, (() => !1));
                    let m = [],
                        _ = [],
                        y = [];
                    i && (m = u.ArrayHelper.shuffle(r.TheCryptSoundConfig.WIN_EXPLOSION_MULTI));
                    const S = u.ArrayHelper.shuffle(i ? r.TheCryptSoundConfig.WIN_HIGHLIGHT_HIGH : r.TheCryptSoundConfig.WIN_HIGHLIGHT_LOW),
                        v = u.ArrayHelper.shuffle(r.TheCryptSoundConfig.WIN_HIGHLIGHT_M_SYM);
                    y = v, _ = S, e.add((() => t.setSkipCallback((() => {
                        e.timeScale(2), b.timeScale(2)
                    })))), e.add((() => { }), o.TheCrypt.model.hasXWaysSymbolThisAvalanche && o.TheCrypt.model.hasNudge.indexOf(!0) < 0 ? .6 : 0), e.add(o.TheCrypt.realArea.addDimmer());
                    const b = a.gsap.timeline();
                    o.TheCrypt.model.gameData.betWayWins.forEach(((t, r) => {
                        const s = a.gsap.timeline(),
                            l = o.TheCrypt.initialWinView.findLastNoWildSymbolPosition(t);
                        t.reelWinPositions.forEach(((e, r) => {
                            e.forEach(((e, a) => {
                                if (e) {
                                    const e = o.TheCrypt.realArea.getSymbol([r, a]);
                                    "FW" === e.symName && (g[r] = !0), r === l[0] && a === l[1] && s.add((() => {
                                        o.TheCrypt.initialWinView.playWinNumbers(t, !1, l)
                                    }), r * c), s.add(e.playInitialWin(p), 0), i && !f[r] && (b.add((() => {
                                        n.TheCryptSoundManager.playSound(m[r]), g[r] && n.TheCryptSoundManager.playSound("wildExplosion")
                                    }), r * d), f[r] = !0), b.add(e.explode(p), r * d)
                                }
                            }))
                        })), e.add([() => {
                            0 === r && (o.TheCrypt.reelFrame.onWinToggle(), o.TheCrypt.reelBackground.onWinToggle()), n.TheCryptSoundManager.playSound("M" === t.symbol[0] ? y[r % 3] : _[r % 3]), g.indexOf(!0) > -1 && n.TheCryptSoundManager.playSound("wildHighlight")
                        }, s])
                    })), e.add(o.TheCrypt.collectors.collect()), e.add([() => {
                        i || (n.TheCryptSoundManager.playSound(r.TheCryptSoundConfig.WIN_EXPLOSION_SINGLE), g.indexOf(!0) > -1 && n.TheCryptSoundManager.playSound("wildExplosion"))
                    }, b]), e.add([() => {
                        o.TheCrypt.keypadPlugin.setWin(o.TheCrypt.model.gameData.accumulatedRoundWin, !0, h.TheCryptHelper.isWinBelowStake()), t.finish()
                    }, o.TheCrypt.realArea.removeDimmer()], "-=0.5"), o.TheCrypt.apiPlugin.settings.get(s.APISetting.FAST_SPIN) && (e.timeScale(1.4), b.timeScale(1.4))
                }
            }
        },
        9515: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptRoundEndPresentation = void 0;
            const n = i(7141),
                r = i(6358),
                o = i(5160),
                s = i(6865);
            e.TheCryptRoundEndPresentation = class {
                constructor() { }
                shouldRun() {
                    return !o.TheCryptHelper.isRespin(n.TheCrypt.model.nextMode)
                }
                start(t) {
                    const e = r.gsap.timeline({
                        onComplete: () => t.finish()
                    });
                    e.add((() => {
                        n.TheCrypt.model.freespinTriggeredThisSpin || s.ScatterCounter.reset(), n.TheCrypt.reelAnticipation.reset()
                    })), e.add((() => t.setSkipCallback())), e.to(this, {
                        duration: .01
                    })
                }
            }
        },
        3524: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.WinCapPresentation = void 0;
            const n = i(7141),
                r = i(6358),
                o = i(2185);
            e.WinCapPresentation = class {
                constructor() {
                    this.name = "WinCapPresentation"
                }
                shouldRun() {
                    return n.TheCrypt.model.brokeTheBank
                }
                start(t) {
                    this._flowStateController = t;
                    const e = r.gsap.timeline(),
                        i = n.TheCrypt.model.hasXWaysSymbolThisAvalanche ? 1 : 0;
                    e.add((() => o.TheCryptSoundManager.playSound("capWinIntro")), i);
                    for (let t = 0; t < 6; t++) n.TheCrypt.realArea.allReels[t].reelView.getAllSymbols().forEach((t => {
                        e.add(t.getShakeAnimation(3, !0), i)
                    }));
                    e.add(n.TheCrypt.winCapScreen.show((() => this.complete())))
                }
                complete() {
                    this._flowStateController.finish(), n.TheCrypt.keypadPlugin.setZeroBetSpinCounter(-1), n.TheCrypt.keypadPlugin.show(), n.TheCrypt.collectors.reset(), n.TheCrypt.setMode(n.TheCrypt.model.data.nextMode)
                }
            }
        },
        8609: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.WinCountUpPresentation = void 0;
            const n = i(7141),
                r = i(2820),
                o = i(6358),
                s = i(2366),
                a = i(5160);
            e.WinCountUpPresentation = class {
                constructor() { }
                shouldRun() {
                    return !n.TheCrypt.model.brokeTheBank && !n.TheCrypt.model.isBigWin && n.TheCrypt.model.isWin
                }
                start(t) {
                    const e = o.gsap.timeline(),
                        i = a.TheCryptHelper.isWinBelowStake();
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(2)
                    })))), i ? e.add((() => {
                        n.TheCrypt.keypadPlugin.setWin(n.TheCrypt.model.gameData.accumulatedRoundWin, !0, i), t.finish()
                    })) : (e.add(n.TheCrypt.totalWinView.show(s.TheCryptWinConfig.getWinConfig())), e.to(this, {
                        duration: .01
                    }), e.add((() => t.finish()), "-=1")), n.TheCrypt.apiPlugin.settings.get(r.APISetting.FAST_SPIN) && e.timeScale(1.4)
                }
            }
        },
        870: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreeSpinNoWinPause = void 0;
            const n = i(7141),
                r = i(6358);
            e.FreeSpinNoWinPause = class {
                constructor() {
                    this.name = "FreeSpinNoWinPause"
                }
                shouldRun() {
                    return !n.TheCrypt.model.gameData.totalSpinWinnings
                }
                start(t) {
                    (new r.TimelineLite).add((() => t.finish()), 1)
                }
            }
        },
        8058: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreespinOutroPresentation = void 0;
            const n = i(7141);
            e.FreespinOutroPresentation = class {
                constructor() {
                    this.name = "FreespinOutroPresentation"
                }
                shouldRun() {
                    return !n.TheCrypt.model.isNormal && n.TheCrypt.model.isNextNormal
                }
                start(t) {
                    this._flowStateController = t, n.TheCrypt.freespinOutro.show((() => this.complete()), n.TheCrypt.apiPlugin.isReplay)
                }
                complete() {
                    this._flowStateController.finish(), n.TheCrypt.keypadPlugin.setZeroBetSpinCounter(-1), n.TheCrypt.keypadPlugin.show(), n.TheCrypt.collectors.reset(), n.TheCrypt.setMode(n.TheCrypt.model.data.nextMode)
                }
            }
        },
        8420: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.UpgradeCollectorPresentation = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2820);
            e.UpgradeCollectorPresentation = class {
                constructor() {
                    this.name = "UpgradeCollectorPresentation"
                }
                shouldRun() {
                    const t = 2 === r.TheCrypt.model.data.addedNumberOfFreespinsThisSpin || r.TheCrypt.collectors.fullyChargedM1Collector;
                    return !r.TheCrypt.model.isRestore && t
                }
                start(t) {
                    const e = n.gsap.timeline({
                        onComplete: () => t.finish()
                    });
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(3)
                    })))), e.add(r.TheCrypt.collectors.showFullFilledCollectorAnimation()), e.to(this, {
                        duration: .01
                    }), r.TheCrypt.apiPlugin.settings.get(o.APISetting.FAST_SPIN) && e.timeScale(1.4)
                }
            }
        },
        6627: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.CollapsePresentation = void 0;
            const n = i(7141),
                r = i(6358);
            e.CollapsePresentation = class {
                constructor() {
                    this.name = "CollapseAndFillPresentation"
                }
                shouldRun() {
                    return n.TheCrypt.model.isNextRespin && !n.TheCrypt.model.brokeTheBank
                }
                start(t) {
                    const e = r.gsap.timeline();
                    e.add((() => t.setSkipCallback())), e.add(n.TheCrypt.realArea.collapse()), e.add((() => t.finish()), .1), e.to(this, {
                        duration: .01
                    })
                }
            }
        },
        5885: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.DropInPresentation = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2820);
            e.DropInPresentation = class {
                constructor() {
                    this.name = "DropInPresentation"
                }
                shouldRun() {
                    return !0
                }
                start(t) {
                    const e = n.gsap.timeline();
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(3)
                    }))));
                    let i = r.TheCrypt.gameFlowController.calculatePaddingDuration(5 * r.TheCrypt.realArea.DROP_IN_REEL_DELAY);
                    i = i > 0 ? i : 0, e.add(r.TheCrypt.realArea.dropIn(i)), e.add((() => r.TheCrypt.reelAnticipation.fadeOutAnticipationSound())), e.addLabel("ending"), e.add((() => t.finish())), r.TheCrypt.apiPlugin.settings.get(o.APISetting.FAST_SPIN) && e.timeScale(1.4)
                }
            }
        },
        4298: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.DropOutPresentation = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2820);
            e.DropOutPresentation = class {
                constructor() {
                    this.name = "DropOutPresentation"
                }
                shouldRun() {
                    return !r.TheCrypt.model.isNextRespin
                }
                start(t) {
                    const e = n.gsap.timeline();
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(2)
                    })))), e.add([() => {
                        r.TheCrypt.reelBackground.onSpin(), r.TheCrypt.reelFrame.onSymbolsDropOut()
                    }, r.TheCrypt.realArea.dropOut()]);
                    const i = .5 * e.duration();
                    e.add((() => t.finish()), i), e.addLabel("ending"), r.TheCrypt.apiPlugin.settings.get(o.APISetting.FAST_SPIN) && e.timeScale(1.4)
                }
            }
        },
        9249: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FillUpPresentation = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2820),
                s = i(6865);
            e.FillUpPresentation = class {
                constructor() {
                    this.name = "FillUpPresentation"
                }
                shouldRun() {
                    return !0
                }
                start(t) {
                    const e = n.gsap.timeline({
                        onComplete: () => t.finish()
                    });
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(3)
                    })))), e.add(r.TheCrypt.realArea.fillUp()), e.add((() => r.TheCrypt.reelAnticipation.fadeOutAnticipationSound())), s.ScatterCounter.allScatters.length >= 2 && r.TheCrypt.reelAnticipation.update(0), e.to(this, {
                        duration: .01
                    }), r.TheCrypt.apiPlugin.settings.get(o.APISetting.FAST_SPIN) && e.timeScale(1.4)
                }
            }
        },
        1013: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.FreespinIntroPresentation = void 0;
            const n = i(6358),
                r = i(7141);
            e.FreespinIntroPresentation = class {
                constructor() {
                    this.name = "FreespinWinPresentation"
                }
                shouldRun() {
                    const t = r.TheCrypt.model.isRestore,
                        e = !r.TheCrypt.model.isNextNormal,
                        i = r.TheCrypt.model.freespinTriggeredThisSpin;
                    return t && e || i
                }
                start(t) {
                    this._flowStateController = t, r.TheCrypt.autoPlayPlugin.turnOffAutoplayOnBonus && r.TheCrypt.autoPlayPlugin.turnOffAutoplayOnBonus(), r.TheCrypt.freespinIntro.show((() => this.complete()), r.TheCrypt.apiPlugin.isReplay)
                }
                complete() {
                    r.TheCrypt.setMode(r.TheCrypt.model.data.nextMode);
                    const t = new n.TimelineLite;
                    t.add(r.TheCrypt.collectors.show(r.TheCrypt.model.isRestore)), t.add((() => {
                        r.TheCrypt.keypadPlugin.show(.2), this._flowStateController.finish()
                    }))
                }
            }
        },
        5010: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptNudgePresentation = void 0;
            const n = i(6358),
                r = i(7141);
            e.TheCryptNudgePresentation = class {
                constructor() {
                    this.name = "DropInPresentation"
                }
                shouldRun() {
                    return r.TheCrypt.model.hasNudge.indexOf(!0) > -1
                }
                start(t) {
                    const e = n.gsap.timeline({
                        onComplete: () => t.finish()
                    });
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(2)
                    }))));
                    let i = 0;
                    r.TheCrypt.model.xNudgeMultiplier.forEach(((t, n) => {
                        t > 0 && (e.add(r.TheCrypt.realArea.allReels[n].reelView.nudge(t, i), .6 * i), i++)
                    })), e.addLabel("ending"), e.to(this, {
                        duration: .01
                    })
                }
            }
        },
        7378: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptXWayExpandPresentation = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2820),
                s = i(7087),
                a = i(2185);
            e.TheCryptXWayExpandPresentation = class {
                constructor() {
                    this.name = "TheCryptXWayExpandPresentation"
                }
                shouldRun() {
                    return r.TheCrypt.model.hasXWaysSymbolThisAvalanche
                }
                start(t) {
                    const e = n.gsap.timeline({
                        onComplete: () => t.finish()
                    }),
                        i = r.TheCrypt.apiPlugin.settings.get(o.APISetting.FAST_SPIN) || r.TheCrypt.model.hasNoAvalancheWin;
                    e.add((() => t.setSkipCallback((() => {
                        e.timeScale(1.5)
                    })))), e.add(s.TheCryptSymbolHighlighter.playXWayPotentialWinHighlighter());
                    const l = e.duration();
                    i && e.add((() => {
                        a.TheCryptSoundManager.playSound(`xwaysExpand${r.TheCrypt.model.hasNoAvalancheWin ? "No" : ""}Win`)
                    }), l), r.TheCrypt.model.mysterySymbolPositions.forEach((t => {
                        let n = i ? l : e.duration();
                        e.add([() => {
                            i || a.TheCryptSoundManager.playSound("xwaysExpandWin")
                        }, r.TheCrypt.realArea.allReels[t].reelView.expand()], n)
                    })), e.to(this, {
                        duration: .01
                    })
                }
            }
        },
        5411: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptAvalancheReelModel = void 0;
            const n = i(1115),
                r = i(16);
            e.TheCryptAvalancheReelModel = class {
                constructor(t, e = !0) {
                    this._reelId = t, this._reelView = new r.TheCryptReelView(t), e && (this.events = n.SlotGame.apiPlugin.eventSystemFactory.create(), this.events.on("ReelStateChange", (t => this.onReelStateChange(t))))
                }
                init(t) {
                    this._reelView.initReel(t)
                }
                reInitReels(t) {
                    this._reelView.removeAllSymbols(), this._reelView.initReel(t)
                }
                onReelStateChange(t) {
                    var e;
                    null === (e = this.events) || void 0 === e || e.trigger(t.state, t)
                }
                get reelView() {
                    return this._reelView
                }
            }
        },
        6810: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptReelArea = void 0;
            const n = i(7141),
                r = i(5411),
                o = i(760),
                s = i(6358),
                a = i(2820),
                l = i(9529),
                h = i(2185);
            class u extends PIXI.Container {
                get isFastSpin() {
                    return !!n.TheCrypt.apiPlugin.settings.get(a.APISetting.FAST_SPIN, !1) || !(!n.TheCrypt.model.data.wasFeatureBuy || !n.TheCrypt.model.isNormal || n.TheCrypt.model.isLuckyDraw)
                }
                get hasAnticipation() {
                    return !n.TheCrypt.apiPlugin.settings.get(a.APISetting.FAST_SPIN, !1)
                }
                creatDimmer() {
                    this._dimmer = new PIXI.Sprite(PIXI.Texture.WHITE), this._dimmer.name = "dimmer", this._dimmer.width = this.getReelAreaWidth(), this._dimmer.height = this.getReelAreaHeight(), this._dimmer.position.set(.5 * -o.TheCryptGameConfig.symbolWidth, 0), this._dimmer.tint = 0, this._dimmer.alpha = .7, this._dimmer.visible = !1
                }
                constructor() {
                    super(), this.DROP_IN_REEL_DELAY = .1, this.FAST_DROP_IN_REEL_DELAY = .05, this.FULL_UP_REEL_DELAY = .05, this.DROP_OUT_REEL_DELAY = .02, this.FILL_UP_REEL_DELAY = .05, this.COLLAPSE_REEL_DELAY = .05, this.DROP_IN_NEAR_WIN_DELAY = 1, this.FAST_DROP_IN_NEAR_WIN_DELAY = .3, this.init()
                }
                init() {
                    this.name = "ReelAreaView", this._allReels = [];
                    const t = n.TheCrypt.model.reelsData;
                    let e;
                    for (let i = 0; i < t.length; i++) {
                        e = [];
                        const n = new r.TheCryptAvalancheReelModel(i);
                        this._allReels.push(n), this.addChild(n.reelView), n.init(t[i])
                    }
                    for (let t = 0; t < this._allReels.length; t++) n.TheCrypt.highSymbolRealArea.addChild(this._allReels[t].reelView.fullWildSymbolView), n.TheCrypt.highSymbolRealArea.addChild(this._allReels[t].reelView.scatterSymbolView), n.TheCrypt.symbolAnimation.addChild(this._allReels[t].reelView.initialWinSymbolView), n.TheCrypt.symbolAnimation.addChild(this._allReels[t].reelView.fullWildSymbolWinView), n.TheCrypt.symbolAnimation.addChild(this._allReels[t].reelView.scatterWinView);
                    const i = new PIXI.Graphics;
                    i.name = "reelAreaMask", i.beginFill(16776971, .5), i.drawRect(-o.TheCryptGameConfig.symbolWidth, 0, this.getReelAreaWidth() + o.TheCryptGameConfig.symbolWidth, this.getReelAreaHeight()), this.addChild(i), this.mask = i, this.position = o.TheCryptGameConfig.reelAreaPos, this.creatDimmer()
                }
                reInitReels() {
                    const t = n.TheCrypt.model.reelsData;
                    for (let e = 0; e < t.length; e++) this._allReels[e].reInitReels(t[e])
                }
                getReelAreaWidth() {
                    return o.TheCryptGameConfig.symbolWidth * o.TheCryptGameConfig.reelsNum + 20
                }
                getReelAreaHeight() {
                    return 4 * o.TheCryptGameConfig.symbolHeight
                }
                get needFillUpReels() {
                    return this._needFillUpReels
                }
                addDimmer() {
                    return (new s.TimelineLite).add((() => {
                        n.TheCrypt.highSymbolRealArea.addChild(this._dimmer), this._dimmer.alpha = 0, this._dimmer.visible = !0
                    })).add(s.TweenLite.to(this._dimmer, .2, {
                        alpha: .7
                    }))
                }
                removeDimmer() {
                    return (new s.TimelineLite).to(this._dimmer, .2, {
                        alpha: 0
                    }).add((() => {
                        this._dimmer.visible = !1
                    }))
                }
                dropIn(t) {
                    const e = [],
                        i = n.TheCrypt.model.nearWinReels,
                        r = this.hasAnticipation,
                        o = this.hasAnticipation ? this.DROP_IN_NEAR_WIN_DELAY : this.FAST_DROP_IN_NEAR_WIN_DELAY,
                        s = this.isFastSpin ? this.FAST_DROP_IN_REEL_DELAY : this.DROP_IN_REEL_DELAY,
                        a = l.MathHelper.roundToDecimals(t / 5, 1);
                    this._needFillUpReels = [!0, !0, !0, !0, !0, !0], h.TheCryptSoundManager.newAvalanche = !0;
                    let u = 0;
                    return this._allReels.forEach(((t, n) => {
                        u += s + (i[n] ? o : 0), e.push(t.reelView.dropIn(u + a * n, r))
                    })), e
                }
                dropOut() {
                    const t = new s.TimelineLite;
                    return this._allReels.forEach(((e, i) => {
                        t.add(e.reelView.dropOut(Math.abs(2.5 - i) * this.DROP_OUT_REEL_DELAY), 0)
                    })), t
                }
                fillUp() {
                    const t = [],
                        e = n.TheCrypt.model.nearWinReels,
                        i = this.hasAnticipation;
                    let r = 0;
                    return h.TheCryptSoundManager.newAvalanche = !0, this._needFillUpReels = [!0, !0, !0, !0, !0, !0], this._allReels.forEach(((n, o) => {
                        n.reelView.needFillUp ? (r += o * this.FULL_UP_REEL_DELAY + (e[o] && o > 0 ? this.DROP_IN_NEAR_WIN_DELAY : 0), t.push(n.reelView.fillUp(r, i))) : this._needFillUpReels[o] = !1
                    })), t
                }
                collapse() {
                    const t = [];
                    let e = 0;
                    return this._allReels.forEach((i => {
                        i.reelView.calculateCollapseData(), i.reelView.needCollapse && (t.push(i.reelView.collapse(e)), e += this.COLLAPSE_REEL_DELAY)
                    })), t
                }
                getSymbol(t) {
                    return this._allReels[t[0]].reelView.getSymbol(t[1])
                }
                get allReels() {
                    return this._allReels
                }
            }
            e.TheCryptReelArea = u
        },
        16: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptReelView = void 0;
            const n = i(6501),
                r = i(7141),
                o = i(6358),
                s = i(760),
                a = i(2185),
                l = i(2820),
                h = i(6364),
                u = i(5160),
                c = i(1199),
                d = i(9529),
                p = i(6865),
                f = i(4336),
                g = i(3554);
            class m extends PIXI.Container {
                constructor(t) {
                    super(), this.DURATION_SYMBOLS_FALL_OUT = .4, this.DURATION_SYMBOLS_FALL_IN = .3, this.DURATION_SYMBOLS_FALL = .3, this.DURATION_SYMBOLS_COLLAPSE_FALL = .1, this.DURATION_SYMBOLS_UNBLUR = .02, this.DURATION_SYMBOLS_EXPAND = .2, this.DURATION_FAST_SYMBOLS_FALL_IN = .2, this.DURATION_FAST_SYMBOLS_FALL_OUT = .4, this.DURATION_FAST_SYMBOLS_EXPAND = .2, this.DURATION_FAST_SYMBOLS_COLLAPSE_FALL = .05, this.DURATION_FAST_SYMBOLS_FALL_SPIN = .3, this.SYMBOLS_FALL_IN_DELAY_NEAR_WIN = .3, this.SYMBOLS_FALL_IN_BLUR_DELAY = .1, this.SYMBOLS_FALL_IN_DELAY = .05, this.SYMBOLS_FALL_OUT_DELAY = .08, this.START_DROP_IN_POSITION = -1e3, this._allOutSymbols = [], this._collapsedReel = [], this._xWaysSymbol = [], this._isStacked = !1, this._scatterWinView = new PIXI.Container, this._scatterSymbolView = new PIXI.Container, this._fullWildSymbolView = new PIXI.Container, this._fullWildSymbolWinView = new PIXI.Container, this._initialWinSymbolView = new PIXI.Container, this._scatterWinView.name = "scatterWinView" + t, this._scatterSymbolView.name = "scatterSymbol" + t, this._fullWildSymbolView.name = "fullWild" + t, this._fullWildSymbolWinView.name = "fullWildWin" + t, this._initialWinSymbolView.name = "initialWinSymbol" + t, this.name = "Reel " + t, this._isStacked = !1, this._reelId = t, this.position = s.TheCryptGameConfig.reelPositions[t], this._scatterSymbolView.position = s.TheCryptGameConfig.reelPositions[t], this._fullWildSymbolView.position = s.TheCryptGameConfig.reelPositions[t], this._fullWildSymbolWinView.position = s.TheCryptGameConfig.reelPositions[t], this._scatterWinView.position = s.TheCryptGameConfig.reelPositions[t], this._initialWinSymbolView.position = s.TheCryptGameConfig.reelPositions[t], this._scatterSymbolView.sortableChildren = !0, this._xWaysSymbol = []
                }
                removeAvalancheSymbol(t) {
                    t.symName.indexOf("FW") > -1 ? this._fullWildSymbolView.removeChild(t) : "S" === t.symName ? this.scatterSymbolView.removeChild(t) : this.removeChild(t), t.remove()
                }
                reArrangeSymbolLayer() {
                    let t = 0;
                    this._allOutSymbols.forEach((e => {
                        u.TheCryptHelper.isLargerSymbol(e.symName) || this.addChildAt(e, t++)
                    }))
                }
                resetSymbolPositions() {
                    r.TheCrypt.model.wildOnReel[this._reelId] || this._allOutSymbols.forEach(((t, e) => {
                        t.id = e, t.position.set(0, r.TheCrypt.model.symbolPositionYsAfterReveal[this._reelId][e])
                    }))
                }
                switchSymbol(t, e, i = !1) {
                    const s = i ? r.TheCrypt.model.mysterySymbolSize[this._reelId] : 1,
                        a = r.TheCrypt.model.gameData.m1CurrentMultiplier,
                        l = [];
                    i && this._xWaysSymbol.push(t);
                    for (let i = 0; i < s; i++) {
                        const o = this.createSymbol({
                            symName: e,
                            reelSize: r.TheCrypt.model.afterRevealGameAreaSize[this._reelId],
                            symSize: r.TheCrypt.model.afterRevealGameAreaSize[this._reelId] - 3,
                            id: t.id - i,
                            reelId: this._reelId,
                            M1Multiplier: "M1" === e && a > 1 ? a : 1
                        }, n.TheCryptSymbolStates.NORMAL, t.id);
                        l.push(o), o.alpha = 0
                    }
                    const h = new o.TimelineLite;
                    return "FW" === e && h.add(l[0].getStateAnimation(n.TheCryptSymbolStates.EXPAND), 0), h.add((() => {
                        for (this._allOutSymbols.splice(t.id, 1), l.forEach((e => {
                            e.alpha = 1, this._allOutSymbols.splice(t.id, 0, e)
                        })); this._allOutSymbols.length > 6;) {
                            const t = this._allOutSymbols.shift();
                            this.removeAvalancheSymbol(t), u.TheCryptHelper.isInvisibleSym(t.symName)
                        }
                        this.resetSymbolPositions(), this.reArrangeSymbolLayer(), i || this.removeAvalancheSymbol(t)
                    }), 0), h
                }
                removeAllSymbols() {
                    for (; this._allOutSymbols.length > 0;) {
                        const t = this._allOutSymbols.pop();
                        t && this.removeAvalancheSymbol(t)
                    }
                }
                initReel(t) {
                    const e = r.TheCrypt.model.symbolPositionYs[this._reelId];
                    let i = !1;
                    for (let o = 0; o < t.length; o++) {
                        const s = this.createSymbol(t[o], n.TheCryptSymbolStates.NORMAL, 0, !0);
                        s.position.set(0, "FW" === s.symName ? 300 : e[o]), "FW" === s.symName && (i = !0, s.getStateAnimation(n.TheCryptSymbolStates.EXPAND)), r.TheCrypt.model.isRestore && "S" === s.symName[0] && p.ScatterCounter.allScatters.push(s), r.TheCrypt.model.isRestore && u.TheCryptHelper.isInvisibleSym(s.symName) || this._allOutSymbols.push(s)
                    }
                    if (i)
                        for (let t = 0; t < 5; t++) {
                            const e = this.createSymbol({
                                symName: "Y",
                                reelSize: 4,
                                symSize: 1,
                                id: t,
                                reelId: this._reelId
                            }, n.TheCryptSymbolStates.NORMAL, 0, !0);
                            this._allOutSymbols.unshift(e)
                        }
                }
                createSymbol(t, e, i, o = !1) {
                    let s;
                    return t.symName.indexOf("FW") > -1 ? (s = new c.TheCryptFullWild(t, e), s.showMultiplier(r.TheCrypt.model.data.xNudgeMultiplier[this._reelId]), this._fullWildSymbolView.addChild(s), s.position.set(0, 300), s) : (s = "S" === t.symName ? new f.TheCryptScatter(t, e) : new n.TheCryptSymbol(t, e), o ? "S" === t.symName ? this._scatterSymbolView.addChild(s) : "W" === t.symName || t.symName.indexOf("FW") > -1 ? this._fullWildSymbolView.addChild(s) : this.addChild(s) : this.addChild(s), s)
                }
                dropOut(t) {
                    const e = o.gsap.timeline({
                        delay: t
                    }),
                        i = this.isFastSpin,
                        r = [];
                    let s = 0;
                    for (; this._allOutSymbols.length > 0;) {
                        const t = this._allOutSymbols.pop();
                        u.TheCryptHelper.checkIfSymbolIsNull(t);
                        const e = t.position.y,
                            a = (i ? 0 : this.SYMBOLS_FALL_OUT_DELAY) * s,
                            l = (i ? 0 : this.SYMBOLS_FALL_OUT_DELAY) * s,
                            h = o.gsap.timeline({
                                delay: a
                            });
                        h.add([() => {
                            u.TheCryptHelper.isLargerSymbol(t.symName) && (t.parent.removeChild(t), this.addChild(t))
                        }, o.gsap.to(t.position, {
                            duration: this.DURATION_SYMBOLS_FALL_OUT,
                            y: e - this.START_DROP_IN_POSITION,
                            ease: "sine.in"
                        })]), h.add([t.getStateAnimation(n.TheCryptSymbolStates.BLUR, this.DURATION_SYMBOLS_UNBLUR)], t.symName.indexOf("FW") > -1 || t.symName.indexOf("S") > -1 ? 0 : l), h.add((() => this.removeAvalancheSymbol(t))), r.push(h), s++
                    }
                    return r.length > 0 && r.push(o.gsap.timeline().add((() => {
                        let t = 0;
                        this._allOutSymbols.forEach(((e, i) => {
                            "S" === e.symName && (e.parent.removeChild(e), this.scatterSymbolView.addChildAt(e, t++))
                        }))
                    }))), 0 === this._reelId && e.add((() => a.TheCryptSoundManager.playReelOut())), e.add(r), e
                }
                symbolBounce(t, e, i = !0) {
                    const r = new o.TimelineLite;
                    i && ("S" === t.symName ? r.add((() => {
                        r.add(p.ScatterCounter.addScatter(t), 0)
                    }), 0) : r.add([() => {
                        "W" === t.symName ? a.TheCryptSoundManager.playWildLandingSound(this._reelId - 1) : "M" === t.symName && a.TheCryptSoundManager.playXWayLandingSound(this._reelId)
                    }, t.getStateAnimation(n.TheCryptSymbolStates.LANDING)], 0)), r.add((() => {
                        u.TheCryptHelper.isLargerSymbol(t.symName) && (t.parent.removeChild(t), "S" === t.symName ? this._scatterWinView.addChild(t) : "W" === t.symName ? this._fullWildSymbolWinView.addChild(t) : "M" === t.symName && this._scatterWinView.addChild(t))
                    }), 0);
                    const s = .02 + .005 * t.id;
                    return r.to(t.position, s, {
                        y: e - 5,
                        ease: "power3.in"
                    }, 0).to(t.position, .03 + .005 * t.id, {
                        y: e,
                        ease: "power3.out"
                    }, s), r
                }
                firstSymbolLandingOnReel() {
                    r.TheCrypt.model.nearWinReels[this._reelId] ? (r.TheCrypt.gameViewContainer.onNearWin(), a.TheCryptSoundManager.playAnticipationLandingSound(this._reelId)) : a.TheCryptSoundManager.playLandingSound(this._reelId), r.TheCrypt.reelAnticipation.fadeOut(this._reelId)
                }
                dropIn(t, e) {
                    const i = r.TheCrypt.model.symbolPositionYs[this._reelId],
                        s = this.isFastSpin,
                        l = new o.TimelineLite({
                            delay: s ? 0 : t
                        }),
                        h = r.TheCrypt.model.reelsData[this._reelId];
                    let c, d = !0;
                    const p = [];
                    this._allOutSymbols = [], this._isStacked = !1, 0 === this._reelId && l.add((() => a.TheCryptSoundManager.playReelIn()));
                    for (let t = 0; t < 6; t++) {
                        const e = this.createSymbol(h[t], n.TheCryptSymbolStates.BLUR, 0);
                        if (this._allOutSymbols.push(e), !u.TheCryptHelper.isInvisibleSym(h[t].symName)) {
                            e.position.y = this.START_DROP_IN_POSITION + e.id * e.symHeight, u.TheCryptHelper.checkIfSymbolIsNull(e), c = o.gsap.timeline({
                                delay: s || r.TheCrypt.model.nearWinReels[this._reelId] ? 0 : this.SYMBOLS_FALL_IN_DELAY * (6 - t)
                            });
                            const n = s ? this.DURATION_FAST_SYMBOLS_FALL_SPIN : this.DURATION_SYMBOLS_FALL_IN;
                            c.add([o.gsap.to(e.position, {
                                duration: n,
                                y: i[t],
                                ease: "power1.in",
                                delay: this.SYMBOLS_FALL_IN_DELAY
                            })]), c.add([() => {
                                d && (this.firstSymbolLandingOnReel(), d = !1)
                            }, this.symbolBounce(e, i[t])]), p.push(c)
                        }
                    }
                    return l.add(p), e && l.add((() => r.TheCrypt.reelAnticipation.update(this._reelId + 1))), l.add((() => this.reArrangeSymbolLayer())), l
                }
                fillUp(t, e) {
                    this._isStacked && (this._isStacked = !1);
                    const i = r.TheCrypt.model.symbolPositionYs[this._reelId],
                        s = [];
                    this._allOutSymbols.forEach((t => {
                        u.TheCryptHelper.isInvisibleSym(t.symName) ? this.removeAvalancheSymbol(t) : s.push(t)
                    })), this._allOutSymbols = [];
                    const a = this.isFastSpin,
                        l = o.gsap.timeline({
                            delay: a ? 0 : t
                        });
                    let h, c = !0,
                        d = !0;
                    const p = [],
                        f = r.TheCrypt.model.reelsFillUpData[this._reelId],
                        g = 6 - s.length - 1;
                    for (let t = g; t > -1; t--) {
                        const e = this.createSymbol(f[t], n.TheCryptSymbolStates.BLUR, s.length > 0 ? s.length - 1 : 0);
                        u.TheCryptHelper.checkIfSymbolIsNull(e), e.position.y = this.START_DROP_IN_POSITION + (e.id - g) * e.symHeight, s.unshift(e), h = o.gsap.timeline({
                            delay: a || r.TheCrypt.model.nearWinReels[this._reelId] ? 0 : this.SYMBOLS_FALL_IN_DELAY * (g - t)
                        });
                        let l = this.SYMBOLS_FALL_IN_DELAY;
                        const m = a ? this.DURATION_FAST_SYMBOLS_FALL_SPIN : this.DURATION_SYMBOLS_FALL_IN;
                        d = !1, h.add([o.gsap.to(e.position, {
                            duration: m,
                            y: i[t],
                            ease: "power1.in",
                            delay: l
                        })]), h.add((() => {
                            c && (this.firstSymbolLandingOnReel(), c = !1), this.symbolBounce(e, i[t])
                        })), p.push(h)
                    }
                    return this._allOutSymbols = s, l.add(p), e && l.add((() => r.TheCrypt.reelAnticipation.update(this._reelId + 1))), l.add((() => this.reArrangeSymbolLayer())), this.printAllSymbol("fillUp"), l
                }
                calculateCollapseData() {
                    const t = h.ArrayHelper.initArrayWithValues(this._allOutSymbols.length, (t => this._allOutSymbols[t]));
                    this._collapsedReel = [];
                    for (let e = t.length - 1; e >= 0; e--) t[e].isRemoved || this._collapsedReel.push(t[e]), t.splice(e, 1)
                }
                collapse(t) {
                    const e = this.isFastSpin,
                        i = o.gsap.timeline({
                            delay: e ? 0 : t
                        }),
                        n = this._collapsedReel.length,
                        r = [];
                    let l, h = !0,
                        c = 4 * s.TheCryptGameConfig.symbolHeight;
                    this._allOutSymbols = [];
                    for (let t = 0; t < n; t++) {
                        const i = this._collapsedReel[t];
                        if (null == i) throw new Error("AvalancheReelPartAnimator.collapseAnimation, symbol is null!");
                        if (!i.isRemoved) {
                            this._allOutSymbols.push(i);
                            const n = c === i.position.y ? 0 : (e ? this.DURATION_FAST_SYMBOLS_COLLAPSE_FALL : this.DURATION_SYMBOLS_COLLAPSE_FALL) * (t + 1);
                            l = o.gsap.timeline(), n > 0 && (c -= .5 * i.symHeight, l.add([o.gsap.to(i.position, {
                                duration: n,
                                y: c,
                                ease: "power2.in"
                            })]), i.position.y == c || u.TheCryptHelper.isInvisibleSym(i.symName) || l.add([() => {
                                h && (a.TheCryptSoundManager.playLandingSound(this._reelId), h = !1)
                            }, this.symbolBounce(i, c, !1)]), i.id = t, c -= .5 * i.symHeight), r.push(l)
                        }
                    }
                    return i.add(r), this._allOutSymbols.reverse(), i
                }
                nudgeAllSymbolsLeft(t, e, i) {
                    const n = o.gsap.timeline(),
                        s = r.TheCrypt.model.symbolPositionYsAfterReveal[this._reelId];
                    for (let r = 0; r <= e; r++) {
                        const e = this._allOutSymbols[r];
                        u.TheCryptHelper.isInvisibleSym(e.symName) || n.to(e.position, i, {
                            y: s[r + t],
                            ease: "power4.in"
                        }, 0)
                    }
                    return n
                }
                nudge(t, e) {
                    if (this._isStacked) return o.gsap.timeline();
                    const i = this.isFastSpin,
                        n = r.TheCrypt.model.hasNoAvalancheWin,
                        s = r.TheCrypt.model.reels[this._reelId].indexOf("W"),
                        l = this._allOutSymbols[s],
                        h = o.gsap.timeline();
                    let c = 0;
                    if (h.add([l.showNudgeMultiplier(.12, i || n || 1 === t, t > 1)], 0), c += h.duration(), i || n || this._reelId > r.TheCrypt.model.maxWinReelId) {
                        h.add([() => a.TheCryptSoundManager.playSound("wildNudgeFast"), l.upgradeWildMultiplier(t, 0, 0, t > 1), this.nudgeAllSymbolsLeft(t - 1, s, .2)], c);
                        for (let t = s + 1; t < 6; t++) h.add(this._allOutSymbols[t].breakOnNudge(.2), c);
                        h.add((() => r.TheCrypt.gameViewContainer.onWildNudge()), c + .1), c += .2
                    } else if (1 === t) h.add((() => {
                        r.TheCrypt.gameViewContainer.onWildNudge(), a.TheCryptSoundManager.playSound(g.TheCryptSoundConfig.WILD_NUDGE_FINAL[e])
                    }), c);
                    else
                        for (let i = 1; i < t; i++) u.TheCryptHelper.checkIfSymbolIsNull(l), h.add([l.upgradeWildMultiplier(i + 1, .48, .12), this.nudgeAllSymbolsLeft(i, s, .6)], c), i + s < 6 && h.add(this._allOutSymbols[i + s].breakOnNudge(.6), c), h.add((() => {
                            r.TheCrypt.gameViewContainer.onWildNudge(), a.TheCryptSoundManager.playNudgeSound(i + 1 === t ? e : -1, i)
                        }), c), c += .6;
                    return h.add([r.TheCrypt.reelFrame.onWildExpand(), this.switchSymbol(l, "FW")], c), h.add((() => {
                        this._allOutSymbols.forEach(((t, e) => {
                            e != s && (t.visible = !1)
                        }))
                    })), this._isStacked = !0, h
                }
                expand() {
                    const t = o.gsap.timeline(),
                        e = r.TheCrypt.model.afterRevealGameAreaSize[this._reelId],
                        i = this.DURATION_SYMBOLS_EXPAND;
                    let n, a = 0;
                    for (let l = 0; l < 6; l++) {
                        const h = this._allOutSymbols[l];
                        if (u.TheCryptHelper.checkIfSymbolIsNull(h), !u.TheCryptHelper.isInvisibleSym(h.symName)) {
                            const l = h.isXWay ? r.TheCrypt.model.mysterySymbolSize[this._reelId] : 1,
                                u = s.TheCryptGameConfig.reelHeight / e * l,
                                c = d.MathHelper.roundToDecimals(u / h.symHeight, 2);
                            a += .5 * u, h.isXWay && (n = h), t.add([() => {
                                h.changeHeight(i, e, c)
                            }, o.gsap.to(h.position, {
                                duration: i,
                                y: a
                            })], 0), a += .5 * u
                        }
                    }
                    return t.add((() => {
                        let t = 1;
                        for (let e = 0; e < 6; e++) t *= e <= this._reelId ? r.TheCrypt.model.afterRevealGameAreaSize[e] : 4;
                        r.TheCrypt.reelFrame.updateWays(t)
                    }), 0), u.TheCryptHelper.checkIfSymbolIsNull(n), t.add((() => {
                        const t = r.TheCrypt.model.afterRevealGameAreaSize[this._reelId];
                        for (let e = 0; e < 6; e++) {
                            const i = this._allOutSymbols[e];
                            u.TheCryptHelper.isInvisibleSym(i.symName) || i.isXWay || (i.reelSize = t)
                        }
                    }), i - .1), t.add(this.switchSymbol(n, r.TheCrypt.model.mysterySymbolRevealed, !0), i), r.TheCrypt.autoPlayPlugin.isAutoplayRound && r.TheCrypt.model.hasNoAvalancheWin && t.add((() => { }), "+=0.5"), t
                }
                printAllSymbol(t) { }
                getSymbol(t) {
                    return this.printAllSymbol("get symbol"), this._allOutSymbols.length, this._allOutSymbols[t]
                }
                getAllSymbols() {
                    return this._allOutSymbols
                }
                get scatterSymbolView() {
                    return this._scatterSymbolView
                }
                get fullWildSymbolView() {
                    return this._fullWildSymbolView
                }
                get normalView() {
                    return this
                }
                get initialWinSymbolView() {
                    return this._initialWinSymbolView
                }
                get scatterWinView() {
                    return this._scatterWinView
                }
                get fullWildSymbolWinView() {
                    return this._fullWildSymbolWinView
                }
                get isFastSpin() {
                    return r.TheCrypt.apiPlugin.settings.get(l.APISetting.FAST_SPIN, !1)
                }
                get isStacked() {
                    return this._isStacked
                }
                get needFillUp() {
                    return this._allOutSymbols.length < 6
                }
                get needCollapse() {
                    return this._collapsedReel.length != this._allOutSymbols.length
                }
            }
            e.TheCryptReelView = m
        },
        9692: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptGameMode = void 0;
            const n = i(2327);
            class r extends n.GameMode { }
            r.NORMAL_AVALANCHE = "NORMAL_AVALANCHE", r.FREESPIN_AVALANCHE = "FREESPIN_AVALANCHE", e.TheCryptGameMode = r
        },
        3116: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptModel = void 0;
            const n = i(6496),
                r = i(8680),
                o = i(7141),
                s = i(7185),
                a = i(5160),
                l = i(760),
                h = i(9529),
                u = i(6364),
                c = i(2366),
                d = i(7785),
                p = i(4968);
            class f extends n.GameModel {
                constructor(t, e = !0) {
                    super(t, e), t.events.once("featureBet", (t => {
                        this._isRestoreFeatureBet = t
                    })), t.events.once("featureName", (t => {
                        this._buyFeatureName = t
                    })), o.TheCrypt.apiPlugin.events.on(s.APIEvent.BET, (t => {
                        t.type === p.APIBetType.FEATURE_BET && t.featureName !== o.TheCrypt.boostedName && (o.TheCrypt.xBetController.selected = !1);
                        for (let e = 0; e < o.TheCrypt.model.initData.featureBuyTimesBetValue.length; e++)
                            if (o.TheCrypt.model.initData.featureBuyTimesBetValue[e].name === t.featureName) {
                                this._buyFeatureName = t.featureName, r.Logger.logDev("Opted Feature : ", this._buyFeatureName);
                                break
                            }
                    })), o.TheCrypt.apiPlugin.events.on(s.APIEvent.ACTION_SPINS_BET, (t => {
                        t.type === p.APIBetType.FEATURE_BET && t.featureName !== o.TheCrypt.boostedName && (o.TheCrypt.xBetController.selected = !1);
                        for (let e = 0; e < o.TheCrypt.model.initData.featureBuyTimesBetValue.length; e++)
                            if (o.TheCrypt.model.initData.featureBuyTimesBetValue[e].name === t.featureName) {
                                this._buyFeatureName = t.featureName, r.Logger.logDev("Opted Feature : ", this._buyFeatureName);
                                break
                            }
                    }))
                }
                checkXNudgeMultiplier(t, e, i) {
                    let n = t.concat(),
                        o = e.concat();
                    n.length, o.length, o.forEach(((t, e) => {
                        t != n[e] && i[e].join() != ["Y", "Y", "W", "W", "W", "W"].join() && r.Logger.logDev(`xNudge multiplier ${n} is not same from server: ${o}`)
                    }))
                }
                checkXWayRevealedSymbol(t, e) {
                    if (!e) return;
                    if (0 === e.length) return;
                    let i = t,
                        n = e;
                    i[0] + i[1] != n && r.Logger.logDev(`xWays reveal to symbol ${i} is not same from server: ${n}`), i.length > 2 && this.wildMSymbols.indexOf(n) < 0 && r.Logger.logDev(`xWays reveal to symbol ${i} is not transformed`)
                }
                checkAllWinPositions(t, e) {
                    if (!e && this.isNextRespin && r.Logger.logDev("no win data"), 0 === e.length) return;
                    let i = t.concat(),
                        n = e.concat();
                    for (let t = 0; t < 6; t++) i[t].splice(0, i[t].length - n[t].length).indexOf(!0) > -1 && r.Logger.logDev(`wins is not the same on reel ${t}`), i[t].join() != n[t].join() && r.Logger.logDev(`wins is not the same on reel ${t}`)
                }
                isWildMidSymbol(t) {
                    return !this.isNormal && !!a.TheCryptHelper.isCollectiveSymbol(t) && (t.indexOf("_W") > 0 || parseInt(t[1]) > 1 && this.wildMSymbols.indexOf(t) > -1)
                }
                parseNearWinOnRestore(t, e) {
                    const i = u.ArrayHelper.initArrayWithValues(6, (() => !1));
                    return this._isRestore && this.isNextRespin ? (this.isLuckyDraw || e || a.TheCryptHelper.sum(t) >= 2 && this.reels.forEach(((e, n) => {
                        t[n] >= 2 ? i[n] = !1 : i[n] = e.indexOf("X") > -1
                    })), i) : i
                }
                parseNearWin(t, e, i, n) {
                    const r = u.ArrayHelper.initArrayWithValues(6, (() => !1));
                    if (!n) return r;
                    let o = a.TheCryptHelper.sum(t),
                        s = o >= 2;
                    if (this.isLuckyDraw) return e.forEach(((t, e) => {
                        r[e] = o >= 3, o += t
                    })), r;
                    if (i) {
                        let t = 3;
                        return "FREESPIN_4_SCATTERS" == this._buyFeatureName ? t = 4 : "FREESPIN_5_SCATTERS" == this._buyFeatureName && (t = 5), e.forEach(((e, i) => {
                            r[i] = o >= t && o < t + 1, o += e
                        })), r
                    }
                    return s ? this.reels.forEach(((e, i) => {
                        t[i] >= 2 ? r[i] = !1 : r[i] = !0
                    })) : e.forEach(((e, i) => {
                        o += e - t[i], r[i] = s, s = o >= 2
                    })), r
                }
                parseScatterNumberOnReels(t) {
                    const e = [];
                    return t.forEach(((t, i) => {
                        let n = 0;
                        t.forEach((t => {
                            n += "S" === t ? 1 : 0
                        })), e.push(n)
                    })), e
                }
                parseRestoreReelData(t) {
                    let e = [];
                    return t.forEach(((t, i) => {
                        t.indexOf("W") > -1 && "W" === t[2] && "W" === t[3] ? e.push(["Y", "Y", "Y", "Y", "Y", "FW"]) : e.push(t.concat())
                    })), e
                }
                parseReelData(t, e) {
                    const i = [];
                    return this.wildOnReel = u.ArrayHelper.initArrayWithValues(6, (() => !1)), t.forEach(((t, n) => {
                        const r = [],
                            o = this._isRestore ? e[n] - 4 + 1 : 1;
                        t.forEach(((t, i) => {
                            r.push({
                                symName: t,
                                reelSize: e[n],
                                symSize: o,
                                id: i,
                                reelId: n
                            }), "M" === t && this.mysterySymbolPositions.push(n)
                        }));
                        let s = t.indexOf("W") > -1;
                        s && (s = !("W" === t[2] && "W" === t[3])), this.wildOnReel[n] = s, i.push(r)
                    })), i
                }
                parseFillUpReelData(t, e) {
                    const i = [];
                    return t.forEach(((t, n) => {
                        const r = [],
                            o = e[n] - 4 + 1;
                        t.forEach(((t, i) => {
                            r.push({
                                symName: t.symName,
                                reelSize: e[n],
                                symSize: o,
                                id: i,
                                reelId: n
                            })
                        })), i.push(r)
                    })), i
                }
                getGameAreaSize(t) {
                    let e = [6, 6, 6, 6, 6, 6];
                    return t.forEach(((t, i) => {
                        t.forEach(((t, n) => {
                            "Y" === t && e[i]--
                        }))
                    })), e
                }
                getWildMultipliers() {
                    let t = [0, 0, 0, 0, 0, 0];
                    return this.wildOnReel.forEach(((e, i) => {
                        e && (t[i] = 6 - this.reels[i].indexOf("W"))
                    })), t
                }
                getMysterySymbolSize(t, e) {
                    let i = [0, 0, 0, 0, 0, 0];
                    return this.mysterySymbolPositions.length > 0 && e.forEach(((e, n) => {
                        e > t[n] && (i[n] = e - t[n] + 1)
                    })), i
                }
                getMysterySymbolRevealed(t, e) {
                    if (this.mysterySymbolPositions.length <= 0) return "";
                    const i = this.mysterySymbolPositions[0],
                        n = e[i][t[i].indexOf("M")];
                    return `${n}${this.wildMSymbols.indexOf(n) > -1 ? "_W" : ""}`
                }
                getSymbolPositionYs(t, e) {
                    const i = [];
                    return t.forEach(((t, n) => {
                        const r = l.TheCryptGameConfig.reelHeight / e[n],
                            o = [];
                        let s = 0;
                        t.forEach(((t, e) => {
                            "Y" != t ? (o.push(s + .5 * r), s += r) : o.push(-200)
                        })), i.push(o)
                    })), i
                }
                parseAllWinPositions(t, e) {
                    const i = u.ArrayHelper.initArrayWithValues(6, (() => u.ArrayHelper.initArrayWithValues(6, (() => !1)))),
                        n = u.ArrayHelper.initArrayWithValues(6, (() => u.ArrayHelper.initArrayWithValues(6, (() => ""))));
                    return this.maxWinReelId = -1, e.forEach((e => {
                        const r = e.symbol;
                        this.maxWinReelId = Math.max(this.maxWinReelId, e.length);
                        let o = u.ArrayHelper.initArrayWithValues(6, (() => u.ArrayHelper.initArrayWithValues(6, (() => !1))));
                        t.forEach(((t, s) => {
                            s <= e.length && t.forEach(((t, e) => {
                                (t === r || a.TheCryptHelper.isWildSymbol(t) || this.isWildMidSymbol(t)) && (i[s][e] = !0, n[s][e] = t, o[s][e] = !0)
                            }))
                        })), e.reelWinPositions = o
                    })), this.allWinPositionSymbols = n, i
                }
                parseMysterySymbolPotentialWin(t) {
                    let e = [],
                        i = [],
                        n = [!1],
                        r = this.mysterySymbolPositions[0],
                        o = [];
                    t[0].forEach((t => {
                        !a.TheCryptHelper.isInvisibleSym(t) && e.indexOf(t) < 0 && (e.push(t), i.push(0))
                    }));
                    for (let r = 1; r < 6; r++) {
                        let o = e.length - 1;
                        const s = t[r].indexOf("M") > -1,
                            a = t[r].indexOf("W") > -1;
                        for (n.push("W" === t[r][2] && "W" === t[r][3]); o > -1;)(t[r].indexOf(e[o]) > -1 || s || a || n[r]) && i[o] === r - 1 ? i[o]++ : r >= 2 && i[o] < 2 && (e.splice(o, 1), i.splice(o, 1)), o--
                    }
                    let s = i.length - 1;
                    for (; s > -1;)(i[s] < 2 || i[s] < r) && (e.splice(s, 1), i.splice(s, 1)), s--;
                    return 0 === e.length || (o = u.ArrayHelper.initArrayWithValues(e.length, (() => [])), e.forEach(((e, n) => {
                        for (let r = 0; r <= i[n]; r++) t[r].forEach(((t, i) => {
                            (t === e || "M" === t || a.TheCryptHelper.isWildSymbol(t) || this.isWildMidSymbol(t)) && o[n].push([r, i])
                        }))
                    }))), o
                }
                addWildOrMultiplier(t, e) {
                    const i = e > 1;
                    t.forEach((t => {
                        t.forEach((t => {
                            i && "M1" === t.symName && (t.M1Multiplier = e), this.isWildMidSymbol(t.symName) && (t.isWild = !0)
                        }))
                    }))
                }
                parseSideBarProgress(t) {
                    const e = u.ArrayHelper.initArrayWithValues(6, (() => -1)),
                        i = Math.min(Math.floor(t[0] / l.TheCryptGameConfig.MSymbolCollectorLevels - 1), 5),
                        n = i + 1;
                    return this.nextWildMSymbols = i > -1 ? u.ArrayHelper.initArrayWithValues(n, (t => (e[t] = l.TheCryptGameConfig.MSymbolCollectorLevels, "M" + (6 - t)))) : [], n <= 5 && (e[n] = t[0] % l.TheCryptGameConfig.MSymbolCollectorLevels), t[1], l.TheCryptGameConfig.M1CollectorLevels, e[5] = t[1], e
                }
                parseM1MultiplierPositions(t, e) {
                    if (1 === e) return [];
                    const i = a.TheCryptHelper.createDefaultSixBySixBooleanArray();
                    return t.forEach(((t, e) => {
                        t.forEach(((t, n) => {
                            "M1" === t && (i[e][n] = !0)
                        }))
                    })), i
                }
                parsePatchWildPositions(t, e) {
                    const i = e[0] / 4;
                    if (0 === i) return [];
                    if (!Number.isInteger(i)) return [];
                    const n = a.TheCryptHelper.createDefaultSixBySixBooleanArray();
                    return t.forEach(((t, e) => {
                        t.forEach(((t, i) => {
                            this.isWildMidSymbol(t) && (n[e][i] = !0)
                        }))
                    })), n
                }
                parseCollectorData(t, e, i = !1) {
                    this.M1MultiplierPositions = [], this.patchWildPositions = [], this.sideBarProgress = this.parseSideBarProgress(t.dragonSideReel), e || (this.M1MultiplierPositions = this.parseM1MultiplierPositions(t.evaluatedArea, t.m1NextMultiplier), this.patchWildPositions = this.parsePatchWildPositions(t.evaluatedArea, t.dragonSideReel), this.addWildOrMultiplier(this.reelsData, t.m1NextMultiplier), i && this.addWildOrMultiplier(this.reelsFillUpData, t.m1NextMultiplier))
                }
                onInit(t) {
                    super.onInit(t), this.mysterySymbolPositions = [], this.brokeTheBank = !1, this._isRestore = t.isRestoreState, this._isBigWin = !1, this.hasMeterUpgrade = !1, this._prevTotalWinBigWin = 0, this.gameAreaSize = this.getGameAreaSize(t.reels), this.reels = a.TheCryptHelper.copyArray(t.reels), this._isRestore && (this.reels = this.parseRestoreReelData(this.reels)), this.reelsData = this.parseReelData(this.reels, this.gameAreaSize), this.mode = t.mode, this.nextMode = t.nextMode, this.wasFeatureBuy = t.wasFeatureBuy, this.afterRevealGameAreaSize = t.gameAreaSize, this.freespinTriggeredThisSpin = a.TheCryptHelper.isNormal(t.mode) && !a.TheCryptHelper.isNormal(t.nextMode), this.freespinsLeft = t.freespinsLeft, this.xNudgeMultiplier = this.getWildMultipliers(), this.symbolPositionYs = this.getSymbolPositionYs(t.reels, t.gameAreaSize), this.symbolPositionYsAfterReveal = this.getSymbolPositionYs(t.reels, t.gameAreaSize), this.evaluatedArea = [], this.numberOfScattersOnReelPrev = u.ArrayHelper.initArrayWithValues(6, (() => 0)), this.numberOfScattersOnReel = this.parseScatterNumberOnReels(t.reels), this.sideBarProgress = this.parseSideBarProgress(t.dragonSideReel), this.wildMSymbols = this.nextWildMSymbols.concat(), this.m1CurrentMultiplier = t.m1NextMultiplier, this.addWildOrMultiplier(this.reelsData, t.m1NextMultiplier), this.nearWinReels = this.parseNearWinOnRestore(this.numberOfScattersOnReel, t.wasFeatureBuy), this.maxWinReelId = -1, this._isRestore && a.TheCryptHelper.isRespin(t.nextMode) && (this.numberOfScattersOnReelPrev = this.numberOfScattersOnReel.concat()), a.TheCryptHelper.isRespin(t.nextMode) ? this.gameAreaSize = t.gameAreaSize : this.gameAreaSize = l.TheCryptGameConfig.defaultGameAreaSize
                }
                onGame(t) {
                    var e;
                    super.onGame(t), this.wildMSymbols = "N" === t.mode[0] ? [] : this.nextWildMSymbols.concat();
                    const i = a.TheCryptHelper.isRespin(t.mode),
                        n = a.TheCryptHelper.isRespin(t.nextMode);
                    this.hasMeterUpgrade = !1, this.mysterySymbolPositions = [], this._prevTotalWinBigWin = i ? this._prevTotalWinBigWin : 0, this.mode = t.mode, this.nextMode = t.nextMode, this.hasNoAvalancheWin = 0 === t.thisSpinWinning;
                    const r = this.isNormal;
                    this.brokeTheBank = t.brokeTheBank, this.wasFeatureBuy = t.wasFeatureBuy, this.freespinTriggeredThisSpin = a.TheCryptHelper.isNormal(t.mode) && !a.TheCryptHelper.isNormal(t.nextMode), this.reels = a.TheCryptHelper.copyArray(t.reels), this.isRestore || (this.numberOfScattersOnReel = this.parseScatterNumberOnReels(t.reels), this.nearWinReels = this.parseNearWin(this.numberOfScattersOnReelPrev, this.numberOfScattersOnReel, t.wasFeatureBuy, r)), this._isRestore = !1, this.reelsData = this.parseReelData(this.reels, this.gameAreaSize), this.reelsFillUpData = this.parseFillUpReelData(this.reelsData, this.gameAreaSize), this.evaluatedArea = a.TheCryptHelper.copyArray(t.evaluatedArea), this.parseCollectorData(t, r, i), this.numberOfScattersOnReelPrev = n ? this.parseScatterNumberOnReels(t.reels) : [0, 0, 0, 0, 0, 0], this.xNudgeMultiplier = this.getWildMultipliers(), this.mysterySymbolSize = this.getMysterySymbolSize(this.gameAreaSize, t.gameAreaSize), this.mysterySymbolRevealed = this.getMysterySymbolRevealed(t.reels, t.evaluatedArea), this.symbolPositionYs = this.getSymbolPositionYs(t.reels, this.gameAreaSize), this.symbolPositionYsAfterReveal = this.getSymbolPositionYs(t.evaluatedArea, t.gameAreaSize), this.afterRevealGameAreaSize = t.gameAreaSize, this.allWinPositionSymbols = [], this.allWinPositions = this.parseAllWinPositions(t.evaluatedArea, t.betWayWins), this.mysterySymbolPotentialWin = this.mysterySymbolRevealed ? this.parseMysterySymbolPotentialWin(t.reels) : [], this.winData = t.betWayWins, this.accumulatedRoundWin = t.accumulatedRoundWin, this.avalancheRoundWin = t.totalSpinWinnings, this.winRatio = h.MathHelper.roundToDecimals(t.totalSpinWinnings / t.playedBetValue, 1), this.currentWinRatio = h.MathHelper.roundToDecimals(t.totalSpinWinnings / t.playedBetValue, 1), this.avalancheWinRatio = h.MathHelper.roundToDecimals(t.thisSpinWinning / t.playedBetValue, 1), this.prevBigWinLevel = c.TheCryptWinConfig.getBigWinLevel(h.MathHelper.roundToDecimals(this._prevTotalWinBigWin / t.playedBetValue, 1)), this.isWin = !n && i, this._isBigWin = !n && a.TheCryptHelper.isBigWin(t.totalSpinWinnings, null === (e = this.gameData) || void 0 === e ? void 0 : e.playedBetValue), this.freespinsLeft = t.freespinsLeft, this.m1CurrentMultiplier = t.m1CurrentMultiplier, d.NolimitConfig.isDevMode && (this.checkXNudgeMultiplier(this.xNudgeMultiplier, t.xNudgeMultiplier, this.reels), this.checkXWayRevealedSymbol(this.mysterySymbolRevealed, t.mysterySymbolRevealed), this.checkAllWinPositions(this.allWinPositions, t.position)), !i && n && this.allWinPositions.forEach(((e, i) => {
                        t.reels[i].indexOf("W") < 0 && e.forEach(((t, e) => {
                            t && (this.reelsData[i][e].hasHighlight = !0)
                        }))
                    })), this.gameAreaSize = n ? t.gameAreaSize : l.TheCryptGameConfig.defaultGameAreaSize
                }
                get isNormal() {
                    return a.TheCryptHelper.isNormal(this.mode)
                }
                get isNextNormal() {
                    return a.TheCryptHelper.isNormal(this.nextMode)
                }
                get isNextRespin() {
                    return a.TheCryptHelper.isRespin(this.nextMode)
                }
                get isRestore() {
                    return this._isRestore
                }
                get buyFeatureName() {
                    return this._buyFeatureName
                }
                get isLuckyDraw() {
                    return "LUCKY_DRAW" === this._buyFeatureName
                }
                get hasNudge() {
                    let t = u.ArrayHelper.initArrayWithValues(6, (t => this.wildOnReel[t]));
                    return this.reels.forEach(((e, i) => {
                        t[i] && (t[i] = ("W" !== e[2] || "W" !== e[3]) && t[i])
                    })), t
                }
                get isBigWin() {
                    return this._isBigWin
                }
                get hasXWaysSymbolThisAvalanche() {
                    return this.mysterySymbolPositions.length > 0
                }
            }
            e.TheCryptModel = f
        },
        2185: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptSoundManager = void 0;
            const n = i(1115),
                r = i(7785),
                o = i(7141),
                s = i(3554),
                a = i(6358),
                l = i(6364),
                h = i(2820),
                u = i(5160);
            class c {
                static get soundPlayer() {
                    return !this._init && r.NolimitConfig.isDevMode && (n.SlotGame.sound.showLogs(!0), this._init = !0), n.SlotGame.sound
                }
                static fadeMusic(t, e, i) {
                    this.soundPlayer.fadeTrack({
                        name: this.currentLoop,
                        from: t,
                        to: e,
                        duration: i
                    })
                }
                static fadeSoundEffect(t, e, i, n) {
                    this.soundPlayer.fadeTrack({
                        name: t,
                        from: e,
                        to: i,
                        duration: n
                    })
                }
                static stopSoundEffect(t) {
                    this.soundPlayer.stopTrack(t)
                }
                static playSound(t, e = 0) {
                    this.soundPlayer.playTrack({
                        name: t,
                        repeat: e
                    })
                }
                static stopAmbientLoop(t = 200) {
                    if (this.currentLoop) {
                        if (this.currentLoop.indexOf("fs") > -1) this.stopSoundEffect(this.currentLoop);
                        else {
                            const e = this.soundPlayer.fadeTrack({
                                name: this.currentLoop,
                                from: 1,
                                to: 0,
                                duration: t
                            });
                            e && a.TweenLite.to(this, {
                                duration: t / 1e3
                            }).eventCallback("onComplete", (() => {
                                this.stopSoundEffect(e.soundName)
                            }))
                        }
                        this.currentLoop = ""
                    }
                }
                static playReelOut() {
                    c.playSound(s.TheCryptSoundConfig.REELS_OUT)
                }
                static playReelIn() {
                    this._reelLandingSoundId = [], c.playSound(s.TheCryptSoundConfig.REELS_IN)
                }
                static playScatterLandSound(t) {
                    if (this.isQuickStop) {
                        if (!this._scatterLandingPlayed) {
                            this._scatterLandingPlayed = !0;
                            const t = u.TheCryptHelper.sum(o.TheCrypt.model.numberOfScattersOnReel) - u.TheCryptHelper.sum(o.TheCrypt.model.numberOfScattersOnReelPrev);
                            if (t < 4) return void c.playSound(`scatter${t}`);
                            c.playSound("scatter3"), c.playSound("scatterLand3Spins")
                        }
                    } else if (o.TheCrypt.model.wasFeatureBuy) {
                        const e = parseInt(o.TheCrypt.model.buyFeatureName[9]);
                        this._scatterLandingPlayed ? t > e && c.playSound("scatterLand3Spins") : (this._scatterLandingPlayed = !0, e < 4 ? c.playSound("scatter3") : (c.playSound("scatter3"), c.playSound("scatterLand3Spins")))
                    } else t < 4 ? c.playSound(`scatter${t}`) : c.playSound("scatterLand3Spins")
                }
                static playAnticipationLandingSound(t) {
                    this.isQuickStop && this._scatterAnticipationPlayed || (this._scatterAnticipationPlayed = !0, c.playSound(this._scatterAnticipationLandSounds[t]))
                }
                static playXWayLandingSound(t) {
                    if (this.isQuickStop && this._xWaysLandingPlayed) return;
                    if (this._xWaysLandingPlayed = !0, !this._xWaysLandingSounds || this._xWaysLandingSounds.length < 1) return void r.NolimitConfig.isDevMode;
                    const e = this._xWaysLandingSounds.pop();
                    c.playSound(e)
                }
                static playWildLandingSound(t) {
                    this.isQuickStop && this._wildLandingPlayed || (this._wildLandingPlayed = !0, c.playSound(this._wildLandingSounds[t]), this._wildFlashPlayed || (this._wildFlashPlayed = !0, c.playSound("wildFlash")))
                }
                static playNudgeSound(t, e) {
                    t > -1 ? c.playSound(s.TheCryptSoundConfig.WILD_NUDGE_FINAL[t]) : c.playSound(this._wildNudgeSounds[e - 1])
                }
                static playLandingSound(t) {
                    const e = this.soundPlayer.playTrack({
                        name: this._reelLandingSounds[t],
                        repeat: 0
                    });
                    e && e.player.stereo(c.davidPanningReelStop[t])
                }
                static playScatterFlashSound() {
                    this._scatterFlashSoundPlayed || (this._scatterFlashSoundPlayed = !0, c.playSound("scatterFlash"))
                }
                static playCountUpStart() {
                    c.playSound("winCountup")
                }
                static getAmbientSoundName() {
                    let t;
                    if (o.TheCrypt.model.isRestore) t = o.TheCrypt.model.isNormal ? s.TheCryptSoundConfig.MAIN_GAME_AMBIANCE : s.TheCryptSoundConfig.FS_INTRO;
                    else {
                        const e = `fs${Math.ceil(2 * Math.random())}`;
                        t = o.TheCrypt.model.isNextNormal ? s.TheCryptSoundConfig.MAIN_GAME_AMBIANCE : e
                    }
                    return t
                }
                static playAmbientLoop(t = 200, e = "", i = 1) {
                    e = e.length > 0 ? e : this.getAmbientSoundName(), this.currentLoop !== e && (this.currentLoop ? (this.stopAmbientLoop(), this.playAmbientLoop(t, e, i)) : (this.currentLoop = e, this.soundPlayer.playTrack({
                        name: this.currentLoop,
                        volume: 0
                    }), this.soundPlayer.fadeTrack({
                        name: this.currentLoop,
                        from: 0,
                        to: i,
                        duration: t
                    })))
                }
                static playBigWinLevelSound(t) {
                    t !== this._currentBigWinLevel && (this._currentBigWinLevel = t, 0 === t && (this._bigWinEndSoundPlayed = l.ArrayHelper.initArrayWithValues(5, (() => !1)), c.fadeMusic(1, 0, 1200)), c.playSound(s.TheCryptSoundConfig.BIGWIN[t], 0))
                }
                static playFSIntroSound() {
                    c.playSound("fsIntro"), c.playAmbientLoop(1e3, s.TheCryptSoundConfig.FS_INTRO)
                }
                static playWinCapMusic() {
                    c.playSound(s.TheCryptSoundConfig.WIN_CAP_MUSIC, 1e3)
                }
                static playMeterShowingSound() {
                    this.playSound("fsMeterFire")
                }
                static playBigWinEndSound(t) {
                    this._bigWinEndSoundPlayed[t] || (c.fadeMusic(0, 1, 1200), this._bigWinEndSoundPlayed[t] = !0, this.stopSoundEffect(s.TheCryptSoundConfig.BIGWIN[t]), c.playSound(s.TheCryptSoundConfig.BIGWIN_ENDS[t]), this._currentBigWinLevel = -1)
                }
                static set newAvalanche(t) {
                    this._newAvalanche = t, this._wildFlashPlayed = !t, this._wildLandingPlayed = !t, this._xWaysLandingPlayed = !t, this._scatterAnticipationPlayed = !t, this._scatterLandingPlayed = !t, this._scatterFlashSoundPlayed = !t, this._reelLandingSounds = l.ArrayHelper.shuffle(s.TheCryptSoundConfig.REEL_LANDING), this._wildLandingSounds = l.ArrayHelper.shuffle(s.TheCryptSoundConfig.WILD_LANDING);
                    const e = l.ArrayHelper.shuffle(s.TheCryptSoundConfig.XWAYS_LANDING),
                        i = l.ArrayHelper.shuffle(s.TheCryptSoundConfig.SCATTER_LANDING),
                        n = l.ArrayHelper.shuffle(s.TheCryptSoundConfig.WILD_NUDGE);
                    this._xWaysLandingSounds = e.concat(e), this._scatterAnticipationLandSounds = i.concat(i), this._wildNudgeSounds = n.concat(n)
                }
                static get isQuickStop() {
                    return o.TheCrypt.apiPlugin.settings.get(h.APISetting.FAST_SPIN)
                }
            }
            c._bigWinEndSoundPlayed = l.ArrayHelper.initArrayWithValues(5, (() => !1)), c._reelLandingSoundId = [], c._currentBigWinLevel = -1, c._reelLandingSounds = [], c._wildLandingSounds = [], c._xWaysLandingSounds = [], c._wildNudgeSounds = [], c._scatterAnticipationLandSounds = [], c.davidPanningReelStop = [-.35, -.25, -.18, .01, .18, .25], e.TheCryptSoundManager = c
        },
        1199: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFullWild = void 0;
            const n = i(6501),
                r = i(6358),
                o = i(7141),
                s = i(7732);
            class a extends n.TheCryptSymbol {
                getSymHeight() {
                    return 600
                }
                constructor(t, e = n.TheCryptSymbolStates.NORMAL) {
                    super(t), this.addChild(this._wildMultiplier)
                }
                getStateAnimation(t = n.TheCryptSymbolStates.NORMAL, e = 0) {
                    var i;
                    const a = new r.TimelineLite;
                    return this.addSpine(), null === (i = this._spine) || void 0 === i || i.position.set(0, 300), t === n.TheCryptSymbolStates.BLUR ? a.add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(1, "spin", !1)
                    })) : t === n.TheCryptSymbolStates.EXPAND && (a.add([new s.SpineTween(this._spine, 0, "expand" + (o.TheCrypt.model.hasNoAvalancheWin ? "_no_win" : ""))]), a.add((() => {
                        this._spine.state.setAnimation(0, "idel_loop", !0)
                    }))), a
                }
                playInitialWin(t) {
                    return t = (t.length > 0 ? "_" : "") + t, this.parent.removeChild(this), o.TheCrypt.realArea.allReels[this.reelId].reelView.scatterWinView.addChild(this), this.isRemoved = !0, (new r.TimelineLite).add([new s.SpineTween(this._spine, 1, `win_toggle${t}`)])
                }
                showMultiplier(t = 1) {
                    this._wildMultiplier.scale.set(1), this._wildMultiplier.text = "X" + t.toString(), this._wildMultiplier.position.set(0, 175), this._wildMultiplier.visible = !0
                }
                explode(t) {
                    return t = (t.length > 0 ? "_" : "") + t, (new r.TimelineMax).add([r.TweenMax.to(this._wildMultiplier, .3, {
                        alpha: 0
                    }), new s.SpineTween(this._spine, 1, `win_break${t}`)]).add((() => {
                        this.remove()
                    }))
                }
            }
            e.TheCryptFullWild = a
        },
        4336: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptScatter = void 0;
            const n = i(6501),
                r = i(6358),
                o = i(7141),
                s = i(5160),
                a = i(7732),
                l = i(2185);
            class h extends n.TheCryptSymbol {
                constructor(t, e = n.TheCryptSymbolStates.NORMAL) {
                    super(t), this._isPlayingTrigger = !1, this._isPlayingAttention = !1, this._currentAnimation = "", this.getStateAnimation(e)
                }
                set isPlayingAttention(t) {
                    this._isPlayingAttention || (this.parent, this.parent.removeChild(this), o.TheCrypt.realArea.allReels[this.reelId].reelView.scatterWinView.addChild(this), this._isPlayingAttention = !0)
                }
                playLandingAnimation() {
                    return (new r.TimelineLite).add([() => {
                        var t;
                        this._currentAnimation = "base", null === (t = this._spine) || void 0 === t || t.state.setAnimation(0, "base", !0)
                    }, new a.SpineTween(this._spine, 2, "land")]).add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setEmptyAnimation(2, 0)
                    }))
                }
                playWin() {
                    return this._isPlayingTrigger = !0, this._currentAnimation = "win", (new r.TimelineLite).add([() => {
                        l.TheCryptSoundManager.playScatterFlashSound()
                    }, new a.SpineTween(this._spine, 1, "win")], 1)
                }
                playPlusThree() {
                    var t;
                    this._isPlayingAttention || this._isPlayingTrigger || (this.parent, this.parent.removeChild(this), o.TheCrypt.realArea.allReels[this.reelId].reelView.scatterWinView.addChild(this)), this._isPlayingAttention = !0, this._currentAnimation = "trigger_4_loop", null === (t = this._spine) || void 0 === t || t.state.setEmptyAnimation(1, .2), (new r.TimelineLite).add(new a.SpineTween(this._spine, 0, "trigger_4")).add((() => {
                        this._spine.state.setAnimation(0, "trigger_4_loop", !0)
                    }))
                }
                playScatterAttention() {
                    var t;
                    return this.isPlayingAttention = !0, this._currentAnimation = "attention", null === (t = this._spine) || void 0 === t || t.state.setAnimation(1, "attention", !0), new r.TimelineLite
                }
                playScatterTrigger() {
                    var t;
                    this._isPlayingAttention = !0, null === (t = this._spine) || void 0 === t || t.state.setEmptyAnimation(1, .2), this._currentAnimation = "trigger_3_loop", (new r.TimelineLite).add(new a.SpineTween(this._spine, 0, "trigger_3")).add((() => {
                        this._spine.state.setAnimation(0, "trigger_3_loop", !0)
                    }))
                }
                remove() {
                    return this.reset(), super.remove()
                }
                reset() {
                    s.TheCryptHelper.resetSpineItem(this._spine)
                }
                stopAnimation(t) {
                    var e, i;
                    t || (("base" != this._currentAnimation || this._isPlayingAttention) && (null === (e = this._spine) || void 0 === e || e.state.setAnimation(0, "base", !0), null === (i = this._spine) || void 0 === i || i.state.setEmptyAnimation(1, .2)), this._currentAnimation = "base", this._isPlayingAttention = !1)
                }
                setRestoreState() {
                    this._currentAnimation = "base"
                }
                setRestoreState3(t) {
                    this.isPlayingAttention = !0, t < 3 ? (this._currentAnimation = "trigger_3_loop", this._spine.state.setAnimation(0, "trigger_3_loop", !0)) : (this._currentAnimation = "trigger_4_loop", this._spine.state.setAnimation(0, "trigger_4_loop", !0))
                }
                setRestoreState2(t) {
                    var e, i;
                    this.isPlayingAttention = !0, this._currentAnimation = "attention", null === (e = this._spine) || void 0 === e || e.state.setAnimation(0, "base", !0), null === (i = this._spine) || void 0 === i || i.state.setAnimation(1, this._currentAnimation, !0)
                }
                setSymbolState(t) {
                    var e, i, n, r;
                    if (t) {
                        if (0 === this._currentAnimation.length) return this._currentAnimation = "base", void (null === (e = this._spine) || void 0 === e || e.state.setAnimation(0, "base", !0));
                        if ("base" !== this._currentAnimation) switch (this._currentAnimation) {
                            case "win":
                                null === (i = this._spine) || void 0 === i || i.state.setAnimation(1, this._currentAnimation, !1);
                                break;
                            case "attention":
                                null === (n = this._spine) || void 0 === n || n.state.setAnimation(0, "base", !0), null === (r = this._spine) || void 0 === r || r.state.setAnimation(1, this._currentAnimation, !0);
                                break;
                            case "trigger_4_loop":
                                this._spine.state.setAnimation(0, "trigger_4_loop", !0);
                                break;
                            case "trigger_3_loop":
                                this._spine.state.setAnimation(0, "trigger_3_loop", !0)
                        }
                    }
                }
            }
            e.TheCryptScatter = h
        },
        6501: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptSymbol = e.TheCryptSymbolStates = void 0;
            const n = i(6358),
                r = i(3832),
                o = i(7141),
                s = i(5160),
                a = i(760);
            var l = PIXI.spine.Spine;
            const h = i(1295),
                u = i(7732),
                c = i(6338),
                d = i(5257);
            var p;
            ! function (t) {
                t[t.NORMAL = 0] = "NORMAL", t[t.BLUR = 1] = "BLUR", t[t.WIN = 2] = "WIN", t[t.NO_WIN = 3] = "NO_WIN", t[t.LANDING = 4] = "LANDING", t[t.EXPAND = 5] = "EXPAND", t[t.NUDGE = 6] = "NUDGE"
            }(p = e.TheCryptSymbolStates || (e.TheCryptSymbolStates = {}));
            class f extends PIXI.Container {
                isSpecialSymbol() {
                    const t = this._name;
                    return "W" === t || t.indexOf("FW") > -1 || "M" === t
                }
                isNormalSymbol() {
                    const t = this._name;
                    return !this._isSpecialSymbol && ("L" === t[0] || "M" === t[0])
                }
                getTextureName(t) {
                    return ""
                }
                getHighLighterTextureName(t) {
                    return "FW" === this._name ? "potential_xway_wins/potential_win_stacked" : `potential_xway_wins/potential_win_${t}`
                }
                isMSymbol() {
                    return "M" != this.symName && "M" === this.symName[0]
                }
                getSpineName(t) {
                    return this._isNormalSymbol ? this.isMSymbol() ? `SymMSize${t}` : `SymLSize${t}` : "W" === this._name || "S" === this._name ? `${this._name}_${t}` : "FW" === this._name || "M" === this._name ? `${this._name}` : ""
                }
                getSymHeight() {
                    return a.TheCryptGameConfig.reelHeight / this._reelSize
                }
                addSpine() {
                    this._spine || (this._spine = new l(o.TheCrypt.assetLoader.getSpineAsset(this._spineName)), this.addChild(this._spine), this._isNormalSymbol && this._spine.skeleton.setSkinByName(this._textureName))
                }
                playLandingAnimation() {
                    return (new n.TimelineLite).add(new u.SpineTween(this._spine, 0, "land"))
                }
                getStateAnimation(t = p.NORMAL, e = 0) {
                    if (s.TheCryptHelper.isInvisibleSym(this.symName)) return n.gsap.timeline();
                    if (this._state === t) return n.gsap.timeline();
                    const i = new n.TimelineLite,
                        r = t === p.BLUR,
                        a = this.getTextureName(this._symSize);
                    return this._spineName.length > 0 ? (this.addSpine(), r ? i.add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(0, "spin", !1)
                    }), 0) : t === p.NUDGE ? i.add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(1, "nudge", !1)
                    }), 0) : t === p.NORMAL ? i.add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(0, "base", "S" === this._name)
                    }), 0) : t === p.LANDING ? ["W", "M"].indexOf(this._name) > -1 ? i.add(this.playLandingAnimation()) : "S" !== this._name && i.add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(0, "base", !1)
                    })) : i.add((() => {
                        this._currentStateSprite.visible = !1
                    }), 0)) : i.add((() => {
                        this._currentStateSprite.texture = o.TheCrypt.assetLoader.getTextures(`${a}${r ? "_spin" : ""}`)[0], this._currentStateSprite.visible = !0, this.addChild(this._currentStateSprite)
                    }), 0), this._state = t, i
                }
                init(t) {
                    return s.TheCryptHelper.isInvisibleSym(this.symName) || this.getStateAnimation(t), this
                }
                constructor(t, e = p.NORMAL) {
                    super(), this._id = -1, this._reelId = -1, this._isRemoved = !1, this._isWild = !1;
                    let i = t.symName;
                    i.indexOf("_W") > 0 && (i = i[0] + i[1], this._isWild = !0), this.name = i + t.symSize.toString(), this._isRemoved = !1, this._name = i, this._textureName = i, this._isSpecialSymbol = this.isSpecialSymbol(), this._isNormalSymbol = this.isNormalSymbol(), this._currentStateSprite = new PIXI.Sprite, this._hasHighlight = !!t.hasHighlight && t.hasHighlight, this._currentStateSprite.name = "currentStateSprite", this._currentStateSprite.anchor.set(.5, .5), this._currentStateSprite.position.set(0, 0), this._highlighter = new PIXI.Sprite(o.TheCrypt.assetLoader.getTextures(this.getHighLighterTextureName(t.symSize))[0]), this._highlighter.anchor.set(.5, .5), this._highlighter.position.set(0, 0), this._highlighter.visible = !1, this._spineName = this.getSpineName(t.symSize), this._id = t.id, this._reelId = t.reelId, this.reelSize = t.reelSize, this._symWidth = a.TheCryptGameConfig.symbolWidth, this._symHeight = this.getSymHeight(), this.init(e), "W" !== i && "FW" !== i || this.addWildMultiplier(), t.M1Multiplier && t.M1Multiplier > 1 && this.patchMidSymWildOrMultiplier(o.TheCrypt.model.m1CurrentMultiplier, !1), (t.isWild || this._isWild) && this.patchMidSymWildOrMultiplier(o.TheCrypt.model.data.m1CurrentMultiplier, !1), this._symbolData = t
                }
                fallOut() { }
                playInitialWin(t) {
                    return this._isRemoved = !0, t += t.length > 0 ? "_" : "", this._isNormalSymbol ? (this.parent.removeChild(this), this._M1Multiplier && !o.TheCrypt.model.isNormal ? o.TheCrypt.realArea.allReels[this._reelId].reelView.scatterWinView.addChild(this) : o.TheCrypt.realArea.allReels[this._reelId].reelView.initialWinSymbolView.addChild(this), new u.SpineTween(this._spine, 0, `${t}win_toggle`)) : this.playWinHighlighter()
                }
                collect() {
                    if (s.TheCryptHelper.isInvisibleSym(this._name)) return new n.TimelineLite;
                    const t = this._isWild || this._name.indexOf("FW") > -1;
                    return (new n.TimelineLite).add(new u.SpineTween(this._spine, t ? 2 : 1, "collect" + ("M1" === this._name ? "_m1" : "")))
                }
                changeHeight(t = 0, e, i) {
                    const r = new n.TimelineLite;
                    return "M" === this._spineName ? r.add([new u.SpineTween(this._spine, 0, `expand_${e - 4 + 1}${o.TheCrypt.model.hasNoAvalancheWin ? "_fast" : ""}`)], t - .2).add((() => {
                        this.remove()
                    }), 1.254) : (this._spineName.length > 0 ? r.add(n.TweenMax.to(this._spine.scale, t, {
                        y: i
                    })) : this._isSpecialSymbol && r.add(n.TweenMax.to(this._currentStateSprite.scale, t, {
                        y: i
                    })), r)
                }
                breakOnNudge(t) {
                    const e = new n.TimelineLite;
                    if (!this._isNormalSymbol) throw Error(`Nudge on special symbol: ${this._name}`);
                    return e.add(new u.SpineTween(this._spine, 1, "nudge_break"), .1), e.add(n.TweenLite.to(this._spine, t, {
                        alpha: 1
                    })), this._M1Multiplier && e.add((() => {
                        this._M1Multiplier.visible = !1
                    })), e
                }
                explodeOnNudge(t, e = !1) {
                    t += t.length > 0 ? "_" : "";
                    const i = new n.TimelineLite;
                    return this._isNormalSymbol && i.add(new u.SpineTween(this._spine, this._isWild ? 2 : 1, `${t}win_break`), 0), this._wildMultiplier && i.add(n.TweenLite.to(this._wildMultiplier, .2, {
                        alpha: 0
                    }), 0).add((() => {
                        this._wildMultiplier.visible = !1
                    })), this._M1Multiplier && i.add(n.TweenLite.to(this._M1Multiplier, .2, {
                        alpha: 0
                    }), 0).add((() => {
                        this._M1Multiplier.visible = !1
                    })), e && i.add((() => {
                        this.remove()
                    })), i
                }
                explode(t) {
                    return this.explodeOnNudge(t, !0)
                }
                patchM1Multiplier(t, e = !0) {
                    const i = new n.TimelineLite,
                        o = e ? a.TheCryptGameConfig.SYMBOL_HIGHLIGHT_DURATION : 0;
                    return this._M1Multiplier ? this._M1Multiplier.text = `X${t}` : this._M1Multiplier = new r.BitmapText(`X${t}`, h.TheCryptFontConfig.M1_MULTIPLIER_STYLE), this._M1Multiplier.position.set(.5 * this._symWidth - this._M1Multiplier.width - 6, .5 * -this._symHeight), this._M1Multiplier.alpha = 0, this._M1Multiplier.letterSpacing = 2, this.addChild(this._M1Multiplier), e && i.add(new u.SpineTween(this._spine, 1, "turn_mult"), 0), t > 1 && (i.add(n.TweenLite.to(this._M1Multiplier, o, {
                        alpha: 1
                    }), 0), i.add((() => {
                        this._spine.state.setAnimation(1, `m1_mult_${t > 5 ? 5 : t}`, !0)
                    }))), i
                }
                patchMidSymWildOrMultiplier(t, e = !0) {
                    const i = new n.TimelineLite;
                    return "M1" === this._name ? this.patchM1Multiplier(t, e) : (this._isWild = !0, e && i.add(new u.SpineTween(this._spine, 1, "turn_wild")), i.add((() => {
                        this._spine.alpha = 1, this._spine.state.setAnimation(1, "wild_state", !0)
                    })), i)
                }
                playWinHighlighter(t = 1.5) {
                    return this._highlighter.alpha = 0, (new n.TimelineLite).add((() => {
                        this._highlighter.alpha = 1, this._highlighter.visible = !0, this.addChild(this._highlighter)
                    })).add(n.TweenLite.to(this._highlighter, .3, {
                        alpha: 0,
                        delay: t - .3
                    }))
                }
                remove() {
                    return this._wildMultiplier && this._wildMultiplier.destroy(), this._M1Multiplier && this._M1Multiplier.destroy(), this._wildMultiplierEffect && this._wildMultiplierEffect.destroy(), this._spine && (this._spine.destroy(), this._spine = null), this.parent && this.parent.removeChild(this), this.destroy({
                        children: !0
                    }), this._isRemoved = !0, this
                }
                multiplierAnimation(t, e, i = 0, r = !0) {
                    return this.addChild(this._wildMultiplier), this.addChild(this._wildMultiplierEffect), this._wildMultiplierEffect.scale.set(1), (new n.TimelineLite).add((() => {
                        var i;
                        this._isRemoved || (this._wildMultiplier.text = `X${t}`, this._wildMultiplierEffect.text = `X${t}`, r && (null === (i = this._spine) || void 0 === i || i.state.setAnimation(1, "nudge", !1)), n.TweenLite.fromTo(this._wildMultiplierEffect, e, {
                            alpha: 1
                        }, {
                            alpha: 0,
                            delay: .5 * e
                        }), n.TweenLite.to(this._wildMultiplier, 0, {
                            alpha: 1
                        }), n.TweenLite.fromTo(this._wildMultiplierEffect.scale, e, {
                            x: 1,
                            y: 1
                        }, {
                            x: 1.5 + Math.min(.5, .1 * t),
                            y: 1.5 + Math.min(.5, .1 * t),
                            ease: "sine.out"
                        }))
                    }), i)
                }
                showNudgeMultiplier(t, e = !1, i = !0) {
                    const o = new n.TimelineLite,
                        s = this.position.y;
                    return this._wildMultiplierEffect = new r.BitmapText("X1", h.TheCryptFontConfig.NUDGE_WILD_MULTIPLIER_STYLE), this._wildMultiplierEffect.anchor = new PIXI.Point(.5, .5), this._wildMultiplierEffect.position.set(-6, 40), this._wildMultiplierEffect.letterSpacing = 6, this._wildMultiplierEffect.alpha = 0, this._wildMultiplier.alpha = 0, this._wildMultiplier.visible = !0, this._wildMultiplier.text = "X1", e || (o.add(n.TweenLite.to(this, .1, {
                        y: s - 15
                    })), o.add(n.TweenLite.to(this, .2, {
                        y: s
                    })), t -= .3, o.add(this.multiplierAnimation(1, t, 0, i))), o
                }
                upgradeWildMultiplier(t, e, i, n = !0) {
                    return this.multiplierAnimation(t, e, i + e, n)
                }
                addWildMultiplier() {
                    this._wildMultiplier = new r.BitmapText("X", h.TheCryptFontConfig.NUDGE_WILD_MULTIPLIER_STYLE), this._wildMultiplier.anchor = new PIXI.Point(.5, .5), this._wildMultiplier.position.set(-6, 40), this._wildMultiplier.letterSpacing = 6, this._wildMultiplier.visible = !1
                }
                getShakeAnimation(t = 1.715, e = !1) {
                    const i = n.gsap.timeline();
                    if ("Y" === this._name) return i;
                    const r = e ? d.TheCryptAnimationConfig.capWinAnticipationWiggleX : d.TheCryptAnimationConfig.bigWinAnticipationWiggle,
                        o = e ? d.TheCryptAnimationConfig.capWinAnticipationWiggleY : d.TheCryptAnimationConfig.bigWinAnticipationWiggle2,
                        s = c.ArrayUtils.shuffleArray([r, o]),
                        a = (Math.random() > .5 ? "-" : "+") + "=2",
                        l = (Math.random() > .5 ? "-" : "+") + "=1",
                        h = "FW" === this._name ? "0.01" : "0.03",
                        u = Math.random() > .5 ? "-=" + h : "+=" + h;
                    return i.add(n.gsap.to(this.position, {
                        duration: t,
                        x: a,
                        ease: s[0]
                    })), i.add(n.gsap.to(this.position, {
                        duration: t,
                        y: l,
                        ease: s[1]
                    }), "<"), this._spine ? i.add(n.gsap.to(this._spine, {
                        duration: t,
                        rotation: u,
                        ease: s[1]
                    }), "<") : i.add(n.gsap.to(this._currentStateSprite, {
                        duration: t,
                        rotation: u,
                        ease: s[1]
                    }), "<"), i.reverse()
                }
                setSymbolState(t) {
                    t && (t.M1Multiplier && t.M1Multiplier > 1 && this.patchMidSymWildOrMultiplier(o.TheCrypt.model.data.m1CurrentMultiplier, !1), (t.isWild || this._isWild) && this.patchMidSymWildOrMultiplier(o.TheCrypt.model.data.m1CurrentMultiplier, !1))
                }
                get isRemoved() {
                    return this._isRemoved
                }
                set isRemoved(t) {
                    this._isRemoved = t
                }
                set wildMultiplier(t) {
                    this._wildMultiplier.text = t
                }
                get symName() {
                    return this._name
                }
                get id() {
                    return this._id
                }
                get reelId() {
                    return this._reelId
                }
                set id(t) {
                    this._id = t
                }
                set reelSize(t) {
                    this._reelSize = t;
                    const e = t - 6 + 3;
                    if (this._symHeight = a.TheCryptGameConfig.reelHeight / t, this._spineName.length > 0) {
                        if (this._spine) {
                            const t = this._spine,
                                i = new l(o.TheCrypt.assetLoader.getSpineAsset(this.getSpineName(e)));
                            this._isNormalSymbol && i.skeleton.setSkinByName(this._name), this.addChild(i), t.destroy(), this._spine = null, this._spine = i
                        }
                    } else this._symSize == e || s.TheCryptHelper.isInvisibleSym(this._name) || (this._currentStateSprite.texture = o.TheCrypt.assetLoader.getTextures(this.getTextureName(e))[0]);
                    this.setSymbolState(this._symbolData), this._symSize = e
                }
                get symHeight() {
                    return this._symHeight
                }
                get isXWay() {
                    return "M" === this._name
                }
            }
            e.TheCryptSymbol = f
        },
        6338: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ArrayUtils = void 0, e.ArrayUtils = class {
                static cloneMatrix(t) {
                    const e = [];
                    for (let i of t) e.push([...i]);
                    return e
                }
                static isAllTrue(t) {
                    for (let e of t)
                        if (!e) return !1;
                    return !0
                }
                static shuffleArray(t) {
                    let e = t.concat();
                    for (let t = e.length; t; t--) {
                        let i = Math.floor(Math.random() * t);
                        [e[t - 1], e[i]] = [e[i], e[t - 1]]
                    }
                    return e
                }
            }
        },
        5160: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptHelper = void 0;
            const n = i(4514),
                r = i(7141),
                o = i(9529),
                s = i(6364),
                a = i(2366);
            class l {
                static copyLocalPosition(t, e, i) {
                    return t.parent.toLocal(t.parent.position, e, i)
                }
                static getBigWinLevel() {
                    return 1
                }
                static isFreeSpin(t) {
                    return t.indexOf("FREESPIN") > -1
                }
                static checkIfSymbolIsNull(t) {
                    if (null == t) throw new Error("AvalancheReelPartAnimator.animateAllIn, symbol is null!")
                }
                static isWildSymbol(t) {
                    return "W" === t
                }
                static isCollectiveSymbol(t) {
                    return "M" === t[0] || "M" !== t
                }
                static isLargerSymbol(t) {
                    return "M" === t || "W" === t || "S" === t || t.indexOf("FW") > -1
                }
                static isNormal(t) {
                    return t.indexOf("NORMAL") > -1
                }
                static isRespin(t) {
                    return t.indexOf("AVALANCHE") > -1
                }
                static isInvisibleSym(t) {
                    return "Y" === t || "X" === t
                }
                static isBigWin(t, e) {
                    return o.MathHelper.ceilToDecimals(t / e, 2) >= a.TheCryptWinConfig.WIN_RATIOS.bigWin[0].ratio
                }
                static copyArray(t) {
                    const e = [];
                    return t.forEach((t => {
                        const i = [];
                        t.forEach((t => {
                            i.push(t)
                        })), e.push(i)
                    })), e
                }
                static get isIpad() {
                    const t = n.NolimitApplication.screenBounds;
                    return n.NolimitApplication.isLandscape ? t.width >= 955 && t.width <= 965 : t.height >= 955 && t.height <= 965
                }
                static getBuyFeaturePrice() {
                    var t;
                    let e = r.TheCrypt.apiPlugin.freeBets.hasFreeBets() ? r.TheCrypt.apiPlugin.freeBets.getBet() : r.TheCrypt.apiPlugin.betLevel.getLevel(),
                        i = (null === (t = r.TheCrypt.model.gameData) || void 0 === t ? void 0 : t.playedBetValue) || parseFloat(e);
                    if (r.TheCrypt.model.data.wasFeatureBuy || "BOOSTED_BET" === r.TheCrypt.model.buyFeatureName)
                        for (let t = 0; t < r.TheCrypt.model.initData.featureBuyTimesBetValue.length; t++)
                            if (r.TheCrypt.model.initData.featureBuyTimesBetValue[t].name === r.TheCrypt.model.buyFeatureName) {
                                i *= r.TheCrypt.model.initData.featureBuyTimesBetValue[t].price;
                                break
                            } return i
                }
                static isWinBelowStake() {
                    return r.TheCrypt.apiPlugin.gameClientConfiguration.belowStakeWinRestriction && r.TheCrypt.model.data.accumulatedRoundWin <= this.getBuyFeaturePrice()
                }
                static createSprite(t, e = 0, i = 0) {
                    const n = new PIXI.Sprite(t ? r.TheCrypt.assetLoader.getTextures(t)[0] : PIXI.Texture.EMPTY);
                    return n.position.set(e, i), n
                }
                static createDefaultSixBySixBooleanArray() {
                    return s.ArrayHelper.initArrayWithValues(6, (() => s.ArrayHelper.initArrayWithValues(6, (() => !1))))
                }
                static randomBetween(t, e) {
                    return Math.floor(Math.random() * (1 + e - t) + t)
                }
                static sum(t) {
                    return t.reduce(((t, e) => t + e), 0)
                }
                static resetSpineItem(t) {
                    t.skeleton.setSlotsToSetupPose(), t.skeleton.setToSetupPose(), t.state.clearTracks(), t.state.setEmptyAnimation(0, 0)
                }
                static getToggleType() {
                    return r.TheCrypt.model.currentWinRatio >= a.TheCryptWinConfig.WIN_RATIOS.normalWin[3].ratio ? "" : r.TheCrypt.model.currentWinRatio >= a.TheCryptWinConfig.WIN_RATIOS.normalWin[2].ratio ? "medium" : "small"
                }
            }
            l.isGameStarted = !1, e.TheCryptHelper = l
        },
        2228: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ExtraFreespinAwardView = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2185),
                s = i(3554),
                a = i(7732);
            class l extends PIXI.Container {
                constructor() {
                    super(), this.name = "ExtraFreespinAwardView", this.init()
                }
                init() {
                    this.position.set(360, 360), this.visible = !1
                }
                reset() {
                    this._spine && (this._spine.destroy(), this._spine = null), this.visible = !1
                }
                show() {
                    if (this.position.set(360, 360), this._spine && (this._spine.destroy(), this._spine = null), !Number.isInteger(r.TheCrypt.model.sideBarProgress[0] / 4)) throw Error;
                    this._spine = new PIXI.spine.Spine(r.TheCrypt.assetLoader.getSpineAsset("plus2banner")), this._spine.skeleton.setSkinByName("M" + (6 - r.TheCrypt.model.gameData.dragonSideReel[0] / 4 + 1));
                    const t = new n.TimelineLite;
                    return t.add([() => {
                        this.visible = !0, this.addChild(this._spine), o.TheCryptSoundManager.playSound(s.TheCryptSoundConfig.FREESPINS_ADD_2)
                    }, new a.SpineTween(this._spine, 0, "base"), n.TweenLite.to(this, 1.5, {
                        alpha: 1
                    })]), t.add((() => {
                        r.TheCrypt.keypadPlugin.setZeroBetSpinCounter(r.TheCrypt.model.freespinsLeft)
                    }), "-=0.5"), t.add((() => {
                        this._spine && (this._spine.destroy(), this._spine = null), this.visible = !1
                    })), t
                }
            }
            e.ExtraFreespinAwardView = l
        },
        8119: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.HighSymbolReelArea = void 0;
            const n = i(760);
            class r extends PIXI.Container {
                constructor() {
                    super(), this.name = "HighSymbolReelArea", this.position = n.TheCryptGameConfig.reelAreaPos
                }
            }
            e.HighSymbolReelArea = r
        },
        6865: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.ScatterCounter = void 0;
            const n = i(6358),
                r = i(7141),
                o = i(2185);
            class s {
                constructor() {
                    s.scatters = []
                }
                static reset() {
                    s.scatters.forEach((t => {
                        t.stopAnimation(r.TheCrypt.model.freespinTriggeredThisSpin)
                    })), s.scatters = []
                }
                static onRestore() {
                    if (!r.TheCrypt.model.isRestore) return;
                    if (s.scatters.length < 2) return void s.scatters.forEach(((t, e) => {
                        t.setRestoreState()
                    }));
                    const t = s.scatters.length;
                    s.scatters.forEach(((e, i) => {
                        t > 2 ? e.setRestoreState3(i) : e.setRestoreState2(i)
                    })), r.TheCrypt.model.isNextRespin
                }
                static addScatter(t) {
                    s.scatters.push(t);
                    const e = new n.TimelineLite;
                    e.add([() => o.TheCryptSoundManager.playScatterLandSound(s.scatters.length), t.playLandingAnimation()]);
                    const i = e.duration();
                    return s.scatters.length >= 4 ? e.add((() => t.playPlusThree()), i) : (2 === s.scatters.length ? s.scatters.forEach((n => {
                        (5 !== t.reelId || r.TheCrypt.model.isNextRespin) && e.add(n.playScatterAttention(), i)
                    })) : 3 === s.scatters.length && (e.add((() => {
                        r.TheCrypt.reelFrame.onThirdScatterLand()
                    }), i), s.scatters.forEach((t => {
                        e.add((() => {
                            t.playScatterTrigger()
                        }), i)
                    }))), e)
                }
                static get allScatters() {
                    return s.scatters
                }
            }
            s.scatters = [], e.ScatterCounter = s
        },
        1765: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptBackground = void 0;
            const n = i(5160),
                r = i(7141),
                o = i(4514);
            class s extends PIXI.Container {
                constructor() {
                    super(), this.GAME_LOGO_POSITION_Y = [53, -150, -200], this.name = "Background", this._spines = [], this.init()
                }
                init() {
                    const t = n.TheCryptHelper.createSprite("introBg", 360, 360);
                    t.anchor.set(.5, .5), this.addChild(t), this._topGradient = n.TheCryptHelper.createSprite("dark_gradient", 360, 0), this._topGradient.anchor.set(.5, 0), this._topGradient.alpha = .3, this._topGradient.blendMode = PIXI.BLEND_MODES.MULTIPLY, this.addChild(this._topGradient), this._mainGameBG = this.addNormalBGAnimation(), this._bonusGameBG = this.addFSBGAnimation(), this._gameNameAndWays = this.addGameNameAndWays(), this._gameLogoOnTop = n.TheCryptHelper.createSprite("logo", 0, 0), this._gameLogoOnTop.name = "logo", this.addChild(this._gameLogoOnTop), this._gameLogoOnTop.scale.set(.8), this._gameLogoOnTop.anchor.set(.5), this._gameLogoportraitPositionY = this.GAME_LOGO_POSITION_Y[r.TheCrypt.model.isNormal ? 1 : 2], this.onResize()
                }
                addNormalBGAnimation() {
                    const t = new PIXI.Container;
                    return t.name = "mainGameBGContainer", t
                }
                addGameNameAndWays() {
                    const t = new PIXI.Container;
                    return t.name = "gameNameAndWays", t
                }
                addFSBGAnimation() {
                    const t = new PIXI.Container;
                    return t.name = "bonusGameBGContainer", this._fsAnimation = new PIXI.spine.Spine(r.TheCrypt.assetLoader.getSpineAsset("FS_background")), this._fsAnimation.position.set(360, 360), t.addChild(this._fsAnimation), t
                }
                setMode(t) {
                    n.TheCryptHelper.isNormal(t) ? (this._bonusGameBG.visible = !1, this.addChild(this._mainGameBG), this._gameLogoportraitPositionY = this.GAME_LOGO_POSITION_Y[1]) : (this._bonusGameBG.visible = !0, this._gameLogoportraitPositionY = this.GAME_LOGO_POSITION_Y[2], this.addChild(this._bonusGameBG)), this.onRePositionLogo(), this.addChild(this._gameNameAndWays)
                }
                onRePositionLogo() {
                    const t = o.NolimitApplication.isLandscape,
                        e = Math.max(this._gameLogoportraitPositionY, o.NolimitApplication.screenBounds.top + 50);
                    t ? (this._gameLogoOnTop.position.set(-174, 53), this._gameLogoOnTop.visible = -174 - o.NolimitApplication.screenBounds.left > 30) : (this._gameLogoOnTop.position.set(360, Math.min(e, -88)), this._gameLogoOnTop.visible = Math.min(e, -88) - o.NolimitApplication.screenBounds.top > (r.TheCrypt.model.isNextNormal ? 35 : 50))
                }
                onResize() {
                    const t = o.NolimitApplication.isLandscape;
                    this._bonusGameBG.visible && this._fsAnimation && this._fsAnimation.state.setAnimation(0, t ? "landscape" : "portrait", !0), this.onRePositionLogo(), this._topGradient.width = o.NolimitApplication.screenBounds.width, this._topGradient.position.y = o.NolimitApplication.screenBounds.top
                }
            }
            e.TheCryptBackground = s
        },
        5944: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptBigWinView = void 0;
            const n = i(6358),
                r = i(8680),
                o = i(7429),
                s = i(5160),
                a = i(7162),
                l = i(7141),
                h = i(3832);
            var u = PIXI.spine.Spine;
            const c = i(7732),
                d = i(2185),
                p = i(3554);
            class f extends PIXI.Container {
                constructor() {
                    super(), this.name = "BIG_WIN", this._spines = [], this.init()
                }
                set maxLevel(t) {
                    this._maxLevel = t
                }
                init() {
                    this._countUp = new o.BasicBitmapCountUp({
                        fontName: a.TheCryptGameAssets.BITMAP_FONT_WIN_COUNT_UP,
                        fontSize: 54,
                        tint: 16777215
                    }, 660, new PIXI.Point(.5, .5)), this._countUp.position.set(360, 600), this._countUp.stopAt(0), this._ghost = new u(l.TheCrypt.assetLoader.getSpineAsset("ghost")), this._ghost.position.set(360, 360), this._ghost.visible = !1, this.addChild(this._countUp), this._waysNumber = new h.BitmapText("", {
                        fontName: a.TheCryptGameAssets.BITMAP_FONT_WIN_WAYS,
                        fontSize: 40,
                        tint: 16777215
                    }), this._waysNumber.letterSpacing = -12, this._waysText = new PIXI.Sprite, this._waysNumber.anchor.set(0, 1), this._waysText.anchor = new PIXI.Point(0, .7), this.visible = !1, this.alpha = 0, this._countUp.visible = !1
                }
                show(t) {
                    const e = n.gsap.timeline();
                    this.alpha = 0, this.visible = !0, this._countUp.scale.set(.5), this._countUp.position.set(360, 600), e.add((() => {
                        l.TheCrypt.bigWinView._countUp.setAmount(0)
                    })), e.add(n.gsap.to(this, {
                        duration: t,
                        alpha: 1
                    }), 0);
                    const i = l.TheCrypt.model.gameData.waysWonTotalRound;
                    this._waysText.texture = l.TheCrypt.assetLoader.getTextures("Way" + (i > 1 ? "s" : ""))[0], this._waysNumber.text = i.toString();
                    const r = 360 - .5 * (this._waysNumber.width + this._waysText.width);
                    return this._waysNumber.position.set(r, 560), this._waysText.position.set(r + this._waysNumber.width + 8, 560), this._waysNumber.alpha = 0, this._waysText.alpha = 0, this.addChild(this._waysText, this._waysNumber), e
                }
                hide(t = 1e-4) {
                    const e = new n.TimelineLite;
                    return s.TheCryptHelper.getBigWinLevel(), e.add(n.gsap.to(this._countUp, {
                        duration: .2,
                        y: 300
                    })), e.add(l.TheCrypt.gameViewContainer.removeDimmer(), .2), e.add(n.gsap.to(this, {
                        duration: t,
                        alpha: 0
                    })), e.add((() => {
                        this.visible = !1, this._countUp.visible = !1, this._ghost.visible = !1, this._spines.forEach((t => {
                            t.destroy()
                        })), this._spines = []
                    })), e
                }
                getSpine(t) {
                    let e = new PIXI.spine.Spine(l.TheCrypt.assetLoader.getSpineAsset("bigWinLv" + t.toString()));
                    return e.position.set(360, 360), e.name = "BIGWIN_SPINE_LEVEL_" + t, this._spines.push(e), e.visible = !1, e
                }
                getLevelAnimation(t, e, i, o) {
                    r.Logger.logDev("getLevelAnimation called details :: from : " + t + " to : " + e + " duration : " + i + " level : " + o);
                    const s = new n.TimelineLite,
                        a = this.getSpine(o),
                        l = o === this._maxLevel;
                    s.add((() => {
                        this.addChild(a), this.addChild(this._countUp), this.addChild(this._ghost), o > 1 && (this._spines[o - 2].visible = !1)
                    }));
                    const h = new n.TimelineLite;
                    return h.add(this.getCountUpScaleAnimation(.1, "power2.in", .4 + .1 * o)), h.add(this.getCountUpScaleAnimation(.2, "power2.out", .5 + .1 * (o + 1))), h.add(this.getCountUpScaleAnimation(i - .3, "power2.in", .5 + .1 * (o + 1))), s.add((() => {
                        this._ghost.visible = !0, new c.SpineTween(this._ghost, 0, `lv${o}`), new c.SpineTween(a, 0, "A"), a.visible = !0
                    }), 0), s.add(h, 0), 1 == o && s.add((() => {
                        this._countUp.visible = !0
                    }), 0), s.add(this._countUp.getCountAnimation(t, e, i - .1, "none", o), .1), l && s.add([() => d.TheCryptSoundManager.playBigWinEndSound(o - 1), n.TweenLite.to(this._waysNumber, .1, {
                        alpha: 1
                    }), n.TweenLite.to(this._waysText, .1, {
                        alpha: 1
                    })]), s
                }
                onAbort(t) {
                    d.TheCryptSoundManager.stopSoundEffect(p.TheCryptSoundConfig.BIGWIN[t])
                }
                getCountUpScaleAnimation(t, e, i, r) {
                    const o = n.gsap.timeline();
                    return null != r && o.add((() => {
                        this._countUp.scale.set(r, r)
                    })), o.add(n.gsap.to(this._countUp.scale, {
                        duration: t,
                        x: i,
                        y: i,
                        ease: e
                    })), o
                }
            }
            e.TheCryptBigWinView = f
        },
        4819: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptCollector = void 0;
            const n = i(6364),
                r = i(4514),
                o = i(6358),
                s = i(7141),
                a = i(7785),
                l = i(5346),
                h = i(6368),
                u = i(5611),
                c = i(760),
                d = i(5160),
                p = i(2185),
                f = i(3554),
                g = i(8680);
            class m extends PIXI.Container {
                constructor() {
                    super(), this._dragonSideReel = [0, 0], this.name = "Collector", this._collectors = [], this._allSwooshes = [], this.init()
                }
                init() {
                    const t = new PIXI.Sprite(s.TheCrypt.assetLoader.getTextures("meter/meter_plate")[0]);
                    t.anchor.set(.5, 0), t.position.set(0, -26), this.addChild(t), this._collectors = n.ArrayHelper.initArrayWithValues(5, (t => new l.MSymbolCollector(6 - t, this))), this._collectorM1 = new h.M1Collector(1, this), this._collectorM1.position.set(895, 97), this.visible = !1, this._locatePositionSprite = new PIXI.Sprite
                }
                collect() {
                    const t = new o.TimelineLite,
                        e = s.TheCrypt.model.data.dragonSideReel;
                    return e[1] > this._dragonSideReel[1] && (this._dragonSideReel[1] = e[1], t.add(this.collectAnimationM1())), e[0] > this._dragonSideReel[0] && (this._dragonSideReel[0] = e[0], t.add(this.collectAnimation())), t
                }
                patchWildOrMultiplier(t, e = -1) {
                    const i = new o.TimelineLite,
                        n = s.TheCrypt.model.data.m1NextMultiplier,
                        r = `M${t ? 1 : e}`;
                    let a = -1;
                    return s.TheCrypt.realArea.allReels.forEach(((e, o) => {
                        e.reelView.getAllSymbols().forEach(((e, l) => {
                            e.symName === r && (a++, i.add([() => p.TheCryptSoundManager.playSound(f.TheCryptSoundConfig.SYM_TO_WILD), s.TheCrypt.realArea.getSymbol([o, l]).patchMidSymWildOrMultiplier(t ? n : -1)], .5 * a))
                        }))
                    })), i
                }
                getCollectorPositions() {
                    const t = [];
                    let e = 30;
                    return this.collectors.forEach(((i, n) => {
                        e += .5 * i.currentHeight, g.Logger.logDev(`${e} collector is active: ${i.isActive}, at step: ${i.progress}`), t.push(e), e += .5 * i.currentHeight
                    })), t
                }
                updateCollectorPositions() {
                    const t = new o.TimelineLite,
                        e = this.getCollectorPositions();
                    return this._collectors.forEach(((i, n) => {
                        t.add(o.TweenLite.to(i, .09, {
                            y: e[n],
                            ease: o.Power0.easeOut
                        }), 0)
                    })), t
                }
                checkServer(t, e) {
                    a.NolimitConfig.isDevMode && (t.progress, s.TheCrypt.model.data.dragonSideReel[0])
                }
                getPathData(t, e, i, n) {
                    return i || (i = 0), n || (n = 0), [{
                        x: i,
                        y: n
                    }, {
                        x: t,
                        y: n
                    }, {
                        x: t,
                        y: .8 * e
                    }, {
                        x: t,
                        y: e
                    }]
                }
                playSwoosh(t, e, i, n = !1) {
                    const r = new u.AnimatedMeshRope(s.TheCrypt.assetLoader.getTextures(`effects/fs_win_swoosh${t ? "_m1" : ""}/fs_win_swoosh_`), i);
                    r.blendMode = PIXI.BLEND_MODES.SCREEN, s.TheCrypt.initialWinView.addChild(r), r.playAnimation()
                }
                updateCollector(t, e) {
                    s.TheCrypt.initialWinView.addChild(this._locatePositionSprite);
                    const i = new o.TimelineLite;
                    let r = 0;
                    const a = n.ArrayHelper.shuffle(f.TheCryptSoundConfig.COLLECT_SWOOSH);
                    return s.TheCrypt.model.allWinPositionSymbols.forEach(((n, o) => {
                        const l = c.TheCryptGameConfig.reelPositions[o].x + .5 * c.TheCryptGameConfig.symbolWidth;
                        r += o > 2 ? .05 : .08, i.add((() => {
                            p.TheCryptSoundManager.playSound(a[o])
                        }), r), n.forEach(((n, a) => {
                            if (e ? "M1" === n : n.length > 0 && "M1" != n) {
                                this._locatePositionSprite.position = d.TheCryptHelper.copyLocalPosition(this._locatePositionSprite, t);
                                const n = s.TheCrypt.realArea.getSymbol([o, a]),
                                    h = this.getPathData(this._locatePositionSprite.position.x + 10 * (e ? 2 : -1), this._locatePositionSprite.position.y, l, n.position.y);
                                i.add((() => {
                                    this.playSwoosh(e, s.TheCrypt.initialWinView, h, !1), n.collect()
                                }), r)
                            }
                        }))
                    })), i.add(t.upgrade()), i
                }
                collectAnimation() {
                    const t = s.TheCrypt.model.sideBarProgress,
                        e = new o.TimelineLite;
                    return this._collectors.forEach(((i, n) => {
                        t[n] > i.progress && e.add(this.updateCollector(i, !1))
                    })), e
                }
                collectAnimationM1() {
                    const t = s.TheCrypt.model.sideBarProgress[5],
                        e = new o.TimelineLite,
                        i = this._collectorM1;
                    return t > i.progress && e.add(this.updateCollector(i, !0)), e
                }
                show(t) {
                    const e = this.getCollectorPositions(),
                        i = new o.TimelineLite;
                    return this._collectors.forEach(((n, r) => {
                        n.position.set(0, e[r]), i.add([() => {
                            this.addChild(n), p.TheCryptSoundManager.playMeterShowingSound()
                        }, n.show("meter", t)], "-=0.5")
                    })), i.add((() => {
                        this.visible = !0, this.onResize()
                    }), 0), this._collectorM1.alpha = 0, this._collectorM1.show("meterM1", t), i.add(o.TweenLite.to(this._collectorM1, 1, {
                        alpha: 1
                    })), t ? i.add((() => {
                        this._collectors.forEach((t => {
                            t.updateStatesOnRestore()
                        }))
                    })) : (this._collectors[0].isActive = !0, i.add(this._collectors[0].activate())), i.add([() => p.TheCryptSoundManager.playSound(f.TheCryptSoundConfig.METER_SHOW), this.updateCollectorPositions()]), i.add(s.TheCrypt.gameViewContainer.removeDimmer()), i
                }
                showFullFilledCollectorAnimation() {
                    const t = new o.TimelineLite,
                        e = this.fullyChargedMSymbolCollector;
                    return e > -1 && (t.add(this._collectors[e].fullyCharged(), 0), e + 1 < this._collectors.length && t.add(this._collectors[e + 1].activate(), 0), t.add(this.updateCollectorPositions(), 0), t.add(s.TheCrypt.extraFreespinAwardView.show()), t.add(this.patchWildOrMultiplier(!1, 6 - e))), this._collectorM1.isFullyCharged && (t.add(this._collectorM1.fullyCharged()), t.add(this.patchWildOrMultiplier(!0))), t
                }
                hide() {
                    this.visible = !1
                }
                reset() {
                    this._dragonSideReel = [0, 0], this._collectors.forEach((t => t.reset()))
                }
                get collectors() {
                    return this._collectors
                }
                get fullyChargedM1Collector() {
                    return this._collectorM1.isFullyCharged
                }
                get fullyChargedMSymbolCollector() {
                    let t = -1;
                    return this._collectors.forEach(((e, i) => {
                        e.isFullyCharged && (t = i)
                    })), t
                }
                onResize() {
                    this.visible && (r.NolimitApplication.isLandscape ? (this.position.set(d.TheCryptHelper.isIpad ? -62.5 : -90, 61), this._collectorM1.position.set(d.TheCryptHelper.isIpad ? 835 : 895, 97), this.rotation = 0, this._collectors.forEach(((t, e) => {
                        t.rotation = 0
                    })), this._collectorM1.rotation = 0) : (this.position.set(15, d.TheCryptHelper.isIpad ? -25 : -100), this.rotation = .5 * -Math.PI, this._collectors.forEach(((t, e) => {
                        t.rotation = .5 * Math.PI
                    })), this._collectorM1.rotation = .5 * Math.PI, this._collectorM1.position.set(0, 619)))
                }
            }
            e.TheCryptCollector = m
        },
        2179: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFreespinIntro = void 0;
            const n = i(6358),
                r = i(8592),
                o = i(2185),
                s = i(3554),
                a = i(7141),
                l = i(6865),
                h = i(7732),
                u = i(4514),
                c = i(3832),
                d = i(7162);
            class p extends PIXI.Container {
                constructor() {
                    super(), this.name = "FreespinIntro", this.init()
                }
                onButtonClick(t) {
                    t && o.TheCryptSoundManager.playSound(s.TheCryptSoundConfig.CONTINUE_BUTTON);
                    const e = new n.TimelineLite;
                    e.add([n.TweenLite.to(this, .2, {
                        alpha: 0
                    }), () => {
                        o.TheCryptSoundManager.playAmbientLoop(.1, `fs${Math.ceil(2 * Math.random())}`), this._button.enable(!1), this._clickCallback(), this._clickCallback = () => { }
                    }]), e.add((() => {
                        this.visible = !1, this._spineContainer.removeChildren(), this._spine && (this._spine.destroy(), this._spine = null), this._spins && (this._spins.destroy(), this._spins = null)
                    }))
                }
                onResize() {
                    this.visible && (u.NolimitApplication.isLandscape ? this._button.position.set(360, 588) : this._button.position.set(360, Math.max(530, u.NolimitApplication.screenBounds.bottom - 210)))
                }
                init() {
                    this._spineContainer = new PIXI.Sprite, this.addChild(this._spineContainer), this._spineContainer.position.set(360, 360), this._button = new r.ContinueButton, this._button.addClickCallback((() => this.onButtonClick(!0))), this._button.position.set(360, 530), this._button.pivot.set(.5 * this._button.width, 0), this._button.enable(!1), this._button.alpha = 0, this.addChild(this._button), this.visible = !1
                }
                show(t, e = !1) {
                    const i = new n.TimelineLite;
                    return a.TheCrypt.xBetController.buttonsVisible = !1, this._button.alpha = 0, this._spine && (this._spine.destroy(), this._spine = null), this._spins && (this._spins.destroy(), this._spine = null), this._spine = new PIXI.spine.Spine(a.TheCrypt.assetLoader.getSpineAsset("FS_Intro")), this._spineContainer.addChild(this._spine), this._spins = new c.BitmapText("22", {
                        fontName: d.TheCryptGameAssets.BITMAP_FONT_FS_SPINS,
                        fontSize: 40
                    }), this._spins.visible = !1, this._spins.text = `${a.TheCrypt.model.freespinsLeft}`, this._spins.letterSpacing = 2, this._spins.position.set(360 - .5 * this._spins.width, 155), this._spins.alpha = 0, this.addChild(this._spins), i.add((() => {
                        this._clickCallback = t
                    })), a.TheCrypt.model.gameData && a.TheCrypt.model.gameData.brokeTheBank ? this.onButtonClick(!1) : (a.TheCrypt.model.freespinTriggeredThisSpin && l.ScatterCounter.allScatters.forEach((t => {
                        i.add(t.playWin(), 0)
                    })), i.add([() => {
                        this._spins.visible = !0, this.visible = !0, this.onResize(), this.alpha = 1, o.TheCryptSoundManager.playFSIntroSound(), a.TheCrypt.keypadPlugin.hide()
                    }, a.TheCrypt.gameViewContainer.addDimmer(!1), n.TweenLite.to(this._button, .4, {
                        alpha: 1
                    }), n.TweenLite.to(this._spins, .4, {
                        alpha: 1,
                        delay: .4
                    }), new h.SpineTween(this._spine, 0, "start")]), i.add([() => {
                        this._spine.state.setAnimation(0, "loop", !0), l.ScatterCounter.reset(), this._button.enable(!0)
                    }])), i
                }
            }
            e.TheCryptFreespinIntro = p
        },
        5644: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFreespinOutro = void 0;
            const n = i(6358),
                r = i(8592),
                o = i(2185),
                s = i(3554),
                a = i(7141),
                l = i(7429),
                h = i(7162),
                u = i(7732),
                c = i(4514),
                d = i(3832),
                p = i(5160),
                f = i(2366);
            class g extends PIXI.Container {
                constructor() {
                    super(), this._spinsPlayedTextStyle = {
                        fontFamily: "Helvetica",
                        align: "center",
                        fill: "#47ff9e",
                        fontSize: 40
                    }, this.name = "FreespinOutro", this.init()
                }
                getFSWinType() {
                    const t = a.TheCrypt.model.accumulatedRoundWin;
                    return t > 100 * a.TheCrypt.model.gameData.playedBetValue ? "good" : t > 5 * a.TheCrypt.model.gameData.playedBetValue ? "normal" : "bad"
                }
                onButtonClick(t) {
                    t && o.TheCryptSoundManager.playSound(s.TheCryptSoundConfig.CONTINUE_BUTTON);
                    const e = new n.TimelineLite;
                    e.add((() => {
                        a.TheCrypt.keypadPlugin.hide(), a.TheCrypt.collectors.hide(), this._button.enable(!1), this._clickCallback(), this._clickCallback = () => { }
                    })), t ? e.add([a.TheCrypt.gameViewContainer.removeDimmer(), () => {
                        n.TweenLite.to(this, .2, {
                            alpha: 0
                        }), n.TweenLite.to([this._button], .2, {
                            alpha: 0
                        })
                    }]) : e.add((() => {
                        this.alpha = 0, this._button.alpha = 0
                    })), e.add((() => {
                        this.visible = !1, this._spineContainer.removeChildren()
                    }))
                }
                onResize() {
                    this._button.position.set(360, Math.max(530, c.NolimitApplication.screenBounds.bottom - 180))
                }
                init() {
                    this._spineContainer = new PIXI.Sprite, this.addChild(this._spineContainer), this._spineContainer.position.set(360, 360), this._button = new r.ContinueButton, this._button.addClickCallback((() => this.onButtonClick(!0))), this._button.position.set(360, 530), this._button.pivot.set(.5 * this._button.width, 0), this._button.enable(!1), this._button.alpha = 0, this._spinsPlayedText = new PIXI.Text("x", this._spinsPlayedTextStyle), this._spinsPlayedText.visible = !1, this._spinsPlayedText.anchor.set(.5), this._spinsPlayedText.position.set(360, 500), this.addChild(this._spinsPlayedText), this._spinsPlayedNr = new d.BitmapText("22", {
                        fontName: h.TheCryptGameAssets.BITMAP_FONT_FS_SPINS,
                        fontSize: 40
                    }), this._spinsPlayedNr.visible = !1, this._spinsPlayedNr.letterSpacing = 10, this.addChild(this._spinsPlayedNr), this.addChild(this._button), this._countUp = new l.BasicBitmapCountUp({
                        fontName: h.TheCryptGameAssets.BITMAP_FONT_WIN_COUNT_UP,
                        fontSize: 50,
                        tint: 16777215
                    }, 520, new PIXI.Point(.5, .5)), this._countUp.position.set(360, 305), this._countUp.stopAt(0), this.visible = !1, this.addChild(this._countUp), this.visible = !1
                }
                show(t, e = !1) {
                    var i;
                    const r = new n.TimelineLite,
                        l = a.TheCrypt.model.gameData.accumulatedRoundWin,
                        h = 0 === l,
                        c = a.TheCrypt.model.hasNoAvalancheWin ? 2 : 0;
                    if (this._spine && (this._spine.destroy(), this._spine = null), this._spine = new PIXI.spine.Spine(a.TheCrypt.assetLoader.getSpineAsset("FS_Outro")), this._spineContainer.addChild(this._spine), this._spine.skeleton.setSkinByName(this.getFSWinType()), this.onResize(), r.add((() => {
                        this._clickCallback = t
                    })), r.add((() => { }), c), this._spinsPlayedText.position.y = h ? 360 : 500, this._countUp.visible = !1, a.TheCrypt.model.gameData && a.TheCrypt.model.gameData.brokeTheBank) this.onButtonClick(!1);
                    else {
                        const t = (new n.TimelineLite).add((() => o.TheCryptSoundManager.playAmbientLoop()), .527);
                        if (r.add([t, a.TheCrypt.gameViewContainer.addDimmer(!0), new u.SpineTween(this._spine, 0, "start"), () => {
                            a.TheCrypt.keypadPlugin.hide(), this._spinsPlayedText.text = a.TheCrypt.apiPlugin.translations.translate("Spins played"), this._spinsPlayedNr.text = `${a.TheCrypt.model.gameData.numberOfFreespinsPlayed}`, this._spinsPlayedNr.position.set(360 - .5 * this._spinsPlayedNr.width, h ? 289 : 429), this.visible = !0, this.alpha = 1, this._spinsPlayedText.visible = !0, this._spinsPlayedNr.visible = !0, o.TheCryptSoundManager.playSound(s.TheCryptSoundConfig.FREESPIN_OUTRO, 0)
                        }], c), r.add([n.TweenLite.to(this._spinsPlayedNr, .1, {
                            alpha: 1
                        }), n.TweenLite.to(this._spinsPlayedText, .1, {
                            alpha: 1
                        })]), !h) {
                            const t = a.TheCrypt.apiPlugin.freeBets.hasFreeBets() ? a.TheCrypt.apiPlugin.freeBets.getBet() : a.TheCrypt.apiPlugin.betLevel.getLevel(),
                                e = (null === (i = a.TheCrypt.model.gameData) || void 0 === i ? void 0 : i.playedBetValue) || parseFloat(t),
                                s = f.TheCryptWinConfig.WIN_RATIOS.normalWin[1].ratio * e,
                                h = f.TheCryptWinConfig.WIN_RATIOS.normalWin[2].ratio * e,
                                u = l <= s ? e === l ? "Small" : "Tiny" : l === h ? "Medium" : "Large",
                                c = !(p.TheCryptHelper.isWinBelowStake() || "Tiny" === u);
                            r.add((() => {
                                this._countUp.stopAt(0), this._countUp.scale.set(.5, .5), this._countUp.alpha = 0, this._countUp.visible = !0
                            })), r.add([() => {
                                c && o.TheCryptSoundManager.playSound("winCountup")
                            }, n.TweenLite.to(this._countUp, .1, {
                                alpha: 1
                            }), n.TweenLite.to(this._countUp.scale, .1, {
                                x: 1,
                                y: 1,
                                ease: "sine.in"
                            }), this._countUp.getCountAnimation(0, l, c ? 1.5 : 0)]), c && r.add((() => {
                                o.TheCryptSoundManager.stopSoundEffect("winCountup"), o.TheCryptSoundManager.playSound(`win${u}`)
                            }))
                        }
                        r.add([n.TweenLite.to(this._button, .4, {
                            alpha: 1
                        })]), r.add([() => {
                            this._button.enable(!0)
                        }])
                    }
                    return r
                }
            }
            e.TheCryptFreespinOutro = g
        },
        2558: (t, e) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptFullScreenDimmer = void 0;
            class i extends PIXI.Container {
                constructor() {
                    super(), this.name = "TheCryptFullScreenDimmer"
                }
                onResize() { }
            }
            e.TheCryptFullScreenDimmer = i
        },
        2303: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptGameView = void 0;
            const n = i(6358),
                r = i(2092),
                o = i(7141),
                s = i(6358),
                a = i(4514);
            class l extends PIXI.Container {
                constructor() {
                    super(), this.name = "GameView", this.init()
                }
                creatDimmer() {
                    this._dimmer = new PIXI.Sprite(PIXI.Texture.WHITE), this._dimmer.name = "dimmer", this._dimmer.tint = 0, this._dimmer.alpha = .7, this._dimmer.visible = !1
                }
                init() {
                    this.position.set(0, 0), this.creatDimmer()
                }
                onWildNudge() {
                    r.AnimationEffects.Shake({
                        obj: this,
                        duration: 1,
                        hertz: 120,
                        x: 1,
                        y: 1,
                        Intensity: 5,
                        positionCb: () => new PIXI.Point(0, 0),
                        ease: n.Power3.easeOut,
                        reverseEase: !0
                    })
                }
                onNearWin() {
                    r.AnimationEffects.Shake({
                        obj: this,
                        duration: 1,
                        hertz: 160,
                        x: 1,
                        y: 1,
                        Intensity: 4,
                        positionCb: () => new PIXI.Point(0, 0),
                        ease: n.Power3.easeOut,
                        reverseEase: !0
                    })
                }
                onResize() {
                    o.TheCrypt.collectors.onResize(), o.TheCrypt.background.onResize(), this._dimmer.visible && this.resetDimmer()
                }
                resetDimmer() {
                    const t = a.NolimitApplication.screenBounds;
                    this._dimmer.width = t.width, this._dimmer.height = t.height, this._dimmer.position.x = t.left, this._dimmer.position.y = t.top
                }
                addDimmer(t = !1, e = .2) {
                    return (new s.TimelineLite).add((() => {
                        t ? o.TheCrypt.fullScreenDimmer.addChild(this._dimmer) : o.TheCrypt.emptyLayerBelowCollector.addChild(this._dimmer), this.resetDimmer(), this._dimmer.alpha = 0, this._dimmer.visible = !0
                    })).add(s.TweenLite.to(this._dimmer, e, {
                        alpha: .7
                    }))
                }
                removeDimmer() {
                    return (new s.TimelineLite).to(this._dimmer, .2, {
                        alpha: 0
                    }).add((() => {
                        this._dimmer.parent && this._dimmer.parent.removeChild(this._dimmer), this._dimmer.visible = !1
                    }))
                }
            }
            e.TheCryptGameView = l
        },
        4283: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptInitialWinView = void 0;
            const n = i(7141),
                r = i(6358),
                o = i(9529),
                s = i(7162),
                a = i(760),
                l = i(3832);
            class h extends PIXI.Container {
                constructor() {
                    super(), this._maxWinNumberWidth = 130, this.name = "TheCryptInitialWinView"
                }
                calculateAboveLevel01LingerTime() {
                    const t = n.TheCrypt.model.gameData.betWayWins;
                    for (let e = 0; e < t.length; e++) t[e].multipliedAmount, h.WIN_ABOVE_LEVEL_01, n.TheCrypt.model.gameData.playedBetValue;
                    return .5
                }
                getStartPosition(t, e) {
                    const i = n.TheCrypt.realArea.getSymbol(t),
                        r = t[0],
                        o = t[1];
                    return [a.TheCryptGameConfig.reelPositions[r].x - (5 === r && e > a.TheCryptGameConfig.symbolWidth ? 4 : 0), i.position.y + 50, 0 === o ? 10 : 100]
                }
                playWinNumbers(t, e, i) {
                    let a = n.TheCrypt.apiPlugin.currency.formatValue(o.MathHelper.roundToDecimals(t.amount, 2)),
                        h = t.numberOfCombinations;
                    t.multiplier > 1 && (a += ` x ${t.multiplier}`), this.calculateAboveLevel01LingerTime();
                    const u = new PIXI.Sprite,
                        c = new PIXI.BitmapText(a, {
                            fontName: s.TheCryptGameAssets.BITMAP_FONT_WIN_COUNT_UP,
                            fontSize: 20
                        }),
                        d = new l.BitmapText(h.toString(), {
                            fontName: s.TheCryptGameAssets.BITMAP_FONT_WIN_WAYS,
                            fontSize: 24,
                            tint: 16777215
                        }),
                        p = new PIXI.Sprite(n.TheCrypt.assetLoader.getTextures("Way" + (h > 1 ? "s" : ""))[0]);
                    if (c.anchor = new PIXI.Point(0, 1), c.position.set(0, 0), d.anchor = new PIXI.Point(0, 0), p.scale.set(.4), p.anchor = new PIXI.Point(0, 0), d.letterSpacing = -12, u.alpha = 0, u.visible = !1, u.addChild(c, p, d), u.anchor.set(1, .1), this.addChild(u), c.updateTransform(), c.width > this._maxWinNumberWidth) {
                        const t = o.MathHelper.roundToDecimals(this._maxWinNumberWidth / c.width, 2);
                        c.scale.set(t)
                    }
                    const f = .5 * (c.width - d.width - p.width);
                    d.position.set(f, 34), p.position.set(f + d.width, 34);
                    const g = this.getStartPosition(i, c.width);
                    u.position.set(g[0], g[1]);
                    const m = r.gsap.timeline();
                    return m.add([() => {
                        u.visible = !0
                    }, r.gsap.to(u, {
                        duration: 0,
                        alpha: 1
                    }), r.gsap.to(u, {
                        duration: .8,
                        y: g[1] - g[2]
                    })], 0), m.add(r.gsap.to(u, {
                        duration: .4,
                        alpha: 0,
                        delay: 0
                    })), m.add((() => {
                        c.parent && this.removeChild(c), c.destroy(), d.parent && this.removeChild(d), d.destroy(), p.destroy(), u.destroy()
                    })), e && m.timeScale(4), m
                }
                findLastNoWildSymbolPosition(t) {
                    for (let e = 5; e > -1; e--)
                        for (let i = 0; i < 6; i++) {
                            if (!t.reelWinPositions[e][i]) continue;
                            const r = n.TheCrypt.realArea.getSymbol([e, i]);
                            if (r && r.visible && "W" !== r.name && "Y" !== r.name && "FW" !== r.name) return [e, i]
                        }
                    return [0, 0]
                }
            }
            h.DELAY_BETWEEN_COMBO_WINS = 0, h.WIN_ABOVE_LEVEL_01 = 50, e.TheCryptInitialWinView = h
        },
        7345: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptReelAnticipation = void 0;
            const n = i(7141);
            var r = PIXI.spine.Spine;
            const o = i(6358),
                s = i(760),
                a = i(2185),
                l = i(6364),
                h = i(5160);
            class u extends PIXI.Container {
                constructor() {
                    super(), this.name = "ReelAnticipation", this._isPlayingAnticipation = !1, this._playingOnReel = l.ArrayHelper.initArrayWithValues(6, (() => !1)), this.init()
                }
                init() {
                    this._animations = l.ArrayHelper.initArrayWithValues(6, (t => {
                        const e = new r(n.TheCrypt.assetLoader.getSpineAsset("s_anticipation"));
                        return e.name = "ReelAnticipation", e.alpha = 0, e.visible = !1, e.position.set(s.TheCryptGameConfig.reelPositions[t].x, 4), e
                    })), this.position.set(s.TheCryptGameConfig.reelAreaPos.x, s.TheCryptGameConfig.reelAreaPos.y)
                }
                fadeOut(t) {
                    this._isPlayingAnticipation && (new o.TimelineLite).add(o.TweenLite.to(this._animations[t], .3, {
                        alpha: 0
                    })).add((() => {
                        this._animations[t].visible = !1, this.update(t + 1)
                    }))
                }
                fadeOutAnticipationSound() {
                    this._isPlayingAnticipation && a.TheCryptSoundManager.fadeSoundEffect("scatterAnticipation", 1, 0, 500)
                }
                reset() {
                    this._isPlayingAnticipation && (n.TheCrypt.reelFrame.resetEyeAnimation(), n.TheCrypt.model.freespinTriggeredThisSpin || n.TheCrypt.reelFrame.onAnticipationFail(), a.TheCryptSoundManager.stopSoundEffect("scatterAnticipation"), a.TheCryptSoundManager.playSound("scatterAnticipationEnd"), this._isPlayingAnticipation = !1, this._playingOnReel = l.ArrayHelper.initArrayWithValues(6, (() => !1)), this._animations.forEach((t => {
                        h.TheCryptHelper.resetSpineItem(t), t.alpha = 0, t.visible = !1
                    })))
                }
                update(t) {
                    if (h.TheCryptHelper.isFreeSpin(n.TheCrypt.model.mode)) return;
                    const e = n.TheCrypt.model.isNextRespin;
                    6 === t || h.TheCryptHelper.isRespin(n.TheCrypt.model.mode) && !n.TheCrypt.realArea.needFillUpReels[t] ? e || this.reset() : this._animations[t].visible || n.TheCrypt.model.nearWinReels[t] && (this._isPlayingAnticipation && 1 !== t || a.TheCryptSoundManager.playSound("scatterAnticipation"), this._animations[t].visible = !0, this._isPlayingAnticipation = !0, n.TheCrypt.reelFrame.updateEyeAnimation(t), this.addChild(this._animations[t]), this._animations[t].state.setAnimation(0, "s_anticipation", !0), (new o.TimelineLite).add(o.TweenLite.to(this._animations[t], .5, {
                        alpha: 1
                    })))
                }
            }
            e.TheCryptReelAnticipation = u
        },
        749: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptReelBackground = void 0;
            var n = PIXI.spine.Spine;
            const r = i(6358),
                o = i(7141),
                s = i(5160),
                a = i(7732),
                l = i(2366);
            class h extends PIXI.Container {
                constructor() {
                    super(), this.name = "ReelBackground", this.init()
                }
                init() {
                    const t = new n(o.TheCrypt.assetLoader.getSpineAsset("reelBg"));
                    t.name = "reelFrame", this.position.set(356, 380), this.addChild(t), t.state.setAnimation(0, "base", !0), this._reelFrame = t, this._logoAnimation = s.TheCryptHelper.createSprite("frame_inneglow", 0, 0), this.addChild(this._logoAnimation), this._logoAnimation.blendMode = PIXI.BLEND_MODES.SCREEN, this._logoAnimation.alpha = .6, this._logoAnimation.anchor.set(.5, .5)
                }
                onSpin() {
                    (new r.TimelineLite).to(this._logoAnimation, .5, {
                        alpha: 0
                    }).to(this._logoAnimation, .5, {
                        alpha: .6
                    }), new a.SpineTween(this._reelFrame, 1, "spin")
                }
                setMode(t) {
                    this._reelFrame.skeleton.setSkinByName(s.TheCryptHelper.isNormal(t) ? "main" : "FS")
                }
                onWinToggle() {
                    const t = o.TheCrypt.model.avalancheWinRatio,
                        e = l.TheCryptWinConfig.WIN_RATIOS.bigWin;
                    t < e[0].ratio || (t >= e[2].ratio ? new a.SpineTween(this._reelFrame, 1, "initial_bigwin_3") : t >= e[1].ratio ? new a.SpineTween(this._reelFrame, 1, "initial_bigwin_2") : new a.SpineTween(this._reelFrame, 1, "initial_bigwin_1"))
                }
            }
            e.TheCryptReelBackground = h
        },
        3465: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptReelFrame = void 0;
            const n = i(8063),
                r = i(7141),
                o = i(6358);
            var s = PIXI.spine.Spine;
            const a = i(5160),
                l = i(7732),
                h = i(9529),
                u = i(2366),
                c = i(2185);
            class d extends PIXI.Container {
                constructor() {
                    super(), this._isIdling = !1, this._idleAnimationPlaying = !1, this._startDelay = 15, this._intervalRange = [10, 30], this._isIdling = !1, this.name = "ReelFrame", this.init()
                }
                init() {
                    this.position.set(360, 360);
                    const t = new s(r.TheCrypt.assetLoader.getSpineAsset("reelFrame"));
                    t.name = "reelFrame", t.position.set(-4, 20), this.addChild(t), this._reelFrame = t, this._reelFrame.state.setAnimation(0, "base", !0);
                    const e = new s(r.TheCrypt.assetLoader.getSpineAsset("eyeAnimation"));
                    e.name = "eye", e.position.set(0, -313), this.addChild(e), this._eye = e, this._eye.state.setAnimation(0, "base", !0), this._ways = new n.Ways, this._ways.position.set(-70, -315), this.addChild(this._ways)
                }
                reset() {
                    this._ways.reset()
                }
                updateWays(t) {
                    return this._ways.updateValue(t)
                }
                setMode(t) {
                    this._reelFrame.skeleton.setSkinByName(a.TheCryptHelper.isNormal(t) ? "main" : "FS")
                }
                onThirdScatterLand() {
                    new l.SpineTween(this._reelFrame, 1, "scatter_trigger"), new l.SpineTween(this._eye, 1, "scatter_trigger")
                }
                onWildExpand() {
                    return (new o.TimelineLite).add(new l.SpineTween(this._eye, 1, "wild_expand")).add((() => this.resetEyeAnimation()))
                }
                onAnticipationFail() {
                    (new o.TimelineLite).add(new l.SpineTween(this._eye, 1, `no_win_${Math.ceil(3 * Math.random())}`)).add((() => this.resetEyeAnimation()))
                }
                onWin() {
                    (new o.TimelineLite).add(new l.SpineTween(this._eye, 1, "win")).add((() => this.resetEyeAnimation()))
                }
                playIdleAnimation() {
                    this._isIdling && (new l.SpineTween(this._eye, 0, "sleep_start"), this._idleAnimationPlaying = !0, this._idleTl = new o.TimelineLite, this._idleTl.add((() => this.playIdleAnimation()), h.MathHelper.randomNumberInRange(this._intervalRange[0], this._intervalRange[1], 2)))
                }
                startIdle() {
                    this._isIdling || (this._isIdling = !0, this._idleTl = new o.TimelineLite, this._idleTl.add((() => {
                        this.playIdleAnimation()
                    }), this._startDelay))
                }
                onSymbolsDropOut() {
                    new l.SpineTween(this._reelFrame, 1, "spin")
                }
                stopIdle() {
                    this._isIdling = !1, this._idleTl && (this._idleTl.pause(), this._idleTl.kill()), this._idleTl = null, this._idleAnimationPlaying && (this._idleAnimationPlaying = !1, (new o.TimelineLite).add([new l.SpineTween(this._eye, 0, "wake_up")]).add((() => {
                        this._eye.state.setAnimation(0, "base", !0).mixDuration = .2
                    })))
                }
                onWinToggle() {
                    const t = r.TheCrypt.model.avalancheWinRatio,
                        e = u.TheCryptWinConfig.WIN_RATIOS.bigWin;
                    t < e[0].ratio || (c.TheCryptSoundManager.playSound("bigwinInit"), t >= e[2].ratio ? new l.SpineTween(this._reelFrame, 1, "initial_bigwin_3") : t >= e[1].ratio ? new l.SpineTween(this._reelFrame, 1, "initial_bigwin_2") : new l.SpineTween(this._reelFrame, 1, "initial_bigwin_1"))
                }
                updateEyeAnimation(t) {
                    this._eye.state.setAnimation(1, `anticipation_${t + 1}`, !0).mixDuration = .2
                }
                resetEyeAnimation() {
                    this._eye.state.setEmptyAnimation(1, 0).mixDuration = .2
                }
            }
            e.TheCryptReelFrame = d
        },
        9621: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptSymbolAnimation = void 0;
            const n = i(760);
            class r extends PIXI.Container {
                constructor() {
                    super(), this.name = "SymbolAnimation", this.position = n.TheCryptGameConfig.reelAreaPos
                }
            }
            e.TheCryptSymbolAnimation = r
        },
        7087: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptSymbolHighlighter = void 0;
            const n = i(6358),
                r = i(7141);
            class o extends PIXI.Container {
                constructor() {
                    super(), this.name = "TheCryptSymbolHighlighter"
                }
                static playXWayPotentialWinHighlighter() {
                    const t = new n.TimelineLite;
                    if (0 === r.TheCrypt.model.mysterySymbolPotentialWin.length) return t;
                    let e = .2 * r.TheCrypt.model.mysterySymbolPotentialWin.length + .3,
                        i = 0;
                    return r.TheCrypt.model.mysterySymbolPotentialWin.forEach(((n, o) => {
                        n.forEach((n => {
                            if (!r.TheCrypt.model.wildOnReel[n[0]]) {
                                const o = r.TheCrypt.realArea.getSymbol([n[0], n[1]]);
                                t.add(o.playWinHighlighter(e), i)
                            }
                        })), i += .2, e -= .2
                    })), t
                }
            }
            e.TheCryptSymbolHighlighter = o
        },
        160: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptTotalWinView = void 0;
            const n = i(6358),
                r = i(7429),
                o = i(7141),
                s = i(7162),
                a = i(5160),
                l = i(3832),
                h = i(2185);
            class u extends PIXI.Container {
                constructor() {
                    super(), this.name = "TotalWin", this.init()
                }
                show(t) {
                    const e = n.gsap.timeline(),
                        i = o.TheCrypt.model.gameData.waysWonTotalRound,
                        r = t.type;
                    let u = a.TheCryptHelper.getToggleType();
                    const c = new l.BitmapText(i.toString(), {
                        fontName: s.TheCryptGameAssets.BITMAP_FONT_WIN_WAYS,
                        fontSize: 40,
                        tint: 16777215
                    });
                    c.anchor = new PIXI.Point(0, 1);
                    const d = new PIXI.spine.Spine(o.TheCrypt.assetLoader.getSpineAsset("total_win"));
                    d.position.set(360, 360), d.name = "totalWin" + u, d.visible = !1;
                    const p = new PIXI.Sprite(o.TheCrypt.assetLoader.getTextures("Way" + (i > 1 ? "s" : ""))[0]);
                    p.anchor = new PIXI.Point(0, .6), c.letterSpacing = -12;
                    const f = 360 - .5 * (c.width + p.width);
                    return c.position.set(f, 484), p.position.set(f + c.width, 472), this.addChild(d, c, p, this._countUp), e.add((() => {
                        this._countUp.stopAt(0), this._countUp.scale.set(.5, .5), this._countUp.alpha = 1, this.alpha = 0, this.visible = !0
                    })), e.add([n.TweenLite.to(this, .1, {
                        alpha: 1
                    }), n.TweenLite.to(this._countUp.scale, .1, {
                        x: 1,
                        y: 1,
                        ease: "sine.in"
                    }), this._countUp.getCountAnimation(0, o.TheCrypt.model.gameData.totalSpinWinnings, t.duration - .2)]), e.add((() => {
                        0 === u.length && o.TheCrypt.reelFrame.onWin(), u = (u.length > 0 ? "_" : "") + u, d.visible = !0, d.state.setAnimation(0, `win${u}`, !1), h.TheCryptSoundManager.playSound(`win${r.charAt(0).toUpperCase() + r.slice(1)}`)
                    }), t.duration - .2), e.add([() => {
                        o.TheCrypt.keypadPlugin.setWin(o.TheCrypt.model.gameData.accumulatedRoundWin, !0, a.TheCryptHelper.isWinBelowStake())
                    }, n.TweenLite.to(this, 1.4, {
                        alpha: 0,
                        delay: .6
                    })]), e.add((() => {
                        this.removeChild(d), this.removeChild(c), this.removeChild(p), d.destroy(), c.destroy(), p.destroy(), this.visible = !1
                    })), e
                }
                init() {
                    this._countUp = new r.BasicBitmapCountUp({
                        fontName: s.TheCryptGameAssets.BITMAP_FONT_WIN_COUNT_UP,
                        fontSize: 50,
                        tint: 16777215
                    }, 480, new PIXI.Point(.5, .5)), this._countUp.position.set(360, 360), this._countUp.stopAt(0), this.visible = !1, this.addChild(this._countUp)
                }
            }
            e.TheCryptTotalWinView = u
        },
        8869: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.TheCryptWinCapView = void 0;
            const n = i(6358),
                r = i(7429),
                o = i(7162),
                s = i(7141),
                a = i(5160),
                l = i(2185),
                h = i(3554),
                u = i(8592),
                c = i(7732),
                d = i(4514);
            class p extends PIXI.Container {
                init() {
                    this._spineContainer = new PIXI.Sprite, this.addChild(this._spineContainer), this._spineContainer.position.set(360, 360), this._button = new u.ContinueButton, this._button.addClickCallback((() => this.onButtonClick(!0))), this._button.pivot.set(.5 * this._button.width, 0), this._button.enable(!1), this._button.alpha = 0, this._countUp = new r.BasicBitmapCountUp({
                        fontName: o.TheCryptGameAssets.BITMAP_FONT_WIN_COUNT_UP,
                        fontSize: 160,
                        tint: 16777215
                    }, 520, new PIXI.Point(.5, .5)), this._countUp.position.set(360, 578), this._countUp.stopAt(0), this.visible = !1, this.addChild(this._countUp), this.visible = !1
                }
                constructor() {
                    super(), this.name = "WinCapView", this.init()
                }
                onButtonClick(t) {
                    l.TheCryptSoundManager.playSound("capWinEnds");
                    const e = new n.TimelineLite;
                    e.add((() => {
                        this._idleTimeLine && (this._idleTimeLine.isActive() && (this._idleTimeLine.pause(), this._idleTimeLine.kill()), this._idleTimeLine = null), this._button.enable(!1)
                    })), e.add([() => {
                        s.TheCrypt.gameViewContainer.removeDimmer(), n.TweenLite.to(this, .2, {
                            alpha: 0
                        }), n.TweenLite.to([this._button, this._countUp], .2, {
                            alpha: 0
                        }), this._clickCallback(), this._clickCallback = () => { }
                    }]), e.add((() => {
                        l.TheCryptSoundManager.playAmbientLoop(1e3), l.TheCryptSoundManager.stopSoundEffect(h.TheCryptSoundConfig.WIN_CAP_MUSIC), this.visible = !1, this._spineContainer.removeChildren(), this._spines.destroy(), this._spines = null
                    }))
                }
                onResize() {
                    this.visible && (d.NolimitApplication.isLandscape ? this._button.position.set(360, 588) : this._button.position.set(360, Math.max(530, d.NolimitApplication.screenBounds.bottom - 210)))
                }
                show(t, e = !1) {
                    const i = new n.TimelineLite,
                        r = s.TheCrypt.model.gameData.accumulatedRoundWin;
                    return i.add((() => {
                        s.TheCrypt.xBetController.buttonsVisible = !1, this._clickCallback = t
                    })), this._spines && (this._spines.destroy(), this._spines = null), this._spines = new PIXI.spine.Spine(s.TheCrypt.assetLoader.getSpineAsset("winCap")), i.add((() => {
                        s.TheCrypt.keypadPlugin.hide(), this._countUp.stopAt(0), this._countUp.scale.set(.5, .5), this._countUp.position.set(360, 578), this._countUp.alpha = 1, this.visible = !0, this.onResize(), this.alpha = 1, l.TheCryptSoundManager.stopAmbientLoop(), s.TheCrypt.gameViewContainer.addDimmer(!0), this._spineContainer.addChild(this._spines), this._spines.state.setAnimation(0, "eff_loop", !0)
                    }), 0), i.add(new c.SpineTween(this._spines, 1, "A"), 0), i.add([() => {
                        l.TheCryptSoundManager.playSound(h.TheCryptSoundConfig.WIN_CAP_START)
                    }, n.TweenLite.to(this._countUp, .1, {
                        alpha: 1
                    }), n.TweenLite.to(this._countUp.scale, .1, {
                        x: 1,
                        y: 1,
                        ease: "sine.in"
                    }), this._countUp.getCountAnimation(0, r, 6.625)], 0), i.add([() => {
                        this.addChild(this._button), l.TheCryptSoundManager.stopSoundEffect(h.TheCryptSoundConfig.WIN_CAP_START), l.TheCryptSoundManager.playWinCapMusic(), this._spines.state.setAnimation(2, "B", !0)
                    }, n.TweenLite.to(this._button, .6, {
                        alpha: 1
                    }), n.TweenLite.to(this._countUp, .6, {
                        alpha: 0
                    })], 8.225), i.add([() => {
                        this._button.enable(!0), s.TheCrypt.keypadPlugin.setWin(s.TheCrypt.model.gameData.accumulatedRoundWin, !0, a.TheCryptHelper.isWinBelowStake()), s.TheCrypt.collectors.hide()
                    }]), i
                }
            }
            e.TheCryptWinCapView = p
        },
        8882: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.XBetController = e.XBetButton = void 0;
            const n = i(2327),
                r = i(1077),
                o = i(6358),
                s = i(1115),
                a = i(4514),
                l = i(1487),
                h = i(9529),
                u = i(1653),
                c = i(5383),
                d = i(7141),
                p = i(3554),
                f = i(2185);
            class g extends r.GuiButton {
                constructor() {
                    super("xBetButton"), this._state = new PIXI.Sprite(d.TheCrypt.assetLoader.getTextures("xbetbutton/xbet")[0]), this._state.anchor.set(.5), this.addChild(this._state), this.hitArea = new PIXI.Rectangle(-50, -38, 100, 70)
                }
                enable(t) {
                    super.enable(t)
                }
                setState(t) {
                    this._state.tint = 1 === t ? 16760644 : 16777215
                }
            }
            e.XBetButton = g;
            class m extends PIXI.Container {
                set buttonsVisible(t) {
                    this._featureAllowed && (this._isFreeBet && (t = !1), this._buttonsVisible = t, this._button.visible = this._buttonsVisible)
                }
                get buttonsVisible() {
                    return this._buttonsVisible
                }
                set featureEnabled(t) {
                    this._featureAllowed && (s.SlotGame.apiPlugin.isReplay && (t = !1), this._featureEnabled = t, this._button.enable(this._featureEnabled), o.gsap.to(this._button, {
                        duration: .5,
                        alpha: t ? 1 : .5
                    }), this._selected && this._buttonsVisible ? this._button.setState(1) : this._buttonsVisible && this._button.setState(0))
                }
                get featureEnabled() {
                    return this._featureEnabled
                }
                set selected(t) {
                    this._featureAllowed && (this._selected = t, s.SlotGame.apiPlugin.betHandler.setBoost(this._selected ? this._boostedData : null), this.featureEnabled = this._featureEnabled, this._isIdle && this.startIdle())
                }
                get selected() {
                    return this._selected
                }
                constructor() {
                    var t;
                    if (super(), this._bubbleCounter = 0, this._buttonsVisible = !1, this._featureEnabled = !1, this._featureAllowed = s.SlotGame.apiPlugin.gameClientConfiguration.boostedBetAllowed, !this._featureAllowed) return;
                    this._button = new g, this._button.y = 15, this._button.addClickCallback((() => {
                        this.selected = !this.selected, f.TheCryptSoundManager.playSound(this.selected ? p.TheCryptSoundConfig.XBET_ON : p.TheCryptSoundConfig.XBET_OFF)
                    })), this.addChild(this._button), null === (t = d.TheCrypt.xBetController) || void 0 === t || t.addChild(this), this._attention = new l.TimelineSprite(d.TheCrypt.assetLoader.getTextures("X_Bet_Attention/X_Bet_Attention_")), this._attention.anchor.set(.5), this._attention.blendMode = PIXI.BLEND_MODES.ADD, this._attention.position.set(this._button.x, this._button.y), this._attention.hide(), this.addChild(this._attention), this._bubble = new PIXI.Sprite(d.TheCrypt.assetLoader.getTextures("xbetbutton/X_Bet_Bubble")[0]), this._bubble.anchor.set(.5, .4), this._bubble.position.set(-110, -170), this.addChild(this._bubble);
                    const e = new PIXI.Text(d.TheCrypt.apiPlugin.translations.translate("5 times more likely to trigger Resurrection Spins."), new PIXI.TextStyle({
                        align: "center",
                        breakWords: !0,
                        fill: "#ffffff",
                        fontFamily: u.OpenSans.FAMILY,
                        fontSize: 20,
                        fontStyle: c.FontStyle.NORMAL,
                        fontWeight: c.FontWeight.LIGHT,
                        wordWrap: !0,
                        wordWrapWidth: 290
                    }));
                    e.anchor.set(.5, 0);
                    let i = e.height;
                    for (; i > 120;) e.style.fontSize--, i = e.height;
                    e.y = .5 * -i, this._bubble.addChild(e), this._bubble.alpha = 0;
                    const n = s.SlotGame.apiPlugin.bonusFeatures.getFeatureDataByName(d.TheCrypt.boostedName);
                    n && (this._boostedData = {
                        featureName: d.TheCrypt.boostedName,
                        price: n.price
                    }), s.SlotGame.apiPlugin.freeBets.events.on(s.SlotGame.apiPlugin.freeBets.FREE_BETS_START, (() => this.onFreeBets(!0))), s.SlotGame.apiPlugin.freeBets.events.on(s.SlotGame.apiPlugin.freeBets.FREE_BETS_END, (() => this.onFreeBets(!1))), this.visible = !1
                }
                onResize() {
                    a.NolimitApplication.isLandscape ? this.position.set(360 + .5 * a.NolimitApplication.screenBounds.width - 110, 320) : this.position.set(530, 360 + .5 * a.NolimitApplication.screenBounds.height - 244)
                }
                onFreeBets(t) {
                    t ? (this._isFreeBet = !0, this.selected = !1, this.buttonsVisible = !1, this.featureEnabled = !1) : (this._isFreeBet = !1, this.buttonsVisible = !0, this.featureEnabled = !0)
                }
                start() {
                    if (!this._featureAllowed) return;
                    s.SlotGame.apiPlugin.freeBets.hasFreeBets() && (this._isFreeBet = !0), this.visible = !0, this.onResize();
                    const t = d.TheCrypt.model.data.nextMode,
                        e = d.TheCrypt.model.isRestore && d.TheCrypt.model.isNormal;
                    this.buttonsVisible = t === n.GameMode.NORMAL || e && !d.TheCrypt.model.freespinTriggeredThisSpin, this.featureEnabled = t === n.GameMode.NORMAL, this.selected = d.TheCrypt.model.buyFeatureName === d.TheCrypt.boostedName
                }
                startIdle(t = !1) {
                    this._featureAllowed && this._buttonsVisible && this._featureEnabled && (this._isIdle = !0, this._selected ? this.stopAllIdleAnimations() : this._idleAttentionTl && this._idleAttentionTl.isActive() || this.playIdleAnimation(t))
                }
                playIdleAnimation(t) {
                    this._isIdle && this._buttonsVisible && this._featureAllowed && this._featureEnabled && !this._selected && (t && (this._attention.getAnimationAutoShowHide(), 0 === this._bubbleCounter && (this._bubbleTl = o.gsap.timeline(), this._bubbleTl.add(o.gsap.to(this._bubble, {
                        alpha: 1,
                        duration: 1
                    })), this._bubbleTl.add(o.gsap.to(this._bubble, {
                        alpha: 0,
                        duration: .8
                    }), 8), this._bubbleCounter = 5), this._bubbleCounter--), this._idleAttentionTl = o.gsap.timeline(), this._idleAttentionTl.add((() => this.playIdleAnimation(!0)), h.MathHelper.randomNumberInRange(15, 30, 2)))
                }
                stopIdle() {
                    this._featureAllowed && (this._isIdle = !1, this.stopAllIdleAnimations())
                }
                stopAllIdleAnimations() {
                    this._idleAttentionTl && (this._idleAttentionTl.pause(), this._idleAttentionTl.kill()), this._idleAttentionTl = null, this._attention.hide(), this._bubbleTl && (this._bubbleTl.pause(), this._bubbleTl.kill()), this._bubbleTl = null, this._bubble.alpha = 0
                }
            }
            e.XBetController = m
        },
        6368: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.M1Collector = void 0;
            const n = i(7459),
                r = i(7141),
                o = i(7732),
                s = i(6358),
                a = i(2185);
            class l extends n.SpriteCollector {
                constructor(t, e) {
                    super(t, e)
                }
                set overlayText(t) {
                    if (this._overlay.text = `X${t}`, this._overlay.position.x = .5 * -this._overlay.width, r.TheCrypt.model.data.m1NextMultiplier < 0) throw Error;
                    this._overlay.letterSpacing = 1 === t ? 8 : 2, this._overlay.visible = !0, this._overlay.alpha = 1, this.addChild(this._overlay)
                }
                resetProgress() { }
                upgrade() {
                    return this._step++, (new s.TimelineLite).add([new o.SpineTween(this._spine, 1, "upgrade"), () => {
                        a.TheCryptSoundManager.playSound("fsMultiCollect")
                    }])
                }
                show(t, e = !1) {
                    const i = super.show(t, e);
                    return this._step = 0, this.isActive = !0, e && !r.TheCrypt.model.isNormal && (this._step = r.TheCrypt.model.sideBarProgress[6 - this._id], this._step = Math.max(-1, this._step)), i.add([() => {
                        this.addChild(this._spine), this.overlayText = r.TheCrypt.model.data.m1NextMultiplier, this._spine.state.setAnimation(0, "base", !0)
                    }]), i
                }
                fullyCharged() {
                    return this.overlayText = r.TheCrypt.model.data.m1NextMultiplier, a.TheCryptSoundManager.playSound("fsMultiUp"), this.resetProgress(), new o.SpineTween(this._spine, 1, "upgrade")
                }
                get isFullyCharged() {
                    if (r.TheCrypt.model.data.m1NextMultiplier < 2) return !1;
                    const t = this._overlay.text;
                    if (!t) return !0;
                    const e = parseInt(t.slice(1));
                    return r.TheCrypt.model.data.m1NextMultiplier > e
                }
            }
            e.M1Collector = l
        },
        5346: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.MSymbolCollector = void 0;
            const n = i(7141),
                r = i(7459),
                o = i(7732),
                s = i(6358);
            class a extends r.SpriteCollector {
                constructor(t, e) {
                    super(t, e)
                }
                hide() {
                    this.alpha = 0
                }
                activate() {
                    return this.isActive = !0, this._step = Math.max(0, this._step), (new s.TimelineLite).add([new o.SpineTween(this._spine, 0, this._step.toString()), () => {
                        this.parent.addChild(this)
                    }])
                }
                show(t, e = !1) {
                    const i = super.show(t, e);
                    return this._isActive = !1, this._step = 0, this._spine.skeleton.setSkinByName(`M${this._id}`), i.add([() => {
                        this.addChild(this._spine)
                    }, new o.SpineTween(this._spine, 0, "popup")]), i.add((() => {
                        this._spine.state.setAnimation(0, "base", !0)
                    })), i
                }
                updateStatesOnRestore() {
                    const t = n.TheCrypt.model.data.dragonSideReel[0];
                    let e = "base";
                    this._step = n.TheCrypt.model.sideBarProgress[6 - this._id], this._step = Math.max(0, this._step), this._isActive = t > 4 * (6 - this.id) - 1, this._step < this._barNum && this._step > 0 && (e = "0"), this._isActive && (this._isActive = !(this._step === this._barNum), e = this._step === this._barNum ? "wild" : this._step.toString(), this.parent.addChild(this)), this._spine.state.setAnimation(0, e, !0)
                }
            }
            e.MSymbolCollector = a
        },
        7459: (t, e, i) => {
            "use strict";
            Object.defineProperty(e, "__esModule", {
                value: !0
            }), e.SpriteCollector = void 0;
            const n = i(760),
                r = i(7141),
                o = i(6358);
            var s = PIXI.spine.Spine;
            const a = i(7732),
                l = i(2185),
                h = i(3554),
                u = i(1295),
                c = i(3832);
            class d extends PIXI.Sprite {
                constructor(t, e) {
                    super(), this._isActive = !1, this._id = t, this.anchor.set(0, 0), this.name = `SpriteCollector-M${this._id}`, this._overlay = new c.BitmapText("", u.TheCryptFontConfig.M1_MULTIPLIER_STYLE), this._overlay.alpha = 0, this._overlay.position.set(0, 14.5), this._isActive = !1, this._step = -1, this._barNum = 1 === t ? n.TheCryptGameConfig.M1CollectorLevels : n.TheCryptGameConfig.MSymbolCollectorLevels, this.visible = !1, e.addChild(this)
                }
                destroySpine() {
                    this._spine && (this._spine.destroy(), this._spine = null)
                }
                reset() {
                    this._overlay.alpha = 0, this._isActive = !1, this._step = -1, this.visible = !1, this.destroySpine()
                }
                fullyCharged() {
                    return this.isActive = !1, this._step = 5, (new o.TimelineLite).add([new a.SpineTween(this._spine, 0, "wild"), () => {
                        l.TheCryptSoundManager.playSound(h.TheCryptSoundConfig.METER_TO_WILD)
                    }]).add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(0, "wild", !0)
                    }))
                }
                upgrade() {
                    this._step++, this._step, this._barNum;
                    const t = new o.TimelineLite;
                    return 0 !== this._step && 4 !== this._step && t.add([() => {
                        l.TheCryptSoundManager.playSound(h.TheCryptSoundConfig.METER_LIGHT)
                    }, new a.SpineTween(this._spine, 0, `${this._step}_add`)]), t.add((() => {
                        var t;
                        null === (t = this._spine) || void 0 === t || t.state.setAnimation(0, `${this._step}`, !0)
                    })), t
                }
                show(t, e = !1) {
                    const i = new o.TimelineLite;
                    return this.visible = !0, this._step = -1, this.destroySpine(), this._spine = new s(r.TheCrypt.assetLoader.getSpineAsset(t)), this._step = Math.max(-1, this._step), i
                }
                get isFullyCharged() {
                    return this._step === this._barNum && this._isActive
                }
                get topLevel() {
                    return this._barNum
                }
                set overlayText(t) { }
                set isActive(t) {
                    this._isActive = t
                }
                get isActive() {
                    return this._isActive
                }
                get id() {
                    return this._id
                }
                get overlay() {
                    return this._overlay
                }
                get progress() {
                    return this._step
                }
                get currentHeight() {
                    return this._isActive ? 136 : 80
                }
            }
            e.SpriteCollector = d
        },
        2511: function (t, e, i) {
            var n;
            t = i.nmd(t),
                function (r) {
                    e && e.nodeType, t && t.nodeType;
                    var o = "object" == typeof i.g && i.g;
                    o.global !== o && o.window !== o && o.self;
                    var s, a = 2147483647,
                        l = 36,
                        h = 26,
                        u = 38,
                        c = 700,
                        d = /^xn--/,
                        p = /[^\x20-\x7E]/,
                        f = /[\x2E\u3002\uFF0E\uFF61]/g,
                        g = {
                            overflow: "Overflow: input needs wider integers to process",
                            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                            "invalid-input": "Invalid input"
                        },
                        m = l - 1,
                        _ = Math.floor,
                        y = String.fromCharCode;

                    function S(t) {
                        throw new RangeError(g[t])
                    }

                    function v(t, e) {
                        for (var i = t.length, n = []; i--;) n[i] = e(t[i]);
                        return n
                    }

                    function b(t, e) {
                        var i = t.split("@"),
                            n = "";
                        return i.length > 1 && (n = i[0] + "@", t = i[1]), n + v((t = t.replace(f, ".")).split("."), e).join(".")
                    }

                    function T(t) {
                        for (var e, i, n = [], r = 0, o = t.length; r < o;)(e = t.charCodeAt(r++)) >= 55296 && e <= 56319 && r < o ? 56320 == (64512 & (i = t.charCodeAt(r++))) ? n.push(((1023 & e) << 10) + (1023 & i) + 65536) : (n.push(e), r--) : n.push(e);
                        return n
                    }

                    function P(t) {
                        return v(t, (function (t) {
                            var e = "";
                            return t > 65535 && (e += y((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e + y(t)
                        })).join("")
                    }

                    function A(t, e) {
                        return t + 22 + 75 * (t < 26) - ((0 != e) << 5)
                    }

                    function I(t, e, i) {
                        var n = 0;
                        for (t = i ? _(t / c) : t >> 1, t += _(t / e); t > m * h >> 1; n += l) t = _(t / m);
                        return _(n + (m + 1) * t / (t + u))
                    }

                    function w(t) {
                        var e, i, n, r, o, s, u, c, d, p, f, g = [],
                            m = t.length,
                            y = 0,
                            v = 128,
                            b = 72;
                        for ((i = t.lastIndexOf("-")) < 0 && (i = 0), n = 0; n < i; ++n) t.charCodeAt(n) >= 128 && S("not-basic"), g.push(t.charCodeAt(n));
                        for (r = i > 0 ? i + 1 : 0; r < m;) {
                            for (o = y, s = 1, u = l; r >= m && S("invalid-input"), ((c = (f = t.charCodeAt(r++)) - 48 < 10 ? f - 22 : f - 65 < 26 ? f - 65 : f - 97 < 26 ? f - 97 : l) >= l || c > _((a - y) / s)) && S("overflow"), y += c * s, !(c < (d = u <= b ? 1 : u >= b + h ? h : u - b)); u += l) s > _(a / (p = l - d)) && S("overflow"), s *= p;
                            b = I(y - o, e = g.length + 1, 0 == o), _(y / e) > a - v && S("overflow"), v += _(y / e), y %= e, g.splice(y++, 0, v)
                        }
                        return P(g)
                    }

                    function E(t) {
                        var e, i, n, r, o, s, u, c, d, p, f, g, m, v, b, P = [];
                        for (g = (t = T(t)).length, e = 128, i = 0, o = 72, s = 0; s < g; ++s)(f = t[s]) < 128 && P.push(y(f));
                        for (n = r = P.length, r && P.push("-"); n < g;) {
                            for (u = a, s = 0; s < g; ++s)(f = t[s]) >= e && f < u && (u = f);
                            for (u - e > _((a - i) / (m = n + 1)) && S("overflow"), i += (u - e) * m, e = u, s = 0; s < g; ++s)
                                if ((f = t[s]) < e && ++i > a && S("overflow"), f == e) {
                                    for (c = i, d = l; !(c < (p = d <= o ? 1 : d >= o + h ? h : d - o)); d += l) b = c - p, v = l - p, P.push(y(A(p + b % v, 0))), c = _(b / v);
                                    P.push(y(A(c, 0))), o = I(i, m, n == r), i = 0, ++n
                                } ++i, ++e
                        }
                        return P.join("")
                    }
                    s = {
                        version: "1.4.1",
                        ucs2: {
                            decode: T,
                            encode: P
                        },
                        decode: w,
                        encode: E,
                        toASCII: function (t) {
                            return b(t, (function (t) {
                                return p.test(t) ? "xn--" + E(t) : t
                            }))
                        },
                        toUnicode: function (t) {
                            return b(t, (function (t) {
                                return d.test(t) ? w(t.slice(4).toLowerCase()) : t
                            }))
                        }
                    }, void 0 === (n = function () {
                        return s
                    }.call(e, i, e, t)) || (t.exports = n)
                }()
        },
        8575: (t, e, i) => {
            "use strict";
            var n = i(2511);

            function r() {
                this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
            }
            var o = /^([a-z0-9.+-]+:)/i,
                s = /:[0-9]*$/,
                a = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
                l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
                h = ["'"].concat(l),
                u = ["%", "/", "?", ";", "#"].concat(h),
                c = ["/", "?", "#"],
                d = /^[+a-z0-9A-Z_-]{0,63}$/,
                p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                f = {
                    javascript: !0,
                    "javascript:": !0
                },
                g = {
                    javascript: !0,
                    "javascript:": !0
                },
                m = {
                    http: !0,
                    https: !0,
                    ftp: !0,
                    gopher: !0,
                    file: !0,
                    "http:": !0,
                    "https:": !0,
                    "ftp:": !0,
                    "gopher:": !0,
                    "file:": !0
                },
                _ = i(129);

            function y(t, e, i) {
                if (t && "object" == typeof t && t instanceof r) return t;
                var n = new r;
                return n.parse(t, e, i), n
            }
            r.prototype.parse = function (t, e, i) {
                if ("string" != typeof t) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
                var r = t.indexOf("?"),
                    s = -1 !== r && r < t.indexOf("#") ? "?" : "#",
                    l = t.split(s);
                l[0] = l[0].replace(/\\/g, "/");
                var y = t = l.join(s);
                if (y = y.trim(), !i && 1 === t.split("#").length) {
                    var S = a.exec(y);
                    if (S) return this.path = y, this.href = y, this.pathname = S[1], S[2] ? (this.search = S[2], this.query = e ? _.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this
                }
                var v = o.exec(y);
                if (v) {
                    var b = (v = v[0]).toLowerCase();
                    this.protocol = b, y = y.substr(v.length)
                }
                if (i || v || y.match(/^\/\/[^@/]+@[^@/]+/)) {
                    var T = "//" === y.substr(0, 2);
                    !T || v && g[v] || (y = y.substr(2), this.slashes = !0)
                }
                if (!g[v] && (T || v && !m[v])) {
                    for (var P, A, I = -1, w = 0; w < c.length; w++) - 1 !== (E = y.indexOf(c[w])) && (-1 === I || E < I) && (I = E);
                    for (-1 !== (A = -1 === I ? y.lastIndexOf("@") : y.lastIndexOf("@", I)) && (P = y.slice(0, A), y = y.slice(A + 1), this.auth = decodeURIComponent(P)), I = -1, w = 0; w < u.length; w++) {
                        var E; - 1 !== (E = y.indexOf(u[w])) && (-1 === I || E < I) && (I = E)
                    } - 1 === I && (I = y.length), this.host = y.slice(0, I), y = y.slice(I), this.parseHost(), this.hostname = this.hostname || "";
                    var C = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                    if (!C)
                        for (var x = this.hostname.split(/\./), B = (w = 0, x.length); w < B; w++) {
                            var L = x[w];
                            if (L && !L.match(d)) {
                                for (var O = "", N = 0, M = L.length; N < M; N++) L.charCodeAt(N) > 127 ? O += "x" : O += L[N];
                                if (!O.match(d)) {
                                    var R = x.slice(0, w),
                                        D = x.slice(w + 1),
                                        F = L.match(p);
                                    F && (R.push(F[1]), D.unshift(F[2])), D.length && (y = "/" + D.join(".") + y), this.hostname = R.join(".");
                                    break
                                }
                            }
                        }
                    this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), C || (this.hostname = n.toASCII(this.hostname));
                    var k = this.port ? ":" + this.port : "",
                        U = this.hostname || "";
                    this.host = U + k, this.href += this.host, C && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== y[0] && (y = "/" + y))
                }
                if (!f[b])
                    for (w = 0, B = h.length; w < B; w++) {
                        var G = h[w];
                        if (-1 !== y.indexOf(G)) {
                            var W = encodeURIComponent(G);
                            W === G && (W = escape(G)), y = y.split(G).join(W)
                        }
                    }
                var V = y.indexOf("#"); - 1 !== V && (this.hash = y.substr(V), y = y.slice(0, V));
                var X = y.indexOf("?");
                if (-1 !== X ? (this.search = y.substr(X), this.query = y.substr(X + 1), e && (this.query = _.parse(this.query)), y = y.slice(0, X)) : e && (this.search = "", this.query = {}), y && (this.pathname = y), m[b] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                    k = this.pathname || "";
                    var H = this.search || "";
                    this.path = k + H
                }
                return this.href = this.format(), this
            }, r.prototype.format = function () {
                var t = this.auth || "";
                t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
                var e = this.protocol || "",
                    i = this.pathname || "",
                    n = this.hash || "",
                    r = !1,
                    o = "";
                this.host ? r = t + this.host : this.hostname && (r = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r += ":" + this.port)), this.query && "object" == typeof this.query && Object.keys(this.query).length && (o = _.stringify(this.query));
                var s = this.search || o && "?" + o || "";
                return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || m[e]) && !1 !== r ? (r = "//" + (r || ""), i && "/" !== i.charAt(0) && (i = "/" + i)) : r || (r = ""), n && "#" !== n.charAt(0) && (n = "#" + n), s && "?" !== s.charAt(0) && (s = "?" + s), e + r + (i = i.replace(/[?#]/g, (function (t) {
                    return encodeURIComponent(t)
                }))) + (s = s.replace("#", "%23")) + n
            }, r.prototype.resolve = function (t) {
                return this.resolveObject(y(t, !1, !0)).format()
            }, r.prototype.resolveObject = function (t) {
                if ("string" == typeof t) {
                    var e = new r;
                    e.parse(t, !1, !0), t = e
                }
                for (var i = new r, n = Object.keys(this), o = 0; o < n.length; o++) {
                    var s = n[o];
                    i[s] = this[s]
                }
                if (i.hash = t.hash, "" === t.href) return i.href = i.format(), i;
                if (t.slashes && !t.protocol) {
                    for (var a = Object.keys(t), l = 0; l < a.length; l++) {
                        var h = a[l];
                        "protocol" !== h && (i[h] = t[h])
                    }
                    return m[i.protocol] && i.hostname && !i.pathname && (i.pathname = "/", i.path = i.pathname), i.href = i.format(), i
                }
                if (t.protocol && t.protocol !== i.protocol) {
                    if (!m[t.protocol]) {
                        for (var u = Object.keys(t), c = 0; c < u.length; c++) {
                            var d = u[c];
                            i[d] = t[d]
                        }
                        return i.href = i.format(), i
                    }
                    if (i.protocol = t.protocol, t.host || g[t.protocol]) i.pathname = t.pathname;
                    else {
                        for (var p = (t.pathname || "").split("/"); p.length && !(t.host = p.shift()););
                        t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== p[0] && p.unshift(""), p.length < 2 && p.unshift(""), i.pathname = p.join("/")
                    }
                    if (i.search = t.search, i.query = t.query, i.host = t.host || "", i.auth = t.auth, i.hostname = t.hostname || t.host, i.port = t.port, i.pathname || i.search) {
                        var f = i.pathname || "",
                            _ = i.search || "";
                        i.path = f + _
                    }
                    return i.slashes = i.slashes || t.slashes, i.href = i.format(), i
                }
                var y = i.pathname && "/" === i.pathname.charAt(0),
                    S = t.host || t.pathname && "/" === t.pathname.charAt(0),
                    v = S || y || i.host && t.pathname,
                    b = v,
                    T = i.pathname && i.pathname.split("/") || [],
                    P = (p = t.pathname && t.pathname.split("/") || [], i.protocol && !m[i.protocol]);
                if (P && (i.hostname = "", i.port = null, i.host && ("" === T[0] ? T[0] = i.host : T.unshift(i.host)), i.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === p[0] ? p[0] = t.host : p.unshift(t.host)), t.host = null), v = v && ("" === p[0] || "" === T[0])), S) i.host = t.host || "" === t.host ? t.host : i.host, i.hostname = t.hostname || "" === t.hostname ? t.hostname : i.hostname, i.search = t.search, i.query = t.query, T = p;
                else if (p.length) T || (T = []), T.pop(), T = T.concat(p), i.search = t.search, i.query = t.query;
                else if (null != t.search) return P && (i.host = T.shift(), i.hostname = i.host, (C = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = C.shift(), i.hostname = C.shift(), i.host = i.hostname)), i.search = t.search, i.query = t.query, null === i.pathname && null === i.search || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.href = i.format(), i;
                if (!T.length) return i.pathname = null, i.search ? i.path = "/" + i.search : i.path = null, i.href = i.format(), i;
                for (var A = T.slice(-1)[0], I = (i.host || t.host || T.length > 1) && ("." === A || ".." === A) || "" === A, w = 0, E = T.length; E >= 0; E--) "." === (A = T[E]) ? T.splice(E, 1) : ".." === A ? (T.splice(E, 1), w++) : w && (T.splice(E, 1), w--);
                if (!v && !b)
                    for (; w--; w) T.unshift("..");
                !v || "" === T[0] || T[0] && "/" === T[0].charAt(0) || T.unshift(""), I && "/" !== T.join("/").substr(-1) && T.push("");
                var C, x = "" === T[0] || T[0] && "/" === T[0].charAt(0);
                return P && (i.hostname = x ? "" : T.length ? T.shift() : "", i.host = i.hostname, (C = !!(i.host && i.host.indexOf("@") > 0) && i.host.split("@")) && (i.auth = C.shift(), i.hostname = C.shift(), i.host = i.hostname)), (v = v || i.host && T.length) && !x && T.unshift(""), T.length > 0 ? i.pathname = T.join("/") : (i.pathname = null, i.path = null), null === i.pathname && null === i.search || (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.auth = t.auth || i.auth, i.slashes = i.slashes || t.slashes, i.href = i.format(), i
            }, r.prototype.parseHost = function () {
                var t = this.host,
                    e = s.exec(t);
                e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
            }, e.parse = y, e.resolve = function (t, e) {
                return y(t, !1, !0).resolve(e)
            }, e.resolveObject = function (t, e) {
                return t ? y(t, !1, !0).resolveObject(e) : e
            }, e.format = function (t) {
                return "string" == typeof t && (t = y(t)), t instanceof r ? t.format() : r.prototype.format.call(t)
            }, e.Url = r
        },
        4654: () => { },
        9319: t => {
            "use strict";
            t.exports = {
                i8: "1.1.17"
            }
        },
        2364: t => {
            "use strict";
            t.exports = JSON.parse('{"name":"@nolimit/game-communication","version":"0.2.1","description":"Connect to the Nolimit City platform as a javascript game client.","main":"src/communication.js","scripts":{"lint":"eslint src test","posttest":"npm run lint","patch":"npm --no-git-tag-version version patch","push":"git commit -a -m $npm_package_version && git push","postpush":"echo $npm_package_name $npm_package_version","ppp":"npm run patch && npm publish && npm run push","pp":"npm run patch && npm publish"},"keywords":[],"author":"Kristoffer Lundn <kristoffer@nolimitcity.com>","license":"UNLICENSED","dependencies":{"@nolimit/core":"^0.1.1"},"repository":{"type":"git","url":"git+https://github.com/nolimitcity/nolimit-game-communication.git"},"bugs":{"url":"https://github.com/nolimitcity/nolimit-game-communication/issues"},"homepage":"https://github.com/nolimitcity/nolimit-game-communication#readme"}')
        },
        452: t => {
            "use strict";
            t.exports = {
                i8: "1.8.26"
            }
        }
    },
        e = {};

    function i(n) {
        var r = e[n];
        if (void 0 !== r) return r.exports;
        var o = e[n] = {
            id: n,
            loaded: !1,
            exports: {}
        };
        return t[n].call(o.exports, o, o.exports, i), o.loaded = !0, o.exports
    }
    i.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return i.d(e, {
            a: e
        }), e
    }, i.d = (t, e) => {
        for (var n in e) i.o(e, n) && !i.o(t, n) && Object.defineProperty(t, n, {
            enumerable: !0,
            get: e[n]
        })
    }, i.g = function () {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (t) {
            if ("object" == typeof window) return window
        }
    }(), i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, i.nmd = t => (t.paths = [], t.children || (t.children = []), t), i.nc = void 0, i(2937)
})();
//# sourceMappingURL=game.js.map
